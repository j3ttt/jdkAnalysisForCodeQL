isThemePartDefined(...)/** Get a <code>Skin</code> object from the current style ... */XPStyle$Skin/** A class which encapsulates attributes for a given part ... */Component component;String string;Dimension size;this.componentint boundingWidthint boundingHeightgetThemeBackgroundContentMargins(...)(...).string/** Paint a skin at x, y. ... *//** Paint a skin in an area defined by a rectangle. ... *//** Paint a skin at a defined position and size ... */isGetThemeTransitionDurationDefined(...)CellRendererPane.class/** Paint a skin at a defined position and size. This method ... */XPStyle$SkinPainterboolean accEnabledDataBufferInt dbiskin.componentXPStyle$GlyphButton// Private constructorgetSysBoolean(...)Prop.FLATMENUSnew HashMap<String,Color>(...)new HashMap<String,Border>(...)/* Copyright (c) 2002, 2007, Oracle and/or its affiliates. All rights reserved. ... */// Special case because XP has no skin for menus// TODO: The classic border uses this color, but we should// create a new UI property called "PopupMenu.borderColor"// instead.// Will cause L&F to use classic border// Ideally we'd have an interface defined for classes which// support margins (to avoid this hackery), but we've// decided against it for simplicity// special casing for comboboxes.// there may be more special cases in the future// note. in the future this should be replaced with a call// to BasicLookAndFeel.getUIOfType()// if this is a toolbar button then ignore getMargin()// and subtract the padding added by the constructor/* idk: it seems margins are the same for all 'big enough' ... */// Note: All further access to the maps must be synchronized// We can use any widget name here, I guess./* ************************************************* ... *//** Defines the Scanner interface, which CUP uses in the default ... *//* Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved. ... *//* **************************************************************** ... *//** Defines the Symbol class, which is used to represent all terminals ... *//** ***************************** ... *//** *************************** ... *//** ********************************* ... */int sym;/** The symbol number of the terminal or non terminal being represented *//* . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . */int parse_state;/** The parse state to be recorded on the parse stack with this symbol. ... */boolean used_by_parser;/** This allows us to catch some errors caused by scanners recycling ... */int left, ...;/** This class implements a skeleton table driven LR parser.  In general, ... */new Stack<Symbol>(...)/** Simple constructor. *//* ----------------------------------------------------------- *//* --- Constructor(s) ---------------------------------------- *//** Constructor that sets the default scanner. [CSA/davidm] */setScanner(...)int _error_sync_size;/** The default number of Symbols after an error we much match to consider ... *//* --- (Access to) Static (Class) Variables ------------------ *//** The number of Symbols after an error we much match to consider it ... *//** Table of production information (supplied by generated subclass). ... *//* --- (Access to) Instance Variables ------------------------ *//** The action table (supplied by generated subclass).  This table is ... *//** The reduce-goto table (supplied by generated subclass).  This ... *//** The index of the start state (supplied by generated subclass). *//** The index of the start production (supplied by generated subclass). *//** The index of the end of file terminal Symbol (supplied by generated ... *//** The index of the special error Symbol (supplied by generated subclass). */boolean _done_parsing;/** Internal flag to indicate when parser should quit. *//** This method is called to indicate that the parser should quit.  This is ... */int tos;/** Indication of the index for top of stack (for use by actions). *//* Global parse state shared by parse(), error recovery, and ... */Symbol cur_token;/** The current lookahead Symbol. */Stack<Symbol> stack;/** The parse stack itself. */...[] production_tab;/** Direct reference to the production table. */...[] action_tab;/** Direct reference to the action table. */...[] reduce_tab;/** Direct reference to the reduce-goto table. */Scanner _scanner;/** This is the scanner object used by the default implementation ... *//** Simple accessor method to set the default scanner. *//** Simple accessor method to get the default scanner. *//** Perform a bit of user supplied action code (supplied by generated ... *//* --- General Methods --------------------------------------- *//** User code for initialization inside the parser.  Typically this ... *//** Initialize the action object.  This is called before the parser does ... *//** Get the next Symbol from the input (supplied by generated subclass). ... */next_token(...)getScanner(...)/** Report a fatal error.  This method takes a  message string and an ... */done_parsing(...)report_error(...)/** Report a non fatal error (or warning).  This method takes a message ... */(...).left/** This method is called when a syntax error has been detected and recovery ... *//** This method is called if it is determined that syntax error recovery ... */report_fatal_error(...)/** Fetch an action from the action table.  The table is broken up into ... */short tagint firstint probeshort[] rowrow.length/** Fetch a state from the reduce-goto table.  The table is broken up into ... *//** This method provides the main parsing routine.  It returns only when ... */int actSymbol lhs_symshort handle_sizeshort lhs_sym_numproduction_table(...)action_table(...)reduce_table(...)init_actions(...)user_init(...)scan(...)removeAllElements(...)new Symbol(...)start_state(...)cur_token.used_by_parserget_action(...)(...).parse_statecur_token.symcur_token.parse_statedo_action(...)get_reduce(...)lhs_sym.parse_statelhs_sym.used_by_parsersyntax_error(...)error_recovery(...)unrecovered_syntax_error(...)/** Write a debugging message to System.err for the debugging version ... *//** Dump the parse stack for debugging purposes. */debug_message(...)(...).sym/** Do debug output for a reduce. ... *//** Do debug output for shift. ... */shift_tkn.parse_stateshift_tkn.sym/** Do debug output for stack state. [CSA] */Symbol ss.syms.parse_state/** Perform a parse with debugging output.  This does exactly the ... */debug_shift(...)debug_reduce(...)/** Attempt to recover from a syntax error.  This returns false if recovery ... *//* Error recovery code */find_recovery_config(...)read_lookahead(...)try_parse_ahead(...)...[...].symEOF_sym(...)cur_err_token(...).symcur_err_token(...)restart_lookahead(...)parse_lookahead(...)/** Determine if we can shift under the special error Symbol out of the ... */error_sym(...)/** Put the (real) parse stack into error recovery configuration by ... */Symbol error_tokenint right_pos(...).rightint left_posshift_under_error(...)pop(...).lefterror_token.parse_stateerror_token.used_by_parser...[] lookahead;/** Lookahead Symbols used for attempting error recovery "parse aheads". */int lookahead_pos;/** Position in lookahead input buffer used for "parse ahead". *//** Read from input to establish our buffer of "parse ahead" lookahead ... */new Symbol[]error_sync_size(...)/** Return the current lookahead in our error "parse ahead" buffer. *//** Advance to next "parse ahead" input Symbol. Return true if we have ... *//** Reset the parse ahead input to one Symbol past where we started error ... *//** Do a simulated parse forward (a "parse ahead") from the current ... */short lhsshort rhs_sizevirtual_parse_stack vstacknew virtual_parse_stack(...)top(...)advance_lookahead(...)start_production(...)/** Parse forward using stored lookahead Symbols.  In this case we have ... */cur_err_token(...).parse_statecur_err_token(...).used_by_parser/** Utility function: unpacks parse tables from strings */int size1short[][] resultnew short[][]sa.lengthint size2/* nothing to do here *//* in case default constructor someday does something *//* stop parsing (not really necessary since we throw an exception, but) *//* use the normal error message reporting to put out the message *//* throw an exception *//* linear search if we are < 10 entries *//* is this entry labeled with our Symbol or the default? *//* return the next entry *//* otherwise binary search *//* leave out trailing default entry *//* not found, use the default at the end *//* shouldn't happened, but if we run off the end we return the ... *//* if we have a null row we go with the default *//* if we run off the end we return the default (error == -1) *//* the current action code *//* the Symbol/stack element returned by a reduce *//* information about production being reduced with *//* set up direct reference to tables to drive the parser *//* initialize the action encapsulation object *//* do user initialization *//* get the first token *//* push dummy Symbol with start state to get us underway *//* continue until we are told to stop *//* Check current token for freshness. *//* current state is always on the top of the stack *//* look up action out of the current state with the current input *//* decode the action -- > 0 encodes shift *//* shift to the encoded state by pushing it on the stack *//* advance to the next Symbol *//* if its less than zero, then it encodes a reduce action *//* perform the action for the reduce *//* look up information about the production *//* pop the handle off the stack *//* look up the state to go to from the one popped back to *//* shift to that state *//* finally if the entry is zero, we have an error *//* call user syntax error reporting routine *//* try to error recover *//* if that fails give up with a fatal syntax error *//* just in case that wasn't fatal enough, end parse *//* dump the stack *//* the current Symbol *///debug_stack();/* first pop the stack back into a state that can shift on error and ... *//* read ahead to create lookahead we can parse multiple times *//* repeatedly try to parse forward until we make it the required dist *//* try to parse forward, if it makes it, bail out of loop *//* if we are now at EOF, we have failed *//* otherwise, we consume another Symbol and try again *//* we have consumed to a point where we can parse forward *//* do the real parse (including actions) across the lookahead *//* we have success *//* is there a shift under error Symbol *//* Remember the right-position of the top symbol on the stack *//* pop down until we can shift under error Symbol *//* pop the stack *//* if we have hit bottom, we fail *//* state on top of the stack can shift under error, find the shift *//* build and shift a special error Symbol *//* create the lookahead array *//* fill in the array *//* start at the beginning *//* advance the input location *//* return true if we didn't go off the end *//* move all the existing input over *//* read a new Symbol into the last spot *//* reset our internal position marker *//* create a virtual stack from the real parse stack *//* parse until we fail or get past the lookahead input *//* look up the action from the current state (on top of stack) *//* if its an error, we fail *//* > 0 encodes a shift *//* push the new state on the stack *//* advance simulated input, if we run off the end, we are done *//* < 0 encodes a reduce *//* if this is a reduce with the start production we are done *//* get the lhs Symbol and the rhs size *//* pop handle off the stack *//* look up goto and push it onto the stack *//* restart the saved input at the beginning *//* continue until we accept or have read all lookahead input *//* advance to the next Symbol, if there is none, we are done *//* scan next Symbol so we can continue parse */// BUGFIX by Chris Harris <ckharris@ucsd.edu>://   correct a one-off error by commenting out//   this next line./* cur_token = scan(); *//* go back to normal parser *//* finally if the entry is zero, we have an error ... */// Concatanate initialization strings.// location in initialization string/** This class implements a temporary or "virtual" parse stack that ... *//** Constructor to build a virtual stack out of a real stack. */new Stack<Integer>(...)get_from_real(...)Stack<Symbol> real_stack;/** The real stack that we shadow.  This is accessed when we move off ... */int real_next;/** Top of stack indicator for where we leave off in the real stack. ... */Stack<Integer> vstack;/** The virtual top portion of the stack.  This stack contains Integer ... *//** Transfer an element from the real to the virtual stack.  This assumes ... */Symbol stack_symstack_sym.parse_state/** Indicate whether the stack is empty. *//** Return value on the top of the stack (without popping it). *//** Pop the stack. *//** Push a state number onto the stack. *//* sanity check *//* set up our internals *//* get one element onto the virtual portion of the stack *//* don't transfer if the real stack is empty *//* get a copy of the first Symbol we have not transfered *//* record the transfer *//* put the state number from the Symbol onto the virtual stack *//* if vstack is empty then we were unable to transfer onto it and ... *//* pop it *//* if we are now empty transfer an element (if there is one) *//** Represents an annotated type. ... *//** Represents an annotation. ... *//** Returns the annotation type of this annotation. ... *//** Returns this annotation's elements and their values. ... *//** Check for the synthesized bit on the annotation. ... *//** Represents an association between an annotation type element ... *//** Returns the annotation type element. ... *//** Returns the value associated with the annotation type element. ... *//** Represents an annotation type. ... *//** Returns the elements of this annotation type. ... *//** Represents an element of an annotation type. ... *//** Returns the default value of this element. ... *//** Represents a value of an annotation type element. ... *//** Returns the value. ... *//** Returns a string representation of the value. ... *//** Represents a java class or interface and provides access to ... *//** Return true if this class is abstract.  Return true ... *//** Return true if this class implements or interface extends ... *//** Return the serialization methods for this class or ... *//** Return the Serializable fields of this class or interface. ... *//** Return true if Serializable fields are explicitly defined with ... *//** Return the superclass of this class.  Return null if this is an ... *//** Test whether this class is a subclass of the specified class. ... *//** Return interfaces implemented by this class or interfaces extended ... *//** Return the formal type parameters of this class or interface. ... *//** Return the type parameter tags of this class or interface. ... *//** Return ... *//** Return fields in this class or interface, filtered to the specified ... *//** Return the enum constants if this is an enum type. ... *//** Return methods in this class or interface, filtered to the specified ... *//** Return constructors in this class, filtered to the specified ... *//** Return nested classes and interfaces within this class or interface ... *//** Find the specified class or interface within the context of this class doc. ... *//** Get the list of classes and interfaces declared as imported. ... *//** Get the list of packages declared as imported. ... *//** Represents a constructor of a java class. ... */import BreakIterator/** Represents Java language constructs (package, class, constructor, ... *//** Return the text of the comment for this doc item. ... *//** Return all tags in this Doc item. ... *//** Return tags of the specified {@linkplain Tag#kind() kind} in ... *//** Return the see also tags in this Doc item. ... *//** Return comment as an array of tags. Includes inline tags ... *//** Return the first sentence of the comment as an array of tags. ... *//** Return the full unprocessed text of the comment.  Tags ... *//** Set the full unprocessed text of the comment.  Tags ... *//** Returns the non-qualified name of this Doc item. ... *//** Compares this doc object with the specified object for order.  Returns a ... *//** Is this Doc item a field (but not an enum constant)? ... *//** Is this Doc item an enum constant? ... *//** Is this Doc item a constructor? ... *//** Is this Doc item a method (but not a constructor or annotation ... *//** Is this Doc item an annotation type element? ... *//** Is this Doc item an interface (but not an annotation type)? ... *//** Is this Doc item an exception class? ... *//** Is this Doc item an error class? ... *//** Is this Doc item an enum type? ... *//** Is this Doc item an annotation type? ... *//** Is this Doc item an ... *//** Is this Doc item a ... *//** Return true if this Doc item is ... *//** Return the source position of the first line of the ... *//** This interface provides error, warning and notice printing. ... *//** Print error message and increment error count. ... *//** Print an error message and increment error count. ... *//** Print warning message and increment warning count. ... *//** Print a message. ... *//** This is an example of a starting class for a doclet, ... *//** Generate documentation here. ... *//** Check for doclet-added options.  Returns the number of ... *//** Check that options have the correct arguments. ... *//** Return the version of the Java Programming Language supported ... */LanguageVersion.JAVA_1_1// default is option unknown// default is options are valid/** Represents a method or constructor of a java class. ... *//** Return exceptions this method or constructor throws. ... *//** Return true if this method is native *//** Return true if this method is synchronized *//** Return true if this method was declared to take a variable number ... *//** Get argument information. ... *//** Get the receiver type of this executable element. ... *//** Return the throws tags in this method. ... *//** Return the param tags in this method, excluding the type ... *//** Return the type parameter tags in this method. ... *//** Get the signature. It is the parameter list, type is qualified. ... *//** get flat signature.  all types are not qualified. ... *//** Return the formal type parameters of this method or constructor. ... *//** Represents a field in a java class. ... *//** Get type of this field. *//** Return true if this field is transient *//** Return true if this field is volatile *//** Return the serialField tags in this FieldDoc item. ... *//** Get the value of a constant field. ... *//** Java Programming Language version.  The constants of this enum ... */new LanguageVersion(...)LanguageVersion JAVA_1_1;/** 1.1 added nested classes and interfaces. */LanguageVersion JAVA_1_5;/** 1.5 added generic types, annotations, enums, and varArgs. *//** Represents a member of a java class: field, constructor, or method. ... *//** Returns true if this member was synthesized by the compiler. *//** Represents a method of a java class. ... *//** Return true if this method is abstract *//** Return true if this method is default *//** Get return type. ... *//** Return the class containing the method that this method overrides. ... *//** Return the type containing the method that this method overrides. ... *//** Return the method that this method overrides. ... *//** Tests whether this method overrides another. ... *//** Represents a java package.  Provides access to information ... *//** Get all classes and interfaces in the package, filtered to the specified ... *//** Get all ... *//** Get included ... *//** Get included Exception classes in this package. ... *//** Get included Error classes in this package. ... *//** Get included enum types in this package. ... *//** Get included interfaces in this package, omitting annotation types. ... *//** Get included annotation types in this package. ... *//** Get the annotations of this package. ... *//** Lookup a class or interface within this package. ... *//** Represents an @param documentation tag. ... *//** Return the name of the parameter or type parameter ... *//** Return the parameter comment ... *//** Return true if this <code>ParamTag</code> corresponds to a type ... *//** Parameter information. ... *//** Get the type of this parameter. *//** Get local name of this parameter. ... *//** Get type name of this parameter. ... *//** Returns a string representation of the parameter. ... *//** Get the annotations of this parameter. ... *//** Represents an invocation of a generic class or interface.  For example, ... *//** Return the generic class or interface that declared this type. ... *//** Return the actual type arguments of this type. ... *//** Return the class type that is a direct supertype of this one. ... *//** Return the interface types directly implemented by or extended by this ... *//** Return the type that contains this type as a member. ... *//** Represents a java program element: class, interface, field, ... *//** Get the containing class or interface of this program element. ... *//** Get the package that this program element is contained in. ... *//** Get the fully qualified name of this program element. ... *//** Get the modifier specifier integer. ... *//** Get modifiers string. ... *//** Get the annotations of this program element. ... *//** Return true if this program element is public. *//** Return true if this program element is protected. *//** Return true if this program element is private. *//** Return true if this program element is package private. *//** Return true if this program element is static. *//** Return true if this program element is final. *//** Represents the root of the program structure information ... *//** Command line options. ... *//** Return the packages ... *//** Return the classes and interfaces ... *//** Return the ... *//** Return a PackageDoc for the specified package name. ... *//** Return a ClassDoc for the specified class or interface name. ... *//** Represents a user-defined cross-reference to related documentation. ... *//** Get the label of the <code>@see</code> tag. ... *//** Get the package doc when <code>@see</code> references only a package. ... *//** Get the class or interface name of the <code>@see</code> reference. ... *//** Get the class doc referenced by the class name part of @see. ... *//** Get the field, constructor or method substring of the <code>@see</code> ... *//** Get the member doc for the field, constructor or method ... *//** Documents a Serializable field defined by an ObjectStreamField. ... *//** Return the serializable field name. *//** Return the field type string. *//** Return the ClassDoc for field type. ... *//** Return the field comment. If there is no serialField comment, return ... *//** Compares this Object with the specified Object for order.  Returns a ... *//** This interface describes a source position: filename, line number, ... *//** The source file. Returns null if no file information is ... *//** The line in the source file. The first line is numbered 1; ... *//** The column in the source file. The first column is ... *//** Convert the source position to the form "Filename:line". *//** Represents a simple documentation tag, such as @since, @author, @version. ... *//** Return the name of this tag.  The name is the string ... *//** Return the containing {@link Doc} of this Tag element. ... *//** Return the kind of this tag. ... *//** Return the text of this tag, that is, the portion beyond tag name. ... *//** Convert this object to a string. *//** For a documentation comment with embedded <code>{&#064;link}</code> ... *//** Return the source position of this tag. ... *//** Represents a @throws or @exception documentation tag. ... *//** Return the name of the exception ... *//** Return the exception comment ... *//** Return a <code>ClassDoc</code> that represents the exception. ... *//** Return the type of the exception ... *//** Represents a type.  A type can be a class or interface, an ... *//** Return unqualified name of type excluding any dimension information. ... *//** Return qualified name of type excluding any dimension information. ... *//** Return the simple name of this type excluding any dimension information. ... *//** Return the type's dimension information, as a string. ... *//** Return a string representation of the type. ... *//** Return true if this type represents a primitive type. ... *//** Return this type as a <code>ClassDoc</code> if it represents a class ... *//** Return this type as a <code>ParameterizedType</code> if it represents ... *//** Return this type as a <code>TypeVariable</code> if it represents ... *//** Return this type as a <code>WildcardType</code> if it represents ... *//** Returns this type as a <code>AnnotatedType</code> if it represents ... *//** Return this type as an <code>AnnotationTypeDoc</code> if it represents ... *//** If this type is an array type, return the element type of the ... *//** Represents a type variable. ... *//** Return the bounds of this type variable. ... *//** Return the class, interface, method, or constructor within ... *//** Represents a wildcard type argument. ... *//** Return the upper bounds of this wildcard type argument ... *//** Return the lower bounds of this wildcard type argument ... */package-info/** The Doclet API (also called the Javadoc API) provides a mechanism ... *//** This contains the property list defined for this ... */// private constructor defined to "hide" the default public constructorString JMX_INITIAL_BUILDER;/** References the property that specifies the directory where ... *///------------------------// PUBLIC STATIC CONSTANTSString MLET_LIB_DIR;String JMX_SPEC_NAME;/** References the property that specifies the full name of the JMX ... */String JMX_SPEC_VERSION;/** References the property that specifies the version of the JMX ... */String JMX_SPEC_VENDOR;/** References the property that specifies the vendor of the JMX ... */String JMX_IMPL_NAME;/** References the property that specifies the full name of this product ... */String JMX_IMPL_VENDOR;/** References the property that specifies the name of the vendor of this ... */String JMX_IMPL_VERSION;/** References the property that specifies the version of this product ... */String MBEANSERVER_LOGGER_NAME;/** Logger name for MBean Server information. */Logger MBEANSERVER_LOGGER;/** Logger for MBean Server information. */String MLET_LOGGER_NAME;/** Logger name for MLet service information. */Logger MLET_LOGGER;/** Logger for MLet service information. */String MONITOR_LOGGER_NAME;/** Logger name for Monitor information. */Logger MONITOR_LOGGER;/** Logger for Monitor information. */String TIMER_LOGGER_NAME;/** Logger name for Timer information. */Logger TIMER_LOGGER;/** Logger for Timer information. */String NOTIFICATION_LOGGER_NAME;/** Logger name for Event Management information. */Logger NOTIFICATION_LOGGER;/** Logger for Event Management information. */String RELATION_LOGGER_NAME;/** Logger name for Relation Service. */Logger RELATION_LOGGER;/** Logger for Relation Service. */String MODELMBEAN_LOGGER_NAME;/** Logger name for Model MBean. */Logger MODELMBEAN_LOGGER;/** Logger for Model MBean. */String MISC_LOGGER_NAME;/** Logger name for all other JMX classes. */Logger MISC_LOGGER;/** Logger for all other JMX classes. */String SNMP_LOGGER_NAME;/** Logger name for SNMP. */Logger SNMP_LOGGER;/** Logger for SNMP. */String SNMP_ADAPTOR_LOGGER_NAME;/** Logger name for SNMP Adaptor. */Logger SNMP_ADAPTOR_LOGGER;/** Logger for SNMP Adaptor. *//* Copyright (c) 1999, 2007, Oracle and/or its affiliates. All rights reserved. ... *//** Used for storing default values used by JMX services. ... */String DELEGATE;/** The object name of the MBeanServer delegate object ... */String MLET;/** The default key properties for registering the class loader of the ... */String DOMAIN;/** The default domain. ... *//** The name of the JMX specification implemented by this product. ... *//** The version of the JMX specification implemented by this product. ... *//** The vendor of the JMX specification implemented by this product. ... *//** The name of this product implementing the  JMX specification. ... *//** The name of the vendor of this product implementing the ... *//* Copyright (c) 1999, 2008, Oracle and/or its affiliates. All rights reserved. ... */import static JmxProperties.MBEANSERVER_LOGGERimport DynamicMBean2import Introspectorimport MBeanInstantiatorimport ModifiableClassLoaderRepositoryimport NamedObjectimport RegistrationContextimport EnvHelpimport Permissionimport Attributeimport AttributeListimport AttributeNotFoundExceptionimport DynamicMBeanimport InstanceAlreadyExistsExceptionimport InstanceNotFoundExceptionimport IntrospectionExceptionimport InvalidAttributeValueExceptionimport JMRuntimeExceptionimport ListenerNotFoundExceptionimport MBeanExceptionimport MBeanInfoimport MBeanPermissionimport MBeanRegistrationimport MBeanRegistrationExceptionimport MBeanServerimport MBeanServerDelegateimport MBeanServerNotificationimport MBeanTrustPermissionimport NotCompliantMBeanExceptionimport Notificationimport NotificationBroadcasterimport NotificationEmitterimport NotificationFilterimport NotificationListenerimport ObjectInstanceimport ObjectNameimport OperationsExceptionimport QueryEvalimport QueryExpimport ReflectionExceptionimport RuntimeErrorExceptionimport RuntimeMBeanExceptionimport RuntimeOperationsExceptionimport ClassLoaderRepository/** This is the default class for MBean manipulation on the agent side. It ... */new WeakHashMap<ListenerWrapper,WeakReference<ListenerWrapper>>(...)new HashSet<ObjectName>(...)MBeanInstantiator instantiator;/** The MBeanInstantiator object used by the ... */MBeanServer server;/** The MBean server object that is associated to the ... */MBeanServerDelegate delegate;/** The MBean server delegate object that is associated to the ... *//** The Repository object used by the DefaultMBeanServerInterceptor */WeakHashMap<ListenerWrapper,WeakReference<ListenerWrapper>> listenerWrappers;/* See the comment before addNotificationListener below. *//** Wrappers for client listeners. */String domain;/** The default domain of the object names *//** Creates a DefaultMBeanServerInterceptor with the specified ... */// private int sequenceNumber=0;// Now sequence number is handled by MBeanServerDelegate./** The sequence number identifying the notifications sent */this.serverthis.instantiatorthis.domaingetDefaultDomain(...)createMBean(...)InstanceNotFoundException eClass<?> theClassObject moiinstantiate(...)String infoClassNamegetNewMBeanClassName(...)RuntimeException wrappednew RuntimeOperationsException(...)isPattern(...)nonDefaultDomain(...)checkMBeanPermission(...)Level.FINERlogp(...)DefaultMBeanServerInterceptor.classfindClassWithDefaultLoaderRepository(...)findClass(...)checkMBeanTrustPermission(...)testCreation(...)checkCompliance(...)registerObject(...)DynamicMBean mbeangetMBeanInfo(...)NotCompliantMBeanException ncmbenew NotCompliantMBeanException(...)Set<ObjectName> beingUnregistered;new MBeanRegistrationException(...)exclusiveUnregisterMBean(...)DynamicMBean instancegetMBean(...)Object resourceResourceContext contextunregisterFromRepository(...)preDeregisterInvoke(...)postDeregisterInvoke(...)new ObjectInstance(...)Set<ObjectInstance> listqueryMBeansImpl(...)Set<ObjectInstance> allowedListnew HashSet<ObjectInstance>(...)ObjectInstance oigetObjectName(...)filterListOfObjectInstances(...)Set<NamedObject> listquery(...)objectInstancesFromFilteredNamedObjects(...)Set<ObjectName> queryListSet<ObjectInstance> queryObjectInstanceListqueryNamesImpl(...)objectNamesFromFilteredNamedObjects(...)String[] domainsgetDomains(...)List<String> resultObjectName domnewObjectName(...)getCount(...)AttributeNotFoundException erethrowMaybeMBeanException(...)new AssertionError(...)String[] allowedAttributesString classnameList<String> allowedListattributes.lengthString attrrethrow(...)InvalidAttributeValueException eAttributeList allowedAttributesnew AttributeList(...)Attribute attributesetAttributes(...)/* Centralize some of the tedious exception wrapping demanded by the JMX ... */ReflectionException eRuntimeOperationsException eRuntimeErrorException enew RuntimeMBeanException(...)new RuntimeErrorException(...)Throwable t2/** Register <code>object</code> in the repository, with the ... */makeDynamicMBean(...)registerDynamicMBean(...)ObjectName logicalNamepreRegister(...)boolean registeredboolean registerFailedpreRegister2(...)registerWithRepository(...)postRegister(...)ObjectName newNamethrowMBeanRegistrationException(...)registerFailed(...)Error erpreDeregister(...)postDeregister(...)/** Gets a specific MBean controlled by the DefaultMBeanServerInterceptor. ... */DynamicMBean objretrieve(...)new InstanceNotFoundException(...)String completeNamegetDomain(...)/* Notification handling. ... */NotificationBroadcaster broadcastergetNotificationBroadcaster(...)NotificationBroadcaster.classNotificationListener listenerWrappergetListenerWrapper(...)addNotificationListener(...)getCanonicalName(...)removeNotificationListener(...)NotificationListener instancegetListener(...)new ListenerNotFoundException(...)NotificationListener.classClass<? extends NotificationBroadcaster> reqClassNotificationEmitter.classNotificationEmitter emitterDynamicMBean moiMBeanInfo mbiRuntimeMBeanException enew JMRuntimeException(...)String resourceClassNameClass<?> classNameClassClass<?> resourceClassException xLevel.FINEST/** <p>Return the {@link java.lang.ClassLoader} that was used for ... *//** <p>Return the named {@link java.lang.ClassLoader}. ... *//** Sends an MBeanServerNotifications with the specified type for the ... */MBeanServerNotification notifnew MBeanServerNotification(...)MBeanServerDelegate.DELEGATE_NAMEsendNotification(...)/** Applies the specified queries to the set of NamedObjects. */Set<ObjectName> resultNamedObject noMBeanServer oldServergetMBeanServer(...)setMBeanServer(...)boolean resSet<ObjectInstance> resultsafeGetClassName(...)/** Applies the specified queries to the set of ObjectInstances. *//* Get the existing wrapper for this listener, name, and mbean, if ... */ListenerWrapper wrappernew ListenerWrapper(...)WeakReference<ListenerWrapper> refNotificationListener existingnew WeakReference<ListenerWrapper>(...)DefaultMBeanServerInterceptor$ListenerWrapperthis.listenerthis.mbeanhandleNotification(...)ListenerWrapper ww.listenerw.mbeanw.nameNotificationListener listener;ObjectName name;Object mbean;//----------------// SECURITY CHECKSPermission permnew MBeanPermission(...)new MBeanTrustPermission(...)PrivilegedAction<ProtectionDomain> actnew PrivilegedAction<ProtectionDomain>(...) { ... }DefaultMBeanServerInterceptor$1AccessControlContext acc/** A RegistrationContext that makes it possible to perform additional ... */// ------------------------------------------------------------------// Dealing with registration of special MBeans in the repository.new ResourceContext(...) { ... }DefaultMBeanServerInterceptor$ResourceContext$1ResourceContext NONE;/** An empty ResourceContext which does nothing * *//** Adds a MBean in the repository, ... */makeResourceContextFor(...)addMBean(...)MBeanServerNotification.REGISTRATION_NOTIFICATION/** Removes a MBean in the repository, ... */MBeanServerNotification.UNREGISTRATION_NOTIFICATION/** Registers a ClassLoader with the CLR. ... */ModifiableClassLoaderRepository clrgetInstantiatorCLR(...)addClassLoader(...)/** Unregisters a ClassLoader from the CLR. ... */removeClassLoader(...)/** Creates a ResourceContext for a ClassLoader MBean. ... */DefaultMBeanServerInterceptor$2/** Creates a ResourceContext for the given resource. ... */createClassLoaderContext(...)ResourceContext.NONEnew PrivilegedAction<ModifiableClassLoaderRepository>(...) { ... }DefaultMBeanServerInterceptor$3getClassLoaderRepository(...)// JMX RI// JMX import/* Can only happen if loaderName doesn't exist, but we just ... *//* Load the appropriate class. */// Check that the MBean can be instantiated by the MBeanServer.// Check the JMX MBean compliance of the class// ------------------------------// Includes case where getMBeanInfo() returns null/* The semantics of preDeregister are tricky.  If it throws an ... */// pretend the exception came from preDeregister;// in another execution sequence it could have// may throw InstanceNotFoundException// Unregisters the MBean from the repository.// Returns the resource context that was used.// The returned context does nothing for regular MBeans.// For ClassLoader MBeans and JMXNamespace (and JMXDomain)// MBeans - the context makes it possible to unregister these// objects from the appropriate framework artifacts, such as// the CLR or the dispatcher, from within the repository lock.// In case of success, we also need to call context.done() at the// Check if the caller has the right to invoke 'queryMBeans'// Perform query without "query".// on each specific classname/objectname in the list.// OK: Do not add this ObjectInstance to the list// Apply query to allowed MBeans only.// Perform query.// Query the MBeans on the repository// Check if the caller has the right to invoke 'queryNames'/* No Permission check */// isRegistered is always unchecked as per JMX spec.// Check if the caller has the right to invoke 'getDomains'// Return domains// on each specific domain in the list.// OK: Do not add this domain to the list// Make an array from result.// not reached// Check if the caller has the right to invoke 'getAttribute'// on each specific attribute// OK: Do not add this attribute to the list// Check if the caller has the right to invoke 'setAttribute'// should not happen// preRegister returned successfully, so from this point on we// must call postRegister(false) if there is any problem.// until we succeed// Register the MBean with the repository.// For ClassLoader MBeans the context makes it possible to register these// objects with the appropriate framework artifacts, such as// the CLR, from within the repository lock.// neither Error nor Exception??/* The ObjectName looks like ":a=b", and that's what its ... */// ------------------// Check listener// ----------------// Get listener object// Add a listener on an MBean/* We could simplify the code by assigning broadcaster after ... *//* Could be SecurityException or ClassNotFoundException *//* Check if the given MBean is a ClassLoader */// ---------------------// Create notification// No query ...// Access the filter/* query.setMBeanServer is probably ... */// Null query.// Access the filter./* Listeners are not supposed to throw exceptions.  If ... *//* We compare all three, in case the same MBean object ... *//* We do not include name.hashCode() in the hash because ... */// Creates a registration context, if needed.// May throw InstanceAlreadyExistsException// Send create event// Send deletion event/** Called when the newly registered MBean is a ClassLoader ... *//** Removes the  MBean from the default loader repository. *//** <p>This interface specifies the behavior to be implemented by an ... *//** This method should never be called. ... *//* Copyright (c) 2002, 2008, Oracle and/or its affiliates. All rights reserved. ... */import PrivateClassLoaderimport ReflectUtil/** This class keeps the list of Class Loaders registered in the MBean Server. ... */new Hashtable<String,List<ClassLoader>>(...)new Hashtable<ObjectName,ClassLoader>(...)new LoaderEntry[]ClassLoaderRepositorySupport$LoaderEntry/* We associate an optional ObjectName with each entry so that ... */// can be null...[] EMPTY_LOADER_ARRAY;...[] loaders;/** List of class loaders ... *//** Same behavior as add(Object o) in {@link java.util.List}. ... */List<LoaderEntry> lnew ArrayList<LoaderEntry>(...)new LoaderEntry(...)/** Same behavior as remove(Object o) in {@link java.util.List}. ... */loaders.lengthLoaderEntry entryboolean matchentry.loaderentry.nameLoaderEntry[] newloadersMap<String,List<ClassLoader>> search;/** List of valid search */Map<ObjectName,ClassLoader> loadersWithNames;/** List of named class loaders. */// from javax.management.loading.DefaultLoaderRepositoryClassLoaderRepositorySupport.classstartValidSearch(...)stopValidSearch(...)checkPackageAccess(...)...[...].loaderList<ClassLoader> excludednew ArrayList<ClassLoader>(...)ClassLoader instance// without is null => just behave as loadClass// We must try to load the class without the given loader.// bootstrap class loader/* We used to have a special case for "instanceof ... */// OK: continue with next class// Check if we have such a current search// Add an entry// Retrieve the search.import Typeimport Descriptorimport OpenDataExceptionimport OpenTypeimport MethodUtilnew ConvertingMethod(...)OpenDataException odedescriptorForElement(...)getGenericReturnType(...)getGenericParameterTypes(...)getOpenType(...)OpenType<?>[] typesnew OpenType<?>[]paramMappings.length/* Check that this method will be callable when we are going from ... */MXBeanMapping paramConvertercheckReconstructible(...)InvalidObjectException eString[] siggetOpenClass(...)toOpenValue(...)fromOpenValue(...)Object[] oparamsObject[] jparamsMXBeanLookup oldgetLookup(...)setLookup(...)invokeWithOpenReturn(...)Object[] javaParamsObject javaReturnfromOpenParameters(...)methodName(...)new MBeanException(...)OpenDataException eMXBeanMappingFactory mappingFactoryMXBeanMappingFactory.DEFAULTType[] paramsboolean identitymappingForType(...)new MXBeanMapping[]isIdentity(...)...[] noStrings;MXBeanMapping returnMapping;...[] paramMappings;boolean paramConversionIsIdentity;// probably can't happenimport static Util.*import static MXBeanIntrospector.typeNameimport static SimpleType.*import Annotationimport ElementTypeimport GenericArrayTypeimport ParameterizedTypeimport SortedMapimport SortedSetimport TreeSetimport JMXimport ArrayTypeimport CompositeDataimport CompositeDataInvocationHandlerimport CompositeDataSupportimport CompositeDataViewimport CompositeTypeimport SimpleTypeimport TabularDataimport TabularDataSupportimport TabularType/** <p>A converter between Java types and the limited set of classes ... */new Mappings(...)newList(...)OpenType<?>[] simpleTypessimpleTypes.lengthOpenType<?> tClass<?> cMXBeanMapping mappingnew IdentityMapping(...)ObjectName.classputPermanentMapping(...)Field typeFieldClass<?> primitiveTypeMXBeanMapping primitiveMappingClass<?> primitiveArrayTypeOpenType<?> primitiveArrayOpenTypegetPrimitiveArrayType(...)MXBeanMapping primitiveArrayMappingnewIdentityHashMap(...)DefaultMXBeanMappingFactory$NonNullMXBeanMappingfromNonNullOpenValue(...)toNonNullOpenValue(...)/** <p>True if and only if this MXBeanMapping's toOpenValue and ... */DefaultMXBeanMappingFactory$MappingsMappings mappings;List<MXBeanMapping> permanentMappings;/** Following List simply serves to keep a reference to predefined ... */WeakReference<MXBeanMapping> wrnew WeakReference<MXBeanMapping>(...)putMapping(...)/** Get the converter for the given Java type, creating it if necessary. */new OpenDataException(...)typeName(...)getMapping(...)makeMapping(...)openDataException(...)Type componentTypegetGenericComponentType(...)makeArrayOrCollectionMapping(...)Class<?> objClassisEnum(...)makeEnumMapping(...)ElementType.classisMXBeanInterface(...)makeMXBeanRefMapping(...)makeCompositeMapping(...)makeParameterizedTypeMapping(...)new EnumMapping<T>(...)DefaultMXBeanMappingFactory$EnumMapping/* Make the converter for an array type, or a collection such as ... */MXBeanMapping elementMappingOpenType<?> elementOpenTypeArrayType<?> openTypegetArrayType(...)Class<?> elementOpenClassClass<?> openArrayClassString openArrayClassNamenew CollectionMapping(...)new ArrayMapping(...)...[] keyArray;...[] keyValueArray;String objTypeNameMXBeanMapping keyMappingMXBeanMapping valueMappingOpenType<?> keyOpenTypeOpenType<?> valueOpenTypeCompositeType rowTypenew CompositeType(...)TabularType tabularTypenew TabularType(...)new TabularMapping(...)/* We know how to translate List<E>, Set<E>, SortedSet<E>, ... */Type rawTypegetRawType(...)List<>.classSet<>.classSortedSet<>.classType[] actualsgetActualTypeArguments(...)actuals.lengthmustBeComparable(...)boolean sortedMapSortedMap<>.classMap<>.classmakeTabularMapping(...)new MXBeanRefMapping(...)boolean gcInfoHackList<Method> methodseliminateCovariantMethods(...)SortedMap<String,Method> getterMapnewSortedMap(...)int nitemsMethod[] gettersString[] itemNamesOpenType<?>[] openTypesCompositeType compositeTypepropertyName(...)Method olddecapitalize(...)Entry<String,Method> entryMap<>.Entry<String,Method>Method getterType retTypenew CompositeMapping(...)DefaultMXBeanMappingFactory$IdentityMapping/* Converter for classes where the open data is identical to the ... */SimpleType<>.STRINGthis.enumClassinvalidObjectException(...)Class<T> enumClass;DefaultMXBeanMappingFactory$ArrayMappingthis.elementMappingObject[] valueArrayvalueArray.lengthObject[] openArrayType javaTypegetJavaType(...)openArray.lengthMXBeanMapping elementMapping;/** DefaultMXBeanMappingFactory for the elements of this array.  If this is an ... */DefaultMXBeanMappingFactory$CollectionMappingType rawClass<?> collCArrayList<>.classHashSet<>.classTreeSet<>.classCollection<?> valueCollectionComparator<?> comparatorcomparator(...)Collection<Object> valueCollectionClass<? extends Collection<?>> collectionClass;DefaultMXBeanMappingFactory$MXBeanRefMappingSimpleType<>.OBJECTNAMEMXBeanLookup lookuplookupNotNull(...)OpenDataException.classObjectName namemxbeanToObjectName(...)InvalidObjectException.classObject mxbeanobjectNameToMXBean(...)T excConstructor<T> conDefaultMXBeanMappingFactory$TabularMappingthis.sortedMapthis.keyMappingthis.valueMappingMap<Object,Object> valueMapTabularData tablenew TabularDataSupport(...)getRowType(...)Entry<Object,Object> entryMap<>.Entry<Object,Object>Object openKeyObject openValueCompositeData rownew CompositeDataSupport(...)Collection<CompositeData> rowsnewInsertionOrderMap(...)boolean sortedMap;MXBeanMapping keyMapping;MXBeanMapping valueMapping;DefaultMXBeanMappingFactory$CompositeMappingitemNames.lengthgetters.lengththis.itemNamesthis.gettersthis.getterMappingsCompositeType cttoCompositeData(...)Object got/** Determine how to convert back from the CompositeData into ... */Class<?> targetClassCompositeBuilder[][] buildersnew CompositeBuilder[][]new CompositeBuilderViaFrom(...)new CompositeBuilderViaConstructor(...)new CompositeBuilderCheckGetters(...)new CompositeBuilderViaSetters(...)new CompositeBuilderViaProxy(...)CompositeBuilder foundBuilderStringBuilder whyNotsThrowable possibleCauseCompositeBuilder[] relatedBuildersrelatedBuilders.lengthCompositeBuilder builderString whyNotapplicable(...)possibleCause(...)makeCompositeBuilder(...)fromCompositeData(...)...[] itemNames;...[] getters;...[] getterMappings;CompositeBuilder compositeBuilder;DefaultMXBeanMappingFactory$CompositeBuilder/** Converts from a CompositeData to an instance of the targetClass. */this.targetClass/** If the subclass is appropriate for targetClass, then the ... *//** If the subclass returns an explanation of why it is not applicable, ... */Class<?> targetClass;DefaultMXBeanMappingFactory$CompositeBuilderViaFrom/** Builder for when the target class has a method "public static ... */getTargetClass(...)Method fromMethodCompositeData.classthis.fromMethodMethod fromMethod;DefaultMXBeanMappingFactory$CompositeBuilderCheckGetters/** This builder never actually returns success.  It simply serves ... */this.getterConverters...[] getterConverters;Throwable possibleCause;DefaultMXBeanMappingFactory$CompositeBuilderViaSetters/** Builder for when the target class has a setter for every getter. */Method[] settersConstructor<?> cClass<?> returnTypeString setterNameMethod setterthis.settersObject openItemObject javaItem...[] setters;DefaultMXBeanMappingFactory$CompositeBuilderViaConstructor/** Builder for when the target class has a constructor that is ... */DefaultMXBeanMappingFactory$CompositeBuilderViaConstructor$AnnotationHelperfindConstructorPropertiesClass(...)Class<? extends Annotation> constructorPropertiesClass;Method valueMethod;DefaultMXBeanMappingFactory.classClassNotFoundException cnfAnnotation agetAnnotation(...)isAvailable(...)Constructor<?>[] constrsgetConstructors(...)List<Constructor<?>> annotatedConstrListMap<String,Integer> getterMapnewMap(...)getItemNames(...)Set<BitSet> getterIndexSetsnewSet(...)Constructor<?> constrgetPropertyNames(...)String[] propertyNamesType[] paramTypesint[] paramIndexesBitSet presentConstr cnew Constr(...)paramTypes.lengthpropertyNames.lengthint getterIndexType propertyTypeString getterNameBitSet aboolean seenBitSet bBitSet uor(...)Set<String> namesnew TreeSet<String>(...)nextSetBit(...)getCompositeType(...)Constr maxcardinality(...)max.presentParamsConstr constrsubset(...)constr.presentParamsmax.paramIndexesmax.constructorBitSet subcopyandNot(...)DefaultMXBeanMappingFactory$CompositeBuilderViaConstructor$ConstrConstructor<?> constructor;...[] paramIndexes;BitSet presentParams;this.constructorthis.paramIndexesthis.presentParamsList<Constr> annotatedConstructors;DefaultMXBeanMappingFactory$CompositeBuilderViaProxy/** Builder for when the target class is an interface and contains ... */Set<Method> methodsString badClass<?>[] mparamsMethod omnew CompositeDataInvocationHandler(...)Comparable<>.class/** Utility method to take a string and convert it to normal Java variable ... */int offset1offsetByCodePoints(...)codePointAt(...)/** Reverse operation for java.beans.Introspector.decapitalize.  For any s, ... */String restgetParameterTypes(...).lengthMap<Type,Type> inProgress;/* Set up the mappings for Java types that map to SimpleType. */// the classes that these predefined types declare must exist!// OK: must not be a primitive wrapper// Should not reach here/* It's not yet worth formalizing these tests by having for example ... */// Huge hack to avoid compiler warnings here.  The ElementType// parameter is ignored but allows us to obtain a type variable// T that matches <T extends Enum<T>>.// For historical reasons GcInfo implements CompositeData but we// shouldn't count its CompositeData.getCompositeType() field as// an item in the computed CompositeType./* Select public methods that look like "T getX()" or "boolean ... */// field names// field descriptions/* Determine the concrete class to be used when converting ... *//* In this 2D array, each subarray is a set of builders where ... *//* We try to make a meaningful exception message by ... */// skip other builders in this group// See if it has a method "T from(CompositeData)"// as is conventional for a CompositeDataView// success!// OK: it doesn't have the method// java.beans not present// should not reach here// Applicable if and only if there are any annotated constructors// Now check that all the annotated constructors are valid// and throw an exception if not.// First link the itemNames to their getter indexes.// Run through the constructors making the checks in the spec.// For each constructor, remember the correspondence between its// parameters and the items.  The int[] for a constructor says// what parameter index should get what item.  For example,// if element 0 is 2 then that means that item 0 in the// CompositeData goes to parameter 2 of the constructor.  If an// element is -1, that item isn't given to the constructor.// Also remember the set of properties in that constructor// so we can test unambiguity./* Check that no possible set of items could lead to an ambiguous ... */// The CompositeData might come from an earlier version where// not all the items were present.  We look for a constructor// that accepts just the items that are present.  Because of// the ambiguity check in applicable(), we know there must be// at most one maximally applicable constructor./* If the interface has any methods left over, they better be ... *//* We don't catch SecurityException since it shouldn't ... */// Should be name.offsetByCodePoints but 6242664 makes this fail// really an IdentityHashSet but that doesn't existimport ImmutableDescriptornew WeakHashMap<ImmutableDescriptor,WeakReference<ImmutableDescriptor>>(...)new DescriptorCache(...)WeakReference<ImmutableDescriptor> wrImmutableDescriptor gotnew WeakReference<ImmutableDescriptor>(...)DescriptorCache instance;WeakHashMap<ImmutableDescriptor,WeakReference<ImmutableDescriptor>> map;/** A dynamic MBean that wraps an underlying resource.  A version of this ... *//** The resource corresponding to this MBean.  This is the object whose ... *//** The name of this MBean's class, as used by permission checks. ... *//** Additional registration hook.  This method is called after ... *//** Additional registration hook.  This method is called if preRegister ... *//** Utility class to be used by the method <tt>AccessControler.doPrivileged</tt> ... */import SoftReferenceimport AnnotatedElementimport DescriptorKey/** This class contains the methods for performing all the tests needed to verify ... */parseBoolean(...)boolean ALLOW_NONPUBLIC_MBEAN;/* ------------------------------------------ ... *//** Tell whether a MBean of the given class is a Dynamic MBean. ... */DynamicMBean.class/** Basic method for testing that a MBean of a given class can be ... */Constructor<?>[] consListisAbstract(...)consList.lengthException mbeanExceptionException mxbeanExceptiongetStandardMBeanInterface(...)NotCompliantMBeanException egetMXBeanInterface(...)Class<?> mbeanClassClass<? super T> cnew StandardMBeanSupport(...)new MXBeanSupport(...)/** Basic method for testing if a given class is a JMX compliant MBean. ... */testCompliance(...)/** Tests the given interface class for being a compliant MXBean interface. ... */getAnalyzer(...)/** Tests the given interface class for being a compliant MBean interface. ... *//** Basic method for testing if a given class is a JMX compliant ... */MBeanIntrospector<?> introspectorgetClassMBeanInfo(...)PerInterface<M> perInterfacegetPerInterface(...)MBeanIntrospector$PerInterfaceMap/** Get the MBean interface implemented by a JMX Standard ... *//** Get the MBean interface implemented by a JMX Standard MBean class. ... */Class<? super T> currentClass<? super T> mbeanInterfacefindMBeanInterface(...)/** Get the MXBean interface implemented by a JMX MXBean class. ... */findMXBeanInterface(...)/** Try to find the MBean interface corresponding to the class aName ... */Class<? super T> interimplementsMBean(...)Annotation[] annotsgetAnnotations(...)ImmutableDescriptor.EMPTY_DESCRIPTORdescriptorForAnnotations(...)Map<String,Object> descriptorMapannots.lengthClass<? extends Annotation> cannotationType(...)Method[] elementsboolean packageAccessMethod elementDescriptorKey keyDescriptorKey.classannotationToField(...)new ImmutableDescriptor(...)/** Throws a NotCompliantMBeanException or a SecurityException. ... */String reasonNotCompliantMBeanException res// will produce a Descriptor field value "java.lang.String"// E.g. with @interface Foo {class value()} an annotation @Foo(String.class)// Convert a value from an annotation element to a descriptor field valueObject[] xxString[] ssxx.length// often so this inefficient check should be enough.// ImmutableDescriptor.union.  But we don't expect to be called very// This must be consistent with the check for duplicate field values indeepEquals(...)/** Returns the XXMBean interface or null if no such interface exists ... */String clMBeanNameObject bigetBeanInfo(...)Object[] pdsgetPropertyDescriptors(...)Object pdgetReadMethod(...)new AttributeNotFoundException(...)Introspector$SimpleIntrospector/** A simple introspector that uses reflection to analyze a class and ... */new WeakHashMap<Class<?>,SoftReference<List<Method>>>(...)String GET_METHOD_PREFIX;String IS_METHOD_PREFIX;Map<Class<?>,SoftReference<List<Method>>> cache;// cache to avoid repeated lookups/** Returns the list of methods cached for the given class, or {@code null} ... */SoftReference<List<Method>> refList<Method> cached/** Returns {@code true} if the given method is a "getter" method (where ... */Class<?>[] paramTypesint paramCount/** Returns the list of "getter" methods for the given class. The list ... */List<Method> cachedResultgetCachedMethods(...)List<Method> resultnew LinkedList<Method>(...)isReadMethod(...)new SoftReference<List<Method>>(...)/** Returns the "getter" to read the given property from the given class or ... */String getMethodString isMethodLocale.ENGLISHgetReadMethods(...)Introspector$BeansHelper/** A class that provides access to the JavaBeans Introspector and ... */Class<?> introspectorClass;Class<?> beanInfoClass;Class<?> getPropertyDescriptorClass;Method getBeanInfo;Method getPropertyDescriptors;Method getPropertyName;Method getReadMethod;/** Returns {@code true} if java.beans is available. *//** Invokes java.beans.Introspector.getBeanInfo(Class) *//** Invokes java.beans.BeanInfo.getPropertyDescriptors() *//** Invokes java.beans.PropertyDescriptor.getName() *//** Invokes java.beans.PropertyDescriptor.getReadMethod() */// Check if the MBean implements the DynamicMBean interface// Check if the class is a concrete class// Check if the MBean has a public constructor// Is DynamicMBean?// Is Standard MBean?// Is MXBean?// Ignore exception - we need to check whether// mbean is an MXBean first.// Ignore exception - we cannot decide whether mbean was supposed// to be an MBean or an MXBean. We will call checkCompliance()// to generate the appropriate exception.// Check if the MBean implements the MBean or the Dynamic// MBean interface// Check if the given class implements the MBean interface// or the Dynamic MBean interface// Avoid checking access more than once per annotation// we don't expect this - except for possibly// security exceptions?// RuntimeExceptions shouldn't be "UndeclaredThrowable".// anyway...// we don't expect this// An annotation element cannot have a null value but never mind// Remaining possibilities: array of primitive (e.g. int[]),// enum, class, array of enum or class.// The only other possibility is that the value is another// annotation, or that the language has evolved since this code// was written.  We don't allow for either of those currently.// If it is indeed another annotation, then x will be a proxy// with an unhelpful name like $Proxy2.  So we extract the// proxy's interface to use that in the exception message.// array "can't be empty"// Java Beans introspection// Java Beans not available so use simple introspection// to locate method// return cached methods if possible// ignore static methods// boolean isXXX()// getXXX()// return cached result if available// get list of public methods, filtering out methods that have// been overridden to return a more specific type.// filter out the non-getter methods// favor isXXX over getXXX// add result to cache// first character in uppercase (compatibility with JavaBeans)import DefaultMBeanServerInterceptorimport MBeanServerInterceptorimport MBeanServerPermission/** This is the base class for MBean manipulation on the agent side. It ... */boolean DEFAULT_FAIR_LOCK_POLICY;/** Control the default locking policy of the repository. ... */SecureClassLoaderRepository secureClr;boolean interceptorsEnabled;/** true if interceptors are enabled * */MBeanServer outerShell;MBeanServer mbsInterceptor;MBeanServerDelegate mBeanServerDelegateObject;/** The MBeanServerDelegate object representing the MBean Server *//** <b>Package:</b> Creates an MBeanServer with the ... *//** <b>Package:</b> Creates an MBeanServer. ... */MBeanInstantiator fInstantiatornew Repository(...)new ClassLoaderRepositorySupport(...)new MBeanInstantiator(...)this.secureClrnew SecureClassLoaderRepository(...)new PrivilegedAction<ClassLoaderRepository>(...) { ... }JmxMBeanServer$1new MBeanServerDelegateImpl(...)this.mBeanServerDelegateObjectthis.outerShellthis.mbsInterceptornew DefaultMBeanServerInterceptor(...)this.interceptorsEnabled/** Tell whether {@link MBeanServerInterceptor}s are enabled on this ... *//** Return the MBeanInstantiator associated to this MBeanServer. ... *//** Instantiates and registers an MBean in the MBean server. ... */cloneObjectName(...)/** Registers a pre-existing object as an MBean with the MBean server. ... */registerMBean(...)/** De-registers an MBean from the MBean server. The MBean is identified by ... */unregisterMBean(...)/** Gets the <CODE>ObjectInstance</CODE> for a given MBean registered ... */getObjectInstance(...)/** Gets MBeans controlled by the MBean server. This method allows any ... */queryMBeans(...)/** Gets the names of MBeans controlled by the MBean server. This method ... */queryNames(...)/** Checks whether an MBean, identified by its object name, is already ... */isRegistered(...)/** Returns the number of MBeans registered in the MBean server. */getMBeanCount(...)/** Gets the value of a specific attribute of a named MBean. The MBean ... *//** Enables the values of several attributes of a named MBean. The MBean ... *//** Sets the value of a specific attribute of a named MBean. The MBean ... */cloneAttribute(...)/** Sets the values of several attributes of a named MBean. The MBean is ... */cloneAttributeList(...)/** Invokes an operation on an MBean. ... *//** Returns the default domain used for naming the MBean. ... */// From MBeanServer/** Adds a listener to a registered MBean. ... *//** This method discovers the attributes and operations that an MBean exposes ... *//** Instantiates an object using the list of all class loaders registered ... *//** Instantiates an object using the class Loader specified by its ... */ClassLoader myLoader/** Instantiates an object. The class loader to be used is identified ... *//** Returns true if the MBean specified is an instance of the specified ... */isInstanceOf(...)/** De-serializes a byte array in the context of the class loader ... */getClassLoaderFor(...)deserialize(...)/** De-serializes a byte array in the context of a given MBean class loader. ... */ClassLoaderRepository clrnew ReflectionException(...)/** Initializes this MBeanServer, registering the MBeanServerDelegate. ... */ModifiableClassLoaderRepository loadersJmxMBeanServer$3new PrivilegedExceptionAction<Object>(...) { ... }JmxMBeanServer$2JmxMBeanServer.classClassLoader systemLoader/** Return the MBeanServerInterceptor. ... *//** Set the MBeanServerInterceptor. ... *//** <p>Return the ClassLoaderRepository for that MBeanServer. ... *//** This method creates a new MBeanServerDelegate for a new MBeanServer. ... */// These methods are called by the JMX MBeanServerBuilder./** This method creates a new MBeanServer implementation object. ... */boolean fairLockcheckNewMBeanServerPermission(...)new JmxMBeanServer(...)/** Clone object name. *///-------------------// JMX OBJECT CLONING/** Clone attribute. */Attribute.classnew Attribute(...)/** Clone attribute list. */List<Attribute> alistAttributeList.classAttributeList newListnew MBeanServerPermission(...)/* Permission check */// This call requires MBeanPermission 'getClassLoaderFor'// This call requires MBeanPermission 'getClassLoaderRepository'// Clone ObjectName// Make this call just to force the 'getClassLoader'// permission check// Registers the MBeanServer identification MBean/* Add my class loader to the repository ... *//* Add the system class loader, so that if the MBean server is ... */// Determine whether to use fair locking for the repository.// This constructor happens to disregard the value of the interceptors// flag - that is, it always uses the default value - false.// This is admitedly a bug, but we chose not to fix it for now// since we would rather not have anybody depending on the Sun private// interceptor APIs - which is most probably going to be removed and// replaced by a public (javax) feature in the future.// Create new attribute list// Iterate through list and replace non JMX attributesimport MBeanServerBuilder/** This class represents a builder that creates ... */newMBeanServerDelegate(...)newMBeanServer(...)MBeanAnalyzer$AttrMethodsMBeanAnalyzer$MBeanVisitor/** <p>An analyzer for a given MBean interface.  The analyzer can ... */Entry<String,AttrMethods<M>> entryMap<>.Entry<String,AttrMethods<M>>AttrMethods<M> amvisitAttribute(...)am.getteram.setterEntry<String,List<M>> entryMap<>.Entry<String,List<M>>M mvisitOperation(...)Map<String,List<M>> opMap;/* Map op name to method */Map<String,AttrMethods<M>> attrMap;/* Map attr name to getter and/or setter */M getter;M setter;// same interface.// an analyzer will not be recreated for a second MBean using the// cached PerInterface object for an MBean interface means that// really impacts proxy generation.  For MBean creation, the// Currently it's two different but equivalent objects.  This only/** <p>Return an MBeanAnalyzer for the given MBean interface and ... */new MBeanAnalyzer<M>(...)Introspector.ALLOW_NONPUBLIC_MBEANinitMaps(...)// Introspect the mbeanInterface and initialize this object's maps.List<Method> methods1int nParamsM cmmFrom(...)String attrNamenew AttrMethods<M>(...)List<M> cmsconsistent(...)MBeanAnalyzer$MethodOrder/** A comparator that defines a total order so that methods have the ... */new MethodOrder(...)int cmpClass<?>[] aparamsClass<?>[] bparamsClass<?> aretClass<?> bretaparams.lengthbparams.lengthMethodOrder instance;/* Eliminate methods that are overridden with a covariant return type. ... */Method[] sortedSet<Method> overriddenMethodOrder.instanceMethod m0Method m1// visit attributes// visit operations/* Run through the methods to detect inconsistencies and to enable ... */// It's a getter// Check we don't have both isX and getX// It's a setter// It's an operation/* Check that getters and setters are consistent. */// Super type comes first: Object, Number, Integer// could assert bret.isAssignableFrom(aret)// We are assuming that you never have very many methods with the// same name, so it is OK to use algorithms that are quadratic// in the number of methods with the same name.// Methods that don't have the same name can't override each other// Methods that have the same name and same signature override// each other. In that case, the second method overrides the first,// due to the way we have sorted them in MethodOrder.import ConstructorUtil/** Implements the MBeanInstantiator interface. Provides methods for ... */ModifiableClassLoaderRepository clr;//    private MetaData meta = null;this.clr/** This methods tests if the MBean class makes it possible to ... *//** Loads the class with the specified name using this object's ... */ClassNotFoundException ee/** Gets the class for the specified class name using the MBean ... *//** Gets the class for the specified class name using the specified ... *//** Return an array of Class corresponding to the given signature, using ... */ClassLoader aLoadersignature.lengthClass<?>[] tabClass<?> primClaMBeanInstantiator.class/** Instantiates an object given its class, using its empty constructor. ... */Constructor<?> consfindConstructor(...)new NoSuchMethodException(...)ensureClassAccess(...)NoSuchMethodError error/** Instantiates an object given its class, the parameters and ... */findSignatureClasses(...)Throwable th/** De-serializes a byte array in the context of a classloader. ... */ByteArrayInputStream bInObjectInputStream objInnew ObjectInputStreamWithLoader(...)new OperationsException(...)/** Instantiates an object. The class loader to be used is identified by its ... *//** Return the Default Loader Repository used by this instantiator object. *//** Load a class with the specified loader, or with this object ... *//** Load the classes specified in the signature with the given loader, ... */Map<String,Class<?>> primitiveClasses;new IllegalAccessException(...)Permissions permissionsProtectionDomain protectionDomainAccessControlContext ctxnew PrivilegedAction<ClassLoader>(...) { ... }MBeanInstantiator$1// Retrieve the class loader from the repository// Start handling primitive types (int. boolean and so// forth)// Ok we do not have a primitive type ! We need to build// the signature of the method// We need to load the class through the class// loader of the target object.// Load through the default class loader// Instantiate the new object// Wrap the exception.// Build the signature of the method// Exception IllegalArgumentException raised in Jdk1.1.8// Query the metadata service to get the right constructor// Check parameter validity// Object deserialization// Load the class using the agent class loader// Get the class loader MBean// Restrict to getClassLoader permission onlyimport MBeanAttributeInfoimport MBeanConstructorInfoimport MBeanNotificationInfoimport MBeanOperationInfo/* Using a type parameter <M> allows us to deal with the fact that ... *//** An introspector for MBeans of a certain type.  There is one instance ... *//** The map from interface to PerInterface for this type of MBean. *//** The map from concrete implementation class and interface to ... *//** Make an interface analyzer for this type of MBean. *//** True if MBeans with this kind of introspector are MXBeans. *//** Find the M corresponding to the given Method. *//** Get the name of this method. *//** Get the return type of this method.  This is the return type ... *//** Get the parameter types of this method in the Java interface ... *//** Get the signature of this method as a caller would have to supply ... *//** Check that this method is valid.  For example, a method in an ... *//* It would be cleaner if the type of the cookie were a ... *//** Invoke the method with the given target and arguments. ... *//** Test whether the given value is valid for the given parameter of this ... *//** Construct an MBeanAttributeInfo for the given attribute based on the ... *//** Construct an MBeanOperationInfo for the given operation based on ... *//** Get a Descriptor containing fields that MBeans of this kind will ... *//** Get a Descriptor containing additional fields beyond the ones ... *//** Get the methods to be analyzed to build the MBean interface. */PerInterfaceMap<M> mapgetPerInterfaceMap(...)WeakReference<PerInterface<M>> wrPerInterface<M> piMBeanAnalyzer<M> analyzerMBeanInfo mbeanInfomakeInterfaceMBeanInfo(...)new PerInterface<M>(...)new WeakReference<PerInterface<M>>(...)/** Make the MBeanInfo skeleton for the given MBean interface using ... */MBeanInfoMaker makernew MBeanInfoMaker(...)String descriptionmakeMBeanInfo(...)/** True if the given getter and setter are consistent. *//** Invoke the given M on the given target with the given args and cookie. ... */invokeM2(...)unwrapInvocationTargetException(...)/* If the value is of the wrong type for the method we are about to ... *//** Invoke the given setter on the given target with the given argument ... */maybeInvalidParameter(...)validParameter(...)new InvalidAttributeValueException(...)Object aMBeanIntrospector$MBeanInfoMaker/** A visitor that constructs the per-interface MBeanInfo. */MBeanAnalyzer<>.MBeanVisitor<M>MBeanAttributeInfo mbaigetMBeanAttributeInfo(...)MBeanOperationInfo mboigetMBeanOperationInfo(...)/** Make an MBeanInfo based on the attributes and operations ... */MBeanAttributeInfo[] attrArraynew MBeanAttributeInfo[]MBeanOperationInfo[] opArraynew MBeanOperationInfo[]String interfaceClassNameDescriptor classNameDescriptorDescriptor mbeanDescriptorgetBasicMBeanDescriptor(...)Descriptor annotatedDescriptorDescriptor descriptornew MBeanInfo(...)List<MBeanAttributeInfo> attrs;List<MBeanOperationInfo> ops;MBeanIntrospector$MBeanInfoMap/* Looking up the MBeanInfo for a given base class (implementation class) ... *//** Return the MBeanInfo for the given resource, based on the given ... */MBeanNotificationInfo[] notifsfindNotifications(...)notifs.lengthgetOperations(...)getDescriptor(...)/** Return the basic MBeanInfo for resources of the given class and ... */MBeanInfoMap mapgetMBeanInfoMap(...)WeakHashMap<Class<?>,MBeanInfo> intfMapClass<?> intfClassgetMBeanInterface(...)new WeakHashMap<Class<?>,MBeanInfo>(...)MBeanInfo imbigetMBeanDescriptor(...)findConstructors(...)MBeanNotificationInfo[] mbngetNotificationInfo(...)MBeanNotificationInfo[] resultnew MBeanNotificationInfo[]mbn.lengthMBeanNotificationInfo niMBeanNotificationInfo.classConstructor<?>[] consMBeanConstructorInfo[] mbcnew MBeanConstructorInfo[]cons.lengthString descrnew MBeanConstructorInfo(...)/* We do not catch and wrap RuntimeException or Error, ... */// Following is expensive but we only call this method to determine// if an exception is due to an incompatible parameter type.// Plain old c.isInstance doesn't work for primitive types./** This class is the MBean implementation of the MBeanServerDelegate. ... */new MBeanAttributeInfo(...)...[] attributeNames;...[] attributeInfos;MBeanInfo delegateInfo;MBeanServerDelegateImpl.attributeInfos/** Obtains the value of a specific attribute of the MBeanServerDelegate. ... */getMBeanServerId(...)getSpecificationName(...)getSpecificationVersion(...)getSpecificationVendor(...)getImplementationName(...)getImplementationVersion(...)getImplementationVendor(...)AttributeNotFoundException xJMRuntimeException jSecurityException s/** This method always fail since all MBeanServerDelegateMBean attributes ... */String attnameRuntimeException r/** Makes it possible to get the values of several attributes of ... */String[] attnattn.lengthAttributeList listAttribute aMBeanServerDelegateImpl.class/** This method always return an empty list since all ... *//** Always fails since the MBeanServerDelegate MBean has no operation. ... *//** Provides the MBeanInfo describing the MBeanServerDelegate. ... */// attribute must not be null// Extract the requested attribute from file// Unknown attribute// Now we will always fail:// Either because the attribute is null or because it is not// accessible (or does not exist).// This is a hack: we call getAttribute in order to generate an// AttributeNotFoundException if the attribute does not exist.// If we reach this point, we know that the requested attribute// exists. However, since all attributes are read-only, we throw// an AttributeNotFoundException.// If attributes is null, the get all attributes.// Prepare the result list.// Get each requested attribute.// Skip the attribute that couldn't be obtained.// Finally return the result.// Check that operation name is not null.import MXBeanMappingFactory/* We maintain a couple of caches to increase sharing between ... *//** Base class for MBeans.  There is one instance of this class for ... */MBeanIntrospector<M> introspectorgetMBeanIntrospector(...)this.perInterfacethis.mbeanInfo/** Return the appropriate introspector for this type of MBean. *//** Return a cookie for this MBean.  This cookie will be passed to ... */isMXBean(...)// call the contained object's preRegister etc methods even if it has them// preRegister and postRegister, given that it is not supposed to// Methods that javax.management.StandardMBean should call from itsunregister(...)getCookie(...)AttributeList resultObject attrValueObject attrObjAttribute attr// Overridden by StandardMBeanSupportMBeanInfo mbeanInfo;Object resource;PerInterface<M> perInterface;// Undo any work from registration.  We do this in postDeregister// not preDeregister, because if the user preDeregister throws an// exception then the MBean is not unregistered.// OK: attribute is not included in returned list, per spec// XXX: log the exception// We can't use AttributeList.asList because it has side-effectsimport MBeanInfoMapimport PerInterfaceMapimport MBeanParameterInfoimport OpenMBeanAttributeInfoSupportimport OpenMBeanOperationInfoSupportimport OpenMBeanParameterInfoimport OpenMBeanParameterInfoSupport/** Introspector for MXBeans.  There is exactly one instance of this class. ... */new PerInterfaceMap<ConvertingMethod>(...)new MXBeanIntrospector(...)new MBeanInfoMap(...)MXBeanIntrospector instance;analyzer(...)from(...)getOpenSignature(...)checkCallFromOpen(...)Type tObject vfromOpenParameter(...)isValidParameter(...)boolean isReadableboolean isWritableboolean isIsOpenType<?> openTypeType originalTypetypeDescriptor(...)MBeanAttributeInfo aigetOpenReturnType(...)getOpenParameterTypes(...)canUseOpenInfo(...)new OpenMBeanAttributeInfoSupport(...)originalTypeString(...)int impactMBeanOperationInfo.UNKNOWNOpenType<?> returnTypeType originalReturnTypeOpenType<?>[] paramTypesType[] originalParamTypesMBeanParameterInfo[] paramsnew MBeanParameterInfo[]boolean openReturnTypeboolean openParameterTypesAnnotation[][] annotsgetParameterAnnotations(...)MBeanOperationInfo oiString paramNameString paramDescriptionMBeanParameterInfo pinew OpenMBeanParameterInfoSupport(...)new MBeanParameterInfo(...)OpenMBeanParameterInfo[] oparamsnew OpenMBeanParameterInfo[]new OpenMBeanOperationInfoSupport(...)new MBeanOperationInfo(...)/** <p>True if this type can be faithfully represented in an ... */GenericArrayType gatParameterizedType ptPerInterfaceMap<ConvertingMethod> perInterfaceMap;MBeanInfoMap mbeanInfoMap;// Null is a valid value for all OpenTypes, even though// OpenType.isValue(null) will return false.  It can always be// matched to the corresponding Java type, except when that// type is primitive.// Ignore the exception and let MBeanIntrospector.invokeSetter()// throw the initial exception.// could also consult annotations for defaultValue,// minValue, maxValue, legalValues/* Ideally this would be an empty string, but ... *//* If the return value and all the parameters can be faithfully ... *//* We already have immutableInfo=true in the Descriptor ... */import MBeanServerConnectionimport MBeanServerInvocationHandler/* This class handles the mapping between MXBean references and ... *//** @since */new ThreadLocal<MXBeanLookup>(...)this.mbscWeakReference<MXBeanLookup> weakLookupnew MXBeanLookup(...)new WeakReference<MXBeanLookup>(...)WeakReference<Object> wrT proxynewMXBeanProxy(...)Object proxynew WeakReference<Object>(...)String wrongInvocationHandler ihMBeanServerInvocationHandler mbsihgetMBeanServerConnection(...)ObjectName existingString multinamenew InstanceAlreadyExistsException(...)ThreadLocal<MXBeanLookup> currentLookup;MBeanServerConnection mbsc;WeakIdentityHashMap<Object,ObjectName> mxbeanToObjectName;Map<ObjectName,WeakReference<Object>> objectNameToProxy;WeakIdentityHashMap<MBeanServerConnection,WeakReference<MXBeanLookup>> mbscToLookup;// Message will be strange if mxbean is null but it is not// supposed to be./* removeReference can be called when the above condition fails, ... *//** <p>A custom mapping between Java types and Open types for use in MXBeans. ... */Type javaType;OpenType<?> openType;Class<?> openClass;/** <p>Construct a mapping between the given Java type and the given ... */this.javaTypethis.openTypethis.openClassmakeOpenClass(...)/** <p>The Java type that was supplied to the constructor.</p> ... *//** <p>The Open Type that was supplied to the constructor.</p> ... *//** <p>The Java class that corresponds to instances of the ... */MXBeanMapping.class/** <p>Convert an instance of the Open Type into the Java type. ... *//** <p>Convert an instance of the Java type into the Open Type. ... *//** <p>Throw an appropriate InvalidObjectException if we will not ... *//* Copyright (c) 2007, 2012, Oracle and/or its affiliates. All rights reserved. ... */import javax.management.openmbean.*import MXBeanMappingimport DefaultMXBeanMappingFactory/** <p>Defines how types are mapped for a given MXBean or set of MXBeans. ... */new DefaultMXBeanMappingFactory(...)/** <p>Construct an instance of this class.</p> */MXBeanMappingFactory DEFAULT;/** <p>Mapping factory that applies the default rules for MXBean ... *//** <p>Return the mapping for the given Java type.  Typically, a ... *//* Copyright (c) 2007, 2008, Oracle and/or its affiliates. All rights reserved. ... *//** <p>Helper class for an {@link InvocationHandler} that forwards methods from an ... */MBeanAnalyzer<ConvertingMethod> analyzernew Visitor(...)MXBeanProxy$VisitorMBeanAnalyzer<>.MBeanVisitor<ConvertingMethod>Method getterMethodcheckCallToOpen(...)new GetHandler(...)Method setterMethodnew SetHandler(...)Method operationMethodnew InvokeHandler(...)MXBeanProxy$Handlerthis.convertingMethodConvertingMethod convertingMethod;MXBeanProxy$GetHandlerMXBeanProxy$SetHandlerMXBeanProxy$InvokeHandlerthis.signature...[] signature;Handler handlerConvertingMethod cmgetConvertingMethod(...)lookupFor(...)MXBeanLookup oldLookupObject[] openArgstoOpenParameters(...)fromOpenReturnValue(...)Map<Method,Handler> handlerMap;// return type is void, no need for checkCallToOpen/** Base class for MXBeans. ... *//** <p>Construct an MXBean that wraps the given resource using the ... */Set<Class<?>> intfstransitiveInterfaces(...)Set<Class<?>> candidatesClass<?> intfIterator<Class<?>> itClass<?> intf2/* Return all interfaces inherited by this class, directly or ... */Set<Class<?>> setClass<?> sup/* The sequence of events for tracking inter-MXBean references is ... */this.mxbeanLookupaddReference(...)this.objectNameremoveReference(...)MXBeanLookup mxbeanLookup;// for mxbeanLookup and objectNameObjectName objectName;// eventually we could have some logic to supply a default name/** This interface keeps the list of Class Loaders registered in the ... *//** Add an anonymous ClassLoader to the repository. *//** Remove the specified ClassLoader to the repository. ... *//** Add a named ClassLoader to the repository. *//** Remove a named ClassLoader from the repository. *//** Get a named ClassLoader from the repository. */import javax.management.*/** This class is used for storing a pair (name, object) where name is ... *//** Object name. */DynamicMBean object;/** Object reference. *//** Allows a named object to be created. ... */ObjectName objNamenew ObjectName(...)/** Compares the current object name with another object name. ... *//** Returns a hash code for this named object. *//** Get the object name. *//** Get the object *//** This class deserializes an object in the context of a specific class loader. ... *//** @exception ... */resolveClass(...)// Java import// Query the class loader .../** Per-MBean-interface behavior.  A single instance of this class can be shared ... */this.mbeanInterfacethis.introspectornew InitMaps(...)invokeM(...)invokeSetter(...)List<MethodAndSig> listMethodAndSig foundnoSuchMethod(...)MethodAndSig masmas.signatureString badSigsigString(...)PerInterface$MethodAndSigget(...).signaturefound.method/* This method is called when invoke doesn't find the named method. ... */ReflectionException exceptionGetPropertyAction actString invokeGettersSMap<String,M> methodsM methodString[] msigmsig.lengthStringBuilder bPerInterface$InitMaps/** Visitor that sets up the method maps (operations, getters, setters). */checkMethod(...)new MethodAndSig(...)mas.methodsingletonList(...)M method;Class<?> mbeanInterface;MBeanIntrospector<M> introspector;Map<String,M> getters;Map<String,M> setters;Map<String,List<MethodAndSig>> ops;// helpful exception message// Construct the exception that we will probably throw// No compatibility requirement here// Is the compatibility property set?// We don't expect an exception here but if we get one then// we'll simply assume that the property is not set.import ServiceNameimport ReentrantReadWriteLock/** This repository does not support persistency. ... *//** An interface that allows the caller to get some control ... *//** Called by {@link #addMBean}. ... *//** Called by {@link #remove}. ... */Map<String,Map<String,NamedObject>> domainTb;/** The structure for storing the objects is very basic. ... */// Private fields -------------------------------------------->int nbElements;/** Number of elements contained in the Repository *//** Domain name of the server the repository is attached to. ... */ReentrantReadWriteLock lock;/** We use a global reentrant read write lock to protect the repository. ... */Repository$ObjectNamePattern/* This class is used to match an ObjectName against a pattern. */// Private methods --------------------------------------------->// Private fields <=============================================...[] keys;String properties;boolean isPropertyListPattern;boolean isPropertyValuePattern;ObjectName pattern;/** The ObjectName pattern against which ObjectNames are matched. *//** Builds a new ObjectNamePattern object from an ObjectName pattern. ... */isPropertyListPattern(...)isPropertyValuePattern(...)getCanonicalKeyPropertyListString(...)getKeyPropertyList(...)/** Builds a new ObjectNamePattern object from an ObjectName pattern ... */this.isPropertyListPatternthis.isPropertyValuePatternthis.propertiesthis.valuesEntry<String,String> entryMap<>.Entry<String,String>this.pattern/** Return true if the given ObjectName matches the ObjectName pattern ... */String p1String p2keys.lengthString vgetKeyProperty(...)wildmatch(...)/** Add all the matching objects from the given hashtable in the ... */ObjectName onmatchKeys(...)Map<String,NamedObject> moiTbnew HashMap<String,NamedObject>(...)addMoiToTb(...)registering(...)RuntimeOperationsException xRuntimeException xunregistered(...)new NamedObject(...)/** Retrieves the named object contained in repository ... */String dom/** Construct a new repository with the given default domain. */// Public methods --------------------------------------------->// Protected methods <=============================================// Protected methods --------------------------------------------->// Private methods <=============================================new ReentrantReadWriteLock(...)new HashMap<String,Map<String,NamedObject>>(...)ServiceName.DOMAIN/** Returns the list of domains in which any MBean is currently ... */readLock(...)Entry<String,Map<String,NamedObject>> entryMap<>.Entry<String,Map<String,NamedObject>>Map<String,NamedObject> t/** Stores an MBean associated with its object name in the repository. ... */boolean to_default_domainRepository.classaddNewDomMoi(...)String cstrNamedObject elmt/** Checks whether an MBean of the name specified is already stored in ... */retrieveNamedObject(...)/** Retrieves the MBean of the name specified from the repository. The ... *//** Selects and retrieves the list of MBeans whose names match the specified ... */Set<NamedObject> resultnew HashSet<NamedObject>(...)ObjectName.WILDCARDString canonical_key_property_list_stringboolean allNamesObjectNamePattern namePatternnew ObjectNamePattern(...)String dom2MatchaddAllMatching(...)isDomainPattern(...)emptySet(...)/** Removes an MBean from the repository. ... */unregistering(...)/** Gets the number of MBeans stored in the repository. ... *//** Gets the name of the domain currently used by default in the ... */// If key property value pattern but not key property list// pattern, then the number of key properties must be equal// If key property value pattern or key property list pattern,// then every property inside pattern should exist in name// Find value in given object name for key at current// index in receiver// Did we find a value for this key ?// If this property is ok (same key, same value), go to next// wildmatch key property values// values[i] is the pattern;// v is the string// If no pattern, then canonical names must be equal// if all couples (property, value) are contained// shouldn't come here...// No patterns inside reposit// Extract the domain name.// Default domain case// No domain containing registered object names// we use == domain later on...// Creates a new hashtable for the default domain// Temporary list// Skip domains that are in the table but have no// MBean registered in them// in particular the default domain may be like this// Set domain to default if domain is empty and not already set// Do we have default domain ?// ES: OK (dom & domain are interned)// Validate name for an object// Domain cannot be JMImplementation if entry does not exist// If domain does not already exist, add it to the hash table// Add instance if not already present// Calls internal retrieve method to get the named object// The following filter cases are considered:// null, "", "*:*" : names in all domains// ":*", ":[key=value],*" : names in defaultDomain// "domain:*", "domain:[key=value],*" : names in the specified domain// Surely one of the most frequent cases ... query on the whole world// If pattern is not a pattern, retrieve this mbean !// All names in all domains// All names in default domain// Pattern matching in the domain name (*, ?)// Debugging stuff// Extract domain name.// Find the domain subtable// Remove the corresponding element// We removed it !// No more object for this domain, we remove this domain hashtable// set a new default domain table (always present)// need to reinstantiate a hashtable because of possible// big buckets array size inside table, never cleared,// thus the new !// ES: OK dom and domain are interned.// Public methods <=============================================/** Fix security hole in ClassLoaderRepository. This class wraps ... */ClassLoaderRepository clr;/** Creates a new secure ClassLoaderRepository wrapping an ... */loadClassWithout(...)loadClassBefore(...)import NotificationBroadcasterSupportnew StandardMBeanIntrospector(...)new WeakHashMap<Class<?>,Boolean>(...)new PerInterfaceMap<Method>(...)StandardMBeanIntrospector instance;IntrospectionException eboolean immutableisDefinitelyImmutableInfo(...)/* Return true if and only if we can be sure that the given MBean implementation ... */Boolean immutableClass<NotificationBroadcasterSupport> nbsNotificationBroadcasterSupport.classWeakHashMap<Class<?>,Boolean> definitelyImmutable;PerInterfaceMap<Method> perInterfaceMap;/* We don't bother saying mxbean=false, and we can't know whether ... */// Too bad, we'll say no for now./** Base class for Standard MBeans. ... *//** <p>Construct a Standard MBean that wraps the given resource using the ... *//* Standard MBeans that are NotificationBroadcasters can return a different ... *//** Extends the MBeanServer interface to ... *//** <p>Return the MBeanServerDelegate representing the MBeanServer. ... *//* Copyright (c) 2000, 2008, Oracle and/or its affiliates. All rights reserved. ... */import TreeMapimport MalformedObjectNameExceptionMalformedObjectNameException enew HashMap<K,V>(...)new IdentityHashMap<K,V>(...)Map<K,V> mapnew TreeMap<K,V>(...)TreeMap$Entrynew LinkedHashMap<K,V>(...)new ArrayList<E>(...)/* This method can be used by code that is deliberately violating the ... *//** Computes a descriptor hashcode from its names and values. ... */deepHashCode(...)/* The algorithm is a classical one.  We advance pointers in ... *//** Match a part of a string against a shell-style pattern. ... */int starstriint starpatichar patc/** Match a string against a shell-style pattern.  The only pattern ... */// hashcode of a list containing just v is// v.hashCode() + 31, see List.hashCode()// System.out.println("matching "+pat.substring(pati,patend)+//        " against "+str.substring(stri, strend));// index for backtrack if "*" attempt fails// index for backtrack if "*" attempt fails, +1/* On each pass through this loop, we either advance pati, ... */// Mismatched, can we backtrack to a "*"?// Retry the match one position later in strimport Referenceimport ReferenceQueue/* The approach ... *//** <p>A map where keys are compared using identity comparison (like ... */new ReferenceQueue<K>(...)new WeakIdentityHashMap<K,V>(...)WeakReference<K> keyrefmakeReference(...)expunge(...)Reference<? extends K> refnew IdentityWeakReference<K>(...)WeakIdentityHashMap$IdentityWeakReference/** WeakReference where equals and hashCode are based on the ... */this.hashCodeIdentityWeakReference<?> wrMap<WeakReference<K>,V> map;ReferenceQueue<K> refQueue;import NotificationFilterSupportimport NotificationResultimport TargetedNotificationimport ClassLogger/* There is one instance of ArrayNotificationBuffer for every ... *//** A circular buffer of notifications received from an MBean server. */new HashSet<ShareBuffer>(...)new BufferListener(...)new NotificationListener(...) { ... }ArrayNotificationBuffer$5debug(...)createdNotification(...)new HashMap<MBeanServer,ArrayNotificationBuffer>(...)new BroadcasterQuery(...)NotificationFilterSupport nfsnew NotificationFilterSupport(...)enableType(...)new ClassLogger(...)boolean disposed;Object globalLock;// FACTORY STUFF, INCLUDING SHARINGHashMap<MBeanServer,ArrayNotificationBuffer> mbsToBuffer;Collection<ShareBuffer> sharers;int queueSizegetNotifBufferSize(...)ArrayNotificationBuffer bufboolean createNotificationBuffer shareremptyMap(...)new ArrayNotificationBuffer(...)new ShareBuffer(...)createListeners(...)/* Ensure that this buffer is no longer the one that will be returned by ... */resize(...)boolean emptyremoveNotificationBuffer(...)ShareBuffer bufint bufsizedestroyListeners(...)dropNotification(...)ArrayNotificationBuffer$ShareBufferaddSharer(...)NotificationBuffer bufArrayNotificationBuffer.thisfetchNotifications(...)removeSharer(...)// ARRAYNOTIFICATIONBUFFER IMPLEMENTATIONtraceOn(...)this.mBeanServerthis.queueSizethis.queuenew ArrayQueue<NamedNotification>(...)this.earliestSequenceNumberthis.nextSequenceNumber// supposed to be accessing this class.// The JDK doesn't contain any such calls and users are not// We no longer support calling this method from outside./** <p>Fetch notifications that match the given listeners.</p> ... */long endTimelong earliestSeqlong nextSeqList<TargetedNotification> notifsnew ArrayList<TargetedNotification>(...)int nnotifsTargetedNotification[] resultNotifsnew TargetedNotification[]NotificationResult nrnew NotificationResult(...)isDisposed(...)earliestSequenceNumber(...)nextSequenceNumber(...)debugOn(...)NamedNotification candidateNotification notifgetNotification(...)List<TargetedNotification> matchedNotifsnotificationAt(...)ServerNotifForwarder.NotifForwarderBufferFilterlong toWaitlong indexArrayNotificationBuffer$NamedNotificationthis.senderthis.notificationObjectName sender;Notification notification;/* Add our listener to every NotificationBroadcaster MBean ... */Set<ObjectName> namesRuntimeException readdBufferListener(...)checkNoLocks(...)new PrivilegedExceptionAction<Void>(...) { ... }ArrayNotificationBuffer$1extractException(...)ArrayNotificationBuffer$2PrivilegedAction<Set<ObjectName>> actnew PrivilegedAction<Set<ObjectName>>(...) { ... }ArrayNotificationBuffer$3PrivilegedExceptionAction<Boolean> actnew PrivilegedExceptionAction<Boolean>(...) { ... }ArrayNotificationBuffer$4/* This method must not be synchronized.  See the comment on the ... */String shouldEqualgetMBeanName(...)removeBufferListener(...)ArrayNotificationBuffer$BufferListeneraddNotification(...)new NamedNotification(...)NotificationListener bufferListener;ArrayNotificationBuffer$BroadcasterQueryMBeanServer mbsQueryExp broadcasterQuery;NotificationFilter creationFilter;NotificationListener creationListener;holdsLock(...)/** Iterate until we extract the real exception ... */ClassLogger logger;MBeanServer mBeanServer;ArrayQueue<NamedNotification> queue;int queueSize;long earliestSequenceNumber;long nextSequenceNumber;Set<ObjectName> createdDuringQuery;String broadcasterClass;//Find out queue size/* We avoid holding any locks while calling createListeners. ... */// Notify potential waiting fetchNotification call// Check arg validity/* Determine the end time corresponding to the timeout value. ... */// overflow/* We set earliestSeq the first time through the loop.  If we ... *//* On exit from this loop, notifs, earliestSeq, and nextSeq must ... *//* Get the next available notification regardless of filters, ... *//* First time through.  The current earliestSequenceNumber ... *//* If many notifications have been dropped since the ... */// Skip security check if NotificationBufferFilter is not overloaded/* nextSeq is the largest sequence number.  If we ... *//* dispose called *//* We have a candidate notification.  See if it matches ... *//* We only check the max size now, so that our ... */// end while/* Construct and return the result. *//* Spec doesn't say whether Set returned by QueryNames can be modified ... *//* This can happen if the MBean was unregistered just ... */this.capacitynewArray(...)this.headthis.tailT[] newqueueint newtailT removedint capacity;...[] queue;int head;int tail;// we did add something// Can't use % here because it's not mod: -3 % 2 is -1, not +1.import InterruptedIOExceptionlong threadNo;this.periodThread tnew Checker(...)/** Called by a client to inform of getting an IOException. */restart(...)/** Called by this class to check a client connection. *//** Tells a client to re-start again. *//** Tells a client to stop because failing to call checkConnection. *//** Terminates this object. */InterruptedException ireInterruptedIOException iioenew InterruptedIOException(...)doStart(...)doStop(...)Exception eeeterminate(...)ClientCommunicatorAdmin$Checker// --------------------------------------------------------------// private varaiblesisInterrupted(...)checkConnection(...)gotIOException(...)Exception eeThread myThread;Checker checker;// private variableslong period;int CONNECTED;// stateint RE_CONNECTING;int FAILED;int TERMINATED;...[] lock;// check state// already failed to re-start by another thread// restart process has been called by another thread// we need to wait// be asked to give up// restarted is failed by another thread// re-starting// OK.// We know there is a problem.// We will check the state at the following steps// XXX stop checking?import Subject/** <p>An identified listener.  A listener has an Integer id that is ... */this.listenerIDthis.filterthis.handbackthis.delegationSubjectgetNotificationFilter(...)getHandback(...)Integer listenerID;NotificationFilter filter;Object handback;Subject delegationSubject;import Executorimport UnmarshalExceptionnew HashMap<Integer,ClientListenerInfo>(...)AccessControlContext acc;ClientNotifForwarder$LinearExecutor/* An Executor that allows at most one executing and one pending ... */this.commandnew Thread(...) { ... }ClientNotifForwarder$LinearExecutor$1Runnable rLinearExecutor.thisLinearExecutor.this.commandRunnable command;Executor exgetMaxFetchNotifNumber(...)getFetchTimeout(...)new LinearExecutor(...)this.defaultClassLoaderthis.executorthis.acc/** Called to to fetch notifications from a server. *//** Used to send out a notification about lost notifs */new ClientListenerInfo(...)List<Integer> idsList<ClientListenerInfo> valuesnew ArrayList<ClientListenerInfo>(...)beforeRemove(...)ClientListenerInfo lisameAs(...)getListenerID(...)/* Called when a connector is doing reconnection. Like <code>postReconnection</code>, ... */ClientListenerInfo[] tmpnew ClientListenerInfo[]/** Called after reconnection is finished. ... */boolean tracelistenerInfos.lengthaddListenerForMBeanRemovedNotif(...)ClientNotifForwarder$NotifFetcher// -------------------------------------------------// private classesboolean alreadyLogged;config(...)// Set new context class loader, returns previous one.AccessControlContext ctxtClientNotifForwarder.this.accClientNotifForwarder.thislogOnce(...)ClientNotifForwarder$NotifFetcher$1ClassLoader previousSecurityException xdoRun(...)shouldStop(...)fetchNotifs(...)TargetedNotification[] notifsgetTargetedNotifications(...)Map<Integer,ClientListenerInfo> listenersInteger myListenerIDlong missedgetEarliestSequenceNumber(...)getNextSequenceNumber(...)TargetedNotification tnInteger listenerIDString unregMBeanServerNotification mbsnlostNotifs(...)dispatchNotification(...)removeListenerForMBeanRemovedNotif(...)execute(...)NotificationListener lObject hfetchOneNotif(...)error(...)/* Fetch one notification when we suspect that it might be a ... */ClientNotifForwarder cnflong startSequenceNumberint notFoundCountNotificationResult resultlong firstEarliest// private methods/* Called to decide whether need to start a thread for fetching notifs. ... */new NotifFetcher(...)/** Import: should not remove a listener during reconnection, the reconnection ... */ClassLoader defaultClassLoader;Executor executor;Map<Integer,ClientListenerInfo> infoList;long clientSequenceNumber;// notif stuffint maxNotifications;Integer mbeanRemovedNotifID;Thread currentFetchThread;int STARTING;/** This state means that a thread is being created for fetching and forwarding notifications. */int STARTED;/** This state tells that a thread has been started for fetching and forwarding notifications. */int STOPPING;/** This state means that the fetching thread is informed to stop. */int STOPPED;/** This state means that the fetching thread is already stopped. *//** This state means that this object is terminated and no more thread will be created ... */boolean beingReconnected;/** This variable is used to tell whether a connector (RMIConnector or ClientIntermediary) ... *//* Copyright (c) 2002, 2015, Oracle and/or its affiliates. All rights reserved. ... *//* You can supply an Executor in which the remote call to ... */// should never// doing or waiting reconnection// only update mbeanRemovedNotifID// old listeners are re-added// not update clientSequenceNumber// only new listeners added during reconnection// need update clientSequenceNumber// Log only once.// if ctxt is null, log a config message and throw a// SecurityException.// get context class loader - may throw// SecurityException - though unlikely.// if nothing needs to be done, break here...// reset context class loader - may throw// SecurityException// nr == null means got exception// check sequence number.// check if an mbean unregistration notif// forward// tell that the thread is REALLY stopped// no more fetching// 0 notifs to update startSequenceNumber// 1 notif to skip possible missing class// Even if result.getEarliestSequenceNumber() is now greater than// it was initially, meaning some notifs have been dropped// from the buffer, we don't want the caller to see that// because it is then likely to renotify about the lost notifs.// So we put back the first value of earliestSequenceNumber// that we saw.// no more listener, stop fetching// wait for another thread to do, which is doing reconnection// make sure only one fetching thread.// re-call this method to check the state again,// the state can be other value like TERMINATED.// init the clientSequenceNumber if not reconnected.// JDK-8038940// reconnection must happen during// fetchNotifs(-1, 0, 0), and a new// thread takes over the fetching job// for cleaning// start fetching// should not/** A helper class for RMI-IIOP and CORBA APIs. */new PrivilegedAction<IIOPProxy>(...) { ... }IIOPHelper$1IIOPHelper.classString IMPL_CLASS;// loads IIOPProxy implementation class if availableIIOPProxy proxy;/** Returns true if RMI-IIOP and CORBA is available. *//** Returns true if the given object is a Stub. *//** Returns the Delegate to which the given Stub delegates. */ensureAvailable(...)/** Sets the Delegate for a given Stub. *//** Returns the ORB associated with the given stub ... */getOrb(...)/** Connects the Stub to the given ORB. *//** Returns true if the given object is an ORB. */isOrb(...)/** Creates, and returns, a new ORB instance. */createOrb(...)/** Converts a string, produced by the object_to_string method, back ... */stringToObject(...)/** Converts the given CORBA object reference to a string. */objectToString(...)/** Checks to ensure that an object of a remote or abstract interface ... *//** Makes a server object ready to receive remote calls *//** Deregisters a server object from the runtime. *//** Returns a stub for the given server object. *//* Copyright (c) 2009, 2012, Oracle and/or its affiliates. All rights reserved. ... *//** An interface to a subset of the RMI-IIOP and CORBA APIs to avoid a ... *//* Copyright (c) 2009, Oracle and/or its affiliates. All rights reserved. ... *//** A buffer of notifications received from an MBean server. *//** <p>Discard this buffer.</p> *//** Add the given notification coming from the given MBean to the list ... */import ObjectInputimport RemoteObjectimport RemoteRefthis.refgetRefClass(...)newCall(...)remoteEquals(...)remoteHashCode(...)remoteToString(...)RemoteRef ref;/* Copyright (c) 2003, 2008, Oracle and/or its affiliates. All rights reserved. ... */import RMIClientSocketFactoryimport RMIServerSocketFactory/** <p>Unpublished interface controlling how the RMI Connector Server ... */String EXPORTER_ATTRIBUTE;Runnable timeoutTasknew Timeout(...)/** Tells that a new request message is received. ... *//** Tells that a response is sent out for a received request. ... */logtime(...)/** Called by this class to tell an implementation to do stop. *//** Terminates this object. ... */ServerCommunicatorAdmin$Timeoutboolean stoppinglong remaininglong elapsedint currentJobs;boolean terminated;// state issueClassLogger timelogger;// If you change this name you will need to change a unit test// (NoServerTimeoutTest)// tells the adminor to restart waiting with timeout// tell Timeout to terminate// wait until there is no more job// stoppingimport NotificationAccessControllernew NotifForwarderBufferFilter(...)new HashMap<ObjectName,Set<IdAndFilter>>(...)String stringBooleanthis.mbeanServerthis.notifBufferthis.connectionIdgetServerConnectionTimeout(...)computeBooleanFromString(...)getNotificationAccessController(...)ObjectName nngetSubject(...)boolean instanceOfServerNotifForwarder$1MalformedObjectNameException mfoeIdAndFilter idafnew IdAndFilter(...)Set<IdAndFilter> setnew HashSet<IdAndFilter>(...)Exception relistenerIDs.lengthNotifForwarderBufferFilter bufferFilter;/* This is the object that will apply our filtering to candidate ... */ServerNotifForwarder$NotifForwarderBufferFilterIdAndFilter[] candidatesnew IdAndFilter[]NotificationFilter nfgetFilter(...)isNotificationEnabled(...)new TargetedNotification(...)allowNotificationEmission(...)long tsnoopOnUnregister(...)// See 6957378.// so that we can know too, and remove the corresponding entry from the listenerMap.// in order to be told when MBeans are unregistered.  We snoop on fetched notifications// The standard RMI connector client will register a listener on the MBeanServerDelegateList<IdAndFilter> copySet<IdAndFilter> delegateSetnew ArrayList<IdAndFilter>(...)idaf.idNotification nObjectName gone// PRIVATE METHODS/** Explicitly check the MBeanPermission for ... */MBeanPermission permnew PrivilegedExceptionAction<ObjectInstance>(...) { ... }ServerNotifForwarder$2/** Check if the caller has the right to get the following notifications. */fetchNotification(...)ServerNotifForwarder$IdAndFilterInteger id;MBeanServer mbeanServer;//------------------// PRIVATE VARIABLESString connectionId;long connectionTimeout;int listenerCounter;...[] listenerCounterLock;NotificationBuffer notifBuffer;Map<ObjectName,Set<IdAndFilter>> listenerMap;...[] terminationLock;boolean checkNotificationEmission;NotificationAccessController notificationAccessController;// Explicitly check MBeanPermission for addNotificationListener// 6238731: set the default domain if no domain is set.// impossible, but...// Tread carefully because if set.size() == 1 it may be the// Collections.singleton we make here, which is unmodifiable.// Explicitly check MBeanPermission for removeNotificationListener// Give back the first exception// Tread carefully because if set.size() == 1 it may be a// Collections.singleton, which is unmodifiable.// We proceed in two stages here, to avoid holding the listenerMap// lock while invoking the filters (which are user code).// We don't synchronize on targetedNotifs, because it is a local// variable of our caller and no other thread can see it.// This is a notification from the MBeanServerDelegate.import MarshalledObjectimport JMXConnectorProviderimport JMXConnectorimport JMXServiceURLimport RMIConnectorgetProtocol(...)new MalformedURLException(...)new RMIConnector(...)import IIOPProxy/** An implementation of IIOPProxy that simply delegates to the appropriate ... */Permissions pAccessControlContext STUB_ACC;// the only allowed privilege is SerializablePermission("enableSubclassImplementation")// special ACC used to initialize the IIOP stubBAD_OPERATION xnew PrivilegedExceptionAction<Remote>(...) { ... }IIOPProxyImpl$1/* Copyright (c) 2009,2013, Oracle and/or its affiliates. All rights reserved. ... */this.inimport JMXConnectorServerimport JMXConnectorServerProviderimport RMIConnectorServernew RMIConnectorServer(...)import FilePermissionimport AccessControlExceptionimport javax.security.auth.*import javax.security.auth.callback.*import javax.security.auth.login.*import javax.security.auth.spi.*import JMXPrincipalimport ConnectorBootstrap/** This {@link LoginModule} performs file-based authentication. ... */ConnectorBootstrap.DefaultValues.PASSWORD_FILE_NAMEFile.separatorCharConnectorBootstrap.DefaultValuesString DEFAULT_PASSWORD_FILE_NAME;// Location of the default password fileString USERNAME_KEY;// Key to retrieve the stored usernameString PASSWORD_KEY;// Key to retrieve the stored password// Log messagesboolean useFirstPass;// Configurable optionsboolean tryFirstPass;boolean storePass;boolean clearPass;boolean succeeded;// Authentication statusboolean commitSucceeded;String username;// Supplied username and password...[] password;JMXPrincipal user;// Initial stateCallbackHandler callbackHandler;Map<String,Object> sharedState;Map<String,?> options;String passwordFile;String passwordFileDisplayName;boolean userSuppliedPasswordFile;boolean hasJavaHomePermission;Properties userCredentials;/** Initialize this <code>LoginModule</code>. ... */this.subjectthis.callbackHandlerthis.sharedStatethis.options/** Begin user authentication (Authentication Phase 1). ... */loadPasswordFile(...)LoginException lenew LoginException(...)attemptAuthentication(...)cleanState(...)/** Complete user authentication (Authentication Phase 2). ... */isReadOnly(...)getPrincipals(...)/** Abort user authentication (Authentication Phase 2). ... */logout(...)/** Logout a user. ... *//** Attempt authentication ... */String localPasswordgetUsernamePassword(...)new FailedLoginException(...)new JMXPrincipal(...)/* Read the password file. */FilePermission fpnew FilePermission(...)AccessControlException acenew AccessControlException(...)setStackTrace(...)BufferedInputStream bis/** Get the username and password. ... */Callback[] callbacksnew Callback[]new NameCallback(...)new PasswordCallback(...)char[] tmpPasswordgetPassword(...)tmpPassword.lengthclearPassword(...)UnsupportedCallbackException ucegetCallback(...)/** Clean out state because of a failed authentication attempt *//* Copyright (c) 2004, 2008, Oracle and/or its affiliates. All rights reserved. ... */// initialize any configured options// set the location of the password file// attempt the authentication// attempt the authentication by getting the// username and password from shared state// authentication succeeded// authentication failed -- try again below by prompting// authentication failed// attempt the authentication using the supplied username and password// add Principals to the Subject// in any case, clean out state// Clean out state// overall authentication succeeded and commit succeeded,// but someone else's commit failed// clean out state// sharedState used as Map<String,Object>// get the username and password// userCredentials is initialized in login()// username not found or passwords do not match// Save the username and password in the shared state// only if authentication succeeded// Create a new user principal// use the password saved by the first module in the stack// acquire username and passwordimport JMXAuthenticatorimport AuthPermissionimport AppConfigurationEntryimport Configurationimport LoginContextimport LoginExceptionimport LoginModule/** <p>This class represents a ... *//** Creates an instance of <code>JMXPluggableAuthenticator</code> ... */String loginConfigNameString passwordFilenew LoginContext(...)new JMXCallbackHandler(...)String pfnew AuthPermission(...)new PrivilegedExceptionAction<LoginContext>(...) { ... }JMXPluggableAuthenticator$1new FileLoginConfig(...)authenticationFailure(...)/** Authenticate the <code>MBeanServerConnection</code> client ... */String[] aCredentialsaCredentials.lengthSubject subjectlogin(...)JMXPluggableAuthenticator$2logException(...)LoginContext loginContext;String password;String LOGIN_CONFIG_PROP;String LOGIN_CONFIG_NAME;String PASSWORD_FILE_PROP;JMXPluggableAuthenticator$JMXCallbackHandler/** This callback handler supplies the username and password (which was ... *//** Sets the username and password in the appropriate Callback object. */callbacks.lengthsetPassword(...)new UnsupportedCallbackException(...)JMXPluggableAuthenticator$FileLoginConfig/** This class defines the JAAS configuration for file-based authentication. ... */FileLoginModule.class// The JAAS configuration for file-based authenticationString FILE_LOGIN_MODULE;// The classname of the login module for file-based authenticationString PASSWORD_FILE_OPTION;// The option that identifies the password file to use/** Creates an instance of <code>FileLoginConfig</code> ... */Map<String,String> optionsnew AppConfigurationEntry[]new AppConfigurationEntry(...)AppConfigurationEntry.LoginModuleControlFlag.REQUIREDAppConfigurationEntry.LoginModuleControlFlag/** Gets the JAAS configuration for file-based authentication *//** Refreshes the configuration. */// use the supplied JAAS login configuration// use the default JAAS login configuration (file-based)// Verify that credentials is of type String[].// Special case for null so we get a more informative message// Verify that the array contains two elements.// Verify that username exists and the associated// password matches the one supplied by the client.// Perform authentication// the configuration is fixedimport CodeSourceimport SubjectDomainCombiner/** <p>This class represents an extension to the {@link SubjectDomainCombiner} ... */new CodeSource(...)ProtectionDomain[] newCurrentcurrent.lengthcombine(...)CodeSource nullCodeSource;/** A null CodeSource. */ProtectionDomain pdNoPerms;/** A ProtectionDomain with a null CodeSource and an empty permission set. *//** Get the current AccessControlContext combined with the supplied subject. */new JMXSubjectDomainCombiner(...)/** Get the AccessControlContext of the domain combiner created with ... */// Add a new ProtectionDomain with the null codesource/signers, and// the empty permission set, to the end of the array containing the// 'current' protections domains, i.e. the ones that will be augmented// with the permissions granted to the set of principals present in// the supplied subject.import MBeanServerForwarder/** <p>An object of this class implements the MBeanServer interface ... */this.mbs/** Check if the caller can do read operations. This method does ... *//** Check if the caller can do write operations.  This method does ... *//** Check if the caller can create the named class.  The default ... */checkWrite(...)/** Check if the caller can unregister the named MBean.  The default ... *//** Call <code>checkRead()</code>, then forward this method to the ... *///--------------------------------------------// Implementation of the MBeanServer interfacecheckRead(...)/** Call <code>checkCreate(className)</code>, then forward this method to the ... */checkCreate(...)checkClassLoader(...)/** Call <code>checkWrite()</code>, then forward this method to the ... */checkMLetMethods(...)/** Call <code>checkUnregister()</code>, then forward this method to the ... */checkUnregister(...)GetPropertyAction propActionboolean allowGetMBeansFromURL// Check if security manager installed// Check for addURL and getMBeansFromURL methods// Check if MBean is instance of MLet// Throw security exception// addURL// getMBeansFromURL// Whether or not calling getMBeansFromURL is allowed is controlled// by the value of the "jmx.remote.x.mlet.allow.getMBeansFromURL"// system property. If the value of this property is true, calling// the MLet's getMBeansFromURL method is allowed. The default value// for this property is false.import Pattern/** <p>An object of this class implements the MBeanServerAccessController ... */String READONLY;String READWRITE;String CREATE;String UNREGISTER;MBeanServerFileAccessController$AccessTypenew AccessType(...)AccessType READ;AccessType WRITE;AccessType CREATE;AccessType UNREGISTER;MBeanServerFileAccessController$Accessboolean write;...[] createPatterns;boolean unregister;int npatsthis.writethis.createPatternsthis.unregister...[] NO_STRINGS;/** <p>Create a new MBeanServerAccessController that forwards all the ... */propertiesFromFile(...)this.accessFileNameparseProperties(...)AccessType.READAccessType.WRITE/** Check if the caller can create MBeans or instances of the given class. ... */AccessType.CREATE/** Check if the caller can do unregister operations.  This method does ... */AccessType.UNREGISTER/** <p>Refresh the set of username/access level entries.</p> ... */FileInputStream finProperties pSubject snew PrivilegedAction<Subject>(...) { ... }MBeanServerFileAccessController$1Set<> principalsString newPropertyValueAccess accessboolean okaccess.writeaccess.unregistercheckCreateAccess(...)SecurityException se2String classNamePatternaccess.createPatternsclassNameMatch(...)String tokquote(...)matches(...)this.accessMapnew HashMap<String,Access>(...)String identityString accessStringparseAccess(...)MBeanServerFileAccessController$ParserisWhitespace(...)int EOS;String identity;String s;// just for better error messagesint len;// the string we're parsing// s.length()// 16 bits for Unicode.// "supplementary characters", the ones that don't fit in the original// (if unlikely) that a classname in a create clause might contain// c is EOS.  We use int rather than char because it is conceivable// At any point, either c is s.codePointAt(i), or i == len andthis.identitythis.sthis.lenthis.inew Parser(...)parseWord(...)skipSpace(...)new Access(...)parseReadWrite(...)syntax(...)List<String> createClassesboolean unregisterparseCreate(...)parseClassName(...)boolean dotOKisJavaIdentifierPart(...)// Advance c and i to the next character, unless already at EOS.charCount(...)Map<String,Access> accessMap;String accessFileName;/* security has not been enabled */// all access entries imply read// Add some more information to help people with deployments that// worked before we required explicit create clauses. We're not giving// any information to the bad guys, other than that the access control// is based on a file, which they could have worked out from the stack// trace anyway.// We studiously avoided regexes when parsing the properties file,// because that is done whenever the VM is started with the// appropriate -Dcom.sun.management options, even if nobody ever// creates an MBean.  We don't want to incur the overhead of loading// all the regex code whenever those options are specified, but if we// get as far as here then the VM is already running and somebody is// doing the very unusual operation of remotely creating an MBean.// Because that operation is so unusual, we don't try to optimize// by hand-matching or by caching compiled Pattern objects.// pseudo-codepoint "end of string"// We don't check that classname components begin with suitable// characters (so we accept 1.2.3 for example).  This means that// there are only two states, which we can call dotOK and !dotOK// according as a dot (.) is legal or not.  Initially we're in// !dotOK since a classname can't start with a dot; after a dot// we're in !dotOK again; and after any other characters we're in// dotOK.  The classname is only accepted if we end in dotOK,// so we reject an empty name or a name that ends with a dot./** <p>This interface allows to control remote access to the ... *//** This method is called when a remote ... *//** This method is called before the ... */import SubjectDelegationPermission/* Return the AccessControlContext appropriate to execute an ... */Collection<Principal> psgetSubjectPrincipals(...)Collection<Permission> permissionsnew ArrayList<Permission>(...)PrivilegedAction<Void> actionSubjectDelegator$1Permission sdpString pnamenew SubjectDelegationPermission(...)getDelegatedAcc(...)getDomainCombinerContext(...)/** Check if the connector server creator can assume the identity of each ... *//** Retrieves the {@linkplain Subject} principals ... */List<Principal> principalsnew Principal[]unmodifiableList(...)/* Copyright (c) 2003, 2014, Oracle and/or its affiliates. All rights reserved. ... */// Check if the subject delegation permission allows the// authenticated subject to assume the identity of each// principal in the delegated subjectthis.cl2ClassNotFoundException cneClassLoaderRepository repository;ClassLoader cl2;boolean loadedLogger.classboolean ok;finerOn(...)finestOn(...)Level.INFOLevel.CONFIGfinest(...)finer(...)/* We attempt to work even if we are running in J2SE 1.3, where ... */// java.util.logger package is not available in this jvm.import JMXConnectorFactoryimport JMXConnectorServerFactoryJMXConnectorFactory.DEFAULT_CLASS_LOADERJMXConnectorServerFactory.DEFAULT_CLASS_LOADER_NAMEString CREDENTIAL_TYPES;/** Name of the attribute that specifies a list of class names acceptable ... */String DEFAULT_CLASS_LOADER;/** <p>Name of the attribute that specifies a default class loader ... */String DEFAULT_CLASS_LOADER_NAME;/** Get the Connector Server default class loader. ... */Object loaderObject nameClassLoader.class/** Get the Connector Client default class loader. ... *//** Initialize the cause field of a {@code Throwable} object. ... *//** Returns the cause field of a {@code Throwable} object. ... */Throwable retMethod getCauseString BUFFER_SIZE_PROPERTY;/** <p>Name of the attribute that specifies the size of a notification ... *//** Returns the size of a notification buffer for a connector server. ... */int defaultQueueSizeString oldPgetIntegerAttribute(...)String MAX_FETCH_NOTIFS;/** <p>Name of the attribute that specifies the maximum number of ... *//** Returns the maximum notification number which a client will ... */String FETCH_TIMEOUT;/** <p>Name of the attribute that specifies the timeout for a ... *//** Returns the timeout for a client to fetch notifications. */String NOTIF_ACCESS_CONTROLLER;/** <p>Name of the attribute that specifies an object that will check ... *//** Get an integer-valued attribute with name <code>name</code> ... */long resultparseLong(...)String DEFAULT_ORB;/* Check that all attributes have a key that is a String. ... *//* Return a writable map containing only those attributes that are ... */SortedMap<String,V> mapnew TreeMap<String,V>(...)purgeUnserializable(...)hideAttributes(...)/** Remove from the given Collection any element that is not a ... */Iterator<?> itnew SinkOutputStream(...)String HIDDEN_ATTRIBUTES;/** The value of this attribute, if present, is a string specifying ... */String DEFAULT_HIDDEN_ATTRIBUTES;/* This list is copied directly from the spec, plus ... *//** Default list of attributes not to show. ... */SortedSet<String> defaultHiddenStrings;SortedSet<String> defaultHiddenPrefixes;SortedSet<String> hiddenStringsSortedSet<String> hiddenPrefixesString hideString sentinelKeylastKey(...)Iterator<String> keyIteratorIterator<String> stringIteratorIterator<String> prefixIteratorString nextStringString nextPrefixparseHiddenAttributes(...)String SERVER_CONNECTION_TIMEOUT;/** <p>Name of the attribute that specifies the timeout to keep a ... *//** Returns the server side connection timeout. */String CLIENT_CONNECTION_CHECK_PERIOD;/** <p>Name of the attribute that specifies the period in ... *//** Returns the client connection check period. *//** Computes a boolean value from a string value retrieved from a ... *//** Converts a map into a valid hash table, i.e. ... */HashMap<K,V> mIterator<?> inew Hashtable<K,V>(...)String JMX_SERVER_DAEMON;/** <p>Name of the attribute that specifies whether a connector server ... *//** Returns true if {@value SERVER_DAEMON} is specified in the {@code env} ... */EnvHelp$SinkOutputStream/* Copyright (c) 2003, 2016, Oracle and/or its affiliates. All rights reserved. ... */// it must be older than 1.4.// default value// keep it for the compability for the fix:// 6174229: Environment parameter should be notification.buffer.size// instead of buffer.size// the default value re-specified in the system// try the old one/* May throw a NumberFormatException, which is an ... */// ObjectOutputStream invalid after exception/* Construct a string that is greater than any key in the map. ... *//* Read each key in sorted order and, if it matches a string ... *//* Continue through string-match values until we find one ... *//* Continue through the prefix values until we find one ... */// returns a default value of 'false' if no property is found.../** The <CODE>BerDecoder</CODE> class is used for decoding ... *//** Constructs a new decoder and attaches it to the specified byte string. ... *//** Fetch an integer. ... */fetchInteger(...)/** Fetch an integer with the specified tag. ... */int backupfetchTag(...)new BerException(...)fetchIntegerValue(...)BerException e/** Fetch an integer and return a long value. ... */fetchIntegerAsLong(...)/** Fetch an integer with the specified tag and return a long value. ... */fetchIntegerValueAsLong(...)/** Fetch an octet string. ... */fetchOctetString(...)/** Fetch an octet string with a specified tag. ... */fetchStringValue(...)/** Fetch an object identifier. ... */fetchOid(...)/** Fetch an object identifier with a specified tag. ... */long[] resultfetchOidValue(...)/** Fetch a <CODE>NULL</CODE> value. ... */fetchNull(...)/** Fetch a <CODE>NULL</CODE> value with a specified tag. ... */fetchLength(...)/** Fetch an <CODE>ANY</CODE> value. In fact, this method does not decode anything ... */int tagint contentLengthint tlvLength/** Fetch an <CODE>ANY</CODE> value with a specific tag. ... */getTag(...)fetchAny(...)/** Fetch a sequence header. ... */openSequence(...)/** Fetch a sequence header with a specific tag. ... *//** Close a sequence. ... *//** Return <CODE>true</CODE> if the end of the current sequence is not reached. ... *//** Get the tag of the data at the current position. ... */int BooleanTag;// Some standard tagsint IntegerTag;int OctetStringTag;int NullTag;int OidTag;int SequenceTag;/** Fetch a tag and move the current position forward. ... */////////////////////////// PRIVATE ///////////////////////////////byte b0/** Fetch a length and move the current position forward. ... */byte bX/** Fetch an integer value and move the current position forward. ... */ArithmeticException e/** Fetch an integer value and return a long value. ... *//** Fetch a byte string and move the current position forward. ... *//** Fetch an oid and move the current position forward. ... */int subidCountint datalenlong[] datalong lb0long lb1long subid...[] bytes;// This is the byte array containing the encoding.//   System.out.println(str);// private static final void debug(String str) {int next;// to be decoded. It's an index in bytes[].// This is the current location. It is the next byte...[] stackBuf;// A value is pulled and checked each time closeSequence() is called.// is invoked.// A value is computed and pushed in it each time openSequence()// This is the stack where end of sequences are kept.int stackTop;// for (int i = 0 ; i < tlvLength ; i++) {//  data[i] = bytes[backup + i] ;// catch(Error e) {//    debug("fetchAny: Error decoding BER: " + e);//    throw e;//      int i = 0 ;//      while (i < length) {//          result[i++] = bytes[next++] ;//  debug("fetchStringValue: Error decoding BER: " + e);//  throw e;// Count how many bytes have their 8th bit to 0// -> this gives the number of components in the oid// bugId 4641746// The 8th bit of the first byte should always be set to 0// The first sub Id cannot be greater than 2// bugId 4654674//  debug("fetchOidValue: Error decoding BER: " + e);/** The <CODE>BerEncoder</CODE> class is used for encoding data using BER. ... *//** Constructs a new encoder and attaches it to the specified byte string. ... *//** Trim the encoding data and returns the length of the encoding. ... *//** Put an integer. ... */putInteger(...)/** Put an integer with the specified tag. ... */putIntegerValue(...)putTag(...)/** Put an integer expressed as a long. ... *//** Put an integer expressed as a long with the specified tag. ... *//** Put an octet string. ... */putOctetString(...)/** Put an octet string with a specified tag. ... */putStringValue(...)/** Put an object identifier. ... */putOid(...)/** Put an object identifier with a specified tag. ... */putOidValue(...)/** Put a <CODE>NULL</CODE> value. */putNull(...)/** Put a <CODE>NULL</CODE> value with a specified tag. ... */putLength(...)/** Put an <CODE>ANY</CODE> value. In fact, this method does not encode anything. ... */putAny(...)/** Put an <CODE>ANY</CODE> value. Only the first <CODE>byteCount</CODE> are considered. ... *//** Open a sequence. ... */closeSequence(...)/** Close a sequence with the specified tag. *//** Put a tag and move the current position backward. ... */////////////////////////// PROTECTED ////////////////////////////////** Put a length and move the current position backward. ... *//** Put an integer value and move the current position backward. ... */int byteNeeded/** Put an integer value expressed as a long. ... */long mask/** Put a byte string and move the current position backward. ... *//** Put an oid and move the current position backward. ... */int slengthlong cint start;// an value is put in the encoder.// It is initialized to <CODE>bytes.length</CODE> and decrease each time// This is the index of the first byte of the encoding.// A value is pulled and checked each time the <CODE>closeSequence</CODE> method is called.// A value is computed and pushed in it each time the <CODE>openSequence</CODE> method// for (int i = start ; i < bytes.length ; i++) {//  bytes[i-start] = bytes[i] ;//    for (int i = byteCount - 1 ; i >= 0 ; i--) {//      bytes[--start] = s[i] ;// for (int i = s.length - 1 ; i >= 0 ; i--) {//   bytes[--start] = s[i] ;// bugId 4641746: 0, 1, and 2 are legal values./** Exception thrown when a BER encoding/decoding error occurs. ... */int BAD_VERSION;int errorType;/** This class is an internal class which is used to represent RowStatus ... */new Hashtable<Integer,String>(...)new Hashtable<String,Integer>(...)int unspecified;/** This value is SNMP Runtime implementation specific, and is used to identify ... */int active;/** This value corresponds to the <i>active</i> RowStatus, as defined in ... */int notInService;/** This value corresponds to the <i>notInService</i> RowStatus, as ... */int notReady;/** This value corresponds to the <i>notReady</i> RowStatus, as defined ... */int createAndGo;/** This value corresponds to the <i>createAndGo</i> RowStatus, ... */int createAndWait;/** This value corresponds to the <i>createAndWait</i> RowStatus, ... */int destroy;/** This value corresponds to the <i>destroy</i> RowStatus, as defined in ... *//** Build an <code>EnumRowStatus</code> from an <code>int</code>. ... *//** Build an <code>EnumRowStatus</code> from an <code>Enumerated</code>. ... *//** Build an <code>EnumRowStatus</code> from a <code>long</code>. ... *//** Build an <code>EnumRowStatus</code> from an <code>Integer</code>. ... *//** Build an <code>EnumRowStatus</code> from a <code>Long</code>. ... *//** Build an <code>EnumRowStatus</code> with <i>unspecified</i> value. *//** Build an <code>EnumRowStatus</code> from a <code>String</code>. ... *//** Build an <code>EnumRowStatus</code> from an <code>SnmpInt</code>. ... *//** Build an SnmpValue from this object. ... */new SnmpInt(...)/** Check that the given <code>value</code> is valid. ... */// Documented in EnumeratedgetRSIntTable(...)getRSStringTable(...)Hashtable<Integer,String> intTable;// Initialize the mapping tables.Hashtable<String,Integer> stringTable;/** This class is used for implementing enumerated values. ... *//** Construct an enumerated with a default value. ... */Enumeration<Integer> egetIntTable(...)/** Construct an enumerated from its integer form. ... *//** Construct an enumerated from its Integer form. ... *//** Construct an enumerated from its string form. ... */Integer indexgetStringTable(...)/** Return the integer form of the enumerated. ... *//** Returns an Java enumeration of the permitted integers. ... *//** Returns an Java enumeration of the permitted strings. ... *//** Compares this enumerated to the specified enumerated. ... */(...).value/** Returns the hash code for this enumerated. ... */String hashString/** Returns the string form of this enumerated. ... *//** Returns the hashtable of the integer forms. ... *//** Returns the hashtable of the string forms. ... *//** This variable keeps the integer form of the enumerated. ... *//* Copyright (c) 1999, 2012, Oracle and/or its affiliates. All rights reserved. ... *//** An implementation of interface CharStream, where the stream is assumed to ... */boolean staticFlag;int bufsize;int available;int tokenBegin;int bufpos;...[] bufline;...[] bufcolumn;int line;boolean prevCharIsCR;boolean prevCharIsLF;Reader inputStream;int maxNextCharInd;int inBuf;char[] newbufferint[] newbuflineint[] newbufcolumnExpandBuff(...)backup(...)FillBuff(...)UpdateLineColumn(...)/** @deprecated ... */buffer.lengthReInit(...)char[] ret/** Method to adjust line and column numbers for the start of a token. */int nextColDiffint columnDiff/* Generated By:JavaCC: Do not edit this line. ASCII_CharStream.java Version 0.7pre6 */import AclEntry/** Represent one entry in the Access Control List (ACL). ... */setPrincipal(...)getPrincipal(...)new Vector<Permission>(...)Enumeration<String> encommunities(...)addCommunity(...)Enumeration<Permission> enpermissions(...)addPermission(...)isNegative(...)setNegativePermissions(...)/** Contructs an empty ACL entry. *//** Constructs an ACL entry with a specified principal. ... *//** Clones this ACL entry. ... */AclEntryImpl inew AclEntryImpl(...)UnknownHostException e/** Returns true if this is a negative ACL entry (one denying the associated principal ... *//** Adds the specified permission to this ACL entry. Note: An entry can ... *//** Removes the specified permission from this ACL entry. ... *//** Checks if the specified permission is part of the permission set in ... *//** Returns an enumeration of the permissions in this ACL entry. ... *//** Sets this ACL entry to be a negative one. That is, the associated principal ... *//** Returns the principal for which permissions are granted or denied by this ACL ... *//** Specifies the principal for which permissions are granted or denied by ... *//** Returns a string representation of the contents of this ACL entry. ... *//** Returns an enumeration of the communities in this ACL entry. ... *//** Adds the specified community to this ACL entry. Note: An entry can ... *//** Removes the specified community from this ACL entry. ... *//** Checks if the specified community is part of the community set in this ... */Principal princ;boolean neg;Vector<Permission> permList;Vector<String> commList;import Aclimport NotOwnerException/** Represent an Access Control List (ACL) which is used to guard access to http adaptor. ... */Vector<AclEntry> entryList;String aclName;/** Constructs the ACL with a specified owner ... */new Vector<AclEntry>(...)/** Sets the name of this ACL. ... */isOwner(...)new NotOwnerException(...)/** Returns the name of this ACL. ... *//** Adds an ACL entry to this ACL. An entry associates a principal (e.g., an individual or a group) ... *//** Removes an ACL entry from this ACL. ... *//** Removes all ACL entries from this ACL. ... *//** Returns an enumeration for the set of allowed permissions for ... */Vector<Permission> emptyEnumeration<AclEntry> eAclEntry ent/** Returns an enumeration of the entries in this ACL. Each element in the ... *//** Checks whether or not the specified principal has the specified ... */AclEntryImpl entcheckCommunity(...)/** Checks whether or not the specified community string is defined. ... *//** Returns a string representation of the ACL contents. ... *//* for (Enumeration e = entryList.elements();e.hasMoreElements();){ ... */import Group/** This class is used to represent a subnet mask (a group of hosts ... *//** Constructs an empty group. ... *//** Constructs a group using the specified subnet mask. ... *//** Adds the specified member to the group. ... *//** Compares this group to the specified object. Returns true if the object ... *//** Returns true if the passed principal is a member of the group. ... *//** Returns an enumeration which contains the subnet mask. ... */Vector<Principal> vnew Vector<Principal>(...)/** Removes the specified member from the group. (Not implemented) ... *//** Prints a string representation of this group. ... */// we don't need to add members because the ip address is a// subnet maskimport static JmxProperties.SNMP_LOGGER/** The class defines an abstract representation of a host. */PrincipalImpl pAclEntryImpl entrycreateAssociatedPrincipal(...)Host.classregisterPermission(...)addEntry(...)NotOwnerException aJDMHost hostjjtGetParent(...)JDMManagers managerJDMAclItem aclJDMAccess accessgetAccess(...)JDMCommunities commgetCommunities(...)putPermission(...)buildCommunities(...)JDMHostTrap hostJDMTrapInterestedHost hostsJDMTrapItem trapJDMTrapCommunity communitygetCommunity(...)String commInetAddress addVector<String> listgetHname(...)JDMHostInform hostJDMInformInterestedHost hostsJDMInformItem informJDMInformCommunity community// java import// Create a principal// Create an AclEntry// Add permissionint access;new JDMAccess(...)ParserConstants.ROgetREAD(...)ParserConstants.RWgetWRITE(...)/* Generated By:JJTree: Do not edit this line. JDMAccess.java */// We have a read-only access.// We have a read-write access.new JDMAclBlock(...)/** Do no need to go through this part of the tree for ... *//* Generated By:JJTree: Do not edit this line. JDMAclBlock.java */JDMAccess access;JDMCommunities com;new JDMAclItem(...)/* Generated By:JJTree: Do not edit this line. JDMAclItem.java */new JDMCommunities(...)/* Generated By:JJTree: Do not edit this line. JDMCommunities.java */String communityString;new JDMCommunity(...)/* Generated By:JJTree: Do not edit this line. JDMCommunity.java */String enterprise;new JDMEnterprise(...)/* Generated By:JJTree: Do not edit this line. JDMEnterprise.java */new JDMHost(...)/* Generated By:JJTree: Do not edit this line. JDMHost.java */new JDMHostInform(...)/* Generated By:JJTree: Do not edit this line. JDMHostInform.java */StringBuffer name;new JDMHostName(...)/* Generated By:JJTree: Do not edit this line. JDMHostName.java */new JDMHostTrap(...)/* Generated By:JJTree: Do not edit this line. JDMHostTrap.java */new JDMInformBlock(...)/* Generated By:JJTree: Do not edit this line. JDMInformBlock.java */String community;new JDMInformCommunity(...)/* Generated By:JJTree: Do not edit this line. JDMInformCommunity.java */new JDMInformInterestedHost(...)/* Generated By:JJTree: Do not edit this line. JDMInformInterestedHost.java */JDMInformCommunity comm;new JDMInformItem(...)/* Generated By:JJTree: Do not edit this line. JDMInformItem.java */import StringBufferStringBuffer address;new JDMIpAddress(...)/* Generated By:JJTree: Do not edit this line. JDMIpAddress.java */new JDMIpMask(...)new GroupImpl(...)/* Generated By:JJTree: Do not edit this line. JDMIpMask.java *//* Generated By:JJTree: Do not edit this line. JDMIpV6Address.java */new JDMManagers(...)/* Generated By:JJTree: Do not edit this line. JDMManagers.java */String mask;new JDMNetMask(...)new NetMaskImpl(...)/* Generated By:JJTree: Do not edit this line. JDMNetMask.java *//* Generated By:JJTree: Do not edit this line. JDMNetMaskV6.java */new JDMSecurityDefs(...)/* Generated By:JJTree: Do not edit this line. JDMSecurityDefs.java */new JDMTrapBlock(...)/* Generated By:JJTree: Do not edit this line. JDMTrapBlock.java */new JDMTrapCommunity(...)/* Generated By:JJTree: Do not edit this line. JDMTrapCommunity.java */new JDMTrapInterestedHost(...)/* Generated By:JJTree: Do not edit this line. JDMTrapInterestedHost.java */JDMTrapCommunity comm;new JDMTrapItem(...)/* Generated By:JJTree: Do not edit this line. JDMTrapItem.java */int low;int high;new JDMTrapNum(...)/* Generated By:JJTree: Do not edit this line. JDMTrapNum.java */Stack<Node> nodes;Stack<Integer> marks;int sp;int mk;// number of nodes on stackboolean node_created;// current marknew Stack<Node>(...)/* Determines whether the current node was actually closed and ... *//* Call this to reinitialize the node stack.  It is called ... *//* Returns the root node of the AST.  It only makes sense to call ... *//* Pushes a node on to the stack. *//* Returns the node on the top of the stack, and remove it from the ... *//* Returns the node currently on the top of the stack. *//* Returns the number of children on the stack in the current node ... */popNode(...)jjtOpen(...)/* A definite node is constructed from a specified number of ... */Node cjjtSetParent(...)jjtAddChild(...)jjtClose(...)pushNode(...)/* A conditional node is constructed if its condition is true.  All ... */nodeArity(...)/* Generated By:JJTree: Do not edit this line. JJTParserState.java *//** This class is used to represent a subnet mask (a group of hosts matching the same ... */...[] subnet;int prefix;int addrLengthbyte[] subnetint fullyCoveredByteint partialyCoveredIndexbyte toDealint nbbitsint subnetSizebyte maskbyte maskedValueNetMaskImpl.classextractSubNet(...)PrincipalImpl receivedInetAddress addrbyte[] recAddrsubnet.length// 8 is a byte size. Common to any InetAddress (V4 or V6).// we don't need to add members because the ip address is a subnet mask/* All AST nodes must implement this interface.  It provides basic ... *//** This method is called after the node has been made the current ... *//** This method is called after all the child nodes have been ... *//** This pair of methods are used to inform the node of its ... *//** This method tells the node to add its argument to the node's ... *//** This method returns a child node.  The children are numbered ... *//** Return the number of children the node has. *//* Generated By:JJTree: Do not edit this line. Node.java */import Ownerimport LastOwnerException/** Owner of Access Control Lists (ACLs). ... */Vector<Principal> ownerList;/** Constructs an empty list of owner. *//** Constructs a list of owner with the specified principal as first element. ... *//** Adds an owner. Only owners can modify ACL contents. The caller principal ... *//** Deletes an owner. If this is the last owner in the ACL, an exception is raised. ... */new LastOwnerException(...)/** Returns true if the given principal is an owner of the ACL. ... *//* Generated By:JavaCC: Do not edit this line. ParseError.java Version 0.7pre1 *//** This exception is thrown when parse errors are encountered. ... *//** This constructor is used by the method "generateParseException" ... *//** The following constructors are for use by you for whatever ... */boolean specialConstructor;/** This variable determines which constructor was used to create ... */Token currentToken;/** This is the last token that has been consumed successfully.  If ... */...[] expectedTokenSequences;/** Each entry in this array is an array of integers.  Each array ... */...[] tokenImage;/** This is a reference to the "tokenImage" array of the generated ... *//** This method has the standard behavior when this object has been ... */int maxSizeString retvalToken tokcurrentToken.nextexpectedTokenSequences.lengthtok.kindadd_escapes(...)tok.imagetok.nextcurrentToken.next.beginColumncurrentToken.next.beginLineString eol;/** The end of line string for this machine. *//** Used to convert raw characters to their escaped version ... */StringBuffer retval/* Generated By:JavaCC: Do not edit this line. ParseException.java Version 0.7pre6 */new JJTParserState(...)new JJCalls[]new Vector<int[]>(...)JJTParserState jjtree;/* @bgen(jjtree) */// A file can contain several acl definitionsJDMSecurityDefs jjtn000boolean jjtc000openNodeScope(...)jj_ntk(...)AclBlock(...)TrapBlock(...)InformBlock(...)jj_consume_token(...)closeNodeScope(...)Throwable jjte000clearNodeScope(...)JDMAclBlock jjtn000AclItem(...)JDMAclItem jjtn000jjtn000.comCommunities(...)jjtn000.accessAccess(...)Managers(...)JDMCommunities jjtn000Community(...)JDMCommunity jjtn000Token tjjtn000.communityStringt.imageJDMAccess jjtn000new ParseException(...)JDMManagers jjtn000Host(...)JDMHost jjtn000HostName(...)jj_2_1(...)NetMask(...)jj_2_2(...)NetMaskV6(...)jj_2_3(...)IpAddress(...)IpV6Address(...)IpMask(...)JDMHostName jjtn000jjtn000.nameJDMIpAddress jjtn000jjtn000.addressJDMIpV6Address jjtn000new JDMIpV6Address(...)JDMIpMask jjtn000JDMNetMask jjtn000jjtn000.maskJDMNetMaskV6 jjtn000new JDMNetMaskV6(...)JDMTrapBlock jjtn000TrapItem(...)JDMTrapItem jjtn000jjtn000.commTrapCommunity(...)TrapInterestedHost(...)Enterprise(...)JDMTrapCommunity jjtn000jjtn000.communityJDMTrapInterestedHost jjtn000HostTrap(...)JDMHostTrap jjtn000JDMEnterprise jjtn000jjtn000.enterpriseTrapNum(...)JDMTrapNum jjtn000jjtn000.lowjjtn000.highJDMInformBlock jjtn000InformItem(...)JDMInformItem jjtn000InformCommunity(...)InformInterestedHost(...)JDMInformCommunity jjtn000JDMInformInterestedHost jjtn000HostInform(...)JDMHostInform jjtn000jj_3_1(...)jj_save(...)jj_3_2(...)jj_3_3(...)jj_scan_token(...)Token xspjj_3R_14(...)ParserTokenManager token_source;ASCII_CharStream jj_input_stream;Token token, ...;int jj_ntk;Token jj_scanpos, ...;int jj_la;boolean lookingAhead;boolean jj_semLA;int jj_gen;...[] jj_la1;...[] jj_la1_0;...[] jj_la1_1;...[] jj_2_rtns;boolean jj_rescan;int jj_gc;new ASCII_CharStream(...)new ParserTokenManager(...)new Token(...)jj_2_rtns.lengthnew JJCalls(...)Token oldToken(...).nexttoken.nextgetNextToken(...)token.kindJJCalls cc.genc.firstc.nextgenerateParseException(...)jj_scanpos.nextjj_add_error_token(...)jj_scanpos.kindt.next(...).kindjj_nt.kindVector<int[]> jj_expentries;...[] jj_expentry;int jj_kind;...[] jj_lasttokens;int jj_endpos;boolean existsEnumeration<int[]> enumvint[] oldentryoldentry.lengthjj_expentry.lengthboolean[] la1tokensint[][] exptokseqjj_rescan_token(...)JJCalls pp.genp.argp.firstp.nextParser$JJCallsint gen;Token first;int arg;JJCalls next;/* Generated By:JJTree&JavaCC: Do not edit this line. Parser.java */// generated code, not worth fixing/* @bgen(jjtree) SecurityDefs *//* @bgen(jjtree) AclBlock *//* @bgen(jjtree) AclItem *//* @bgen(jjtree) Communities *//* @bgen(jjtree) Community *//* @bgen(jjtree) Access *//* @bgen(jjtree) Managers *//* @bgen(jjtree) Host *//* @bgen(jjtree) HostName *//* @bgen(jjtree) IpAddress *//* @bgen(jjtree) IpV6Address *//* @bgen(jjtree) IpMask *//* @bgen(jjtree) NetMask *//* @bgen(jjtree) NetMaskV6 *//* @bgen(jjtree) TrapBlock *//* @bgen(jjtree) TrapItem *//* @bgen(jjtree) TrapCommunity *//* @bgen(jjtree) TrapInterestedHost *//* @bgen(jjtree) HostTrap *//* @bgen(jjtree) Enterprise *//* @bgen(jjtree) TrapNum *//* @bgen(jjtree) InformBlock *//* @bgen(jjtree) InformItem *//* @bgen(jjtree) InformCommunity *//* @bgen(jjtree) InformInterestedHost *//* @bgen(jjtree) HostInform */int EOF;int ACCESS;int ACL;int ASSIGN;int COMMUNITIES;int ENTERPRISE;int HOSTS;int LBRACE;int MANAGERS;int RANGE;int RBRACE;int RO;int RW;int TRAP;int INFORM;int TRAPCOMMUNITY;int INFORMCOMMUNITY;int TRAPNUM;int INTEGER_LITERAL;int DECIMAL_LITERAL;int HEX_LITERAL;int OCTAL_LITERAL;int V6_ADDRESS;int H;int D;int IDENTIFIER;int LETTER;int SEPARATOR;int DIGIT;int CSTRING;int COMMA;int DOT;int MARK;int MASK;int DEFAULT;/* Generated By:JJTree&JavaCC: Do not edit this line. ParserConstants.java */jjMoveNfa_0(...)jjStopStringLiteralDfa_0(...)jjStopAtPos(...)jjStartNfaWithStates_0(...)jjMoveStringLiteralDfa1_0(...)jjMoveStringLiteralDfa2_0(...)jjStartNfa_0(...)jjMoveStringLiteralDfa3_0(...)jjMoveStringLiteralDfa4_0(...)jjMoveStringLiteralDfa5_0(...)jjMoveStringLiteralDfa6_0(...)jjMoveStringLiteralDfa7_0(...)jjMoveStringLiteralDfa8_0(...)jjMoveStringLiteralDfa9_0(...)jjMoveStringLiteralDfa10_0(...)jjMoveStringLiteralDfa11_0(...)jjMoveStringLiteralDfa12_0(...)jjMoveStringLiteralDfa13_0(...)jjMoveStringLiteralDfa14_0(...)jjMoveStringLiteralDfa15_0(...)jjCheckNAdd(...)...[] jjbitVec0;int[] nextStatesint startsAtReInitRounds(...)jjCheckNAddTwoStates(...)jjCheckNAddStates(...)jjAddStates(...)long l2...[] jjnextStates;...[] jjstrLiteralImages;...[] lexStateNames;...[] jjtoToken;...[] jjtoSkip;ASCII_CharStream input_stream;...[] jjrounds;...[] jjstateSet;char curChar;ASCII_CharStream.staticFlagSwitchTo(...)new TokenMgrError(...)TokenMgrError.INVALID_LEXICAL_STATEnewToken(...)String imt.kindGetImage(...)t.beginLinegetBeginLine(...)t.beginColumngetBeginColumn(...)t.endLinegetEndLine(...)t.endColumngetEndColumn(...)int curLexState;int defaultLexState;int jjnewStateCnt;int jjround;int jjmatchedPos;int jjmatchedKind;Token specialTokenToken matchedTokenint curPosint error_lineint error_columnString error_afterboolean EOFSeenBeginToken(...)jjFillToken(...)jjMoveStringLiteralDfa0_0(...)TokenMgrError.LEXICAL_ERROR/* Generated By:JJTree&JavaCC: Do not edit this line. ParserTokenManager.java */int JJTSECURITYDEFS;int JJTACLBLOCK;int JJTACLITEM;int JJTCOMMUNITIES;int JJTCOMMUNITY;int JJTACCESS;int JJTMANAGERS;int JJTHOST;int JJTHOSTNAME;int JJTIPADDRESS;int JJTIPV6ADDRESS;int JJTIPMASK;int JJTNETMASK;int JJTNETMASKV6;int JJTTRAPBLOCK;int JJTTRAPITEM;int JJTTRAPCOMMUNITY;int JJTTRAPINTERESTEDHOST;int JJTHOSTTRAP;int JJTENTERPRISE;int JJTTRAPNUM;int JJTINFORMBLOCK;int JJTINFORMITEM;int JJTINFORMCOMMUNITY;int JJTINFORMINTERESTEDHOST;int JJTHOSTINFORM;...[] jjtNodeName;/* Generated By:JJTree: Do not edit this line. ParserTreeConstants.java *//** Permission is represented as a String. ... */String perm;/** Constructs a permission. ... *//** Returns true if the object passed matches the permission represented in. ... *//** Prints a string representation of this permission. ... *//** Prints the permission. ... *//** Principal represents a host. */...[] add;/** Constructs a principal with the local host. */new InetAddress[]/** Construct a principal using the specified host. ... */getAllByName(...)/** Constructs a principal using an Internet Protocol (IP) address. ... *//** Returns the name of this principal. ... *//** Compares this principal to the specified object. Returns true if the ... */add.length/** Returns a hashcode for this principal. ... *//** Returns a string representation of this principal. In case of multiple address, the first one is returned. ... *//** Returns the Internet Protocol (IP) address for this principal. In case of multiple address, the first one is returned. ... */Node parent;Parser parser;new SimpleNode(...)Node[] c/** Build the Trap entries from the syntactic tree. *//* SR. Extend the SimpleNode definition */SimpleNode nbuildTrapEntries(...)/** Build the Inform entries from the syntactic tree. */buildInformEntries(...)/** Build the Acl entries from the syntactic tree. */buildAclEntries(...)/* You can override these two methods in subclasses of SimpleNode to ... *//* END SR */ParserTreeConstants.jjtNodeName/* Override this method if you want to customize how the node dumps ... *//* Generated By:JJTree: Do not edit this line. SimpleNode.java *//* end of loop */import InetAddressAcl/** Defines an implementation of the {@link com.sun.jmx.snmp.InetAddressAcl InetAddressAcl} interface. ... */new PermissionImpl(...)PermissionImpl READ;PermissionImpl WRITE;/** Constructs the Java Dynamic Management(TM) Access Control List ... */new Hashtable<InetAddress,Vector<String>>(...)AclEntry ownEntrynew AclImpl(...)NotOwnerException exSnmpAcl.classsetDefaultFileName(...)setAuthorizedListFile(...)readAuthorizedListFile(...)entries(...)/** Returns ann enumeration of community strings. Community strings are returned as String. ... */HashSet<String> setnew HashSet<String>(...)Vector<String> resString[] objsEnumeration<String> cs/** Returns the name of the ACL. ... *//** Returns the read permission instance used. ... *//** Returns the write permission instance used. ... *//** Get the default name for the ACL file. ... */String fileSeparatorStringBuffer defaultAclName/** Sets the full path of the file containing the ACL information. ... *//** Resets this ACL to the values contained in the configuration file. ... *//** Returns the full path of the file used to get ACL information. ... *//** Checks whether or not the specified host has <CODE>READ</CODE> access. ... *//** Checks whether or not the specified host and community have <CODE>READ</CODE> access. ... *//** Checks whether or not a community string is defined. ... *//** Checks whether or not the specified host has <CODE>WRITE</CODE> access. ... *//** Checks whether or not the specified host and community have <CODE>WRITE</CODE> access. ... *//** Returns an enumeration of trap destinations. ... *//** Returns an enumeration of trap communities for a given host. ... *//** Returns an enumeration of inform destinations. ... *//** Returns an enumeration of inform communities for a given host. ... *//** Converts the input configuration file into ACL. */Parser parsergetAuthorizedListFile(...)JDMSecurityDefs nSecurityDefs(...)ParseException eAclEntryImpl aaEnumeration<Permission> eee/** Set the default full path for "snmp.acl" input file. ... */getDefaultAclFileName(...)IllegalArgumentException xAclImpl acl;/** Represents the Access Control List. */boolean alwaysAuthorized;/** Flag indicating whether the access is always authorized. ... */String authorizedListFile;/** Represents the Access Control List flat file. */Hashtable<InetAddress,Vector<String>> trapDestList;/** Contains the hosts list for trap destination. */Hashtable<InetAddress,Vector<String>> informDestList;/** Contains the hosts list for inform destination. */PrincipalImpl owner;// SNMP Runtime import// PrincipalImpl() take the current host as entry// Read the file content// OK.../** Describes the input token stream. */int kind;/** An integer that describes the kind of this token.  This numbering ... */int beginLine, ...;/** beginLine and beginColumn describe the position of the first character ... */String image;/** The string image of the token. */Token next;/** A reference to the next regular (non-special) token from the input ... */Token specialToken;/** This field is used to access special tokens that occur prior to this ... *//** Returns the image. *//** Returns a new Token object, by default. However, if you want, you ... *//* Generated By:JavaCC: Do not edit this line. Token.java Version 0.7pre3 */int LEXICAL_ERROR;/** Lexical error occurred. *//* Ordinals for various reasons why an Error of this type can be thrown. */int STATIC_LEXER_ERROR;/** An attempt wass made to create a second instance of a static token manager. */int INVALID_LEXICAL_STATE;/** Tried to change to an invalid lexical state. */int LOOP_DETECTED;/** Detected (and bailed out of) an infinite loop in the token manager. */int errorCode;/** Indicates the reason why the exception is thrown. It will have ... *//** Replaces unprintable characters by their espaced (or unicode escaped) ... *//** Returns a detailed message for the Error when it is thrown by the ... */addEscapes(...)/** You can also modify the body of this method to customize your error messages. ... *//* Constructors of various flavors follow. */LexicalError(...)/* Generated By:JavaCC: Do not edit this line. TokenMgrError.java Version 0.7pre2 *//** Defines the IP address based ACL used by the SNMP protocol adaptor. ... *//** Used for storing default values used by SNMP Runtime services. ... *//** The default key properties for registering the class loader of the MLet service. ... */int RMI_CONNECTOR_PORT;/** The default port for the RMI connector. ... */String RMI_CONNECTOR_SERVER;/** The default key properties for the RMI connector. ... */int SNMP_ADAPTOR_PORT;/** The default port for the SNMP adaptor. ... */String SNMP_ADAPTOR_SERVER;/** The default key properties for the SNMP protocol adaptor. ... */int HTTP_CONNECTOR_PORT;/** The default port for the HTTP connector. ... */String HTTP_CONNECTOR_SERVER;/** The default key properties for the HTTP connector. ... */int HTTPS_CONNECTOR_PORT;/** The default port for the HTTPS connector. ... */String HTTPS_CONNECTOR_SERVER;/** The default key properties for the HTTPS connector. ... */int HTML_ADAPTOR_PORT;/** The default port for the HTML adaptor. ... */String HTML_ADAPTOR_SERVER;/** The default key properties for the HTML protocol adaptor. ... *//** The name of the vendor of this product implementing the  JMX specification. ... */String BUILD_NUMBER;/** The build number of the current product version, of the form <CODE>rXX</CODE>. *//** The version of this product implementing the  JMX specification. ... *//** Interface to be implemented by PDUs that are acknowledged (eg: ... *//** Returns the PDU to use for the response. ... *//** This exception is thrown when an incorrect security level is handled. ... *//* Copyright (c) 2001, 2006, Oracle and/or its affiliates. All rights reserved. ... *//** Represents an SNMP counter. ... *//** Constructs a new <CODE>SnmpCounter</CODE> from the specified integer value. ... *///-------------// CONSTRUCTORS/** Constructs a new <CODE>SnmpCounter</CODE> from the specified <CODE>Integer</CODE> value. ... *//** Constructs a new <CODE>SnmpCounter</CODE> from the specified long value. ... *//** Constructs a new <CODE>SnmpCounter</CODE> from the specified <CODE>Long</CODE> value. ... *//** Returns a textual description of the type object. ... *///---------------// PUBLIC METHODS/** Name of the type. *///----------// VARIABLES/** Represents an SNMP 64bits counter. ... *//** Constructs a new <CODE>SnmpCounter64</CODE> from the specified long value. ... *//** Constructs a new <CODE>SnmpCounter64</CODE> from the specified <CODE>Long</CODE> value. ... *//** Returns the counter value of this <CODE>SnmpCounter64</CODE>. ... *//** Converts the counter value to its <CODE>Long</CODE> form. ... *//** Converts the counter value to its integer form. ... *//** Converts the counter value to its <CODE>Integer</CODE> form. ... *//** Converts the counter value to its <CODE>String</CODE> form. ... *//** Converts the counter value to its <CODE>SnmpOid</CODE> form. ... */new SnmpOid(...)/** Extracts the counter from an index OID and returns its ... */new SnmpStatusException(...)SnmpStatusException.noSuchName/** Scans an index OID, skips the counter value and returns the position ... */index.length/** Appends an <CODE>SnmpOid</CODE> representing an <CODE>SnmpCounter64</CODE> to another OID. ... *//** Performs a clone action. This provides a workaround for the ... *//** Clones the <CODE>SnmpCounter64</CODE> object, making a copy of its data. ... */SnmpCounter64 newclonenewclone.value/** This is where the value is stored. This long is positive. ... *//* Copyright (c) 1997, 2011, Oracle and/or its affiliates. All rights reserved. ... */// The max value for a counter64 variable is 2^64 - 1.// The max value for a Long is 2^63 - 1.// All the allowed values for a conuter64 variable cannot be covered !!!// vm bug./** Contains SNMP data type constants. ... *//** ASN.1 tag for representing the boolean type. *///-----------------------// ASN1 Type definitions./** ASN.1 tag for representing the integer type. */int BitStringTag;/** ASN.1 tag for representing the bit string type. *//** ASN.1 tag for representing the octet string type. *//** ASN.1 tag for representing the null type. */int ObjectIdentiferTag;/** ASN.1 tag for representing the Object Identifier type. */int UnknownSyntaxTag;/** Represents a unknown syntax type. No meaning in an ASN.1 context. *//** ASN.1 tag for a <CODE>SEQUENCE</CODE> or <CODE>SEQUENCE OF</CODE>. */int TableTag;/** Represents an SNMP table. No meaning in an ASN.1 context. */int ApplFlag;/** ASN.1 Tag for application context. */// SNMP definitions.int CtxtFlag;/** ASN.1 tag for implicit context. */int IpAddressTag;/** ASN.1 tag for representing an IP address as defined in RFC 1155. */int CounterTag;/** ASN.1 tag for representing a <CODE>Counter32</CODE> as defined in RFC 1155. */int GaugeTag;/** ASN.1 tag for representing a <CODE>Gauge32</CODE> as defined in RFC 1155. */int TimeticksTag;/** ASN.1 tag for representing a <CODE>Timeticks</CODE> as defined in RFC 1155. */int OpaqueTag;/** ASN.1 tag for representing an <CODE>Opaque</CODE> type as defined in RFC 1155. */int Counter64Tag;/** ASN.1 tag for representing a <CODE>Counter64</CODE> as defined in RFC 1155. */int NsapTag;/** ASN.1 tag for representing an <CODE>Nsap</CODE> as defined in RFC 1902. */int UintegerTag;/** ASN.1 tag for representing an <CODE>Unsigned32</CODE> integer as defined in RFC 1902. */int errNoSuchObjectTag;/** ASN.1 tag for representing a <CODE>NoSuchObject</CODE> as defined in RFC 1902. */int errNoSuchInstanceTag;/** ASN.1 tag for representing a <CODE>NoSuchInstance</CODE> as defined in RFC 1902. */int errEndOfMibViewTag;/** ASN.1 tag for representing an <CODE>EndOfMibView</CODE> as defined in RFC 1902. */// Copyright (c) 1995-96 by Cisco Systems, Inc./** Contains SNMP constants related to command and response codes. ... */int noAuthNoPriv;/** Security level. No authentication, no privacy. Value is 0, as ... */int authNoPriv;/** Security level. Authentication, no privacy. Value is 1, as ... */int authPriv;/** Security level. Authentication, privacy. Value is 3, as defined ... */int reportableFlag;/** Flag that indicates that a report is to be sent. Value is 4, as ... */int authMask;/** Mask used to isolate authentication information within a message flag. ... */int privMask;/** Mask used to isolate privacy information within a message flag. */int authPrivMask;/** Mask used to isolate authentication and privacy information within a message flag. ... */int CtxtConsFlag;/** ASN.1 prefix for encoding PDU types. */byte snmpVersionOne;/** Represents the SNMP protocol version: <CODE>SnmpV1</CODE>. */byte snmpVersionTwo;/** Represents the SNMP protocol version: <CODE>SnmpV2</CODE>. */byte snmpVersionThree;/** Represents the SNMP protocol version: <CODE>SnmpV3</CODE>. ... */int pduGetRequestPdu;/** Represents a <CODE>GetRequest</CODE> PDU type (V1 or V2). */int pduGetNextRequestPdu;/** Represents a <CODE>GetNextRequest</CODE> PDU type (V1 or V2). */int pduGetResponsePdu;/** Represents a <CODE>GetResponse</CODE> PDU type (V1 or V2). */int pduSetRequestPdu;/** Represents a <CODE>SetRequest</CODE> PDU type (V1 or V2). */int pduGetBulkRequestPdu;/** Represents a <CODE>GetBulkRequest</CODE> PDU type (V2 only). */int pduWalkRequest;/** Represents a <CODE>Walk</CODE> request. ... */int pduV1TrapPdu;/** Represents a <CODE>V1Trap</CODE> PDU type (V1 only). */int pduV2TrapPdu;/** Represents a <CODE>V2Trap</CODE> PDU type (V2 only). */int pduInformRequestPdu;/** Represents an <CODE>InformRequest</CODE> PDU type (V2 only). */int pduReportPdu;/** Represents a <CODE>Report</CODE> PDU type (V2 only). */int trapColdStart;/** Code as defined in RFC 1157 for generic trap info in Trap-PDU: <CODE>coldStart</CODE>. *///-------------------------------------------------// SNMPv1 values for generic trap info in Trap-PDU.int trapWarmStart;/** Code as defined in RFC 1157 for generic trap info in Trap-PDU: <CODE>warmStart</CODE>. */int trapLinkDown;/** Code as defined in RFC 1157 for generic trap info in Trap-PDU: <CODE>linkDown</CODE>. */int trapLinkUp;/** Code as defined in RFC 1157 for generic trap info in Trap-PDU: <CODE>linkUp</CODE>. */int trapAuthenticationFailure;/** Code as defined in RFC 1157 for generic trap info in Trap-PDU: <CODE>authenticationFailure</CODE>. */int trapEgpNeighborLoss;/** Code as defined in RFC 1157 for generic trap info in Trap-PDU: <CODE>egpNeighborLoss</CODE>. */int trapEnterpriseSpecific;/** Code as defined in RFC 1157 for generic trap info in Trap-PDU: <CODE>enterpriseSpecific</CODE>. */int snmpRspNoError;/** Error code as defined in RFC 1448 for: <CODE>noError</CODE>. *///------------------------------// PDU error status enumeration.int snmpRspTooBig;/** Error code as defined in RFC 1448 for: <CODE>tooBig</CODE>. */int snmpRspNoSuchName;/** Error code as defined in RFC 1448 for: <CODE>noSuchName</CODE>. */int snmpRspBadValue;/** Error code as defined in RFC 1448 for: <CODE>badValue</CODE>. */int snmpRspReadOnly;/** Error code as defined in RFC 1448 for: <CODE>readOnly</CODE>. */int snmpRspGenErr;/** Error code as defined in RFC 1448 for: <CODE>genErr</CODE>. */int snmpRspNoAccess;/** Error code as defined in RFC 1448 for: <CODE>noAccess</CODE>. */int snmpRspWrongType;/** Error code as defined in RFC 1448 for: <CODE>wrongType</CODE>. */int snmpRspWrongLength;/** Error code as defined in RFC 1448 for: <CODE>wrongLength</CODE>. */int snmpRspWrongEncoding;/** Error code as defined in RFC 1448 for: <CODE>wrongEncoding</CODE>. */int snmpRspWrongValue;/** Error code as defined in RFC 1448 for: <CODE>wrongValue</CODE>. */int snmpRspNoCreation;/** Error code as defined in RFC 1448 for: <CODE>noCreation</CODE>. */int snmpRspInconsistentValue;/** Error code as defined in RFC 1448 for: <CODE>inconsistentValue</CODE>. */int snmpRspResourceUnavailable;/** Error code as defined in RFC 1448 for: <CODE>resourceUnavailable</CODE>. */int snmpRspCommitFailed;/** Error code as defined in RFC 1448 for: <CODE>commitFailed</CODE>. */int snmpRspUndoFailed;/** Error code as defined in RFC 1448 for: <CODE>undoFailed</CODE>. */int snmpRspAuthorizationError;/** Error code as defined in RFC 1448 for: <CODE>authorizationError</CODE>. */int snmpRspNotWritable;/** Error code as defined in RFC 1448 for: <CODE>notWritable</CODE>. */int snmpRspInconsistentName;/** Error code as defined in RFC 1448 for: <CODE>inconsistentName</CODE>. */int noSuchView;/** Error that is returned by VACM. ... */int noSuchContext;int noGroupName;int notInView;int snmpReqTimeout;/** Error code specific to the API. ... */// API error status enumeration.int snmpReqAborted;int snmpRspDecodingError;int snmpReqEncodingError;int snmpReqPacketOverflow;int snmpRspEndOfTable;int snmpReqRefireAfterVbFix;int snmpReqHandleTooBig;int snmpReqTooBigImpossible;int snmpReqInternalError;int snmpReqSocketIOError;int snmpReqUnknownError;int snmpWrongSnmpVersion;int snmpUnknownPrincipal;/** SNMP V3 Error code specific to the API. ... */int snmpAuthNotSupported;int snmpPrivNotSupported;int snmpBadSecurityLevel;int snmpUsmBadEngineId;/** SNMP Usm V3 Error code specific to the API. ... */int snmpUsmInvalidTimeliness;int snmpV1SecurityModel;/** Snmp V1 security model id (1). ... */int snmpV2SecurityModel;/** Snmp V2 security model id (2). ... */int snmpUsmSecurityModel;/** Snmp V3 security model id (3). ... */int snmpV1MsgProcessingModel;/** Snmp V1 msg processing model id (0). ... */int snmpV2MsgProcessingModel;/** Snmp V2 msg processing model id (1). ... */int snmpV3MsgProcessingModel;/** Snmp V3 msg processing model id (3). ... */int snmpV1AccessControlModel;/** Snmp V1 access control model id (0). ... */int snmpV2AccessControlModel;/** Snmp V2 access control model id (1). ... */int snmpV3AccessControlModel;/** Snmp V3 access control model id (3). ... *//** This engine is conformant with the RFC 2571. It is the main object within an SNMP entity (agent, manager...). ... *//** Gets the engine time in seconds. This is the time from the last reboot. ... *//** Gets the engine Id. This is unique for each engine. ... *//** Gets the engine boot number. This is the number of time this engine has rebooted. Each time an <CODE>SnmpEngine</CODE> is instantiated, it will read this value in its Lcd, and store back the value incremented by one. ... *//** Gets the Usm key handler. ... *//** This <CODE>SnmpEngineFactory</CODE> is instantiating an <CODE>SnmpEngine</CODE> containing : ... *//** The engine instantiation method. ... */import SnmpTools/** This class is handling an <CODE>SnmpEngineId</CODE> data. It copes with binary as well as <CODE>String</CODE> representation of an engine Id. A string format engine is an hex string starting with 0x. ... */...[] engineId;String hexString;String humanString;/** New <CODE>SnmpEngineId</CODE> with an hex string value. Can handle engine Id format &lt;host&gt:&lt;port&gt. ... */ascii2binary(...)this.hexString/** New <CODE>SnmpEngineId</CODE> with a binary value. You can use <CODE> SnmpTools </CODE> to convert from hex string to binary format. ... */binary2ascii(...)/** If a string of the format &lt;address&gt;:&lt;port&gt;:&lt;IANA number&gt; has been provided at creation time, this string is returned. ... *//** Returns a string format engine Id. ... *//** Returns a binary engine Id. ... *//** In order to store the string used to create the engineId. */validateId(...)byte[] zeroedArraysbyte[] FFArrays/** Generates an engine Id based on the passed array. ... */new SnmpEngineId(...)/** Generates an engine Id that is unique to the host the agent is running on. The engine Id unicity is system time based. The creation algorithm uses the SUN Microsystems IANA number (42). ... */byte[] addressbyte[] engineidint ianalong time/** Translates an engine Id in an SnmpOid format. This is useful when dealing with USM MIB indexes. ... */long[] oidengineId.length/** <P>Generates a unique engine Id. Hexadecimal strings as well as a textual description are supported. The textual format is as follow: ... */createEngineId(...)/** Idem { @link ... */StringTokenizer tokenString addressString portString ianaint objPortint objIanaInetAddress objAddressSnmpEngineId engsetStringValue(...)/** Generates a unique engine Id. The engine Id unicity is based on ... */int sunianaInetAddress address/** Generates a unique engine Id. The engine Id unicity is based on the host IP address and port. The IP address is the passed one, it handles IPv4 and IPv6 hosts. The creation algorithm uses the passed IANA number. ... */address.length/** Generates an engine Id based on an InetAddress. Handles IPv4 and IPv6 addresses. The creation algorithm uses the passed IANA number. ... *//** Generates an engine Id based on an InetAddress. Handles IPv4 and IPv6 ... *//** Tests <CODE>SnmpEngineId</CODE> instance equality. Two <CODE>SnmpEngineId</CODE> are equal if they have the same value. ... *///octet strings with very first bit = 0 and length != 12 octets//Deal with address//No need to go further, no port.//Deal with port//No need to go further, no iana.//Deal with iana/** This class is used to pass some specific parameters to an <CODE> ... */UserAcl uacl;String securityFile;boolean encrypt;SnmpEngineId engineId;/** Sets the file to use for SNMP Runtime Lcd. If no file is provided, the default location will be checked. */this.securityFile/** Gets the file to use for SNMP Runtime Lcd. ... *//** Sets a customized user ACL. User Acl is used in order to check ... */this.uacl/** Gets the customized user ACL. ... *//** Activate SNMP V3 encryption. By default the encryption is not activated. Be sure that the security provider classes needed for DES are in your classpath (eg:JCE classes) */this.encrypt/** Deactivate SNMP V3 encryption. By default the encryption is not activated. Be sure that the security provider classes needed for DES are in your classpath (eg:JCE classes) *//** Check if encryption is activated. By default the encryption is not activated. ... *//** Set the engine Id. ... */this.engineId/** Get the engine Id. ... *//** Represents an SNMP gauge. ... *//** Constructs a new <CODE>SnmpGauge</CODE> from the specified integer value. ... *//** Constructs a new <CODE>SnmpGauge</CODE> from the specified <CODE>Integer</CODE> value. ... *//** Constructs a new <CODE>SnmpGauge</CODE> from the specified long value. ... *//** Constructs a new <CODE>SnmpGauge</CODE> from the specified <CODE>Long</CODE> value. ... */import Enumerated/** Represents an SNMP integer. ... *//** Constructs a new <CODE>SnmpInt</CODE> from the specified integer value. ... */isInitValueValid(...)/** Constructs a new <CODE>SnmpInt</CODE> from the specified <CODE>Integer</CODE> value. ... *//** Constructs a new <CODE>SnmpInt</CODE> from the specified long value. ... *//** Constructs a new <CODE>SnmpInt</CODE> from the specified <CODE>Long</CODE> value. ... *//** Constructs a new <CODE>SnmpInt</CODE> from the specified <CODE>Enumerated</CODE> value. ... *//** Constructs a new <CODE>SnmpInt</CODE> from the specified boolean value. ... *//** Returns the long value of this <CODE>SnmpInt</CODE>. ... *//** Converts the integer value to its <CODE>Long</CODE> form. ... *//** Converts the integer value to its integer form. ... *//** Converts the integer value to its <CODE>Integer</CODE> form. ... *//** Converts the integer value to its <CODE>String</CODE> form. ... *//** Converts the integer value to its <CODE>SnmpOid</CODE> form. ... *//** Extracts the integer from an index OID and returns its ... *//** Scans an index OID, skips the integer value and returns the position ... *//** Appends an <CODE>SnmpOid</CODE> representing an <CODE>SnmpInt</CODE> to another OID. ... *//** Clones the <CODE>SnmpInt</CODE> object, making a copy of its data. ... */SnmpInt newclone/** This method has been defined to allow the sub-classes ... */Integer.MIN_VALUE/** This is where the value is stored. This long is signed. ... *//** Represents an SNMP IpAddress. ... *//** Constructs a new <CODE>SnmpIpAddress</CODE> from the specified bytes array. ... */buildFromByteArray(...)/** Constructs a new <CODE>SnmpIpAddress</CODE> from the specified long value. ... */int addressbyte[] ipaddr/** Constructs a new <CODE>SnmpIpAddress</CODE> from a dot-formatted <CODE>String</CODE>. ... *//** Constructs a new <CODE>SnmpIpAddress</CODE> from four long values. ... *//** Converts the address value to its byte array form. ... *//** Converts the address to its <CODE>String</CODE> form. ... *//** Extracts the ip address from an index OID and returns its ... *//** Scans an index OID, skips the address value and returns the position ... *//** Appends an <CODE>SnmpOid</CODE> representing an <CODE>SnmpIpAddress</CODE> to another OID. ... *//** Build Ip address from byte array. *//** Is a partially decoded representation of an SNMP packet. ... */...[] community;/** Community name. *//** Encodes this message and puts the result in the specified byte array. ... */int encodingLengthBerEncoder bencnew BerEncoder(...)ArrayIndexOutOfBoundsException xnew SnmpTooBigException(...)/** Returns the associated request ID. ... */BerDecoder bdecBerDecoder bdec2byte[] anynew BerDecoder(...)BerException x/** Decodes the specified bytes and initializes this message. ... *//** Initializes this message with the specified <CODE>pdu</CODE>. ... */SnmpPduPacket pdupacketpdupacket.versionpdupacket.communitypdupacket.addresspdupacket.portencodeVarBindList(...)pdupacket.varBindListpdupacket.typeSnmpPduRequest reqPduSnmpPduBulk bulkPduSnmpPduTrap trapPdureqPdu.errorIndexreqPdu.errorStatusreqPdu.requestIdbulkPdu.maxRepetitionsbulkPdu.nonRepeatersbulkPdu.requestIdtrapPdu.timeStampSnmpValue.TimeticksTagtrapPdu.specificTraptrapPdu.genericTraptrapPdu.agentAddrSnmpValue.IpAddressTagtrapPdu.enterprise/** Gets the PDU encoded in this message. ... */SnmpPduPacket pdunew SnmpPduRequest(...)new SnmpPduBulk(...)new SnmpPduTrap(...)new SnmpIpAddress(...)pdu.typepdu.varBindListdecodeVarBindList(...)SnmpMessage.classpdu.versionpdu.communitypdu.addresspdu.port/** Dumps this message in a string. ... */dumpHexBuffer(...)community.lengthprintMessage(...)/* Copyright (c) 1998, 2007, Oracle and/or its affiliates. All rights reserved. ... */// java imports// Reminder: BerEncoder does backward encoding !/* , byteCount */// FIXME// The easy work// Allocate the array to receive the encoding.// Encode the pdupacket// Decode the pdu// bug id 4654066import SnmpSecurityParametersimport SnmpStatusException/** A partially decoded representation of an SNMP packet. It contains ... *//** The protocol version. ... *//** Encoding of the PDU. ... */int dataLength;/** Number of useful bytes in the <CODE>data</CODE> field. */InetAddress address;/** Source or destination address. ... *//** Source or destination port. ... */SnmpSecurityParameters securityParameters;/** Security parameters. Contain informations according to Security Model (Usm, community string based, ...). *//** Returns the encoded SNMP version present in the passed byte array. ... *//** Dumps the content of a byte buffer using hexadecimal form. ... */int flen/** For SNMP Runtime private use only. */int encodedVarBindCountvarBindList.lengthSnmpVarBind bindencodeVarBindValue(...)bind.valuebind.oidSnmpValue.CounterTagSnmpValue.GaugeTagSnmpValue.OpaqueTagSnmpValue.Counter64TagSnmpValue.NullTagSnmpVarBind.errNoSuchObjectTagSnmpVarBind.errNoSuchInstanceTagSnmpVarBind.errEndOfMibViewTagVector<SnmpVarBind> tmpnew Vector<SnmpVarBind>(...)SnmpVarBind[] varBindListnew SnmpVarBind[]cannotCloseSequence(...)new SnmpVarBind(...)setSnmpValue(...)decodeVarBindValue(...)copyInto(...)SnmpValue resultBerDecoder.IntegerTagBerDecoder.OctetStringTagnew SnmpString(...)BerDecoder.OidTagBerDecoder.NullTagnew SnmpNull(...)new SnmpCounter(...)new SnmpGauge(...)new SnmpTimeticks(...)new SnmpOpaque(...)BerException.BAD_VERSIONnew SnmpCounter64(...)SnmpVarBind.noSuchObjectSnmpVarBind.noSuchInstanceSnmpVarBind.endOfMibView// Remember: the encoder does backward encoding// bugId 4641696 : RuntimeExceptions must be transformed in//                 BerException.// Simple syntax// BerException("Can't build SnmpInt from decoded value.");// BerException("Can't build SnmpString from decoded value.");// BerException("Can't build SnmpOid from decoded value.");// BerException("Can't build SnmpNull from decoded value.");// Application syntax// BerException("Can't build SnmpIpAddress from decoded value.");// BerException("Can't build SnmpCounter from decoded value.");// BerException("Can't build SnmpGauge from decoded value.");// BerException("Can't build SnmpTimeticks from decoded value.");// BerException("Can't build SnmpOpaque from decoded value.");// V2 syntaxes// BerException("Can't build SnmpCounter64 from decoded value.");/** Represents an SNMP null value. ... *//** Constructs a new <CODE>SnmpNull</CODE>. *//** Constructs a new <CODE>SnmpNull</CODE>. ... *//** Constructs a new <CODE>SnmpNull</CODE> from the specified tag value. ... *//** Returns the tag value of this <CODE>SnmpNull</CODE>. ... *//** Converts the <CODE>NULL</CODE> value to its ASN.1 <CODE>String</CODE> form. ... *//** Converts the <CODE>NULL</CODE> value to its <CODE>SnmpOid</CODE> form. ... *//** Clones the <CODE>SnmpNull</CODE> object, making a copy of its data. ... */SnmpNull newclonenewclone.tag/** Checks if this <CODE>SnmpNull</CODE> object corresponds to a <CODE>noSuchObject</CODE> value. ... */SnmpDataTypeEnums.errNoSuchObjectTag/** Checks if this <CODE>SnmpNull</CODE> object corresponds to a <CODE>noSuchInstance</CODE> value. ... */SnmpDataTypeEnums.errNoSuchInstanceTag/** Checks if this <CODE>SnmpNull</CODE> object corresponds to an <CODE>endOfMibView</CODE> value. ... */SnmpDataTypeEnums.errEndOfMibViewTag/** This is the tag of the NULL value. By default, it is the universal tag value. *//** Represents an SNMP Object Identifier (OID). ... *//** Constructs a new <CODE>SnmpOid</CODE> with no components. *//** Constructs a new <CODE>SnmpOid</CODE> from the specified component array. ... *//** Constructs a new <CODE>SnmpOid</CODE> containing one component with the ... *//** Constructs a new <CODE>SnmpOid</CODE> containing four components ... *//** Constructs a new <CODE>SnmpOid</CODE> from a dot-formatted <CODE>String</CODE> or a MIB variable ... */String dotStringresolveVarName(...)SnmpStatusException e/** Gets the number of components in this OID. ... *//** Returns a copy of the components array of this <CODE>SnmpOid</CODE>. ... *//** Returns the components array of this <CODE>SnmpOid</CODE>. ... *//** Returns the value of the OID arc found at the requested position ... */SnmpStatusException.noAccess/** Converts the OID value to its <CODE>Long</CODE> form. ... *//** Converts the OID value to its <CODE>Integer</CODE> form. ... *//** Converts the OID value to its <CODE>String</CODE> form. ... *//** Converts the OID value to its <CODE>Boolean</CODE> form. ... *//** Converts the OID value to its array of <CODE>Bytes</CODE> form. ... */Byte[] resultnew Byte[]/** Converts the OID value to its <CODE>SnmpOid</CODE> form. ... */long[] ids/** Extracts the OID from an index OID and returns its ... */int idCount/** Scans an index OID, skips the OID value and returns the position ... *//** Appends an <CODE>SnmpOid</CODE> representing an <CODE>SnmpOid</CODE> to another OID. ... *//** Clones the <CODE>SnmpOid</CODE> object, making a copy of its data. ... */SnmpOid objobj.componentsthis.componentCountthis.components/** Inserts a subid at the beginning of this <CODE>SnmpOid</CODE>. ... */enlargeIfNeeded(...)/** Appends the specified <CODE>SnmpOid</CODE> to the end of this <CODE>SnmpOid</CODE>. ... */oid.componentCountoid.components/** Appends the specified long to the end of this <CODE>SnmpOid</CODE>. ... *//** Adds the specified dot-formatted OID <CODE>String</CODE> to the end of this <CODE>SnmpOid</CODE>. ... */SnmpOid suffix/** Adds the specified array of longs to the end of this <CODE>SnmpOid</CODE>. ... *//** Checks the validity of the OID. ... *//** Checks whether the specified <CODE>Object</CODE> is equal to this <CODE>SnmpOid</CODE>. ... */SnmpOid oidlong[] objoid/** The hashCode is computed from the OID components. ... */long acc/** Compares two OIDs lexicographically. ... */int cmplenother.componentCountlong[] otheroidother.components/** Resolves a MIB variable <CODE>String</CODE> with the MIB database. ... */SnmpOidTable tablegetSnmpOidTable(...)handleLong(...)SnmpOidRecord recgetOid(...)/** Returns the MIB table used for resolving MIB variable names. ... *//** Sets the MIB table to use for resolving MIB variable names. ... */new SnmpPermission(...)/** Converts an OID index converted string back to a DisplayString */tobyte(...)/** convert the components array into a byte array *//** Checks if there is enough space in the components ... */int neededSizelong[] newComponents/** The components' array. ... */int componentCount;/** The length of the components' array. ... *//** The name of the type. */SnmpOidTable meta;/** Reference to a mib table. If no mib table is available, ... *//** Ensure serialization compatibility with version 4.1 FCS */// Now extract the ids// should never happen. VM bug.// First handle the case where oid is expressed as 1.2.3.4// if we are here, it means we have something to resolve..// Ok assume there is a variable name to resolve ...// just parse the element.import SnmpOidTableimport SnmpOidRecord/** Defines the minimal functionality that should be provided by ... *//** Adds an <CODE>SnmpOidTable</CODE> object in this <CODE>SnmpOidDatabase</CODE>. ... *//** Removes an <CODE>SnmpOidTable</CODE> object from this <CODE>SnmpOidDatabase</CODE>. ... *//** Removes all the <CODE>SnmpOidTable</CODE> objects from this <CODE>SnmpOidDatabase</CODE>. *//** Searches for a MIB variable given its logical name and returns an <CODE>SnmpOidRecord</CODE> ... *//** Searches for a MIB variable given its OID and returns an <CODE>SnmpOidRecord</CODE> object containing ... *//** Returns a list that can be used to traverse all the entries of the <CODE>SnmpOidTable</CODE> objects ... */// jmx import// We can't specify Vector<SnmpOidTable> because the subinterface SnmpOidTable// overrides this method to return Vector<SnmpOidRecord>import static Util.cast/** Defines a set of <CODE>SnmpOidTable</CODE> objects containing metadata definitions for MIB variables. ... *//** Creates an empty <CODE>SnmpOidDatabaseSupport</CODE>. */new Vector<SnmpOidTable>(...)/** Creates an <CODE>SnmpOidDatabaseSupport</CODE> containing the specified <CODE>SnmpOidTable</CODE> object. ... *//** Adds a <CODE>SnmpOidTable</CODE> object in this <CODE>SnmpOidDatabase</CODE>. ... *//** Removes a <CODE>SnmpOidTable</CODE> object from this <CODE>SnmpOidDatabase</CODE>. ... */resolveVarOid(...)Vector<SnmpOidTable> resVector<SnmpOidTable> tmpgetAllEntries(...)int ii/** Removes all <CODE>SnmpOidTable</CODE> objects from this <CODE>SnmpOidDatabase</CODE>. */Vector<SnmpOidTable> tables;//      res.addAll(((SnmpOidTable)tables.elementAt(i)).getAllEntries());/** Represents an entry of an {@link com.sun.jmx.snmp.SnmpOidTable SnmpOidTable}. It contains the name of the MIB variable, ... *//** Creates an <CODE>SnmpOidRecord</CODE> with the specified MIB variable ... *//** Gets the logical name of the MIB variable. ... *//** Gets the OID of the MIB variable. ... *//** Gets the type of the MIB variable. ... *//** The MIB variable name. */String oid;/** The MIB variable OID. *//** The MIB variable type. *//** Defines the minimum functionality that should be provided by ... *//** Searches for a MIB variable given its logical name and returns an {@link com.sun.jmx.snmp.SnmpOidRecord} object ... *//** Searches for a MIB variable given its OID and returns an {@link com.sun.jmx.snmp.SnmpOidRecord} object ... *//** Returns a list that can be used to traverse all the entries this <CODE>SnmpOidTable</CODE>. ... */import Objects/** Contains metadata definitions for MIB variables. ... */new Hashtable<String,SnmpOidRecord>(...)/** Creates an <CODE>SnmpOidTableSupport</CODE> with the specified name. ... */SnmpOidRecord varEnumeration<SnmpOidRecord> listSnmpOidRecord element/** Returns a list that can be used to traverse all the entries in this <CODE>SnmpOidTable</CODE>. ... */Vector<SnmpOidRecord> elementsVectornew Vector<SnmpOidRecord>(...)Enumeration<SnmpOidRecord> e/** Loads a list of variables into the storage area, ... */SnmpOidRecord sSnmpOidTableSupport.class/** Checks if the specified <CODE>Object</CODE> is equal to this <CODE>SnmpOidTableSupport</CODE>. ... */SnmpOidTableSupport val/** Returns the name identifying this <CODE>SnmpOidTableSupport</CODE> object. ... */Hashtable<String,SnmpOidRecord> oidStore;String myName;//RI import// Try to see if the variable name is actually an OID to resolve.// The oid starts with a '.' ala CMU.// Go through the oidStore ... Good luck !// get the locally defined elements .../** Is used to represent an SNMP value. ... *//** Constructs a new <CODE>SnmpOpaque</CODE> from the specified bytes array. ... *//** Constructs a new <CODE>SnmpOpaque</CODE> with the specified <CODE>Bytes</CODE> array. ... *//** Constructs a new <CODE>SnmpOpaque</CODE> from the specified <CODE>String</CODE> value. ... *//** Converts the opaque to its <CODE>String</CODE> form, that is, a string of ... */import SnmpDefinitions/** Contains a set of resources that are used by while sending or receiving ... *//** Creates an <CODE>SnmpParameters</CODE> object with defaults set up. ... *//** Creates an <CODE>SnmpParameters</CODE> object. ... *//** Gets the community to be used when issuing <CODE>get</CODE> operations. ... *//** Sets the community string to use when performing <CODE>get</CODE> operations. ... *//** Gets the community to be used when issuing <CODE>set</CODE> operations. ... *//** Sets the community to be used when issuing <CODE>set</CODE> operations. ... *//** Gets the community to be used when issuing <CODE>inform</CODE> requests. ... *//** Sets the community string to use when performing <CODE>inform</CODE> requests. ... *//** Checks whether parameters are in place for an SNMP <CODE>set</CODE> operation. ... *//** Compares two objects. ... */SnmpParameters paramparam._protocolVersionparam._readCommunity/** Clones the object and its content. ... */SnmpParameters parpar._readCommunitypar._writeCommunitypar._informCommunity/** For SNMP Runtime internal use only. */String defaultRdCommunity;/** Specify the default community string to use for <CODE>get</CODE> operations. ... */int _protocolVersion;String _readCommunity;/** The community to be used when issuing <CODE>get</CODE> operations. ... */String _writeCommunity;/** The community to be used when issuing <CODE>set</CODE> operations. ... */String _informCommunity;/** The community to be used when issuing <CODE>inform</CODE> requests. ... *///par._retryPolicy = _retryPolicy ;// VM bug.// Returns the community string associated to the specified command.//private int               _retryPolicy ;  // not implemented as yet./** This class is the base class of all parameters that are used when making SNMP requests to an <CODE>SnmpPeer</CODE>. ... */int protocolVersion;/** Returns the version of the protocol to use. ... *//** Sets the version of the protocol to be used. ... */this.protocolVersion/** Is the fully decoded representation of an SNMP packet. ... *//** PDU type. Types are defined in ... *//** Protocol version. Versions are defined in ... */...[] varBindList;/** List of variables. ... *//** Request identifier. ... *//** Returns the <CODE>String</CODE> representation of a PDU type. ... *//** Represents a <CODE>get-bulk</CODE> PDU as defined in RFC 1448. ... */int nonRepeaters;/** The <CODE>non-repeaters</CODE> value. ... */int maxRepetitions;/** The <CODE>max-repetitions</CODE> value. ... *//** Builds a new <CODE>get-bulk</CODE> PDU. ... *//** Implements the <CODE>SnmpPduBulkType</CODE> interface. ... *//** Implements the <CODE>SnmpAckPdu</CODE> interface. ... */SnmpPduRequest resultresult.addressresult.portresult.communitySnmpDefinitions.pduGetResponsePduresult.requestIdresult.errorStatusSnmpDefinitions.snmpRspNoErrorresult.errorIndex/** Interface implemented by classes modelizing bulk pdu. ... *//** The <CODE>max-repetitions</CODE> setter. ... *//** The <CODE>non-repeaters</CODE> setter. ... *//** The <CODE>max-repetitions</CODE> getter. ... *//** The <CODE>non-repeaters</CODE> getter. ... *//** Defines the interface of the object in charge of encoding and decoding SNMP packets. ... *//** Decodes the specified <CODE>SnmpMsg</CODE> and returns the ... *//** Encodes the specified <CODE>SnmpPdu</CODE> and ... */import SnmpPduFactoryimport SnmpMessageimport SnmpPduPacketimport SnmpPduimport SnmpMsgimport SnmpTooBigExceptionimport SnmpV3Message/** Default implementation of the {@link com.sun.jmx.snmp.SnmpPduFactory SnmpPduFactory} interface. ... *//** Calls {@link com.sun.jmx.snmp.SnmpMsg#decodeSnmpPdu SnmpMsg.decodeSnmpPdu} ... */decodeSnmpPdu(...)p.versionSnmpDefinitions.snmpVersionOneSnmpDefinitions.snmpVersionTwoSnmpMessage resultnew SnmpMessage(...)encodeSnmpPdu(...)SnmpDefinitions.snmpVersionThreeSnmpV3Message resultnew SnmpV3Message(...)/** The pdu community string. *//** Is used to represent <CODE>get</CODE>, <CODE>get-next</CODE>, <CODE>set</CODE>, <CODE>response</CODE> and <CODE>SNMPv2-trap</CODE> PDUs. ... */int errorStatus;/** Error status. Statuses are defined in ... */int errorIndex;/** Error index. Remember that SNMP indices start from 1. ... *//** Implements <CODE>SnmpPduRequestType</CODE> interface. ... *//** Implements <CODE>SnmpAckPdu</CODE> interface. ... *//** Interface implemented by classes modelizing request pdu. ... *//** Error index setter. Remember that SNMP indices start from 1. ... *//** Error status setter. Statuses are defined in ... *//** Error index getter. Remember that SNMP indices start from 1. ... *//** Error status getter. Statuses are defined in ... *//** Represents an SNMPv1-trap PDU. ... */SnmpOid enterprise;/** Enterprise object identifier. ... */SnmpIpAddress agentAddr;/** Agent address. If the agent address source was not an IPv4 one (eg : IPv6), this field is null. ... */int genericTrap;/** Generic trap number. ... */int specificTrap;/** Specific trap number. ... *//** Time-stamp. ... *//** Builds a new trap PDU. ... *//** Holds information about an SNMP agent. This information is used to communicate with the agent. ... */new SnmpPduFactoryBER(...)new SnmpParameters(...)int defaultSnmpRequestPktSize;/** The default SNMP packet size of an SNMP request (2 * 1024). ... *///-----------------// PUBLIC VARIABLESint defaultSnmpResponsePktSize;/** The default SNMP packet size of an SNMP response (8 * 1024). ... */int maxVarBindLimit;/** The maximum number of variable bindings that can be packed into a request. ... */int portNum;/** Port number of the destination host. ... */int maxTries;/** Number of times to try before giving up. ... */int timeout;/** The amount of time to wait for a response from the peer. ... */SnmpPduFactory pduFactory;/** The PDU factory. The default factory is an instance of <CODE>SnmpPduFactoryBER</CODE>. */long _maxrtt;/** The maximum round trip time for a packet with the peer. */long _minrtt;/** The minimum round trip time for a packet with the peer. */long _avgrtt;/** The average round trip time for a packet with the peer. */SnmpParams _snmpParameter;/** SNMP parameters for this peer are valid for all requests using this peer. ... */InetAddress _devAddr;/** Internet address of the peer to be used when communicating with the peer. */int maxSnmpPacketSize;/** Maximum packet size of the request PDU.  This can be set by the user. ... */...[] _devAddrList;/** List of alternate addresses. */int _addrIndex;/** The index of address currently being used. */boolean customPduFactory;/** Creates an SNMP peer object for a device. The default port is 161. ... *//** Creates an SNMP peer object for a device with the specified port. ... */useIPAddress(...)/** Sets a specific IP address to which the peer will communicate. ... *//** Returns the dot-formatted IP address string (for example 171.69.220.224). ... */byte[] adr/** Specifies the list of addresses to be used.  When a host is not responding ... */useNextAddress(...)/** Causes all subsequent requests to go to the new address ... */_devAddrList.length/** Determines whether an SNMP <CODE>set</CODE> operation is allowed with this ... */allowSnmpSets(...)/** Gets the list of alternate <CODE>InetAddress</CODE> configured for this peer. ... *//** Gets the <CODE>InetAddress</CODE> object for this peer. ... *//** Gets the destination port number of the peer to which SNMP requests are to be sent. ... *//** Changes the port address of the destination for the request. ... *//** Gets the timeout to wait for a response from the peer. ... *//** Changes the timeout to wait for a response from the peer. ... *//** Gets the number of times to try before giving up. ... *//** Changes the maximun number of times to try before giving up. ... *//** Gets the name specified in the constructor while creating this object. ... */getDestAddr(...)/** Returns the <CODE>String</CODE> representation for this <CODE>SnmpPeer</CODE>. ... */getDestPort(...)/** Gets the maximum number of variable bindings that can be sent to a peer. ... *//** Configures the maximum number of variable bindings that can be sent to a peer. ... *//** Sets the <CODE>SnmpParams</CODE> object associated with the peer. ... *//** Gets the <CODE>SnmpParams</CODE> object associated with the peer. ... *//** Gets the maximum request packet size that is currently used. ... *//** Configures the maximum packet size that can be used when generating an SNMP request. ... *//** Finalizer of the <CODE>SnmpPeer</CODE> objects. ... *//** Gets the minimum round trip time for a packet with the peer. ... *//** Gets the maximum round trip time for a packet with the peer. ... *//** Gets the average round trip time for a packet with the peer. ... *//* NPCTE fix for bug 4486059, esc 0 MR 03-August-2001 *//* if (_addrIndex > _devAddrList.length) *//* end of NPCTE fix for bugid 4486059 */// For security and performance reasons we don't call getHostName here// Use getDevName() explicitly when necessary.// to do later.import BasicPermission/** SNMP Permission ... *//** Constructs a SnmpPermission with the specified name. ... *//** Constructs a new SnmpPermission object. ... *//** Generates the pdu to use for response. ... */SnmpScopedPduRequest resultnew SnmpScopedPduRequest(...)result.msgIdresult.msgMaxSizeresult.msgFlagsresult.msgSecurityModelresult.contextEngineIdresult.contextNameresult.securityParameters/** Is the fully decoded representation of an SNMP V3 packet. ... */int msgMaxSize;/** Message max size the pdu sender can deal with. */int msgId;/** Message identifier. */byte msgFlags;/** Message flags. Reportable flag  and security level.</P> ... */int msgSecurityModel;/** The security model the security sub system MUST use in order to deal with this pdu (eg: User based Security Model Id = 3). */...[] contextEngineId;/** The context engine Id in which the pdu must be handled (Generaly the local engine Id). */...[] contextName;/** The context name in which the OID have to be interpreted. *//** The security parameters. This is an opaque member that is ... *//** Constructor. Is only called by a son. Set the version to <CODE>SnmpDefinitions.snmpVersionThree</CODE>. *//** Is used to represent <CODE>get</CODE>, <CODE>get-next</CODE>, <CODE>set</CODE>, <CODE>response</CODE> SNMP V3 scoped PDUs. ... *//** This exception is thrown when an error occurs in an <CODE> SnmpSecurityModel </CODE>. ... */SnmpDefinitions.snmpReqUnknownErrorSnmpDefinitions.noAuthNoPriv...[] list;/** The current request varbind list. */int status;/** The status of the exception. See {@link com.sun.jmx.snmp.SnmpDefinitions} for possible values. */SnmpSecurityParameters params;/** The current security model related security parameters. *//** The current context engine Id. *//** The current context name. *//** The current flags. *//** Constructor. ... *//** Security parameters are security model dependent. Every security parameters class wishing to be passed to a security model must implement this marker interface. ... *//** BER encoding of security parameters. ... *//** BER decoding of security parameters. ... *//** Principal coded inside the security parameters. ... *//** Reports an error which occurred during a get/set operation on a mib node. ... */int noSuchName;int badValue;int readOnly;int noAccess;int noSuchInstance;/** Error code for reporting a no such instance error. */int noSuchObject;/** Error code for reporting a no such object error. *//** Constructs a new <CODE>SnmpStatusException</CODE> with the specified status error. ... *//** Constructs a new <CODE>SnmpStatusException</CODE> with the specified status error and status index. ... *//** Constructs a new <CODE>SnmpStatusException</CODE> with an error message. ... *//** Constructs a new <CODE>SnmpStatusException</CODE> with an error index. ... */x.errorStatus/** Return the error status. ... *//** Returns the index of the error. ... *//** Status of the error. ... *///--------------------/** Index of the error. ... *//** Represents an SNMP string. ... *//** Constructs a new empty <CODE>SnmpString</CODE>. *//** Constructs a new <CODE>SnmpString</CODE> from the specified bytes array. ... *//** Constructs a new <CODE>SnmpString</CODE> from the specified <CODE>Bytes</CODE> array. ... */v.length/** Constructs a new <CODE>SnmpString</CODE> from the specified <CODE>String</CODE> value. ... *//** Constructs a new <CODE>SnmpString</CODE> from the specified <CODE> InetAddress </Code>. ... *//** Converts the string value to its <CODE> InetAddress </CODE> form. ... */getByAddress(...)/** Converts the specified binary string into a character string. ... */char[] valueint binLength/** Converts the specified hexadecimal string into a character string. ... */int hexLength/** Returns the bytes array of this <CODE>SnmpString</CODE>. ... *//** Converts the string value to its array of <CODE>Bytes</CODE> form. ... *//** Converts the string value to its <CODE>String</CODE> form. ... *//** Converts the string value to its <CODE>SnmpOid</CODE> form. ... *//** Extracts the string from an index OID and returns its ... */int strLen/** Scans an index OID, skips the string value and returns the position ... *//** Appends an <CODE>SnmpOid</CODE> representing an <CODE>SnmpString</CODE> to another OID. ... *//** Clones the <CODE>SnmpString</CODE> object, making a copy of its data. ... */SnmpString newclone/** This is the bytes array of the string value. ... */import Math/** Represents an SNMP String defined with a fixed length. ... *//** Constructs a new <CODE>SnmpStringFixed</CODE> from the specified bytes array. ... *//** Constructs a new <CODE>SnmpStringFixed</CODE> with the specified <CODE>Bytes</CODE> array. ... *//** Constructs a new <CODE>SnmpStringFixed</CODE> from the specified <CODE>String</CODE> value. ... *//** Constructs a new <CODE>SnmpStringFixed</CODE> from the specified <CODE>bytes</CODE> array ... *//** Constructs a new <CODE>SnmpStringFixed</CODE> from the specified <CODE>Bytes</CODE> array ... *//** Constructs a new <CODE>SnmpStringFixed</CODE> from the specified <CODE>String</CODE> ... */byte[] v/** Extracts the fixed-string from an index OID and returns its ... *//** Scans an index OID, skip the string value and returns the position ... *//** Appends an <CODE>SnmpOid</CODE> representing an <CODE>SnmpStringFixed</CODE> to another OID. ... *//** Contains an <CODE>SnmpTimeTick</CODE> value which ... *//** Constructs a new <CODE>SnmpTimeticks</CODE> from the specified ... *//** Constructs a new <CODE>SnmpTimeticks</CODE> from the specified long ... */SnmpUnsignedInt.MAX_VALUE/** Parses the specified long value with time units and ... */int secondsint minutesint hoursint days/** Converts the timeticks value to its <CODE>String</CODE> form. ... */printTimeTicks(...)/** Is used internally to signal that the size of a PDU exceeds the packet size limitation. ... *//** Builds an <CODE>SnmpTooBigException</CODE> with ... *//** Returns the number of <CODE>SnmpVarBind</CODE> successfully ... */int varBindCount;/** The <CODE>varBindCount</CODE>. ... */import SnmpUnknownModelException/** This exception is thrown when an ... *//** This exception is thrown when a needed model is not present in the engine. ... *//** This exception is thrown when an <CODE>SnmpLcd</CODE> has no ModelLcd associated to the model. ... *//** This exception is thrown when an <CODE>SnmpMsgProcessingSubSystem</CODE> doesn't know the passed ID. ... *//** This exception is thrown when an <CODE>SnmpSecuritySubSystem</CODE> doesn't know the passed ID. ... *//** This exception is thrown when the handled <CODE> SnmpSubSystem </CODE> is unknown. ... *//** Is the base for all SNMP syntaxes based on unsigned integers. ... */long MAX_VALUE;/** The largest value of the type <code>unsigned int</code> (2^32 - 1). *//** Constructs a new <CODE>SnmpUnsignedInt</CODE> from the specified integer value. ... *//** Constructs a new <CODE>SnmpUnsignedInt</CODE> from the specified <CODE>Integer</CODE> value. ... *//** Constructs a new <CODE>SnmpUnsignedInt</CODE> from the specified long value. ... *//** Constructs a new <CODE>SnmpUnsignedInt</CODE> from the specified <CODE>Long</CODE> value. ... *//** This interface allows you to compute key localization and delta generation. It is useful when adding user in USM MIB. An instance of <CODE> SnmpUsmKeyHandler </CODE> is associated to each <CODE> SnmpEngine </CODE> object. ... */int DES_KEY_SIZE;/** DES privacy algorithm key size. To be used when localizing privacy key */int DES_DELTA_SIZE;/** DES privacy algorithm delta size. To be used when calculing privacy key delta. *//** Translate a password to a key. It MUST be compliant to RFC 2574 description. ... *//** Localize the passed key using the passed <CODE>SnmpEngineId</CODE>. It MUST be compliant to RFC 2574 description. ... *//** Localize the passed privacy key using the passed <CODE>SnmpEngineId</CODE>. It MUST be compliant to RFC 2574 description. ... *//** Calculate the delta parameter needed when processing key change. This computation is done by the key change initiator. It MUST be compliant to RFC 2574 description. ... *//** Calculate the delta parameter needed when processing key change for a privacy algorithm. This computation is done by the key change initiator. It MUST be compliant to RFC 2574 description. ... */import SnmpMsgProcessingSubSystemimport SnmpSecurityModelimport SnmpDecryptedPduimport SnmpSecurityCacheimport SnmpScopedPduBulkimport BerExceptionimport SnmpScopedPduRequestimport BerDecoderimport SnmpEngineIdimport SnmpScopedPduPacketimport BerEncoderimport SnmpPduRequestTypeimport SnmpPduBulkType/** Is a partially decoded representation of an SNMP V3 packet. ... */...[] msgSecurityParameters;/** The unmarshalled security parameters. *//** The context name in which the OID has to be interpreted. */...[] encryptedPdu;/** The encrypted form of the scoped pdu (Only relevant when dealing with privacy). */SnmpV3Message.classSnmpDefinitions.privMaskStringBuilder strb/** Returns the associated request Id. ... */int msgIdSnmpScopedPduPacket pdupdu.contextNamepdu.contextEngineIdpdu.msgSecurityModelpdu.msgFlagspdu.msgMaxSizepdu.msgIdpdu.requestIdpdu.securityParametersSnmpPduRequestType reqPduSnmpPduBulkType bulkPdugetErrorIndex(...)getErrorStatus(...)getMaxRepetitions(...)getNonRepeaters(...)SnmpScopedPduRequest reqPduSnmpScopedPduBulk bulkPdunew SnmpScopedPduBulk(...)setErrorStatus(...)setErrorIndex(...)setNonRepeaters(...)setMaxRepetitions(...)contextEngineId.lengthcontextName.length// import debug stuff// Encode the pdu// The easy work./** Is an abstract representation of an SNMP Value. ... *//** Returns a <CODE>String</CODE> form containing ASN.1 tagging information. ... */getTypeName(...)/** Returns the value encoded as an OID. ... *//** Returns a textual description of the object. ... *//** Same as clone, but you cannot perform cloning using this object because ... *//** This method returns <CODE>false</CODE> by default and is redefined ... *//** This class holds information for a MIB variable contained in an {@link com.sun.jmx.snmp.SnmpVarBindList}. ... */...[] statusLegend;/** Keeps the legend for the value part of the <CODE>SnmpVarBind</CODE>. */int stValueUnspecified;/** Useful constant indicating that the status of the <CODE>SnmpVarBind</CODE> object is not initialized. */int stValueOk;/** Useful constant indicating that the status of the <CODE>SnmpVarBind</CODE> object is valid. */int stValueNoSuchObject;/** Useful constant indicating that the status of the <CODE>SnmpVarBind</CODE> object is <CODE>noSuchObject</CODE>. ... */int stValueNoSuchInstance;/** Useful constant indicating that the status of the <CODE>SnmpVarBind</CODE> object is ... */int stValueEndOfMibView;/** Useful constant indicating that the status of the <CODE>SnmpVarBind</CODE> object is <CODE>endOfMibView</CODE>. ... */SnmpNull noSuchObject;/** Error code value as defined in RFC 1448 for: <CODE>noSuchObject</CODE>. */// These are predefined values for SNMP V2 variablesSnmpNull noSuchInstance;/** Error code value as defined in RFC 1448 for: <CODE>noSuchInstance</CODE>. */SnmpNull endOfMibView;/** Error code value as defined in RFC 1448 for: <CODE>endOfMibView</CODE>. */SnmpOid oid;/** The OID of the <CODE>SnmpVarBind</CODE>. ... */SnmpValue value;/** The value of the <CODE>SnmpVarBind</CODE>. ... *//** Indicates the status of the value in this <CODE>SnmpVarBind</CODE>. ... *//** Default constructor. *//** Constructs a new <CODE>SnmpVarBind</CODE> object from the specified <CODE>SnmpOid</CODE> value. ... *//** Constructs a new <CODE>SnmpVarBind</CODE> object from the specified <CODE>SnmpOid</CODE> and ... *//** Constructs a new <CODE>SnmpVarBind</CODE> object from the specified <CODE>String</CODE> value. ... */SnmpOidRecord record/** Returns the complete OID part associated with this <CODE>SnmpVarBind</CODE>. ... *///--------------// GETTER/SETTER/** Sets the <CODE>SnmpOid</CODE> part associated with this <CODE>SnmpVarBind</CODE> with the specified OID. ... */clearValue(...)/** Returns the value part associated with this <CODE>SnmpVarBind</CODE>. ... *//** Sets the <CODE>SnmpValue</CODE> part associated with this <CODE>SnmpVarBind</CODE> with the specified value. ... */setValueValid(...)/** Sets the <CODE>SnmpCounter64</CODE> value part associated with this <CODE>SnmpVarBind</CODE> ... *//** Sets the <CODE>SnmpInt</CODE> value part associated with this <CODE>SnmpVarBind</CODE> ... *//** Sets the <CODE>SnmpCounter</CODE> value part associated with this <CODE>SnmpVarBind</CODE> ... *//** Sets the <CODE>SnmpGauge</CODE> value part associated with this <CODE>SnmpVarBind</CODE> ... *//** Sets the <CODE>SnmpTimeticks</CODE> value part associated with this <CODE>SnmpVarBind</CODE> ... *//** Sets the <CODE>SnmpOid</CODE> value part associated with this <CODE>SnmpVarBind</CODE> ... *//** Sets the <CODE>SnmpIpAddress</CODE> value part associated with this <CODE>SnmpVarBind</CODE> ... *//** Sets the <CODE>SnmpString</CODE> value part associated with this <CODE>SnmpVarBind</CODE> ... *//** Sets the <CODE>SnmpOpaque</CODE> value part associated with this <CODE>SnmpVarBind</CODE> ... *//** Sets the <CODE>SnmpStringFixed</CODE> value part associated with this <CODE>SnmpVarBind</CODE> ... */new SnmpStringFixed(...)/** Consults the MIB table storage to resolve the name to its OID type structure. ... */SnmpOidTable mibTable/** Returns the status of the value associated with this <CODE>SnmpVarBind</CODE> as an integer. ... *//** Returns the status of the value associated with this <CODE>SnmpVarBind</CODE> as a <CODE>String</CODE>. ... *//** Checks whether the object contains a valid accessible value. ... *//** Checks whether the value associated with this <CODE>SnmpVarBind</CODE> is unspecified. ... *//** Clears the value associated with this <CODE>SnmpVarBind</CODE> and sets the status to ... *//** Checks whether the OID for this variable completely matches the OID part of the specified ... */var.oid/** Adds an instance part to the OID in the <CODE>SnmpOid</CODE> object. ... */addToOid(...)/** Inserts a sub-id at the beginning of the OID of this <CODE>SnmpVarBind</CODE>. ... *//** Appends the specified <CODE>SnmpOid</CODE> to the end of the OID of this <CODE>SnmpVarBind</CODE>. ... *//** Determines whether the <CODE>SnmpVarBind</CODE> has an SNMP exception ... *//** Clones and copies the OID and value part from another <CODE>SnmpVarBind</CODE> object. ... */setOid(...)copyValue(...)/** Clones and copies only the value part from another <CODE>SnmpVarBind</CODE> object. ... */isValidValue(...)duplicate(...)getSnmpValue(...)getValueStatus(...)/** Clones the SNMP variable. It does not clone the value portion. ... */SnmpOid noid/** Clones the SNMP variable (including value). ... */SnmpVarBind vcopyValueAndOid(...)/** Returns the printable ASCII representation for the corresponding variable value. ... *//** Set the value to {@link #noSuchObject}. This is equivalent to ... *//** Set the value to {@link #noSuchInstance}. This is equivalent to ... *//** Set the value to {@link #endOfMibView}. This is equivalent to ... *//** Returns the printable ASCII representation of this <CODE>SnmpVarBind</CODE>. ... */StringBuilder sgetValueStatusLegend(...)/** Sets the status to indicate that the value for this <CODE>SnmpVarBind</CODE> is valid. */// FindBugs will issue a warning here, because super.clone()// is not called. But this is actually OK because we construct// a brand new object./** Contains a list of <CODE>SnmpVarBind</CODE> objects. ... *//** A name given to the <CODE>SnmpVarBindList</CODE>. Useful for debugging. ... */Timestamp timestamp;/** Timestamp when this <CODE>SnmpVarBindList</CODE> was updated. ... */// name identifying this list./** Prepares an empty list. ... *//** Prepares an empty list with a <CODE>String</CODE> to print while debugging. ... *//** Similar to the copy constructor. Does a shallow copy of the elements. ... *//** Creates a new <CODE>SnmpVarBindList</CODE> object from a plain vector of <CODE>SnmpVarBind</CODE> objects. ... */Enumeration<SnmpVarBind> eSnmpVarBind varBind/** Gets the <CODE>timestamp</CODE> associated with this <CODE>SnmpVarBindList</CODE>. ... *//** Records the <CODE>sysUpTime</CODE> and the actual time when this <CODE>SnmpVarBindList</CODE> ... *//** Gets an <CODE>SnmpVarBind</CODE> object. ... *//** Gets the number of elements in this list. ... *//** This is a convenience function that returns an enumeration. This can be used to traverse the list. ... *//** Replaces the current variable binding list of <CODE>SnmpVarBind</CODE> with the new specified variable binding ... */setVarBindList(...)/** Replaces the current variable binding list of <CODE>SnmpVarBind</CODE> objects with the new variable binding ... */SnmpVarBind avar/** Appends an <CODE>SnmpVarBindList</CODE> at the end of the current <CODE>SnmpVarBindList</CODE> object. ... */getVarBindAt(...)/** Removes all the <CODE>SnmpVarBind</CODE> objects of the given <CODE>SnmpVarBindList</CODE> from the existing ... *//** Replaces an element at a specified location with the new element. ... */setElementAt(...)/** Prepares a vector of <CODE>SnmpVarBindList</CODE> from an array of SNMP MIB variables and instances. ... */addInstance(...)/** Removes the array of SNMP MIB variables and instances from the existing <CODE>SnmpVarBindList</CODE>. ... */int indexOidindexOfOid(...)/** Adds an array of MIB variable names to the list. For example: ... */addVarBind(...)/** Removes the array of SNMP MIB variables from the existing <CODE>SnmpVarBindList</CODE>. ... */removeVarBind(...)/** Creates an <CODE>SnmpVarBind</CODE> object from the given MIB variable and appends it to the existing ... *//** Removes the <CODE>SnmpVarBind</CODE> object corresponding to the given MIB variable from the existing ... *//** Appends the given <CODE>SnmpVarBind</CODE> object to the existing <CODE>SnmpVarBindList</CODE>. ... *//** Removes the given <CODE>SnmpVarBind</CODE> object from the existing <CODE>SnmpVarBindList</CODE>. ... *//** Adds the string as an instance part to all OIDs in this list. ... *//** Adds elements in the specified <CODE>SnmpVarBindList</CODE> to this list. ... *//** Returns <CODE>false</CODE> if any of the variables does not contain a valid value. ... *//** Returns <CODE>true</CODE> if there is a value that is not specified. ... */isUnspecifiedValue(...)/** Splits the <CODE>SnmpVarBindList</CODE>. ... */SnmpVarBindList splitVbnew SnmpVarBindList(...)/** Gives the index of an OID in the <CODE>SnmpVarBindList</CODE>. ... */SnmpOid oidarg/** Clones the <CODE>SnmpVarBindList</CODE>. A new copy of the <CODE>SnmpVarBindList</CODE> is created. ... */SnmpVarBindList newvbsetTimestamp(...)getTimestamp(...)/** Clones the <CODE>SnmpVarBindList</CODE>. It does not clone the value part of the variable. ... */cloneWithoutValue(...)cloneWithValue(...)/** Copies the <CODE>SnmpVarBindList</CODE> into a plain vector of <CODE>SnmpVarBind</CODE> objects. ... */Vector<SnmpVarBind> result/** Returns a <CODE>String</CODE> containing the ASCII representation of all OIDs in the list. ... *//** Constructs a <CODE>String</CODE> containing details of each <CODE>SnmpVarBindList</CODE> (oid+value). ... *//** Finalizer of the <CODE>SnmpVarBindList</CODE> objects. ... */// do deepcopy of all vars.// size() - atPosition) ;/** <p><b>Warning: The interface of this class is subject to change. ... */new ThreadLocal<ThreadContext>(...)ThreadContext previous;/* We have to comment out "final" here because of a bug in the JDK1.1 ... *//* The context of a thread is stored as a linked list.  At the ... */this.previous/** <p>Get the Object that was most recently pushed with the given key.</p> ... */ThreadContext contextcontextContaining(...)context.value/** <p>Check whether a value with the given key exists in the stack. ... *//** <p>Find the ThreadContext in the stack that contains the given key, ... */context.previouscontext.key/** <p>Push an object on the context stack with the given key. ... *///  }//      return old;//      context.value = value;//      Object old = context.value;//          return null;//      if (context == null)//      ThreadContext context = contextContaining(key);//          throws IllegalArgumentException {//  public static Object set(String key, Object value)//   *///   * @exception IllegalArgumentException if <code>key</code> is null.//   *//   * if the key does not exist in the stack.//   * @return the value that was previously associated with the key, or null//   * @param value the new value to associate with that key.//   * @param key the key of interest.//   * and the return value is null.//   * <code>restore</code>.  If there is no such association, nothing happens//   * in a <code>push</code> operation not cancelled by a subsequent//   * Change the value that was most recently associated with the given key//  /**ThreadContext oldContextThreadContext newContextnew ThreadContext(...)setContext(...)/** <p>Return an object that can later be supplied to <code>restore</code> ... *//** <p>Restore the context stack to an earlier state.  This typically ... */oldContext.key/* We rely on the fact that ThreadContext objects are immutable. ... *//** <p>Set the initial context of the calling thread to a context obtained ... */ThreadLocal<ThreadContext> localContext;/* Copyright (c) 2000, 2007, Oracle and/or its affiliates. All rights reserved. ... *//* final *//* Note that "context.key" may be null if "context" is the ... */// make sentinel/* The following test is not strictly necessary in the code as it ... *//* Check that the restored context is in the stack. *//* Discard the sentinel if the stack is empty.  This means that it ... *//* The following test assumes that we discard sentinels when the ... *//** This class is used by the {@link com.sun.jmx.snmp.SnmpVarBindList SnmpVarBindList} object. ... */long sysUpTime;/** The time (in hundreds of a second) since the network management portion of the system ... */long crtime;/** A <CODE>long</CODE> representing the current date. */SnmpTimeticks uptimeCache;/** The <CODE>SnmpTimeticks</CODE> object corresponding to the <CODE>TimeStamp</CODE> object. *//** The default constructor. <CODE>Sysuptime</CODE> is 0. ... *//** Creates a <CODE>TimeStamp</CODE> object using the user parameters. ... *//** Gets the <CODE>SnmpTimeticks</CODE> object corresponding to the <CODE>TimeStamp</CODE> object. ... *//** Gets the time (in hundredths of a second) since the network management portion of the system ... *//** Gets the current date. ... *//** Returns a <CODE>String</CODE> representation of the <CODE>TimeStamp</CODE> object. ... */getDate(...)/** Defines the user based ACL used by the SNMP protocol adaptor. ... *//** Checks whether or not the specified user has <CODE>READ</CODE> access. ... *//** Checks whether or not the specified user and context name have <CODE>READ</CODE> access. ... *//** Checks whether or not a context name is defined. ... *//** Checks whether or not the specified user has <CODE>WRITE</CODE> access. ... *//** Checks whether or not the specified user and context name have <CODE>WRITE</CODE> access. ... */import static JmxProperties.SNMP_ADAPTOR_LOGGERimport SnmpOidimport SnmpVarBindimport SnmpEngineimport SnmpAccessControlModelimport SnmpEngineImpl/** Oid Checker makes use of ACM to check each OID during the getnext process. */SnmpAccessControlModel model;String principal;int securityLevel;int pduType;int securityModel;SnmpEngineImpl engine;LongList l;getEngine(...)isCheckOidActivated(...)SnmpMib.classgetAccessControlSubSystem(...)getSecurityLevel(...)getPdu(...).typegetPdu(...)getRequestPduVersion(...)getSecurityModel(...)getAccessContextName(...)new LongList(...)SnmpUnknownModelException e//We are in V3 architecture, ACM is in the picture./** This list is used in order to construct the OID during the getnext. ... */int DEFAULT_CAPACITY;int DEFAULT_INCREMENT;int DELTA;/** The list content. Any access to this variable must be protected ... *//** Same behaviour than size() in {@link java.util.List}. *//** Same behaviour than add(long o) in {@link java.util.List}. ... *//** Same behaviour than add(int index, long o) in ... *//** Adds <var>count</var> elements to the list. ... *//** Any access to this method should be protected in a synchronized ... */long oint oldsize/** Same behaviour than remove(int index) in {@link java.util.List}. ... *//** Same behaviour than the toArray(long[] a) method in ... *//** Same behaviour than the toArray() method in ... *//** Resize the list. Increase its capacity by DELTA elements. ... */long[] newlist/** Resize the list. Insure that the new length will be at ... */int min/** Allocate a new array of object of specified length. *//** This class only adds a new constructor to SnmpOid... *//** Constructs a new <CODE>SnmpOid</CODE> from the specified ... */int subLengthoid.lengthlong[] subOid/* Copyright (c) 2000, 2006, Oracle and/or its affiliates. All rights reserved. ... *//** A simple MIB agent that implements SNMP calls (get, set, getnext and getbulk) in a way that only errors or exceptions are returned. Every call done on this agent fails. Error handling is done according to the manager's SNMP protocol version. ... *//** Initializes the MIB (with no registration of the MBeans into the ... *//** Initializes the MIB but each single MBean representing the MIB ... *//** Gets the root object identifier of the MIB. ... *//** Processes a <CODE>get</CODE> operation. It will throw an exception for V1 requests or it will set exceptions within the list for V2 requests. ... */Enumeration<SnmpVarBind> lgetElements(...)SnmpErrorHandlerAgent.classSnmpVarBind varbindsetNoSuchObject(...)/** Checks if a <CODE>set</CODE> operation can be performed. ... */SnmpDefinitions.snmpRspNotWritable/** Processes a <CODE>set</CODE> operation. Should never be called (check previously called having failed). ... *//** Processes a <CODE>getNext</CODE> operation. It will throw an exception for V1 requests or it will set exceptions within the list for V2 requests.. ... */setEndOfMibView(...)/** Processes a <CODE>getBulk</CODE> operation. It will throw an exception if the request is a V1 one or it will set exceptions within the list for V2 ones. ... */SnmpDefinitions.snmpRspGenErrimport SnmpValue/** Construct an attribute value (as returned by Attribute::getValue()) ... *//** Construct an SnmpValue from an Attribute value as returned by ... *//** Return the name of the attribute corresponding to the ... *//** Check the access rights for a SET operation. ... *//** Check the access rights for a GET operation. ... */// jmx imports/** The MBean server through which the MBeans will be accessed. */// ----------------------------------------------------------------------//    Protected variables/** Builds a new SnmpGenericObjectServer. Usually there will be a single ... *//** Execute an SNMP GET request. ... */Object datagetUserData(...)String[] nameListSnmpVarBind[] varListlong[] idListint errorCodeSnmpStatusException.noSuchInstanceSnmpVarBind varlong idgetOidArc(...)getAttributeName(...)checkGetAccess(...)SnmpStatusException xregisterGetException(...)InstanceNotFoundException fReflectionException rAttribute attbuildSnmpValue(...)/** Get the value of an SNMP variable. ... */MBeanException mException t/** Execute an SNMP SET request. ... */AttributeList attListObject attvaluebuildAttributeValue(...)var.valueregisterSetException(...)SnmpStatusException.snmpRspInconsistentName/** Set the value of an SNMP variable. ... */InvalidAttributeValueException ivSnmpStatusException.snmpRspWrongValue/** Checks whether an SNMP SET request can be successfully performed. ... */registerCheckException(...)// XXX xxx ZZZ zzz Maybe we should go through the MBeanInfo here?/** Checks whether a SET operation can be performed on a given SNMP ... */checkSetAccess(...)String[] signatureInstanceNotFoundException iInstanceAlreadyExistsException eMBeanRegistrationException eSnmpStatusException.snmpRspNoAccessSnmpStatusException.snmpRspGenErr// java.lang.System.out.println(">>>>>>>>> GET " + name);// Check the access rights according to the MIB.// The MBean might be less restrictive (have a getter// while the MIB defines the variable as AFN)//java.lang.System.out.println(nameList[i] + " added.");//java.lang.System.out.println("exception for " + nameList[i]);//x.printStackTrace();//java.lang.System.out.println(name + ": instance not found.");//f.printStackTrace();//java.lang.System.out.println(name + ": reflexion error.");//r.printStackTrace();//java.lang.System.out.println(name + "variable[" + j +//                           "] absent");//java.lang.System.out.println(name + "variable[" +j +//                           "] not found");//java.lang.System.out.println(att.getName() + " retrieved.");//java.lang.System.out.println(">>>>>>>>> END GET");// call meta.check() here, and meta.check will call check()// checkXXXX() not defined => do nothing/** Represents a SNMP index. ... */new Vector<SnmpOid>(...)/** Initializes an <CODE>SnmpIndex</CODE> using a vector of object identifiers. ... */oidList.length/** Initializes an <CODE>SnmpIndex</CODE> using the specified Object Identifier. ... *//** Gets the number of Object Identifiers the index is made of. ... *//** Gets the index as a vector of Object Identifiers. ... *//** Compares two indexes for equality. ... */SnmpOid oid1SnmpOid oid2Vector<SnmpOid> componentsgetNbComponents(...)/** Compares two indexes. ... */int comp/** Returns a <CODE>String</CODE> representation of the index. ... */StringBuilder msgEnumeration<SnmpOid> eSnmpOid valVector<SnmpOid> oids;/** The list of OIDs. ... *//** The number of elements in the index. ... */// The order is important ...// The two vectors have the same length.// Compare each single element ...// There is no more element in the index// Access the element .../** Abstract class for representing an SNMP MIB. ... *//** Default constructor. ... */new SnmpMibOid(...)// --------------------------------------------------------------------// POLYMORHIC METHODSregisterNode(...)/** Returns a registered SNMP Table metadata node. ... */// for java-doc// Implements the method defined in SnmpMibAgent. See SnmpMibAgent/** Processes a <CODE>get</CODE> operation. */int reqTypeSnmpDefinitions.pduGetRequestPduSnmpRequestTree handlersgetHandlers(...)SnmpRequestTree.HandlerHandler hSnmpMibNode metaEnumeration<Handler> ehint depthgetOidDepth(...)getMetaNode(...)Enumeration<SnmpMibSubRequest> rqsgetSubRequests(...)/** Processes a <CODE>set</CODE> operation. */SnmpDefinitions.pduSetRequestPdugetRequestTree(...)switchCreationFlag(...)setPduType(...)SnmpDefinitions.pduWalkRequestsetRequestTree(...)/** Processes a <CODE>getNext</CODE> operation. */getGetNextHandlers(...)/** Processes a <CODE>getBulk</CODE> operation. ... */getBulkWithGetNext(...)Vector<Integer> listnew Vector<Integer>(...)getRootOid(...)/** This method builds the temporary request-tree that will be used to ... *///---------------------------------------------------------------------new SnmpRequestTree(...)int verfindHandlingNode(...)mapGetException(...)getStatus(...)SnmpStatusException ssemapSetException(...)SnmpStatusException.noSuchObjectSnmpDefinitions.pduGetNextRequestPduAcmChecker checkernew AcmChecker(...)SnmpOid originalsetGetNextFlag(...)SnmpOid resultfindNextHandlingNode(...)SnmpMibOid root;/** The top element in the Mib tree. ... */// PROTECTED VARIABLES...[] rootOid;/** The root object identifier of the MIB. */// Builds the request tree: creation is not allowed, operation// is not atomic.// For each sub-request stored in the request-tree, invoke the// get() method.// Gets the Meta node. It can be either a Group Meta or a// Table Meta.// Gets the depth of the Meta node in the OID tree// Invoke the get() operation.// Optimization: we're going to get the whole SnmpRequestTree// built in the "check" method, so that we don't have to rebuild// it here.// Optimization didn't work: we have to rebuild the tree.// is atomic.// Invoke the set() operation// Builds the request tree: creation is allowed, operation// check() method.// Invoke the check() operation// Optimization: we're going to pass the whole SnmpRequestTree// to the "set" method, so that we don't have to rebuild it there.// Build the request tree for the operation// The subrequest stored in the request tree are valid GET requests// Now invoke get() for each subrequest of the request tree.// Invoke the get() operation// Ask the tree to do the job !// Now format the result// Build an empty request tree// For each varbind in the list finds its handling node.// Find the handling node for this varbind.// If the operation is atomic (Check/Set) or the version// is V1 we must generate an exception.// The index in the exception must correspond to the// SNMP index ...// Should never come here...// Creates an empty request tree, no entry creation is allowed (false)// Sets the getNext flag: if version=V2, status exception are// transformed in  endOfMibView// For each varbind, finds the handling node.// This function has the side effect of transforming a GET-NEXT// request into a valid GET request, replacing the OIDs in the// original GET-NEXT request with the OID of the first leaf that// follows.// Find the node handling the OID that follows the varbind// OID. `result' contains this next leaf OID.//ACM loop.// We replace the varbind original OID with the OID of the// leaf object we have to return.// if (isDebugOn())//    debug("getGetNextHandlers",//        "Couldn't find a handling node for "//        + var.oid.toString());import ServiceNotFoundException/** Abstract class for representing an SNMP agent. ... *///----------------------------------------------------------------------// ---------------------------------------------------------------------/** Not used in this context. *//** Processes a <CODE>get</CODE> operation. ... *//** Processes a <CODE>getNext</CODE> operation. ... *//** Processes a <CODE>set</CODE> operation. ... *//** Gets the reference to the MBean server in which the SNMP MIB is ... */// GETTERS AND SETTERS/** Gets the reference to the SNMP protocol adaptor to which the MIB is ... *//** Sets the reference to the SNMP protocol adaptor through which the MIB ... */removeMib(...)addMib(...)/** Gets the object name of the SNMP protocol adaptor to which the MIB ... */new ServiceNotFoundException(...)MBeanException e/** Indicates whether or not the MIB module is bound to a SNMP protocol ... *//** Gets the MIB name. ... *//** This is a factory method for creating new SnmpMibRequest objects. ... */new SnmpMibRequestImpl(...)/** Processes a <CODE>getBulk</CODE> operation using call to ... */// PACKAGE METHODSVector<SnmpVarBind> listgetSubList(...)int Lint Nint Mint RVector<SnmpVarBind> repeaterssplitFrom(...)SnmpMibRequestImpl repeatedReqgetContextName(...)getNext(...)concatVector(...)/** This method creates a new Vector which does not contain the first ... */SnmpDefinitions.snmpV1SecurityModelSnmpDefinitions.snmpV2SecurityModelString mibName;/** The object name of the MIB. ... *//** The reference to the MBean server. ... */ObjectName adaptorName;/** The object name of the SNMP protocol adaptor. ... */SnmpMibHandler adaptor;/** The reference to the SNMP stack. */// First remove the reference on the old adaptor server.// Then update the reference to the new adaptor server.// Should never occur...// RFC 1905, Section 4.2.3, p14// Let's build the varBindList for the response pdu// int errorStatus = SnmpDefinitions.snmpRspNoError ;// int errorIndex = 0 ;// Non-repeaters and first row of repeaters// Now the remaining repeaters// Ok the loop looks a bit strange. But in order to improve the// perf, we try to avoid reference to the limit variable from// within the loop ...// We need to duplicate the SnmpVarBind otherwise it is going// to be overloaded by the next get Next .../** Exposes the remote management interface of the <CODE>SnmpMibAgent</CODE> MBean. ... *//** Sets the reference to the SNMP protocol adaptor through which the ... *//** Gets the object name of the SNMP protocol adaptor to which the MIB is ... *//** Represents a node in an SNMP MIB which corresponds to a table entry ... *//** Tells whether the given arc identifies a variable (scalar object) in ... *//** Tells whether the given arc identifies a readable scalar object in ... *//** Get the next OID arc corresponding to a readable scalar variable. */long nextvargetNextVarId(...)isReadable(...)/** Checks whether the given OID arc identifies a variable (columnar ... */isVariable(...)SnmpDefinitions.snmpRspNoSuchName/** Generic handling of the <CODE>get</CODE> operation. ... *//** Generic handling of the <CODE>set</CODE> operation. ... *//** Generic handling of the <CODE>check</CODE> operation. ... *//** Represents a node in an SNMP MIB which corresponds to a group. ... */Hashtable<Long,Long> subgroups;// or to a variable.// to a subgroup, if it is not in subgroup, it leads either to a table// So for each arc in varList, if the arc is also in subgroups, it leads// We will register the OID arcs leading to subgroups in this hashtable./** Tells whether the given arc identifies a table in this group. ... *//** Gets the table identified by the given `arc'. ... *//** Checks whether the given OID arc identifies a variable (scalar ... *//** Tell whether the given OID arc identifies a sub-tree ... */// groups and subgroups are dynamically registered in the MIB.// However, the generic approach was preferred because at this time// method in which the subgroup OID arcs would be hardcoded.// For instance, the subclass could provide a generated isNestedArc()// needed...// OID arc leads to a subgroup. This implementation can be changed if// We use a hashtable (subgroup) in order to determine whether an// -------------------------------------------------------------------// return.// If we reach this node, we are below the root OID, so we just/** Register an OID arc that identifies a sub-tree ... *///    useless and can become empty.// => if isNestedArc() is hardcoded, then registerSubArc() becomes// different implementation of the isNestedArc() method.// This method can also be overriden in a subclass to provide aLong objnew Hashtable<Long,Long>(...)/** Register an OID arc that identifies a scalar object or a table. ... */// table arc by the generated subclass.// registerObject() should be called for each scalar object and each// correct location.// in varList, so that the real subgroup nodes can be inserted at the// So the trick is to register a null node in children for each variable// position in children.// registered in varList, there is a corresponding node at the same// The SnmpMibOid algorithm relies on the fact that for every arc/** Register a child node of this node in the OID tree. ... */// We trap registerNode() in order to call registerSubArc()// be called to register nested-groups.// registered in the MIB. So we do know that this method will only// registerNode() will be called at runtime when nested groups areregisterNestedArc(...)// see comments in SnmpMibNodelong arcisNestedArc(...)isTable(...)SnmpMibTable tablevalidateVarId(...)// See comments in SnmpMibNode.SnmpMibNode nodeint pduVersionSnmpStatusException excheckCurrentOid(...)SnmpMibNode childlong[] newOid// if the arc is registered in the hashtable,// it leads to a subgroup.// registers the arc in the hashtable.// this will register the variable in both varList and children// The node registered in children will be null, so that the parent// algorithm will behave as if no node were registered. This is a// trick that makes the parent algorithm behave as if only subgroups// were registered in varList and children.// if we get here, then it means we are registering a subgroup.// We will thus register the sub arc in the subgroups hashtable.// Nothing is left... the oid is not valid// This arc leads to a subgroup: delegates the search to the// method defined in SnmpMibOid// This arc leads to a table: forward the search to the table.// Gets the table// Forward the search to the table// If it's not a variable, throws an exception// The trailing .0 is missing in the OID// There are too many arcs left in the OID (there should remain// a single trailing .0)// The last trailing arc is not .0// It's one of our variable, register this node.// This should be considered as a genErr, but we do not want to// abort the whole request, so we're going to throw// a noSuchObject...// The generic case where the end of the OID has been reached is// handled in the superclass// XXX Revisit: this works but it is somewhat convoluted. Just setting//              arc to -1 would work too.// Ok, we've got the arc.// We have a recursive logic. Should we have a loop instead?// If the arc identifies a table, then we need to forward// the search to the table.// Gets the table identified by `arc'// Forward to the table// Build up the leaf OID// If the arc identifies a readable variable, then two cases:// The end of the OID is reached, so we return the leaf// corresponding to the variable identified by `arc'// Build up the OID// result = new SnmpOid(0);// result.insert((int)arc);// Registers this node// The end of the OID is not yet reached, so we must return// the next leaf following the variable identified by `arc'.// We cannot return the variable because whatever follows in// the OID will be greater or equals to 0, and 0 identifies// the variable itself - so we have indeed to return the// next object.// So we do nothing, because this case is handled at the// end of the if ... else if ... else ... block.// Now if the arc leads to a subgroup, we delegate the// search to the child, just as done in SnmpMibNode.// get the child ( = nested arc node).// The oid is not valid, we will throw an exception in order// to try with the next valid identifier...// We didn't find anything at the given arc, so we're going// to try with the next valid arc/** The logical link between an SNMP MIB and the SNMP communication stack. ... *//** Adds a new MIB in the SNMP MIB handler. ... *//** Adds a new contextualized MIB in the SNMP MIB handler. ... *//** Removes the specified MIB from the SNMP protocol adaptor. ... *//** The <CODE>SnmpMibNode</CODE> class represents a node in an SNMP MIB. ... *//** Get the next OID arc corresponding to a readable scalar variable, ... */getNextIdentifier(...)long varidskipVariable(...)/** Hook for subclasses. ... *//** Find the node which handles a varbind, and register it in the ... *//** Find the node which handles the leaf that immediately follows the ... *//** Sorts the specified integer array. ... */QuickSort(...)/** Computes the root OID of the MIB. *//** This is a generic version of C.A.R Hoare's Quick Sort ... */int loint hiint midswap(...)/** This will give the first element greater than <CODE>value</CODE> ... */// PROTECTED METHODSint[] aint lowa.lengthint elmtint T...[] varList;/** Contains the list of variable identifiers. *//* Arbitrarily establishing partition element as the midpoint of ... */// loop through the array until indices cross/* find the first element that is greater than or equal to ... *//* find an element that is smaller than or equal to ... */// if the indexes have not crossed, swap/* If the right index has not reached the left side of array ... *//* If the left index has not reached the right side of array ... */// Basic check// We ned to get the next index ...SnmpMibOid$NonSyncVector/** Represents a node in an SNMP MIB which is neither a group nor a variable. ... */new NonSyncVector<SnmpMibNode>(...)// Implements the method defined in SnmpMibNode.firstElement(...)/** Registers a specific node in the tree. */long varretrieveIndex(...)SnmpMibOid childint[] tmpint newPosexportChildren(...)/** Export this node's children to a brother node that will replace ... */getInsertAt(...)elementAtNonSync(...)int cursorvarList.lengthNonSyncVector<SnmpMibNode> children;/** Contains the list of sub nodes. */int nbChildren;/** The number of sub nodes. */// not always required...// Synchronization is a very expensive operation. In our case it is// All the methods of the Vector class are synchronized.// The oid is not complete...// Some children variable or subobject is being querried// getChild() will raise an exception if no child is found.// XXXX zzzz : what about null children?//             (variables for nested groups)// if child==null, then we're dealing with a variable or// a table: we register this node.// This behaviour should be overriden in subclasses,// in particular in group meta classes: the group// meta classes that hold tables should take care// of forwarding this call to all the tables involved.// search the element specified in the oid// SnmpOid result = null;// shouldn't happen// validateVarId(index);// handlers.add(this,varbind,depth);// If there is no such element go one level up ...// There is no need to carry the original oid ...// If a node has several children, let assume that we are one step to// far in order to get the MIB root.// Now query our child.// Check if the node is already defined//System.out.println("entering registration for val="// + String.valueOf(var) + " position= " + cursor);// That 's the end of the trip.// Do not forward the registration//System.out.println("End of trip for val="//      + String.valueOf(var) + " position= " + cursor);//System.out.println("Create node for val="//       + String.valueOf(var) + " position= " + cursor);// The node is not yet registered//     + String.valueOf(var) + " position= " + cursor);// System.out.println("Create node for val=" +//     String.valueOf(var) + " position= " + cursor);// The node is already registered//System.out.println("Node already registered val=" +//          String.valueOf(var) + " position= " + cursor);// Now we're going to patch the tree the following way://   if a subgroup has been registered before its father,//   we're going to replace the father OID node with//   the actual group-node and export the children from//   the temporary OID node to the actual group node.// `node' is a group => replace `child' with `node'// export the child's subtree to `node'.// `node' is a temporary node, and `child' is a//  group => keep child and export the node's//  subtree to `child'.// `node' and `child' are both temporary OID nodes// => replace `child' with `node' and export child's// subtree to `node'.// first we need to retrieve the identifier in the list of children// Access the node// We need to get the next index ...//final int[] v = varList;//if (index > a[max])//return max +1;// never know ...we might find something ...// We will never serialize this// cast to E/** This interface models the part of a SNMP request that involves ... *//** Returns the list of varbind to be handled by the SNMP mib node. ... *//** Returns the vector of varbind to be handled by the SNMP mib node. ... *//** Returns the SNMP protocol version of the original request. If SNMP V1 request are received, the version is upgraded to SNMP V2. ... *//** Returns the SNMP protocol version of the original request. No translation is done on the version. The actual received request SNMP version is returned. ... *//** Returns the local engine. This parameter is returned only if <CODE> SnmpV3AdaptorServer </CODE> is the adaptor receiving this request. Otherwise null is returned. ... *//** Gets the incoming request principal. This parameter is returned only if <CODE> SnmpV3AdaptorServer </CODE> is the adaptor receiving this request. Otherwise null is returned. ... *//** Gets the incoming request security level. This level is defined in {@link com.sun.jmx.snmp.SnmpEngine SnmpEngine}. This parameter is returned only if <CODE> SnmpV3AdaptorServer </CODE> is the adaptor receiving this request. Otherwise -1 is returned. ... *//** Gets the incoming request security model. This parameter is returned only if <CODE> SnmpV3AdaptorServer </CODE> is the adaptor receiving this request. Otherwise -1 is returned. ... *//** Gets the incoming request context name. This parameter is returned only if <CODE> SnmpV3AdaptorServer </CODE> is the adaptor receiving this request. Otherwise null is returned. ... *//** Gets the incoming request context name used by Access Control Model in order to allow or deny the access to OIDs. This parameter is returned only if <CODE> SnmpV3AdaptorServer </CODE> is the adaptor receiving this request. Otherwise null is returned. ... *//** Returns a handle on a user allocated contextual object. ... *//** Returns the varbind index that should be embedded in an ... *//** Adds a varbind to this request sublist. This method is used for ... *//** Returns the number of elements (varbinds) in this request sublist. ... *//** Returns the SNMP PDU attached to the request. ... *//** This class implements the SnmpMibRequest interface. ... */this.reqPduthis.enginethis.principalthis.securityLevelthis.securityModelthis.contextNamethis.accessContextName// PUBLIC METHODS from SnmpMibRequest// See SnmpMibRequest for the java doc.// Implements the method defined in SnmpMibRequest interface.reqPdu.version// optimize the SET requests.// Passing this tree in the SnmpMibRequestImpl object allows to// in the check() method.// set() method will rebuild a new tree identical to the tree built// to the set() method. Note: the if the tree is `null', then the// Allow to pass the request tree built during the check() phasethis.tree// phase for two-phase SNMP requests (like SET).// Returns the SnmpRequestTree object built in the first operation// optimization).// Returns the underlying vector of SNMP varbinds (used for algorithmVector<SnmpVarBind> varbinds;// is OK).// the jdk1.1.x compiler complain (seems to be a compiler bug, jdk1.2// Ideally these variables should be declared final but it makes// Private variablesSnmpPdu reqPdu;SnmpRequestTree tree;// Non final variable.SnmpEngine engine;...[] accessContextName;/** This interface models an SNMP sub request to be performed on a specific ... */// import com.sun.jmx.snmp.SnmpIndex;/** Return the list of varbind to be handled by the SNMP MIB node. ... *//** Return the part of the OID identifying the table entry involved. ... *//** Indicate whether the entry involved is a new entry. ... *//** Return the varbind that holds the RowStatus variable. ... *//** This method should be called when a status exception needs to ... */import EnumRowStatusimport SnmpInt/** This class is the base class for SNMP table metadata. ... */new SnmpOid[]new Vector<Object>(...)new Vector<ObjectName>(...)new Hashtable<NotificationListener,Vector<Object>>(...)new Hashtable<NotificationListener,Vector<NotificationFilter>>(...)/** Create a new <CODE>SnmpMibTable</CODE> metadata node. ... */this.theMibsetCreationEnabled(...)/** This method is invoked when the creation of a new entry is requested ... *//** Tell whether the specific version of this metadata generated ... *//** Tell whether a new entry should be created when a SET operation ... *//** This method lets you dynamically switch the creation policy. ... *//** Return <code>true</code> if the conceptual row contains a columnar ... */boolean isnewisNewEntry(...)SnmpMibSubRequest rgetEntryOid(...)int actiongetRowAction(...)SnmpMibTable.classbeginRowAction(...)endRowAction(...)// public void addEntry(SnmpIndex index, Object entry)/** Add a new entry in this <CODE>SnmpMibTable</CODE>. ... *///                                      Object entry)// protected synchronized void addEntry(SnmpIndex index, ObjectName name,isRegistrationRequired(...)SnmpStatusException.badValueinsertOid(...)addEntryCb(...)removeOid(...)SnmpTableEntryNotification.SNMP_ENTRY_ADDEDgetTime(...)getInsertionPoint(...)/** Remove the specified entry from the table. ... */findObject(...)SnmpOid rowOidremoveEntryCb(...)SnmpTableEntryNotification.SNMP_ENTRY_REMOVED/** Get the entry corresponding to the specified rowOid. ... *//** Get the ObjectName of the entry corresponding to the ... *//** Return the entries stored in this table <CODE>SnmpMibTable</CODE>. ... *//** Get the size of the table. ... *//** Enable to add an SNMP entry listener to this ... *///------------// EVENT STUFFVector<Object> handbackListVector<NotificationFilter> filterListnew Vector<NotificationFilter>(...)/** Enable to remove an SNMP entry listener from this ... */Vector<?> handbackList/** Return a <CODE>NotificationInfo</CODE> object containing the ... */String[] typesMBeanNotificationInfo[] notifsInfonew MBeanNotificationInfo(...)/** Register the factory through which table entries should ... *//** Return true if the columnar object identified by <code>var</code> ... */// PROTECTED METHODS - RowStatus/** Return the RowStatus code value specified in this request. ... */SnmpVarBind vbgetRowStatusVarBind(...)hasRowStatus(...)EnumRowStatus.createAndGoEnumRowStatus.unspecifiedmapRowStatus(...)checkRowStatusFail(...)/** Map the value of the <code>vbstatus</code> varbind to the ... */SnmpValue rsvaluevbstatus.valueSnmpStatusException.snmpRspInconsistentValue/** Set the control variable to the specified <code>newStatus</code> ... *//** Tell whether the specified row is ready and can be put in the ... *//** Check whether the control variable of the given row can be ... *//** Check whether the specified row can be removed from the table. ... *//** Remove a table row upon a remote manager request. ... *//** This method takes care of initial RowStatus handling during the ... */EnumRowStatus.createAndWaitisCreationEnabled(...)createNewEntry(...)EnumRowStatus.destroycheckRemoveTableRow(...)EnumRowStatus.activeEnumRowStatus.notInServicecheckRowStatusChange(...)EnumRowStatus.notReady/** This method takes care of final RowStatus handling during the ... */SnmpValue valuesetRowStatus(...)isRowReady(...)removeTableRow(...)setRowStatusFail(...)vb.value/** Return the next OID arc corresponding to a readable columnar ... */// PROTECTED METHODS - get nextskipEntryVariable(...)getNextVarEntryId(...)/** Get the <CODE>SnmpOid</CODE> index of the row that follows ... */SnmpOid resOidSnmpOid last/** Return the first entry OID registered in the table. ... *//** This method is used internally and is implemented by the ... */// Abstract Protected Methods/** Get the <CODE>SnmpOid</CODE> index of the row that follows the ... */new SnmpEntryOid(...)getNextOid(...)// Register an exception when checking the RowStatus variableSnmpVarBind statusvbSnmpOid entryoidboolean hasEntryisCreationAllowed(...)validateVarEntryId(...)isSetRequest(...)isRowStatus(...)// largely inspired from the original getNext() method.// Implements the method defined in SnmpMibNode. The algorithm is verySnmpStatusException sefindNextAccessibleOid(...)long[] etableint elengthetable.lengthisReadableEntryId(...)/** Validate the specified OID. ... *//** Enable this <CODE>SnmpMibTable</CODE> to send a notification. ... */Enumeration<NotificationListener> kNotificationListener listenerEnumeration<NotificationFilter> fEnumeration<?> hObject handbackNotificationFilter filter/** This method is used by the SnmpMibTable to create and send a table ... */SnmpTableEntryNotification notifnew SnmpTableEntryNotification(...)/** Return true if the entry identified by the given OID index ... *//** Look for the given oid in the OID table (tableoids) and returns ... */SnmpOid pos/** Search the position at which the given oid should be inserted ... */int failStatusSnmpStatusException.snmpRspNotWritable/** Remove the OID located at the given position. ... */int l1/** Insert an OID at the given position. ... */SnmpOid[] oldeint l2int nodeId;/** The id of the contained entry object. ... */SnmpMib theMib;/** The MIB to which the metadata is linked. ... */boolean creationEnabled;/** <CODE>true</CODE> if remote creation of entries via SET operations ... */SnmpTableEntryFactory factory;/** The entry factory *//** The number of elements in the table. ... */int Delta;// private Vector oids= new Vector();//    private Vector indexes= new Vector();/** The list of indexes. ... */int tablecount;int tablesize;...[] tableoids;Vector<Object> entries;/** The list of entries. ... */Vector<ObjectName> entrynames;/** The list of object names. ... */Hashtable<NotificationListener,Vector<Object>> handbackTable;/** Listener hashtable containing the hand-back objects. */// final Vector callbacks = new Vector();/** Callback handlers */Hashtable<NotificationListener,Vector<NotificationFilter>> filterTable;/** Listener hashtable containing the filter objects. */long sequenceNumber;/** SNMP table sequence number. ... */// PACKAGE VARIABLES// each varbind involved (nb: should not happen, the error// should have been registered earlier)// SnmpIndex   index  = buildSnmpIndex(oid.longValue(false), 0);// get(req,index,depth+1);//            indexes.addElement(index);// XX oids.addElement(oid);// triggers callbacks on the entry factory// sends the notifications// Get the insertion position ...// bug jaw.00356.B : use oid rather than index to get the// insertion point.// Add a new element in the vectors ...// Insert new element ...//                indexes.insertElementAt(index, pos);// XX oids.insertElementAt(oid, pos);// looking for listener in handbackTable// Add the handback and the filter// If handback is null, remove the listener entry// Just a simple check to speed up retrieval of last element ...// XX SnmpOid last= (SnmpOid) oids.lastElement();// Last element of the table ...// First find the oid. This will allow to speed up retrieval process// during smart discovery of table (using the getNext) as the// management station will use the valid index returned during a// previous getNext ...// Returns the position following the position at which resOid// is found, or the position at which resOid should be inserted.// If the position returned is not out of bound, we will find// the next element in the array.// XX last = (SnmpOid) oids.elementAt(newPos);// We are dealing with the last element of the table ..// XX return (SnmpOid) oids.firstElement();// Construct the sub-oid starting at pos.// This sub-oid correspond to the oid part just after the entry// variable oid.// Checks that the oid is valid// validateOid(oid,depth);// Gets the part of the OID that identifies the entry// Finds the entry: false means that the entry does not exists// Fails if the entry is not found and the table does not// not support creation.// We know that the entry does not exists if (isentry == false).// we're not doing a set// we're doing a set but creation is disabled.// Validate the entry id// The entry already exists - validate the id// Registers this node for the identified entry.// We only try to identify the RowStatus for SET operations// If the querried oid contains less arcs than the OID of the// xxxEntry object, we must return the first leaf under the// first columnar object: the best way to do that is to reset// the queried oid://   oid[0] = nodeId (arc of the xxxEntry object)//   pos    = 0 (points to the arc of the xxxEntry object)// then we just have to proceed...// this will have the side effect to set//    oid[pos] = nodeId// and//    (pos+1) = length// so we won't fall into the "else if" cases below -// so using "else if" rather than "if ..." is guaranteed// to be safe.// oid[pos] is expected to be the id of the xxxEntry ...// The id requested is greater than the id of the xxxEntry,// so we won't find the next element in this table... (any// element in this table will have a smaller OID)// we must return the first leaf under the first columnar// object, so we are back to our first case where pos was// out of bounds... => reset the oid to contain only the// arc of the xxxEntry object.// The arc at the position "pos+1" is the id of the columnar// object (ie: the id of the variable in the table entry)// Now that we've got everything right we can begin.// pos points to the last arc in the oid, and this arc is// guaranteed to be the xxxEntry id (we have handled all// the other possibilities before)// We must therefore return the first leaf below the first// columnar object in the table.// Get the first index. If an exception is raised,// then it means that the table is empty. We thus do not// have to catch the exception - we let it propagate to// the caller.// In that case we have (pos+1) = (length-1), so pos// points to the arc of the querried variable (columnar object).// Since the requested oid stops there, it means we have// to return the first leaf under this columnar object.// So we first get the first index:// Note: if this raises an exception, this means that the table// is empty, so we can let the exception propagate to the caller.// XXX revisit: not exactly perfect://     a specific row could be empty.. But we don't know//     how to make the difference! => tradeoff holes//     in tables can't be properly supported (all rows//     must have the same holes)// So now there remain one last case, namely: some part of the// index is provided by the oid...// We build a possibly incomplete and invalid index from// the OID.// The piece of index provided should begin at pos+2//   oid[pos]   = id of the xxxEntry object,//   oid[pos+1] = id of the columnar object,//   oid[pos+2] ... oid[length-1] = piece of index.// We get the next index following the provided index.// If this raises an exception, then it means that we have// reached the last index in the table, and we must then// try with the next columnar object.// Bug fix 4269251// The SnmpIndex is defined to contain a valid oid:// this is not an SNMP requirement for the getNext request.// So we no more use the SnmpIndex but directly the SnmpOid.// If the variable must ne skipped, fall through...// Loop on each var (column)// This should not happen. If it happens, (bug, or customized// methods returning garbage instead of raising an exception),// it probably means that there is nothing to return anyway.// So we throw the exception.// => will skip to next node in the MIB tree.// So here we know both the row (entryoid) and the column (var)// Raising an exception here will make the catch() clause// switch to the next variable. If `var' is not readable// for this specific entry, it is not readable for any// other entry => skip to next column.// Prepare the result and the ACM checker.// Bug detector!// Copy the entryOid at the end of `result'// Set the node Id and var Id in result.// Append nodeId.varId.<rowOid> to ACM checker.// No we're going to ACM check our OID.// No exception thrown by checker => this is all OK!// we have it: register the handler and return the// result.// Skip to the next entry. If an exception is// thrown, will be catch by enclosing catch// and a skip is done to the next var.// Clean the checker.// Catching an exception here means we have to skip to the// next column.// Back to the first row.// Find out the next column.// No need to continue, we throw an exception.// Control the length of the oid// Check that the entry identifier is specified// loop on listener// Get the associated handback list and the associated filter list// loop on handback//System.out.println("Try to retrieve: " + oid.toString());// XX pos = (SnmpOid) oids.elementAt(curr);//System.out.println("Compare with" + pos.toString());// XX pos= (SnmpOid) oids.elementAt(curr);// Vector must be enlarged// Save old vector// Allocate larger vectors// Check pos validity// Copy original vector up to `pos'// Copy original vector from `pos' to end, leaving// an empty room at `pos' in the new vector.// Vector is large enough to accommodate one additional// entry.// Shift vector, making an empty room at `pos'// Fill the gap at `pos'/** This class is used to register varbinds from a SNMP varbind list with ... *///       => in that case, the key should be SnmpOid.toString()//  XXX: Maybe use hashlists rather than vectors for entries?//       evolutions.//  XXX: things to do: use SnmpOid rather than `instance' for future//         in SnmpDefinitions// @param  pdutype indicates the type of the request PDU as defined//         allows for entry creation (ie: it is a SET request).// @param  creationflag indicates whether the operation involved//         original positions will be lost.//         way to do this - since as a result of the segmentation the//         position of a varbind in the vector. There is no other easy//         varbind vector is used to retrieve the "real"//         by the SnmpSubRequestHandler to this MIB. This//         tree. It holds the original varbind vector passed// @param  req The SnmpMibRequest that will be segmented in this// Constructor:this.creationflagthis.hashtablenew Hashtable<Object,Handler>(...)int mappedErrorCodeSnmpStatusException.snmpRspWrongTypeSnmpStatusException.readOnlySnmpStatusException.snmpRspAuthorizationErrorSnmpRequestTree$Enum//-------------------------------------------------------------------// SnmSubRequest associated with an Handler node.// This class is a package implementation of the enumeration ofthis.hlistgetSubReqCount(...)Handler handler;SnmpRequestTree hlist;int entry;int iter;SnmpMibSubRequest resultgetSubRequest(...)handler.sublistSnmpRequestTree$SnmpMibSubRequestImpl// interface. It can only be instantiated by SnmpRequestTree.// This class is a package implementation of the SnmpMibSubRequestthis.globalthis.entryoidthis.isnewthis.getnextflagthis.statusvbSnmpMibRequest global;boolean isnew;SnmpOid entryoid;boolean getnextflag;SnmpVarBind statusvb;// -------------------------------------------------------------// See SnmpMibSubRequest for the java doc.// Implements the method defined in SnmpMibSubRequest interface.getVarIndex(...)SnmpDefinitions.snmpRspUndoFailedSnmpRequestTree$Handler//      of the SnmpMIbNode (when it is a table).//    o A vector of sublists concerning the entries (existing or not)//    o The sublist of varbind directly handled by this node//    o The SnmpMibNode involved (key)// It stores:// This class implements a node in the SnmpRequestTree.SnmpMibNode meta;// The meta  which handles the sublist.Vector<SnmpVarBind> sublist;// The depth of the meta node....[] entryoids;// List        isentrynew; // Sorted array of booleans// List        entrylists; // Sorted array of entry lists// List        entryoids;  // Sorted array of entry oids// The sublist of varbinds to be handled....[] entrylists;// Sorted array of entry oids...[] isentrynew;// Sorted array of entry lists...[] rowstatus;// Sorted array of booleansint entrycount;// RowStatus varbind, if anyint entrysize;// request PDU type as defined in SnmpDefinitions/** Adds a varbind in this node sublist. *//** register an entry for the given oid at the given position with ... */new Vector<?>[]Vector<>[] oldlboolean[] oldnSnmpVarBind[] oldrint l3Vector<SnmpVarBind> vSnmpVarBind rsfindOid(...)// through the SnmpUserDataFactory for this request.// Returns the contextual object containing user-data allocated// Public interface// to the operation involved (GET=>false/SET=>true)// Tells whether creation of new entries is allowed with respect// Tells whether we are currently processing a SET request (check/set)// evaluated.// Returns the protocol version in which the original request is// Returns the actual protocol version of the request PDU.// Returns the SnmpMibNode associated with the given handlerhandler.meta// SnmpMibNode associated with the given handler// Indicates the depth of the arc in the OID that identifies thehandler.depth// If it is a table, there will be one subrequest per entry involved.// If this node is a group, there will be a single subrequest.// the SnmpMibNode associated with a given Handler node.// returns an enumeration of the SnmpMibSubRequest's to be invoked onnew Enum(...)// returns an enumeration of the Handlers stored in the Hashtable.// adds a varbind to a handler node sublist// adds an entry varbind to a handler node sublist// varbind which holds the row status// adds an entry varbind to a handler node sublist - specifying the// Type of the request (see SnmpDefinitions)// Protected interface// We deal with a GET-NEXT request// Tell whether creation is allowed.// (in principle, only for Groups)// Returns the subrequest handled by the SnmpMibNode itselfnew SnmpMibSubRequestImpl(...)// the given entry (only for tables)// Returns the subrequest associated with the entry identified bygetEntryPos(...)getEntrySubList(...)// index relative to the position of the entry in the handler sublist.// the given entry (only for tables). The `entry' parameter is an// stores a handler node in the Hashtable// Private section// finds a handler node in the Hashtable// otherwise, returns the index at which the oid is located.// Search for the given oid in `oids'. If none is found, returns -1// `oids' array.// Return the index at which the given oid should be inserted in theSnmpOid[] localoids// adds a varbind in a handler node sublistSnmpRequestTree.classnew Handler(...)addVarbind(...)Hashtable<Object,Handler> hashtable;SnmpMibRequest request;// Hashtable of Handler objects// The original list of varbindsboolean creationflag;// The protocol version// creation of entries// Does the operation allowboolean setreqflag;// in SnmpDefinitions// Request PDU type as defined// Now take care of V2 errorCodes that can be stored// in the varbind itself:// noSuchObject => notWritable// noSuchInstance => notWritable// noSuchObject => noSuchObject// noSuchInstance => noSuchInstance// Now we're going to try to transform every other// global code in either noSuchInstance or noSuchObject,// so that the get can return a partial result.// Only noSuchInstance or noSuchObject can be stored// in the varbind itself.// According to RFC 1905: noAccess is emitted when the// the access is denied because it is not in the MIB view...// noAccess => noSuchInstance// According to RFC 1905: (my interpretation because it is not// really clear) The specified variable name exists - but the// variable does not exists and cannot be created under the// present circumstances (probably because the request specifies// another variable/value which is incompatible, or because the// value of some other variable in the MIB prevents the creation)// Note that this error should never be raised in a GET context// but who knows?// inconsistentName => noSuchInstance// All the errors comprised between snmpRspWrongType and// snmpRspInconsistentValue concern values: so we're going// to assume the OID was correct, and reply with noSuchInstance.// We're going to assume the OID was correct, and reply// with noSuchInstance.// For all other errors but genErr, we're going to reply with// noSuchObject// Only genErr will abort the GET and be returned as global// XXX not sure we must also add the varbind in the global//     request? or whether we should raise an exception://     in principle, this method should not be called!// The index in the exception must correspond to// the SNMP index ...// If we're doing a getnext ==> endOfMibView// Although the first pass of check() did not fail,// the set() phase could not be carried out correctly.// Since we don't know how to make an "undo", and some// assignation may already have been performed, we're going// to throw an snmpRspUndoFailed.// We throw the exception in order to abort the SET operation// in an atomic way.// We need this because of new Vector[n] instead of// new Vector<SnmpVarBind>[n], which is illegal.// Vectors are null: Allocate new vectors// Vectors must be enlarged// Save old vectors// Copy original vectors up to `pos'// Copy original vectors from `pos' to end, leaving// an empty room at `pos' in the new vectors.// Vectors are large enough to accommodate one additional// Shift vectors, making an empty room at `pos'//              entryoids = new ArrayList();//              entrylists = new ArrayList();//              isentrynew = new ArrayList();//              entryoids.add(entryoid);//              entrylists.add(v);//              isentrynew.add(new Boolean(isnew));// int pos = findOid(entryoids,entryoid);// int pos = findOid(entryoids,entrycount,entryoid);// if (pos == -1 || pos >= entryoids.size() ) {// if (pos == -1 || pos >= entrycount ) {// pos = getInsertionPoint(entryoids,entryoid);// pos = getInsertionPoint(entryoids,entrycount,entryoid);//                  entryoids.add(pos,entryoid);//                  entrylists.add(pos,v);//                  isentrynew.add(pos,new Boolean(isnew));//              } else v = (Vector) entrylists.get(pos);// } else v = entrylists[pos];// We do not include the status variable in the varbind,// because we're going to set it separately...//          if (entryoids != null) count += entryoids.size();// return findOid(entryoids,entryoid);// if (pos == -1 || pos >= entryoids.size() ) return null;// return (SnmpOid) entryoids.get(pos);// if (pos == -1 || pos >= entryoids.size() ) return false;// return ((Boolean)isentrynew.get(pos)).booleanValue();// if (pos == -1 || pos >= entrylists.size() ) return null;// return (Vector) entrylists.get(pos);// return entryoids.iterator();// return entryoids.size();// In the calling method we will have to check for this case...//    if (comp == 0)//       return -1;// Returning curr instead of -1 avoids having to call// findOid() first and getInsertionPoint() afterwards.// We can simply call getInsertionPoint() and then checks whether// there's an OID at the returned position which equals the// given OID.// retrieve the handler node associated with the given meta,// If no handler node was found for that meta, create one.//    debug("registerNode", "adding node for " +//          varbind.oid.toString());// else {//   if (isDebugOn())//      debug("registerNode","found node for " +//            varbind.oid.toString());// Adds the varbind in the handler node's sublist.// True if we're processing a// SET request (check/set)./** Returns the value of the scalar object identified by the given ... *//** Sets the value of the scalar object identified by the given ... *//** Checks that the new desired value of the scalar object identified ... */// SNMP Runtime importsimport SnmpMibTable/** This interface ensures the synchronization between Metadata table objects ... *//** This method is called by the SNMP runtime after a new entry ... */import SnmpMibSubRequest/** This interface is implemented by mibgen generated table objects ... *//** This method is called by the SNMP runtime whenever a new entry ... *//** Represents a notification emitted when an ... *//** Creates and initializes a table entry notification object. ... *//** Gets the entry object. ... *//** Gets the ObjectName of the entry. ... */String SNMP_ENTRY_ADDED;/** Notification type denoting that a new entry has been added to the ... */String SNMP_ENTRY_REMOVED;/** Notification type denoting that an entry has been removed from the ... */Object entry;/** The entry object. ... *//** The entry name. ... */// Ensure compatibility/** This class is an abstraction for an SNMP table. ... */List<Object> entries;/** The list of entries *///-----------------------------------------------------------------//  Protected Variables// end of NPCTE fix for bugId 4499265SnmpMibTable meta;/** The associated metadata object *//** The MIB to which this table belongs */boolean registrationRequired;/** This variable is initialized while binding this object to its ... *///  Private Variables/** Initializes the table. ... *///  ConstructorgetRegisteredTableMeta(...)bindWithTableMeta(...)allocateTable(...)/** Creates a new entry in the table. ... *///  Implementation of the SnmpTableEntryFactory interface// XXXX xxxx zzz ZZZZ => public? or protected?/** Returns the entry located at the given position in the table. ... *///  Public methods/** Returns the number of entries registered in the table. ... *//** Tells whether a new entry should be created when a SET operation ... *//** Tells whether the metadata object to which this table is linked ... *//** Builds an entry SnmpIndex from its row OID. ... */buildSnmpIndex(...)/** Builds an SnmpOid from an SnmpIndex object. ... *//** Builds the default ObjectName of an entry from the SnmpIndex ... *//** This callback is called by  the associated metadata object ... *//** Enables to add an SNMP entry listener to this ... *//** Enables to remove an SNMP entry listener from this ... *//** Returns a <CODE>NotificationInfo</CODE> object containing the ... *//** Builds an SnmpIndex object from the index part of an OID. ... *///  Protected Abstract methods/** Returns the metadata object associated with this table. ... *//** Allocates an ArrayList for storing table entries. ... *///  Protected methodsnew ArrayList<Object>(...)/** Add an entry in this table. ... */buildOidFromIndex(...)buildNameFromIndex(...)/** Remove an entry from this table. ... *//** Returns the entries in the table. ... *///  meta.removeEntry(name,entry);//  throws SnmpStatusException {// protected void removeEntry(ObjectName name, Object entry)/** Binds this table with its associated metadata, registering itself ... */registerEntryFactory(...)// NPCTE fix for bugId 4499265, esc 0, MR 04 sept 2001//  SnmpTableCallbackHandler {/** This interface is provided to enable fine customization of the SNMP ... *//** Called by the <CODE>SnmpAdaptorServer</CODE> adaptor. ... *//** The <CODE>ClientHandler</CODE> class is the base class of each ... */makeDebugTag(...)createThread(...)// thread serviceentering(...)exiting(...)InterruptedException xnotifyClientHandlerCreated(...)notifyClientHandlerDeleted(...)// The protocol-dependent part of the requestCommunicatorServer adaptorServer;boolean interruptCalled;String dbgTag;/* Copyright (c) 1999, 2006, Oracle and/or its affiliates. All rights reserved. ... */// jmx RI import//if (mbs == null ){//thread = new Thread (this) ;//} else {//thread = mbs.getThreadAllocatorSrvIf().obtainThread(objectName,this) ;// Note: the thread will be started by the subclass.// Notify the server we are now active// Call protocol specific sequence// Now notify the adaptor server that the handler is terminating.// This is important because the server may be blocked waiting for// a handler to terminate./** Represents exceptions raised due to communications problems, ... *//* Serial version *//** Constructs a CommunicationException with a target exception. *//** Constructs a CommunicationException with a target exception ... *//** Constructs a CommunicationException with a detail message. *//** Get the thrown target exception. */import AttributeChangeNotification/** Defines generic behavior for the server part of a connector or an adaptor. ... */new Vector<ClientHandler>(...)new NotificationBroadcasterSupport(...)int ONLINE;/** Represents an <CODE>ONLINE</CODE> state. */// States of a CommunicatorServerint OFFLINE;/** Represents an <CODE>OFFLINE</CODE> state. *//** Represents a <CODE>STOPPING</CODE> state. *//** Represents a <CODE>STARTING</CODE> state. */int SNMP_TYPE;/** Indicates that it is an SNMP connector type. *///public static final int HTML_TYPE = 3 ;/** Indicates that it is an HTML connector type. *///public static final int HTTP_TYPE = 2 ;/** Indicates that it is an HTTP connector type. *///public static final int RMI_TYPE = 1 ;/** Indicates that it is an RMI connector type. */// Types of connectors./** The state of the connector server. */// Package variables//public static final int HTTPS_TYPE = 5 ;/** Indicates that it is an HTTPS connector type. *//** The object name of the connector server. ... */MBeanServer topMBS;MBeanServer bottomMBS;int maxActiveClientCount;/** The maximum number of clients that the CommunicatorServer can ... */int servedClientCount;/** The host name used by this CommunicatorServer. ... *//** The port number used by this CommunicatorServer. ... */Object stateLock;/* This object controls access to the "state" and "interrupted" variables. ... */// Private fieldsVector<ClientHandler> clientHandlerVector;Thread mainThread;boolean stopRequested;boolean interrupted;Exception startException;long notifCount;// Notifs count, broadcaster and infoNotificationBroadcasterSupport notifBroadcaster;...[] notifInfos;/** Instantiates a <CODE>CommunicatorServer</CODE>. ... */makeThreadName(...)/** Starts this <CODE>CommunicatorServer</CODE>. ... */boolean startwaitState(...)changeState(...)createMainThread(...)waitForStart(...)/** Stops this <CODE>CommunicatorServer</CODE>. ... */terminateAllClient(...)/** Tests whether the <CODE>CommunicatorServer</CODE> is active. ... *//** <p>Waits until either the State attribute of this MBean equals the ... *//** <p>Waits until the communicator is started or timeout expires. ... */long startTimelong remainingTimenew CommunicationException(...)getStringForState(...)/** Gets the state of this <CODE>CommunicatorServer</CODE> as an integer. ... *//** Gets the state of this <CODE>CommunicatorServer</CODE> as a string. ... *//** Gets the host name used by this <CODE>CommunicatorServer</CODE>. ... *//** Gets the port number used by this <CODE>CommunicatorServer</CODE>. ... *//** Sets the port number used by this <CODE>CommunicatorServer</CODE>. ... *//** Gets the protocol being used by this <CODE>CommunicatorServer</CODE>. ... *//** Gets the number of clients that have been processed by this ... *//** Gets the number of clients currently being processed by this ... *//** Gets the maximum number of clients that this ... *//** Sets the maximum number of clients this ... *//** The number of times the communicator server will attempt ... *//** The delay, in ms, during which the communicator server will sleep before ... *//** For SNMP Runtime internal use only. ... */int bindRetriesgetBindTries(...)long sleepTimegetBindSleepTime(...)CommunicationException cedoError(...)doReceive(...)waitIfTooManyClients(...)doProcess(...)waitClientTermination(...)// and run() ends up.// If doBind() throws an exception, doUnbind() is not to be called// doBind() should do all what is needed before calling doReceive().// run() that the connector must be switch OFFLINE.// All these methods should propagate the InterruptedException to inform//       Debug.printException().// If it is a CommunicationException, run() will call// will end up the run() method and switch the connector offline.// If the method sends an exception (Communication or Interrupt), this// Each method below is called by run() and must be subclassed.// To be defined by the subclass./** <CODE>doReceive()</CODE> should block until a client is available. ... *//** <CODE>doProcess()</CODE> is called after <CODE>doReceive()</CODE>: ... *//** <CODE>doUnbind()</CODE> is called whenever the connector goes ... *//** Get the <code>MBeanServer</code> object to which incoming requests are ... *//** Set the <code>MBeanServer</code> object to which incoming ... */String errorVector<MBeanServer> seenMBSnew Vector<MBeanServer>(...)/** For internal use only. */// To be called by the subclass if neededint oldStatesendStateChangeNotification(...)/** Returns the string used in debug traces. *//** Returns the string used to name the connector thread. *//** This method blocks if there are too many active clients. ... */getActiveClientCount(...)/** This method blocks until there is no more active client. */NoSuchElementException x/** Call <CODE>interrupt()</CODE> on each pending client. */ClientHandler[] handlersnew ClientHandler[]ClientHandler h/** Controls the way the CommunicatorServer service is deserialized. */defaultReadObject(...)/** Adds a listener for the notifications emitted by this ... */// NotificationBroadcaster/** Removes the specified listener from this CommunicatorServer. ... *//** Returns an array of MBeanNotificationInfo objects describing ... */String[] notifTypesAttributeChangeNotification.ATTRIBUTE_CHANGEAttributeChangeNotification.classString oldStateStringString newStateStringAttributeChangeNotification notifnew AttributeChangeNotification(...)/** Preregister method of connector. ... */// MBeanRegistration/** Stop the connector. ... */int cstate/** Do nothing. */// JSR 160 import// XXX Revisit://   used to import com.sun.jmx.snmp.MBeanServerForwarder// Now using JSR 160 instead. => this is an additional// dependency to JSR 160.//No op. int Type deciding debugging removed.// Fix for bug 4352451://     "java.net.BindException: Address in use".// cannot happen because of `0'// Stop the connector thread// Call terminate on each active client handler// ----------------------// changeState// timeOut == 0// Time elapsed since startTime...// wait for timeout - elapsed.// A timeout of Long.MAX_VALUE is equivalent to something// like 292271023 years - which is pretty close to// forever as far as we are concerned ;-)// If remainingTime is negative, the timeout has elapsed.// We're going to wait until someone notifies on the// the stateLock object, or until the timeout expires,// or until the thread is interrupted.// If we are now ONLINE, then no need to rethrow the// exception... we're simply going to exit the while// loop. Otherwise, throw the InterruptedException.// We're no longer in STARTING state// OK, we're started, everything went fine, just return// There was some exception during the starting phase.// Cast and throw...// Wrap and throw...// We're not ONLINE, and there's no exception...// Something went wrong but we don't know what...// Fix jaw.00667.B// It seems that the init of "i" and "success"// need to be done outside the "try" clause...// A bug in Java 2 production release ?// Bind// Fix for bug 4352451: "java.net.BindException: Address in use".// Try socket connection.// Retry last time to get correct exception.// State change// unBind// The ClientHandler will remove themselves from the// clientHandlerVector at the end of their run() method, by// calling notifyClientHandlerDeleted().// Since the clientHandlerVector is modified by the ClientHandler// threads we must avoid using Enumeration or Iterator to loop// over this array. We must also take care of NoSuchElementException// which could be thrown if the last ClientHandler removes itself// between the call to clientHandlerVector.isEmpty() and the call// to clientHandlerVector.firstElement().// What we *MUST NOT DO* is locking the clientHandlerVector, because// this would most probably cause a deadlock.// over this array.// We cannot use the same logic here than in waitClientTermination()// because there is no guarantee that calling interrupt() on the// ClientHandler will actually terminate the ClientHandler.// Since we do not want to wait for the actual ClientHandler// termination, we cannot simply loop over the array until it is// empty (this might result in calling interrupt() endlessly on// the same client handler. So what we do is simply take a snapshot// copy of the vector and loop over the copy.// Call the default deserialization of the object.// Call the specific initialization for the CommunicatorServer service.// This is for transient structures to be initialized to specific// default values.// Initialize notifInfos on first call to getNotificationInfo()// source// sequence number// time stamp// message// attribute name// attribute type// old value// new value/** Defines generic behaviour for the server ... *//** Tests if the <CODE>CommunicatorServer</CODE> is active. ... *//** Waits untill either the State attribute of this MBean equals the specified <VAR>state</VAR> parameter, ... */import DatagramSocketimport DatagramPacketimport SnmpIpAddressimport SnmpPduRequestimport SnmpPduTrapimport SnmpTimeticksimport SnmpVarBindListimport SnmpPeerimport SnmpParametersimport SnmpPduFactoryBERimport SnmpMibAgentimport SnmpMibHandlerimport SnmpUserDataFactoryimport SnmpErrorHandlerAgentimport SnmpAclimport ThreadService/** Implements an adaptor on top of the SNMP protocol. ... */new Vector<SnmpMibAgent>(...)SnmpAdaptorServer.classint trapPort;/** Port number for sending SNMP traps. ... */int informPort;/** Port number for sending SNMP inform requests. ... *//** The <CODE>InetAddress</CODE> used when creating the datagram socket. ... */InetAddressAcl ipacl;/** The IP address based ACL used by this SNMP protocol adaptor. *//** The factory object. */SnmpUserDataFactory userDataFactory;/** The user-data factory object. */boolean authRespEnabled;/** Indicates if the SNMP protocol adaptor sends a response in case ... */boolean authTrapEnabled;/** Indicates if authentication traps are enabled. */SnmpOid enterpriseOid;/** The enterprise OID. ... */int bufferSize;/** The buffer size of the SNMP protocol adaptor. ... */long startUpTime;DatagramSocket socket;DatagramSocket trapSocket;SnmpSession informSession;DatagramPacket packet;Vector<SnmpMibAgent> mibs;SnmpMibTree root;boolean useAcl;/** Whether ACL must be used. *//** Number of times to try an inform request before giving up. ... *///---------------------------// SENDING SNMP INFORMS STUFF/** The amount of time to wait for an inform response from the manager. ... */int snmpOutTraps;/** The <CODE>snmpOutTraps</CODE> value defined in MIB-II. *///-------------------------------------------------------// VARIABLES REQUIRED FOR IMPLEMENTING SNMP GROUP (MIBII)int snmpOutGetResponses;/** The <CODE>snmpOutGetResponses</CODE> value defined in MIB-II. */int snmpOutGenErrs;/** The <CODE>snmpOutGenErrs</CODE> value defined in MIB-II. */int snmpOutBadValues;/** The <CODE>snmpOutBadValues</CODE> value defined in MIB-II. */int snmpOutNoSuchNames;/** The <CODE>snmpOutNoSuchNames</CODE> value defined in MIB-II. */int snmpOutTooBigs;/** The <CODE>snmpOutTooBigs</CODE> value defined in MIB-II. */int snmpOutPkts;/** The <CODE>snmpOutPkts</CODE> value defined in MIB-II. */int snmpInASNParseErrs;/** The <CODE>snmpInASNParseErrs</CODE> value defined in MIB-II. */int snmpInBadCommunityUses;/** The <CODE>snmpInBadCommunityUses</CODE> value defined in MIB-II. */int snmpInBadCommunityNames;/** The <CODE>snmpInBadCommunityNames</CODE> value defined in MIB-II. */int snmpInBadVersions;/** The <CODE>snmpInBadVersions</CODE> value defined in MIB-II. */int snmpInGetRequests;/** The <CODE>snmpInGetRequests</CODE> value defined in MIB-II. */int snmpInGetNexts;/** The <CODE>snmpInGetNexts</CODE> value defined in MIB-II. */int snmpInSetRequests;/** The <CODE>snmpInSetRequests</CODE> value defined in MIB-II. */int snmpInPkts;/** The <CODE>snmpInPkts</CODE> value defined in MIB-II. */int snmpInTotalReqVars;/** The <CODE>snmpInTotalReqVars</CODE> value defined in MIB-II. */int snmpInTotalSetVars;/** The <CODE>snmpInTotalSetVars</CODE> value defined in MIB-II. */int snmpSilentDrops;/** The <CODE>snmpInTotalSetVars</CODE> value defined in rfc 1907 MIB-II. */String InterruptSysCallMsg;SnmpOid sysUpTimeOid;SnmpOid snmpTrapOidOid;ThreadService threadService;int threadNumber;/** Initializes this SNMP protocol adaptor using the default port (161). ... */// PUBLIC CONSTRUCTORSServiceName.SNMP_ADAPTOR_PORT/** Initializes this SNMP protocol adaptor using the specified port. ... *//** Initializes this SNMP protocol adaptor using the default port (161) ... *//** Initializes this SNMP protocol adaptor using the specified port and the ... *//** Initializes this SNMP protocol adaptor using the specified IP ... *//** Initializes this SNMP protocol adaptor using the specified port, the ... */// SnmpAcl object is created.// If forceAcl is `true' and InetAddressAcl is null, then a defaultCommunicatorServer.SNMP_TYPEnew SnmpAcl(...)this.useAcl/** Gets the number of managers that have been processed by this ... */getServedClientCount(...)/** Gets the number of managers currently being processed by this ... *//** Gets the maximum number of managers that this SNMP protocol adaptor can ... */getMaxActiveClientCount(...)/** Sets the maximum number of managers this SNMP protocol adaptor can ... */setMaxActiveClientCount(...)/** Returns the Ip address based ACL used by this SNMP protocol adaptor. ... *//** Returns the port used by this SNMP protocol adaptor for sending traps. ... *//** Sets the port used by this SNMP protocol adaptor for sending traps. ... */setTrapPort(...)/** Returns the port used by this SNMP protocol adaptor for sending ... *//** Sets the port used by this SNMP protocol adaptor for sending ... *//** Returns the protocol of this SNMP protocol adaptor. ... *//** Returns the buffer size of this SNMP protocol adaptor. ... *//** Sets the buffer size of this SNMP protocol adaptor. ... *//** Gets the number of times to try sending an inform request before ... *//** Changes the maximun number of times to try sending an inform ... *//** Gets the timeout to wait for an inform response from the manager. ... *//** Changes the timeout to wait for an inform response from the manager. ... *//** Returns the message factory of this SNMP protocol adaptor. ... *//** Sets the message factory of this SNMP protocol adaptor. ... *//** Set the user-data factory of this SNMP protocol adaptor. ... *//** Get the user-data factory associated with this SNMP protocol adaptor. ... *//** Returns <CODE>true</CODE> if authentication traps are enabled. ... *//** Sets the flag indicating if traps need to be sent in case of ... *//** Returns <code>true</code> if this SNMP protocol adaptor sends a ... *//** Sets the flag indicating if responses need to be sent in case of ... *//** Returns the enterprise OID. It is used by ... *//** Sets the enterprise OID. ... *//** Returns the names of the MIBs available in this SNMP protocol adaptor. ... */Enumeration<SnmpMibAgent> eSnmpMibAgent mibgetMibName(...)/** Returns the <CODE>snmpOutTraps</CODE> value defined in MIB-II. ... *///-------------------------------// GETTERS FOR SNMP GROUP (MIBII)/** Returns the <CODE>snmpOutGetResponses</CODE> value defined in MIB-II. ... *//** Returns the <CODE>snmpOutGenErrs</CODE> value defined in MIB-II. ... *//** Returns the <CODE>snmpOutBadValues</CODE> value defined in MIB-II. ... *//** Returns the <CODE>snmpOutNoSuchNames</CODE> value defined in MIB-II. ... *//** Returns the <CODE>snmpOutTooBigs</CODE> value defined in MIB-II. ... *//** Returns the <CODE>snmpInASNParseErrs</CODE> value defined in MIB-II. ... *//** Returns the <CODE>snmpInBadCommunityUses</CODE> value defined in MIB-II. ... *//** Returns the <CODE>snmpInBadCommunityNames</CODE> value defined in ... *//** Returns the <CODE>snmpInBadVersions</CODE> value defined in MIB-II. ... *//** Returns the <CODE>snmpOutPkts</CODE> value defined in MIB-II. ... *//** Returns the <CODE>snmpInPkts</CODE> value defined in MIB-II. ... *//** Returns the <CODE>snmpInGetRequests</CODE> value defined in MIB-II. ... *//** Returns the <CODE>snmpInGetNexts</CODE> value defined in MIB-II. ... *//** Returns the <CODE>snmpInSetRequests</CODE> value defined in MIB-II. ... *//** Returns the <CODE>snmpInTotalSetVars</CODE> value defined in MIB-II. ... *//** Returns the <CODE>snmpInTotalReqVars</CODE> value defined in MIB-II. ... *//** Returns the <CODE>snmpSilentDrops</CODE> value defined in RFC ... *//** Returns the <CODE>snmpProxyDrops</CODE> value defined in RFC ... *//** Allows the MBean to perform any operations it needs before being ... */ServiceName.SNMP_ADAPTOR_SERVERoids.length/** Adds a new MIB in the SNMP MIB handler. In SNMP V1 and V2 the ... *//** Creates the datagram socket. *///-----------------------------------// SUBCLASSING OF COMMUNICATOR SERVERnew DatagramSocket(...)SocketException e/** Return the actual port to which the adaptor is bound. ... *//** Closes the datagram socket. */closeTrapSocketIfNeeded(...)closeInformSocketIfNeeded(...)SnmpRequestHandler handlernew SnmpRequestHandler(...)submitTask(...)/** Reads a packet from the datagram socket and creates a request ... */new DatagramPacket(...)receive(...)createSnmpRequestHandler(...)InterruptedIOException eCommunicationException e/** Stops this SNMP protocol adaptor. ... */DatagramSocket snbyte[] obDatagramPacket pksend(...)/** Sends a trap using SNMP V1 trap format. ... *///-------------------------// SENDING SNMP TRAPS STUFFSnmpPduTrap pdupdu.enterprisepdu.genericTrappdu.specificTrappdu.timeStampgetSysUpTime(...)pdu.agentAddrhandleMultipleIpVersion(...)byte[] zeroedAddrsendTrapPdu(...)snmpV1Trap(...)SnmpParameters pgetParams(...)getRdCommunity(...)InetAddress inetAddr/** Sends a trap using SNMP V2 trap format. ... */snmpV2Trap(...)SnmpPduRequest pduSnmpVarBindList fullVblSnmpTimeticks sysUpTimeValue/** Send the specified trap PDU to the passed <CODE>InetAddress</CODE>. ... *//** Send the specified trap PDU to the passed <CODE>SnmpPeer</CODE>. ... */getTrapPort(...)/** Send the specified trap PDU to every destinations from the ACL file. */SnmpMessage msgint sendingCountSnmpDefinitions.snmpRspAuthorizationErrorSnmpTooBigException xSnmpDefinitions.snmpRspTooBigopenTrapSocketIfNeeded(...)Enumeration<InetAddress> edgetTrapDestinations(...)Enumeration<String> ecgetTrapCommunities(...)msg.addressmsg.communitysendTrapMessage(...)/** Send the specified trap PDU to the specified destination. *//** Send the specified message on trapSocket. */DatagramPacket packetencodeMessage(...)setAddress(...)msg.port/** Open trapSocket if it's not already done. *//** Close trapSocket if the SNMP protocol adaptor is not ONLINE. *//** Sends an inform using SNMP V2 inform request format. ... */Vector<SnmpInformRequest> informReqListnew Vector<SnmpInformRequest>(...)String csopenInformSocketIfNeeded(...)getInformDestinations(...)getInformCommunities(...)makeAsyncRequest(...)getInformPort(...)snmpInformRequest(...)getInformCommunity(...)/** Method that maps an SNMP error status in the passed protocolVersion ... */mapErrorStatus(...)/** Open informSocket if it's not already done. */new SnmpSession(...)/** Close informSocket if the SNMP protocol adaptor is not ONLINE. */destroySession(...)/** Gets the IP address to bind. ... *//** Finalizer of the SNMP protocol adaptor objects. ... *//** Returns the time (in hundreths of second) elapsed since the SNMP ... *//** Control the way the SnmpAdaptorServer service is deserialized. *//** Common initializations. */new SnmpMibTree(...)setDefaultAgent(...)new SnmpErrorHandlerAgent(...)new ThreadService(...)getAgentMib(...)// Initialize the ACL implementation.//If null oid array, just add it to the mib.// Important to inform finalize() that the socket is closed...// Let's wait for something to be received.// Let's check if we have been interrupted by stop().// First, make an SNMP V1 trap pdu// If the local host cannot be determined, we put 0.0.0.0 in agentAddr// Next, send the pdu to all destinations defined in ACL// Next, send the pdu to the specified destination//Diff start//Diff end// Diff start// If the local host cannot be determined,// we put 0.0.0.0 in agentAddr//End diff// First, make an SNMP V2 trap pdu// We clone varBindList and insert sysUpTime and snmpTrapOid// Only difference with other//End of diff// Make an SNMP message from the pdu// FIXME: is the right exception to throw ?// We could simply forward SnmpTooBigException ?// Now send the SNMP message to each destination// If there is no destination defined or if everything has failed// we tried to send the trap to the local host (as suggested by// mister Olivier Reisacher).// Now send the SNMP message to specified destination// First, make an SNMP inform pdu:// We clone varBindList and insert sysUpTime and snmpTrapOid variables.// Call the specific initialization for the SnmpAdaptorServer service.// The default Agent is initialized with a SnmpErrorHandlerAgent agent.// For the trap time, use the time the agent started ...// Create the default message factory/** Exposes the remote management interface of the {@link SnmpAdaptorServer} MBean. ... *//** Returns the port used by this SNMP protocol adaptor for sending inform requests. ... *//** Sets the port used by this SNMP protocol adaptor for sending inform requests. ... *//** Gets the number of managers that have been processed by this SNMP protocol adaptor ... *//** Gets the number of times to try sending an inform request before giving up. ... *//** Changes the maximun number of times to try sending an inform request before giving up. ... *//** Sets the flag indicating if traps need to be sent in case of authentication failure. ... *//** Returns <code>true</code> if this SNMP protocol adaptor sends a response in case ... *//** Sets the flag indicating if responses need to be sent in case of authentication failure. ... *//** Returns the enterprise OID. It is used by {@link #snmpV1Trap snmpV1Trap} to fill ... *//** Returns the <CODE>snmpInBadCommunityNames</CODE> value defined in MIB-II. ... *//** Returns the <CODE>snmpSilentDrops</CODE> value defined in rfc 1907 NMPv2-MIB . ... *//** Returns the <CODE>snmpProxyDrops</CODE> value defined in rfc 1907 NMPv2-MIB . ... *//** Provides the callback methods that are required to be implemented by the application ... *//** This callback is invoked when a manager responds to an SNMP inform request. ... *//** This callback is invoked when a manager does not respond within the ... *//** This callback is invoked when any form of internal error occurs. ... */// JMX imports/** This class is used by the {@link com.sun.jmx.snmp.daemon.SnmpAdaptorServer SNMP adaptor server} to send inform requests ... */new SnmpRequestCounter(...)SnmpRequestCounter requestCounter;/** This object maintains a global counter for the inform request ID. */SnmpVarBindList varBindList;/** This contains a list of <CODE>SnmpVarBind</CODE> objects for making the SNMP inform requests. *//** The error status associated with the inform response packet. *//** The index in <CODE>SnmpVarBindList</CODE> that caused the exception. */...[] internalVarBind;//private SnmpVarBind internalVarBind[] = null;//private String reason = null;SnmpAdaptorServer adaptor;/** The SNMP adaptor associated with this inform request. *//** The session object associated with this inform request. */SnmpInformHandler callback;/** The user implementation of the callback interface for this request. */SnmpPdu requestPdu;//private SnmpPduPacket requestPdu;/** The inform request PDU. */SnmpPduRequestType responsePdu;//private SnmpPduRequest responsePdu;/** The inform response PDU. */int stBase;/** Base status of an inform request. */int stInProgress;/** Status of an inform request: in progress. */int stWaitingToSend;/** Status of an inform request: waiting to be sent. */int stWaitingForReply;/** Status of an inform request: waiting for reply. */int stReceivedReply;/** Status of an inform request: reply received. */int stAborted;/** Status of an inform request: request aborted. */int stTimeout;/** Status of an inform request: timeout. */int stInternalError;/** Status of an inform request: internal error occured. */int stResultsAvailable;/** Status of an inform request: result available for the request. */int stNeverUsed;/** Status of an inform request: request never used. */int numTries;/** Number of tries performed for the current polling operation. *//** Timeout. ... */int reqState;// 3 seconds.long prevPollTime;// Polling control parameters.long nextPollTime;// value of 0 means poll never happened.long waitTimeForResponse;Date debugDate;/** The request ID for an active inform request. */addInformRequest(...)setTimeout(...)getTimeout(...)/** Gets the request id (invoke identifier) of the current inform request. ... *//** Gets the destination address of the current inform request. ... *//** Gets the current status of the inform request. ... *//** Indicates whether or not the inform request was aborted. ... *//** Indicates whether or not the inform request is in progress. ... *//** Indicates whether or not the inform request result is available. ... *//** Gets the status associated with the <CODE>SnmpVarBindList</CODE>. ... *//** Gets the index. ... *//** Gets the maximum number of tries before declaring that the manager is not responding. ... */getMaxTries(...)/** Gets the number of tries performed for the current inform request. ... *//** Gets absolute time in milliseconds (based on epoch time) when the next ... *//** Gets absolute time in milliseconds (based on epoch time) before which an inform ... *//** Gets the <CODE>SnmpVarBindList</CODE> of the inform response. ... */inProgress(...)/** Used in synchronous mode only. ... */thisSessionContext(...)SnmpInformHandler savedCallback/** Cancels the active inform request and removes itself from the polling list. */stopRequest(...)deleteRequest(...)notifyClient(...)/** Notifies the registered client about the completion of an operation. *//** Finalizer of the <CODE>SnmpInformRequest</CODE> objects. ... *//** Returns the <CODE>String</CODE> representation of an error code. ... *///----------------------------// PRIVATE AND PACKAGE METHODSinitializeAndFire(...)startRequest(...)setErrorStatusAndIndex(...)/** This method submits the inform request for polling and marks the request ... */schedulePoll(...)/** This method creates a new request ID. The ID is submitted to the poll server for scheduling. */initNewRequest(...)setRequestStatus(...)addRequest(...)getSnmpQManager(...)/** This method determines whether the inform request is to be retried. This is used if the ... */invokeOnReady(...)invokeOnRetry(...)invokeOnTimeout(...)OutOfMemoryError omerrSnmpInformRequest.classyield(...)constructPduPacket(...)sendPdu(...)queueResponse(...)addResponse(...)/** Constructs an inform request PDU. */SnmpPduPacket reqpduException excepreqpdu.portreqpdu.typereqpdu.versionreqpdu.communityreqpdu.requestIdreqpdu.varBindListSnmpPduFactory pduFactorygetPduFactory(...)int maxPktSizebyte[] encodingsendPduPacket(...)SnmpTooBigException argetVarBindCount(...)/** Sends the prepared PDU packet to the manager and updates the data structure ... */SnmpSocket theSocketsendPacket(...)setRequestSentTime(...)handleInternalError(...)parsePduPacket(...)handleSuccess(...)handleTimeout(...)handleError(...)/** Parses the inform response packet. If the agent responds with error set, ... */updateInternalVarBindWithResult(...)(...).varBindList/** Calls the user implementation of the <CODE>SnmpInformHandler</CODE> interface. */processSnmpPollData(...)getVarBindList(...)OutOfMemoryError omesnmpErrorToString(...)processSnmpPollTimeout(...)processSnmpInternalError(...)internalVarBind.lengthSnmpVarBind res/** This method cancels an active inform request and removes it from the polling list. */removeRequest(...)removeInformRequest(...)setPrevPollTime(...)addWaiting(...)/** Initializes the request id from the request counter. */getNewId(...)/** Returns the string state corresponding to the specified integer state. ... *//** Sets the request status to the specified value. ... *//** Gives a status report of the request. ... */tostring(...)statusDescription(...)setTime(...)timeRemainingForAction(...)// JAVA imports// add to adaptor queue.// should never happen.// check if request is in progress.// We can manipulate callback safely as we are in session thread.// This is being done from a different thread. So notifyClient will do the notification.// true if request completed.// Consider it as a try !// This exception will caught hereafter and reported as an snmpReqUnknownError// FIXME: may be it's not the best behaviour ?// check if this request is still alive.// the request may have  cancelled.//responsePdu = null;// At this point the errorIndex is rationalized to start with 0.// Refire request after fixing varbindlist.// rationalize for index to start with 0.// delete only non-poll request.// catch all user exception which may happen in callback.// catch any exception a user might not handle.// Remove the clause synchronized of the stopRequest method.// Synchronization is isolated as possible to avoid thread lock.// Note: the method removeRequest from SendQ is synchronized.// fix bug jaw.00392.B/** The class is used for building a tree representation of the different ... */new TreeNode(...)root.agentTreeNode noderetrieveMatchingBranch(...)removeAgent(...)removeAgentFully(...)/* public void unregister(SnmpMibAgent agent) { ... */printTree(...)SnmpMibAgent defaultAgent;TreeNode root;SnmpMibTree$TreeNode// A SnmpMibTree object is a tree of TreeNodenew Vector<TreeNode>(...)retrieveChild(...)TreeNode nn.agentStringBuilder buffEnumeration<TreeNode> e/** Only the treeNode class can create an instance of treeNode. ... */// PRIVATE STUFFthis.nodeValueVector<TreeNode> vnode.agentsthis.agentTreeNode childlong theValuesetAgent(...)match(...)Vector<TreeNode> children;Vector<SnmpMibAgent> agents;long nodeValue;SnmpMibAgent agent;TreeNode parent;// In this case, the node does not have any children. So no point to// continue the search ...// In this case, the oid does not have any more element. So the search// is over.//If the returned node got a null agent, we have to replace it by//the current one (in case it is not null)//That's it !// Create a child and register it !// We have to set the agent attribute// end of class TreeNode/** This class implements a server queue manager. ... */SendQ newq;WaitQ waitq;ThreadGroup queueThreadGroup;Thread requestQThread;Thread timerQThread;new SendQ(...)new WaitQ(...)startQThreads(...)isAlive(...)new SnmpTimerServer(...)new SnmpSendServer(...)(...).isBeingDestroyedwaitq.isBeingDestroyednewq.isBeingDestroyedstopTimerServer(...)stopSendServer(...)getAllOutstandingRequest(...)getTimeoutRequests(...)SnmpInformRequest reqc/** This vector manages the inform requests to be sent to the manager. */long nextPollgetAbsNextPollTime(...)getRequestAt(...)notifyClients(...)long tmplong currTimeSnmpInformRequest reqlastElement(...)waitOnThisQueue(...)Vector<SnmpInformRequest> outreqwaitUntilReady(...)long refTimeSnmpQManager.classboolean isBeingDestroyed;// is being destroyed.// This boolean is used to stop handling requests while the corresponding SnmpQManager/** This vector manages the inform requests to be retried to the manager. */getAbsMaxTimeToWait(...)// TIME BOMB HERE// no serialVersionUID but never serialized// no serialVersionUID, but never serialized/** A static instance of this class is usually created.  It contains a ... */int reqid;/** A counter with value between 1...2^31-1. *//** Returns the next request identifier. ... */import SnmpPduBulkimport SnmpDataTypeEnumsHashtable<SnmpMibAgent,SnmpSubRequestHandler> subs;/** Contains the list of sub-requests associated to the current request. *//** Reference on the MIBS *//** Full constructor */new Hashtable<SnmpMibAgent,SnmpSubRequestHandler>(...)/** Treat the request available in 'packet' and send the result ... */DatagramPacket respPacketmakeResponsePacket(...)/** Here we make a response packet from a request packet. ... */SnmpMessage reqMsgSnmpMessage respMsgdecodeMessage(...)reqMsg.addressreqMsg.portincSnmpInASNParseErrs(...)makeResponseMessage(...)newTooBigMessage(...)SnmpTooBigException xxincSnmpSilentDrops(...)/** Here we make a response message from a request message. ... */SnmpPduPacket reqPduObject userDataSnmpPduPacket respPduallocateUserData(...)SnmpAdaptorServer snmpServerSnmpDefinitions.snmpWrongSnmpVersionincSnmpInBadVersions(...)makeResponsePdu(...)releaseUserData(...)int oldreduceResponsePdu(...)SnmpStatusException xxnewTooBigPdu(...)SnmpTooBigException xxxException xxxException xx/** Here we make a response pdu from a request pdu. ... */updateRequestCounters(...)reqPdu.typereqPdu.varBindListupdateVarCounters(...)reqPdu.varBindList.lengthcheckPduType(...)checkAcl(...)makeNoMibErrorPdu(...)SnmpPduPacket.pduGetRequestPduSnmpPduPacket.pduGetNextRequestPduSnmpPduPacket.pduSetRequestPdumakeGetSetResponsePdu(...)SnmpPduPacket.pduGetBulkRequestPdumakeGetBulkResponsePdu(...)getAuthRespEnabled(...)getAuthTrapEnabled(...)SnmpPduTrap.trapAuthenticationFailure//        <li>SnmpDataTypeEnums.errNoSuchInstanceTag</li>//        <li>SnmpDataTypeEnums.errNoSuchObjectTag</li>//        <li>SnmpDataTypeEnums.errEndOfMibViewTag</li>// @param statusTag should be one of:// according to the value of <code>status</code>// varbindlist with one of endOfMibView, noSuchObject, noSuchInstance// Generates a response packet, filling the values in theSnmpVarBind[] vblistreq.varBindListvblist.lengthnewErrorResponsePdu(...)newValidResponsePdu(...)// </ul>//          response PDU</li>//     <li>If the request is a SET, generates a NoAccess error V2//         list with EndOfMibView's</li>//     <li>If the request is a GET-NEXT/GET-BULK, fills the varbind//         NoSuchObject's</li>// <ul><li>If the request is a GET, fills the varbind list with// <li>If the version is V2:</li>// <ul><li>Generates a NoSuchName error V1 response PDU</li></ul>// <li>If the version is V1:</li>// the adaptor.// Generates an appropriate response when no mib is registered inreq.versionreq.typemakeErrorVarbindPdu(...)/** Here we make the response pdu from a get/set request pdu. ... */int nbSubRequestSnmpPduPacket resultexecuteSubRequest(...)splitRequest(...)turboProcessingGetSet(...)req.requestIdmergeResponses(...)/** The method runs all the sub-requests associated to the current ... */int errorStatusEnumeration<SnmpSubRequestHandler> eSnmpSubRequestHandler subsetUserData(...)sub.type/** Optimize when there is only one sub request */int realIndex/** Here we make the response pdu for a bulk request. ... */SnmpVarBind[] respVarBindListreq.varBindList.lengthreq.nonRepeatersreq.maxRepetitionsint m2int trespVarBindList.lengthsplitBulkRequest(...)mergeBulkResponses(...)SnmpVarBind[] truncatedList/** Check the type of the pdu: only the get/set/bulk request ... */SnmpDefinitions.pduGetBulkRequestPdu/** Check if the specified pdu is conform to the ACL. ... */SnmpPduPacket responseString communitycheckWritePermission(...)int errcheckReadPermission(...)updateErrorCounters(...)incSnmpInBadCommunityUses(...)incSnmpInBadCommunityNames(...)/** Make a response pdu with the specified error status and index. ... */reqPdu.addressreqPdu.portreqPdu.communitySnmpPduRequest.pduGetResponsePduresult.varBindListint vbCountresp.varBindList.lengthresp.varBindListSnmpVarBind[] newVbListnewVbList.length/** The method takes the incoming requests and split it into subrequests. */int nbAgentsSnmpMibAgent agentint nbReqsSnmpVarBind[] varsnew SnmpSubRequestHandler(...)SnmpMibAgent agnew SnmpSubNextRequestHandler(...)...[...].oidupdateRequest(...)/** The method takes the incoming get bulk requests and split it into ... */new SnmpSubBulkRequestHandler(...)SnmpVarBind[] resultmergeNextResponses(...)updateResult(...)SnmpValue val// RI imports// SNMP runtime import//import com.sun.jmx.snmp.IPAcl.IPAcl;// Need a reference on SnmpAdaptorServer for getNext & getBulk,// in case of oid equality (mib overlapping).//thread.start();// Trace the input packet// Let's build the response packet// Trace the output packet// Send the response packet if any// Transform the request packet into a request SnmpMessage// Make the response SnmpMessage if any// Try to transform the response SnmpMessage into response packet.// NOTE: we overwrite the request packet.// Transform the request message into a request pdu// Make the response pdu if any// Try to transform the response pdu into a response message if any// if the PDU is too small, why should we try to do// recovery ?// we can not go any further in trying to// reduce the message !// end of loop// reqPdu is accepted by ACLs// reqPdu is rejected by ACLs// respPdu contains the error response to be sent.// We send this response only if authResEnabled is true.// No response should be sent// A trap must be sent// There is no agent registered// Version 1: => NoSuchName// Version 2: => depends on PDU type// SET request => NoAccess// GET request => NoSuchObject// GET-NEXT or GET-BULK => EndOfMibView// Something wrong here: => snmpRspGenErr// Create the trhead group specific for handling sub-requests// associated to the current request. Use the invoke id// Nice idea to use a thread group on a request basis.// However the impact on performance is terrible !// theGroup= new ThreadGroup(thread.getThreadGroup(),//                "request " + String.valueOf(req.requestId));// Good ! Let's make a full response pdu.// First we need to split the request into subrequests// Execute all the subrequests resulting from the split of the// varbind list.// It means that an error occurred. The error is already// formatted by the executeSubRequest// So far so good. So we need to concatenate all the answers.// If it's a set request, we must first check any varBind// Indicate to the sub request that a check must be invoked ...// OK we should have defined out own tag for that !// No point to go any further.// end processing check operation for a set PDU.// Let's start the sub-requests./* NPCTE fix for bugId 4492741, esc 0, 16-August 2001 *//* end of NPCTE fix for bugId 4492741 */// everything is ok// Check the error status.// process the operation// Split the request into subrequests.// Now we remove useless trailing endOfMibView.// respVarBindList[m2] item and next are going to be removed// Trivial, of course...// We check the pdu type and create an error response if// the check failed.// If the response is not null, this means the pdu is rejected.// So let's update the statistics.// This should not occur because decodeIncomingRequest has normally// been successfully called before.// Reduction can be attempted only on bulk response// We're going to reduce the varbind list.// First determine which items should be removed.// Next duplicate and replace the existing list by the reduced one.// acceptedVbCount is the number of varbind which have been// successfully encoded before reaching bufferSize://   * when it is >= 2, we split the varbindlist at this//     position (-1 to be safe),//   * when it is 1, we only put one (big?) item in the varbindlist//   * when it is 0 (in fact, acceptedVbCount is not available),//     we split the varbindlist by 2.// acceptedCount == 0 ie it is unknown// Take all the oids contained in the request and// For the get next operation we are going to send the varbind list// to all agents// We need to create the sub request handler and update// the hashtable// Update the translation table within the subrequest// Send the getBulk to all agents// Go through the list of subrequests and concatenate.// Hopefully, by now all the sub-requests should be finished// In v1 make sure there is no endOfMibView ...// So far so good ...// Let's allocate the array for storing the result/** This class is used to handle received inform request responses. ... */SnmpQManager snmpq;SnmpResponseHandler.classSnmpPduPacket snmpProtSnmpPduRequest pduReqpduReq.requestIdinvokeOnResponse(...)// Retreive the PDU factory of the SNMP adaptor to decode the received inform response./** This class starts a thread which picks up a session from the queue ... */int intervalRange;Vector<SnmpInformRequest> readyPool;setPriority(...)Thread.NORM_PRIORITYSnmpSendServer.classprepareAndSendRequest(...)Exception anyereqListToString(...)fireRequestList(...)fireRequest(...)/** This will fire the specified request. */action(...)Enumeration<SnmpInformRequest> dbge// Wait until the thread die.// Ignore...// This is not good but Netscape does kill all threads when// the pagecontext changes.// wait to be signaled by the an active request.// Fire all requests as independent requests./** This class is used for sending INFORM REQUESTS from an agent to a manager. ... */new Hashtable<SnmpInformRequest,SnmpInformRequest>(...)new Stack<SnmpInformRequest>(...)/** The SNMP adaptor associated with this SnmpSession. */SnmpSocket informSocket;/** The SnmpSocket to be used to communicate with the manager ... */Hashtable<SnmpInformRequest,SnmpInformRequest> informRequestList;/** This table maintains the list of inform requests. */Stack<SnmpInformRequest> informRespq;/** This table maintains the list of inform responses. ... *//** The dispatcher that will service all inform responses to inform requests generated ... */SnmpInformRequest syncInformReq;/** Request being synchronized from session thread. This happens when ... */SnmpQManager snmpQman;boolean isBeingCancelled;/** Constructor for creating a new session. ... */SnmpResponseHandler snmpRespHdlrnew SnmpResponseHandler(...)new SnmpQManager(...)/** Constructor for creating a new session. Allows subclassing. *//** Initializes the SnmpSession. ... */// OTHER METHODSnew SnmpSocket(...)/** Indicates whether the thread for this session is active and the SNMP adaptor server ONLINE. ... *//** Gets the SnmpSocket which will be used by inform requests created in this session. ... *//** Gets the SnmpQManager which will be used by inform requests created in this session. ... *//** Indicates whether this session is performing synchronous operation for an inform request. ... *//** Returns <CODE>true</CODE> if the current executing thread is this session's dispatcher. ... *//** Sends an inform request to the specified InetAddress destination using the specified community string. ... */SnmpInformRequest snmpreqnew SnmpInformRequest(...)isSessionActive(...)/** Performs sync operations on active requests. Any number of inform requests ... */long maxTimesetSyncMode(...)SnmpSession.classsyncInProgress(...)resetSyncMode(...)/** Dispatcher method for this session thread. This is the dispatcher method ... */nextResponse(...)/** Adds an inform request. ... *///--------------------------------------------------------// HANDLING INFORM REQUESTS LIST AND INFORM RESPONSES LIST/** Deletes an inform request. ... *//** Cancels all pending inform requests in this session. */SnmpInformRequest[] listIterator<SnmpInformRequest> itnew SnmpInformRequest[]cancelRequest(...)/** Adds the inform request object which received a response to an inform request ... *//** Destroys any pending inform requests and then stops the session. ... */cancelAllRequests(...)cancelAllResponses(...)stopQThreads(...)killSessionThread(...)/** Make sure you are killing the thread when it is active. Instead ... *//** Finalizer of the <CODE>SnmpSession</CODE> objects. ... *///return ((myThread != null) && (myThread.isAlive()));// Handles out of memory.// finished processing.// re-process the request.// If the adaptor is not ONLINE, stop adding requests.// deleteRequest can be called from destroySnmpSession.//In such a case remove is done in cancelAllRequest method./** This class creates an SNMP Datagram Socket. This class has methods helpful ... */DatagramSocket _socket;SnmpResponseHandler _dgramHdlr;Thread _sockThread;...[] _buffer;boolean isClosing;int _socketPort;int responseBufSize;/** Creates a new <CODE>SnmpSocket</CODE> object. ... */SnmpSocket.class/** Sends a datagram packet to a specified device at specified port. ... */DatagramPacket dgrmpkt/** Checks if the socket is initialised correctly and if it is still active. ... *//** Closes the socket and its associated resources. *//** Dispatcher method for this socket thread. This is the dispatcher method ... */_buffer.lengthhandleDatagram(...)IOException iohandleJavaError(...)/** Finalizer of the <CODE>SnmpSocket</CODE> objects. ... *//* Keep this locked so that send can't happen. */processDatagram(...)// We send an empty datagram packet to fix bug 4293791 (it's a jdk 1.1 bug)// First close the datagram socket.// This may generates an IO exception at the run method (_socket.receive).// Then stop the thread socket.// If the corresponding session is being destroyed, stop handling received responses.// We are closing the snmp socket while handling the datagram.// If the IO exception has been generated because of closing this SNMP socket,// (call to _socket.close while _socket is blocked for receiving packet) simply terminate closing properly.// If the exception (NullPointerException) has been generated because of closing this SNMP socket,// (call to _socket = null while _socket is blocked for receiving packet) simply terminate closing properly.// rethrow dead thread.import SnmpIncomingRequestimport ThreadContextSnmpAdaptorServer server;/** The constructor initialize the subrequest with the whole varbind list contained ... */SnmpSubRequestHandler.classgetBulk(...)createMibRequest(...)restore(...)translation.lengthSnmpVarBind[] listSnmpSubRequestHandler$NonSyncVectorNonSyncVector<SnmpVarBind> nonSyncVarBindthis.nonRepeatthis.maxRepeatthis.globalRSnmpVarBind newVarBindaddNonSyncElement(...)/** The method updates find out which element to use at update time. Handle oid overlapping as well */result.valueelement.oidresult.oidelement.valueSnmpMibAgent deeperAgent/** The method updates a given var bind list with the result of a ... */int localRSnmpVarBind elementfindVarBind(...)int nonRepeat;/** Specific to the sub request */int maxRepeat;int globalR;/** R as defined in RCF 1902 for the global request the sub-request is associated to. */// Invoke a getBulk operation/* NPCTE fix for bugId 4492741, esc 0, 16-August-2001 */// we need to allocate a new SnmpVarBind. Otherwise the first// sub request will modify the list...// Take the smallest (lexicographically)// Must compare agent used for reply// Take the deeper within the reply/* Vector v = new Vector(); ... */// we can assume that the run method is over ...// First go through all the values once ...// May be we should control the position ...// bugId 4641694: must check position in order to avoid//       ArrayIndexOutOfBoundException// Now update the values which have been repeated// more than once.import SnmpMibRequestimport SnmpAdaptorServer/** The constructor initialize the subrequest with the whole varbind ... */SnmpSubNextRequestHandler.class/** The method updates the varbind list of the subrequest. */SnmpVarBind elmtelmt.oidvb.oidelmt.value/* NPCTE fix for bugId 4492741, esc 0 */// The translation table is easy in this case ...// Always call with V2. So the merge of the responses will// be easier./* NPCTE fix for bugid 4381195 esc 0. <J.C.> < 17-Oct-2000> */// if ((elmt != null) &&  (elmt.value == null) &&//    (version == snmpVersionTwo))//    elmt.value = SnmpVarBind.endOfMibView;/* end of NPCTE fix for bugid 4381195 */// else if ((val == null) && (version == snmpVersionTwo))//    vb.value = SnmpVarBind.endOfMibView;// Now we need to take the smallest oid ...SnmpIncomingRequest incRequest;/** V3 enabled Adaptor. Each Oid is added using updateRequest method. *//** V3 enabled Adaptor. *//** SNMP V1/V2 . To be called with updateRequest. */new NonSyncVector<SnmpVarBind>(...)/** SNMP V1/V2 The constructor initialize the subrequest with the whole varbind list contained ... */SnmpMibRequest resultnewMibRequest(...)getAccessContext(...)//                  => snmpRspGenErr//      snmpRspUndoFailed//      snmpRspResourceUnavailable, snmpRspRspCommitFailed,//               => snmpRspBadValue  (snmpRspNoSuchName for GET/GETNEXT)//      snmpRspWrong*//               => snmpRspReadOnly  (snmpRspNoSuchName for GET/GETNEXT)//      snmpRspAuthorizationError, snmpRspNotWritable, snmpRspNoCreation//               => snmpRspNoSuchName//      snmpRspNoAccess, snmpRspInconsistentName//    Otherwise://         snmpRspNoSuchName or snmpRspGenErr is returned.//    If the request was a GET/GETNEXT then either// v2 global error codes are transformed in the following way:// transformed in a global v1 snmpRspNoSuchName error.// v2 local error codes (noSuchInstance, noSuchObject) are// <li> v1 global error codes </li>// <li> v2 global error codes </li>// <li> v2 local error codes (that should be stored in the varbind)</li>// An SnmpStatusException can contain either:// to SNMP v1 valid global error status.// This function does a best-effort to map global error statusSnmpDefinitions.snmpRspNoAccessSnmpDefinitions.snmpRspInconsistentNameSnmpDefinitions.snmpRspReadOnlySnmpDefinitions.snmpRspNoCreationSnmpDefinitions.snmpRspWrongTypeSnmpDefinitions.snmpRspWrongLengthSnmpDefinitions.snmpRspWrongEncodingSnmpDefinitions.snmpRspWrongValueSnmpDefinitions.snmpRspInconsistentValueSnmpDefinitions.snmpRspBadValueSnmpDefinitions.snmpRspResourceUnavailableSnmpDefinitions.snmpRspCommitFailed//               => snmpRspWrongValue  (snmpRspGenErr for GET/GETNEXT)//      snmpRspBadValue//               => snmpRspNotWritable (snmpRspGenErr for GET/GETNEXT)//      snmpRspReadOnly//               => snmpRspNoAccess  (snmpRspGenErr for GET/GETNEXT)//      snmpRspNoSuchName// v1 global error codes are transformed in the following way://    Otherwise the v2 code itself is returned//     raised by a GET/GETNEXT request).//    (snmpRspGenErr is the only global error that is expected to be//    If the request was a GET/GETNEXT then snmpRspGenErr is returned.// <li> a global snmpRspNoSuchName otherwise. </li>// <li> a global snmpRspGenErr (if the request is a GET/GETNEXT) </li>// to transform them into:// varbind earlier. If they, do there is nothing much we can do except// should not raise this level: they should have been stored in the// v2 local error codes (noSuchInstance, noSuchObject)// to SNMP v2 valid global error status.mapErrorStatusToV1(...)mapErrorStatusToV2(...)/** The method returns the error status of the operation. ... *//** The method returns the error index as a position in the var bind list. ... */this.incRequest/** Store the protocol version to handle *//** Store the operation type. Remember if the type is Walk, it means ... *//** Agent directly handled by the sub-request handler. *//** Error status. *//** Index of error. ... */Vector<SnmpVarBind> varBind;/** The varbind list specific to the current sub request. ... */...[] translation;/** The array giving the index translation between the content of ... *//** Contextual object allocated by the SnmpUserDataFactory. */SnmpMibRequest mibRequest;/** The SnmpMibRequest that will be passed to the agent. *//** The SnmpPdu that will be passed to the request. */// required...// Synchronization is a very expensive operation. In our case it is not always// We get a ref on the pdu in order to pass it to SnmpMibRequest.//Pre-allocate room for storing varbindlist and translation table.// cast to NonSyncVector<SnmpVarBind>// This is an optimization://    The SnmpMibRequest created in the check() phase is//    reused in the set() phase.//This is a request comming from an SnmpV3AdaptorServer.//Full power.// If we're doing the check() phase, we store the SnmpMibRequest// so that we can reuse it in the set() phase.// Invoke a get operation//#ifdef DEBUG// end of switch// Map v2 codes onto v1 codes// At this point we should have a V1 error code// We have a snmpRspGenErr, or something which is not defined// in RFC1905 => return a snmpRspGenErr// Map v1 codes onto v2 codes// For get / getNext / getBulk the only global error// (PDU-level) possible is genErr.// Map to noSuchName//      if ((errorStatus == SnmpDefinitions.snmpRspNoSuchName) ||//   (errorStatus == SnmpStatusException.noSuchInstance) ||//  (errorStatus == SnmpStatusException.noSuchObject))//  return SnmpDefinitions.snmpRspNoSuchName;// SnmpStatusException.noSuchInstance and// SnmpStatusException.noSuchObject can't happen...// Map to notWritable// Map to wrongValue// Other valid V2 codes// Ivalid V2 code => genErr// Too bad, an error occurs ... we need to translate it ...// An error occurs. We need to be carefull because the index// we are getting is a valid SNMP index (so range starts at 1).// FIX ME: Shall we double-check the range here ?// The response is : YES :// we never serialize this/** This class retries any timed out inform requests. This class is for internal use. */SnmpInformRequest req;SnmpTimerServer.class/** This class represents a set of default directories used by Java DMK. ... */String INSTALL_PATH_RESOURCE_NAME;/** Returns the installation directory for Java DMK. ... *///----------------------// PUBLIC STATIC METHODSuseRessourceFile(...)/** Returns the installation directory for Java DMK concatenated with dirname. ... */getInstallDir(...)/** Sets the installation directory for Java DMK. ... *//** Returns the <CODE>etc</CODE> directory for Java DMK. ... *//** Returns the <CODE>etc</CODE> directory for Java DMK concatenated with dirname. ... */getEtcDir(...)/** Sets the <CODE>etc</CODE> directory for Java DMK. ... *//** Returns the <CODE>tmp</CODE> directory for the product. ... *//** Returns the <CODE>tmp</CODE> directory for Java DMK concatenated with dirname. ... */getTmpDir(...)/** Sets the <CODE>tmp</CODE> directory for the product ... */// PRIVATE STATIC METHODSBufferedReader rDefaultPaths.classString etcDir;/** Directories used by Java DMK. */String tmpDir;String installDir;/** This class reads a file containing the property list defined for Java DMK ... *//** Reads the Java DMK property list from a file and ... */Enumeration<?> e// PUBLIC STATIC VARIABLESString ACL_FILE;/** References the property that specifies the ACL file ... */String SECURITY_FILE;/** References the property that specifies the Security file ... */String UACL_FILE;/** References the property that specifies the User ACL file ... */String MIB_CORE_FILE;/** References the property that specifies the default mib_core file ... *//** References the property that specifies the name of the vendor of this product ... */String SSL_CIPHER_SUITE;/** References the property that specifies the SSL cipher suites to ... *//** Access Control Model interface. Every access control model must implement this interface in order to be integrated in the engine based framework. ... *//** Method called by the dispatcher in order to control the access at an <CODE>SnmpOid</CODE> Level. If access is not allowed, an <CODE>SnmpStatusException</CODE> is thrown. ... *//** Method called by the dispatcher in order to control the access at an SNMP pdu Level. If access is not allowed, an <CODE>SnmpStatusException</CODE> is thrown. In case of exception, the access control is aborted. OIDs are not checked. ... *//** Enable SNMP V1 and V2 set requests. Be aware that can lead to a security hole in a context of SNMP V3 management. By default SNMP V1 and V2 set requests are not authorized. ... *//** Disable SNMP V1 and V2 set requests. By default SNMP V1 and V2 set requests are not authorized. ... *//** The SNMP V1 and V2 set requests authorization status. By default SNMP V1 and V2 set requests are not authorized. ... */import SnmpUnknownAccContrModelException/** Access Control sub system interface. To allow engine integration, an Access Control sub system must implement this interface. ... *//** Method called by the dispatcher in order to control the access at an SNMP pdu Level. ... *//** Method called by the dispatcher in order to control the access at an <CODE>SnmpOid</CODE> Level. ... *//** Class returned by <CODE>SnmpSecuritySubSystem</CODE> and <CODE>SnmpSecurityModel</CODE>. If privacy is applied, the received pdu must be decrypted. This class contains the field of of a decrypted scoped pdu. ... *//** Decrypted pdu data. *//** Decrypted pdu data length. *//** Decrypted context name. *//** Decrypted context engine Id. */import SnmpUsmKeyHandlerimport SnmpEngineFactoryimport SnmpBadSecurityLevelException/** This engine is conformant with the RFC 2571. It is the main object within ... *//** Security level. No authentication, no privacy. Value is 0, ... *//** Security level. Authentication, privacy. Value is 3, ... *//** Flag that indicates that a report is to be sent. Value is 4, as defined in RFC 2572 *//** Mask used to isolate authentication information within a message flag. *//** Mask used to isolate authentication and privacy information within a message flag. */SnmpEngineId engineid;SnmpEngineFactory factory;int boot;boolean checkOid;SnmpUsmKeyHandler usmKeyHandler;SnmpLcd lcd;SnmpSecuritySubSystem securitySub;SnmpMsgProcessingSubSystem messageSub;SnmpAccessControlSubSystem accessSub;long deltastoreNBBoots(...)/** Gets the engine Lcd. ... *//** Constructor. A Local Configuration Datastore is passed to the engine. It will be used to store and retrieve data (engine Id, engine boots). ... */initEngineID(...)this.engineidstoreEngineId(...)SnmpEngineImpl.class/** Constructor. A Local Configuration Datastore is passed to the engine. It will be used to store and retrieve data (engine ID, engine boots). ... */getEngineTime(...)/** Access Control will check the oids. By default is false. *//** Access Control will not check the oids. By default is false. *//** Access Control check or not the oids. By default is false. *///Do some check and store the nb boots value.storeEngineBoots(...)// Initialize internal status.this.lcdgetEngineBoots(...)this.usmKeyHandler//Initialize the engineID.getEngineId(...)/** Returns the Message Processing Sub System. ... *//** Sets the Message Processing Sub System. ... *//** Returns the Security Sub System. ... *//** Sets the Security Sub System. ... *//** Sets the Access Control Sub System. ... *//** Returns the Access Control Sub System. ... *//** Checks the passed msg flags according to the rules specified in RFC 2572. ... */int secLevelSnmpDefinitions.authPrivSnmpDefinitions.authMasknew SnmpBadSecurityLevelException(...)//We do the counter wrap in a lazt way. Each time Engine is asked for his time it checks. So if nobody use the Engine, the time can wrap and wrap again without incrementing nb boot. We can imagine that it is irrelevant due to the amount of time needed to wrap.//67 years of running. That is a great thing!//Reinitialize startTime.//Can't do anything with this counter.//Store for future use.import SnmpUnknownSecModelException/** <P> An <CODE>SnmpIncomingRequest</CODE> handles both sides of an incoming SNMP request: ... *//** Once the incoming request decoded, returns the decoded security parameters. ... *//** Tests if a report is expected. ... *//** Tests if a response is expected. ... *//** Tells this request that no response will be sent. *//** Gets the incoming request principal. ... *//** Gets the incoming request security level. This level is defined in {@link com.sun.jmx.snmp.SnmpEngine SnmpEngine}. ... *//** Gets the incoming request security model. ... *//** Gets the incoming request context name. ... *//** Gets the incoming request context engine Id. ... *//** Gets the incoming request context name used by Access Control Model in order to allow or deny the access to OIDs. *//** Encodes the response message to send and puts the result in the specified byte array. ... *//** Decodes the specified bytes and initializes the request with the incoming message. ... *//** Initializes the response to send with the passed Pdu. ... *//** Gets the request PDU encoded in the received message. ... *//** Returns a stringified form of the received message. ... *//** Returns a stringified form of the message to send. ... */import SnmpSecurityException/** <P> An <CODE>SnmpIncomingResponse</CODE> handles the unmarshalling of the received response.</P> ... *//** Returns the source address. ... *//** Returns the source port. ... *//** Gets the incoming response security parameters. ... *//** Call this method in order to reuse <CODE>SnmpOutgoingRequest</CODE> cache. ... *//** Gets the incoming response security level. This level is defined in ... *//** Gets the incoming response security model. ... *//** Gets the incoming response context name. ... *//** Decodes the specified bytes and initializes itself with the received ... *//** Gets the request PDU encoded in the received response. ... *//** Returns the response request Id. ... */import SnmpUnknownModelLcdExceptionimport SnmpUnknownSubSystemException/** Class to extend in order to develop a customized Local Configuration Datastore. The Lcd is used by the <CODE>SnmpEngine</CODE> to store and retrieve data. ... */new Hashtable<SnmpSubSystem,SubSysLcdManager>(...)SnmpLcd$SubSysLcdManagernew Hashtable<Integer,SnmpModelLcd>(...)Hashtable<Integer,SnmpModelLcd> models;Hashtable<SnmpSubSystem,SubSysLcdManager> subs;/** Returns the number of time the engine rebooted. ... *//** Returns the engine Id located in the Lcd. ... *//** Persists the number of reboots. ... *//** Persists the engine Id. ... *//** Adds an Lcd model. ... */SubSysLcdManager subsysnew SubSysLcdManager(...)addModelLcd(...)/** Removes an Lcd model. ... */SnmpModelLcd lcdremoveModelLcd(...)new SnmpUnknownModelLcdException(...)new SnmpUnknownSubSystemException(...)/** Gets an Lcd model. ... */getModelLcd(...)/** Interface that every SNMP model must implement in order to be integrated in the engine framework. ... *//** Returns the sub system that manages this model. ... *//** A human readable model name. ... *//** An interface to implement when developping customized model configuration datastore. ... */import SnmpMsgTranslatorimport SnmpParams/** The message processing model interface. Any message processing model must implement this interface in order to be integrated in the engine framework. ... *//** This method is called when a call is to be sent to the network. ... *//** This method is called when a call is received from the network. ... *//** This method is called when a response is received from the network. ... *//** This method is called to instantiate a pdu according to the passed pdu type and parameters. ... *//** This method is called to encode a full scoped pdu that has not been encrypted. <CODE>contextName</CODE>, <CODE>contextEngineID</CODE> and data are known. ... *//** This method is called to encode a full scoped pdu that as been encrypted. <CODE>contextName</CODE>, <CODE>contextEngineID</CODE> and data are known. ... *//** This method returns a decoded scoped pdu. This method decodes only the <CODE>contextEngineID</CODE>, <CODE>contextName</CODE> and data. It is needed by the <CODE>SnmpSecurityModel</CODE> after decryption. ... *//** This method returns an encoded scoped pdu. This method encode only the <CODE>contextEngineID</CODE>, <CODE>contextName</CODE> and data. It is needed by the <CODE>SnmpSecurityModel</CODE> for decryption. ... *//** In order to change the behavior of the translator, set it. ... *//** Returns the current translator. ... */import SnmpUnknownMsgProcModelException/** Message processing sub system interface. To allow engine integration, a message processing sub system must implement this interface. This sub system is called by the dispatcher when receiving or sending calls. ... *//** Attaches the security sub system to this sub system. Message processing model are making usage of various security sub systems. This direct attachement avoid the need of accessing the engine to retrieve the Security sub system. ... *//** Gets the attached security sub system. ... *//** This method is called when a call is to be sent to the network. The sub system routes the call to the dedicated model according to the model ID. ... *//** This method is called to instantiate a pdu according to the passed pdu type and parameters. The sub system routes the call to the dedicated model according to the model ID. ... *//** This method is called when a call is received from the network. The sub system routes the call to the dedicated model according to the model ID. ... *//** This method is called to encode a full scoped pdu that as not been encrypted. <CODE>contextName</CODE>, <CODE>contextEngineID</CODE> and data are known. It will be routed to the dedicated model according to the version value. ... *//** This method is called to encode a full scoped pdu that as been encrypted. <CODE>contextName</CODE>, <CODE>contextEngineID</CODE> and data are not known. It will be routed to the dedicated model according to the version value. ... *//** This method returns a decoded scoped pdu. This method decodes only the <CODE>contextEngineID</CODE>, <CODE>contextName</CODE> and data. It is needed by the <CODE>SnmpSecurityModel</CODE> after decryption. It will be routed to the dedicated model according to the version value. ... *//** This method returns an encoded scoped pdu. This method encodes only the <CODE>contextEngineID</CODE>, <CODE>contextName</CODE> and data. It is needed by the <CODE>SnmpSecurityModel</CODE> for decryption. It will be routed to the dedicated model according to the version value. ... *//** <P> An <CODE>SnmpOutgoingRequest</CODE> handles the marshalling of the message to send.</P> ... *//** Returns the cached security data used when marshalling the call as a secure one. ... *//** Encodes the message to send and puts the result in the specified byte array. ... *//** Initializes the message to send with the passed Pdu. ... *//** Cache is returned by <CODE>SnmpSecurityModel</CODE> when handling requests. The cache contants is security dependant. This interface is a marker that every cache classes must implement. ... *//** Security model interface. Any security model implementation must implement this interface in order to be integrated in the engine framework. Security models are called when SNMP messages are received or sent. They deal with security (authentication and privacy). ... *//** Called when a request is to be sent to the network. It must be securized. ... *//** Called when a response is to be sent to the network. It must be securized. ... *//** Called when a request is received from the network. It handles authentication and privacy. ... *//** Called when a response is received from the network. It handles authentication and privacy. ... *//** Instantiate an <CODE>SnmpSecurityCache</CODE> that is dependant to the model implementation. ... *//** Release the previously created cache. ... *//** Security sub system interface. To allow engine integration, a security sub system must implement this interface. ... *//** Instantiates an <CODE>SnmpSecurityCache</CODE> that is dependant to the model implementation. This call is routed to the dedicated model according to the model ID. ... *//** To release the previously created cache. This call is routed to the dedicated model according to the model ID. ... *//** Called when a request is to be sent to the network. It must be securized. This call is routed to the dedicated model according to the model ID. ... *//** Called when a response is to be sent to the network. It must be securized. This call is routed to the dedicated model according to the model ID. ... *//** Called when a request is received from the network. It handles authentication and privacy. This call is routed to the dedicated model according to the model ID. ... *//** Called when a response is received from the network. It handles authentication and privacy. This call is routed to the dedicated model according to the model ID. ... *//** SNMP sub system interface. To allow engine framework integration, a sub system must implement this interface. A sub system is a model manager. Every model is identified by an ID. A sub system can retrieve a previously registered model using this ID. ... *//** Returns the associated engine. ... *//** Adds a model to this sub system. ... *//** Removes a model from this sub system. ... *//** Gets a model from this sub system. ... *//** Returns the set of model Ids that have been registered within the sub system. *//** Returns the set of model names that have been registered within the sub system. *//** Utility class used to deal with various data representations. ... *//** Translates a binary representation in an ASCII one. The returned string is an hexadecimal string starting with 0x. ... */byte[] asciiData/** Translates a stringified representation in a binary one. The passed string is an hexadecimal one starting with 0x. ... */byte[] pbyte v//System.out.println("ascii : " + p[j+1]);//System.out.println("binary : " + v);//System.out.println("binary : " + v+1);/** The translator interface is implemented by classes dealing with a specific SNMP protocol version. SnmpMsgTranslator are used in conjonction with SnmpMsgProcessingModel implementations. ... *//** Returns the request or message Id contained in the passed message. The message is a generic one that is narrowed in the object implementing this interface. *//** Returns the response max message size. The message is a generic one that is narrowed in the object implementing this interface. *//** Returns the message flags. The message is a generic one that is narrowed in the object implementing this interface. *//** Returns the message security model. The message is a generic one that is narrowed in the object implementing this interface. *//** Returns the message security level. The message is a generic one that is narrowed in the object implementing this interface. *//** Returns an encoded representation of security parameters contained in the passed msg. The message is a generic one that is narrowed in the object implementing this interface. *//** Returns the message security parameters. The message is a generic one that is narrowed in the object implementing this interface. *//** Returns the message context Engine Id. The message is a generic one that is narrowed in the object implementing this interface. *//** Returns the message context name. The message is a generic one that is narrowed in the object implementing this interface. *//** Returns the raw message context name. Raw mean as it is received from the network, without translation. It can be useful when some data are piggy backed in the context name.The message is a generic one that is narrowed in the object implementing this interface. *//** Returns the message accesscontext name. This access context name is used when dealing with access rights (eg: community for V1/V2 or context name for V3).The message is a generic one that is narrowed in the object implementing this interface. *//** Returns the message encrypted pdu or null if no encryption. The message is a generic one that is narrowed in the object implementing this interface. *//** Set the context name of the passed message. *//** Set the context engine Id of the passed message. *//** This interface is implemented by objects that can be executed ... *//** Cancel the submitted task. ... */// NPCTE fix for bugId 4510777, esc 532372, MR October 2001// file Task.java created for this bug fix/** This interface is implemented by objects that are able to execute ... *//** Submit a task to be executed. ... */// file TaskServer.java created for this bug fiximport Taskimport TaskServer/** This class implements a {@link com.sun.jmx.snmp.tasks.TaskServer} over ... */new ArrayList<Runnable>(...)new ExecutorThread[]getPriority(...)// --------------// public methodsstateCheck(...)Runnable removedint lgObject[] jobsjobs.length// to terminate// A thread used to execute jobs// ---------------Runnable jobExecutorThread etnew ExecutorThread(...)ArrayList<Runnable> jobList;// protected or private variables...[] threadList;int minThreads;int currThreds;int idle;int priority;ClassLoader cloader;long counter;int addedJobs;int doneJobs;// TODO// init// terminated ?// re-initimport NamingException// no need to implement Enumeration since this is only for internal use/** The FactoryEnumeration is used for returning factory instances. ... */List<NamedWeakReference<Object>> factories;// List<NamedWeakReference<Class | Object>>int posn;/** Records the input list and uses it directly to satisfy ... */this.factoriesNamedWeakReference<Object> refObject answernew NamedWeakReference<Object>(...)NamingException nenew NamingException(...)setRootCause(...)// reload class if weak ref cleared// Instantiate Class to get factory// replace Class object or null/** A NamedWeakReference is a WeakReference with an immutable string name. ... *//* Copyright (c) 2001, 2011, Oracle and/or its affiliates. All rights reserved. ... *//** The ResourceManager class facilitates the reading of JNDI resource files. ... */Context.OBJECT_FACTORIESContext.URL_PKG_PREFIXESContext.STATE_FACTORIESLdapContext.CONTROL_FACTORIESgetVersionHelper(...)new WeakHashMap<Object,Hashtable<? super String,Object>>(...)new WeakHashMap<ClassLoader,Map<String,List<NamedWeakReference<Object>>>>(...)new WeakHashMap<ClassLoader,Map<String,WeakReference<Object>>>(...)String PROVIDER_RESOURCE_FILE_NAME;/* Name of provider resource files (without the package-name prefix.) */String APP_RESOURCE_FILE_NAME;/* Name of application resource files. */String JRELIB_PROPERTY_FILE_NAME;/* Name of properties file in <java.home>/lib. */String DISABLE_APP_RESOURCE_FILES;/* Internal environment property, that when set to "true", disables ... */...[] listProperties;/* The standard JNDI properties that specify colon-separated lists. */VersionHelper helper;WeakHashMap<Object,Hashtable<? super String,Object>> propertiesCache;// WeakHashMap<Class | ClassLoader, Hashtable>/* A cache of the properties that have been constructed by ... */WeakHashMap<ClassLoader,Map<String,List<NamedWeakReference<Object>>>> factoryCache;/* A cache of factory objects (ObjectFactory, StateFactory, ControlFactory). ... */WeakHashMap<ClassLoader,Map<String,WeakReference<Object>>> urlFactoryCache;/* A cache of URL factory objects (ObjectFactory). ... */WeakReference<Object> NO_FACTORY;ResourceManager$AppletParameter/** A class to allow JNDI properties be specified as applet parameters ... */Class<?> clazz;Method getMethod;/** Returns the value of the applet's named parameter. */ReflectiveOperationException e// There should be no instances of this class./* Given the environment parameter passed to the initial context ... */// ---------- Public methods ----------String[] propsVersionHelper.PROPSObject appletContext.APPLETString[] jndiSysPropsgetJndiProperties(...)String disableAppResnew Hashtable<Object,Object>(...)props.lengthgetJndiProperty(...)mergeTables(...)getApplicationResources(...)/** Retrieves the property from the environment, or from the provider ... */String val1String val2getProviderResource(...)/** Retrieves an enumeration of factory classes/object specified by a ... */String facPropMap<String,List<NamedWeakReference<Object>>> perLoaderCachenew HashMap<String,List<NamedWeakReference<Object>>>(...)List<NamedWeakReference<Object>> factoriesnew FactoryEnumeration(...)StringTokenizer parsernew ArrayList<NamedWeakReference<Object>>(...)/** Retrieves a factory from a list of packages specified in a ... */Map<String,WeakReference<Object>> perLoaderCachenew HashMap<String,WeakReference<Object>>(...)Object factoryWeakReference<Object> factoryRef/* Returns the properties contained in the provider resource file ... */// ---------- Private methods ----------new Hashtable<String,Object>(...)Hashtable<? super String,Object> propsInputStream istreamnew ConfigurationException(...)/* Returns the Hashtable (never null) that results from merging ... */Hashtable<? super String,Object> resultNamingEnumeration<InputStream> resourcesgetResources(...)getJavaHomeLibStream(...)hasMore(...)/* Merge the properties from one hash table into another.  Each ... */Object val1isListProperty(...)/* Is a property one of the standard JNDI properties that specify ... */listProperties.length// The following shouldn't create a runtime dependence on ldap package.// if clazz is null then applet cannot be an Applet.// system/applet properties// Merge property values from env param, applet params, and system// properties.  The first value wins:  there's no concatenation of// colon-separated lists.// Read system properties by first trying System.getProperties(),// and then trying System.getProperty() if that fails.  The former// is more efficient due to fewer permission checks.// Read system property.// Return without merging if application resource files lookup// is disabled.// Merge the above with the values read from all application// resource files.  Colon-separated lists are concatenated.// no classes specified; return null// Cache is based on context class loader and property val// Cached list// Populate list with classes named in facProp; skipping// those that we cannot load// System.out.println("loading");// ignore ClassNotFoundException, IllegalArgumentException// System.out.println("adding to cache: " + factories);// Merge property with provider property and supplied default// Cache factory based on context class loader, class name, and// property val// check if weak ref has been cleared// Not cached; find first factory and cache// System.out.println("loading " + className);// ignore ClassNotFoundException, IllegalArgumentException,// etc.// Cache it.// Merge in properties from file in <java.home>/lib.import NamingEnumeration/** VersionHelper was used by JNDI to accommodate differences between ... */Context.INITIAL_CONTEXT_FACTORYContext.PROVIDER_URLContext.DNS_URLnew VersionHelper12(...)...[] PROPS;int INITIAL_CONTEXT_FACTORY;int OBJECT_FACTORIES;int URL_PKG_PREFIXES;int STATE_FACTORIES;int PROVIDER_URL;int DNS_URL;int CONTROL_FACTORIES;/* Returns a JNDI property from the system properties.  Returns ... *//* Reads each property in PROPS from the system properties, and ... *//* Returns the resource of a given name associated with a particular ... *//* Returns an input stream for a file in <java.home>/lib, ... *//* Returns an enumeration (never null) of InputStreams of the ... *//* Returns the context class loader associated with the current thread. ... */Vector<String> vecString[] urlURL[] urlArraynew URL[]url.lengthurlArray.length// Disallow anyone from creating one of these.// Parse codebase into separate URLsimport URLClassLoaderVersionHelper12$1// Disallow external from creating one of these.String TRUST_URL_CODEBASE_PROPERTY;/** Determines whether classes may be loaded from an arbitrary URL code base. */String trustURLCodebase;/** Package private. ... */ClassLoader parentgetUrlArray(...)VersionHelper12$2Properties sysPropsnew PrivilegedAction<Properties>(...) { ... }VersionHelper12$3String[] jPropsPROPS.lengthVersionHelper12$4VersionHelper12$5String javahomeString pathnameEnumeration<URL> urlsnew PrivilegedExceptionAction<Enumeration<URL>>(...) { ... }VersionHelper12$6getSystemResources(...)new InputStreamEnumeration(...)VersionHelper12$7VersionHelper12$InputStreamEnumeration/** Given an enumeration of URLs, an instance of this class represents ... */Enumeration<URL> urls;InputStream nextElement;this.urls/* Returns the next InputStream, or null if there are no more. ... */VersionHelper12$InputStreamEnumeration$1getNextElement(...)InputStream res// Don't use bootstrap class loader directly!// skip this URL/** Constants for the project, mostly defined in the JVM specification. ... */ACCESS_NAMES.lengthOPCODE_NAMES.lengthint JVM_CLASSFILE_MAGIC;/** Java class file format Magic number (0xCAFEBABE) ... */short MAJOR_1_1;/** Major version number of class files for Java 1.1. ... */short MINOR_1_1;/** Minor version number of class files for Java 1.1. ... */short MAJOR_1_2;/** Major version number of class files for Java 1.2. ... */short MINOR_1_2;/** Minor version number of class files for Java 1.2. ... */short MAJOR_1_3;short MINOR_1_3;/** Minor version number of class files for Java 1.3. ... */short MAJOR_1_4;/** Major version number of class files for Java 1.3. ... */short MINOR_1_4;/** Minor version number of class files for Java 1.4. ... */short MAJOR_1_5;/** Major version number of class files for Java 1.4. ... */short MINOR_1_5;/** Minor version number of class files for Java 1.5. ... */short MAJOR_1_6;/** Major version number of class files for Java 1.6. ... */short MINOR_1_6;/** Minor version number of class files for Java 1.6. ... */short MAJOR_1_7;/** Major version number of class files for Java 1.7. ... */short MINOR_1_7;/** Minor version number of class files for Java 1.7. ... */short MAJOR_1_8;/** Major version number of class files for Java 1.8. ... */short MAJOR_1_9;/** Major version number of class files for Java 9. ... */short MINOR_1_8;/** Minor version number of class files for Java 1.8. ... */short MINOR_1_9;/** Minor version number of class files for Java 9. ... */short MAJOR;/** Default major version number. Class file is for Java 1.1. ... */short MINOR;int MAX_SHORT;/** Maximum value for an unsigned short. */int MAX_BYTE;/** Maximum value for an unsigned byte. */short ACC_PUBLIC;/** One of the access flags for fields, methods, or classes. ... */// 2^8 - 1short ACC_PRIVATE;short ACC_PROTECTED;short ACC_STATIC;short ACC_FINAL;short ACC_SYNCHRONIZED;short ACC_VOLATILE;short ACC_BRIDGE;short ACC_TRANSIENT;short ACC_VARARGS;short ACC_NATIVE;short ACC_INTERFACE;short ACC_ABSTRACT;short ACC_STRICT;short ACC_SYNTHETIC;short ACC_ANNOTATION;short ACC_ENUM;short ACC_MANDATED;short ACC_SUPER;// Applies to classes compiled by new compilers onlyshort MAX_ACC_FLAG;...[] ACCESS_NAMES;/** The names of the access flags. */int ACCESS_NAMES_LENGTH;byte CONSTANT_Utf8;/** Marks a constant pool entry as type UTF-8. ... *//* The description of the constant pool is at: ... */byte CONSTANT_Integer;/** Marks a constant pool entry as type Integer. ... */byte CONSTANT_Float;/** Marks a constant pool entry as type Float. ... */byte CONSTANT_Long;/** Marks a constant pool entry as type Long. ... */byte CONSTANT_Double;/** Marks a constant pool entry as type Double. ... */byte CONSTANT_Class;/** Marks a constant pool entry as a Class ... */byte CONSTANT_Fieldref;/** Marks a constant pool entry as a Field Reference. ... */byte CONSTANT_String;/** Marks a constant pool entry as type String ... */byte CONSTANT_Methodref;/** Marks a constant pool entry as a Method Reference. ... */byte CONSTANT_InterfaceMethodref;/** Marks a constant pool entry as an Interface Method Reference. ... */byte CONSTANT_NameAndType;/** Marks a constant pool entry as a name and type. ... */byte CONSTANT_MethodHandle;/** Marks a constant pool entry as a Method Handle. ... */byte CONSTANT_MethodType;/** Marks a constant pool entry as a Method Type. ... */byte CONSTANT_InvokeDynamic;/** Marks a constant pool entry as an Invoke Dynamic ... */...[] CONSTANT_NAMES;/** The names of the types of entries in a constant pool. Use getConstantName ... */String STATIC_INITIALIZER_NAME;/** The name of the static initializer, also called &quot;class ... */String CONSTRUCTOR_NAME;/** The name of every constructor method in a class, also called ... */...[] INTERFACES_IMPLEMENTED_BY_ARRAYS;/** The names of the interfaces implemented by arrays */int MAX_CP_ENTRIES;/** Maximum Constant Pool entries. One of the limitations of the Java Virtual ... */int MAX_CODE_SIZE;/** Maximum code size (plus one; the code size must be LESS than this) One of ... */int MAX_ARRAY_DIMENSIONS;/** The maximum number of dimensions in an array ({@value}). One of the ... *///bytesshort NOP;/** Java VM opcode. ... */short ACONST_NULL;short ICONST_M1;short ICONST_0;short ICONST_1;short ICONST_2;short ICONST_3;short ICONST_4;short ICONST_5;short LCONST_0;short LCONST_1;short FCONST_0;short FCONST_1;short FCONST_2;short DCONST_0;short DCONST_1;short BIPUSH;short SIPUSH;short LDC;short LDC_W;short LDC2_W;short ILOAD;short LLOAD;short FLOAD;short DLOAD;short ALOAD;short ILOAD_0;short ILOAD_1;short ILOAD_2;short ILOAD_3;short LLOAD_0;short LLOAD_1;short LLOAD_2;short LLOAD_3;short FLOAD_0;short FLOAD_1;short FLOAD_2;short FLOAD_3;short DLOAD_0;short DLOAD_1;short DLOAD_2;short DLOAD_3;short ALOAD_0;short ALOAD_1;short ALOAD_2;short ALOAD_3;short IALOAD;short LALOAD;short FALOAD;short DALOAD;short AALOAD;short BALOAD;short CALOAD;short SALOAD;short ISTORE;short LSTORE;short FSTORE;short DSTORE;short ASTORE;short ISTORE_0;short ISTORE_1;short ISTORE_2;short ISTORE_3;short LSTORE_0;short LSTORE_1;short LSTORE_2;short LSTORE_3;short FSTORE_0;short FSTORE_1;short FSTORE_2;short FSTORE_3;short DSTORE_0;short DSTORE_1;short DSTORE_2;short DSTORE_3;short ASTORE_0;short ASTORE_1;short ASTORE_2;short ASTORE_3;short IASTORE;short LASTORE;short FASTORE;short DASTORE;short AASTORE;short BASTORE;short CASTORE;short SASTORE;short POP;short POP2;short DUP;short DUP_X1;short DUP_X2;short DUP2;short DUP2_X1;short DUP2_X2;short SWAP;short IADD;short LADD;short FADD;short DADD;short ISUB;short LSUB;short FSUB;short DSUB;short IMUL;short LMUL;short FMUL;short DMUL;short IDIV;short LDIV;short FDIV;short DDIV;short IREM;short LREM;short FREM;short DREM;short INEG;short LNEG;short FNEG;short DNEG;short ISHL;short LSHL;short ISHR;short LSHR;short IUSHR;short LUSHR;short IAND;short LAND;short IOR;short LOR;short IXOR;short LXOR;short IINC;short I2L;short I2F;short I2D;short L2I;short L2F;short L2D;short F2I;short F2L;short F2D;short D2I;short D2L;short D2F;short I2B;short INT2BYTE;short I2C;// Old notationshort INT2CHAR;short I2S;short INT2SHORT;short LCMP;short FCMPL;short FCMPG;short DCMPL;short DCMPG;short IFEQ;short IFNE;short IFLT;short IFGE;short IFGT;short IFLE;short IF_ICMPEQ;short IF_ICMPNE;short IF_ICMPLT;short IF_ICMPGE;short IF_ICMPGT;short IF_ICMPLE;short IF_ACMPEQ;short IF_ACMPNE;short GOTO;short JSR;short RET;short TABLESWITCH;short LOOKUPSWITCH;short IRETURN;short LRETURN;short FRETURN;short DRETURN;short ARETURN;short RETURN;short GETSTATIC;short PUTSTATIC;short GETFIELD;short PUTFIELD;short INVOKEVIRTUAL;short INVOKESPECIAL;short INVOKENONVIRTUAL;short INVOKESTATIC;// Old name in JDK 1.0short INVOKEINTERFACE;short INVOKEDYNAMIC;short NEW;short NEWARRAY;short ANEWARRAY;short ARRAYLENGTH;short ATHROW;short CHECKCAST;short INSTANCEOF;short MONITORENTER;short MONITOREXIT;short WIDE;short MULTIANEWARRAY;short IFNULL;short IFNONNULL;short GOTO_W;short JSR_W;short BREAKPOINT;/** JVM internal opcode. ... */short LDC_QUICK;short LDC_W_QUICK;short LDC2_W_QUICK;short GETFIELD_QUICK;short PUTFIELD_QUICK;short GETFIELD2_QUICK;short PUTFIELD2_QUICK;short GETSTATIC_QUICK;short PUTSTATIC_QUICK;short GETSTATIC2_QUICK;short PUTSTATIC2_QUICK;short INVOKEVIRTUAL_QUICK;short INVOKENONVIRTUAL_QUICK;short INVOKESUPER_QUICK;short INVOKESTATIC_QUICK;short INVOKEINTERFACE_QUICK;short INVOKEVIRTUALOBJECT_QUICK;short NEW_QUICK;short ANEWARRAY_QUICK;short MULTIANEWARRAY_QUICK;short CHECKCAST_QUICK;short INSTANCEOF_QUICK;short INVOKEVIRTUAL_QUICK_W;short GETFIELD_QUICK_W;short PUTFIELD_QUICK_W;short IMPDEP1;short IMPDEP2;short PUSH;/** BCEL virtual instruction for pushing an arbitrary data type onto the ... */short SWITCH;/** BCEL virtual instruction for either LOOKUPSWITCH or TABLESWITCH. Will be ... */short UNDEFINED;/** Illegal opcode. */short UNPREDICTABLE;short RESERVED;String ILLEGAL_OPCODE;/** Mnemonic for an illegal opcode. */String ILLEGAL_TYPE;/** Mnemonic for an illegal type. */byte T_BOOLEAN;/** Boolean data type. ... */byte T_CHAR;/** Char data type. ... */byte T_FLOAT;/** Float data type. ... */byte T_DOUBLE;/** Double data type. ... */byte T_BYTE;/** Byte data type. ... */byte T_SHORT;/** Short data type. ... */byte T_INT;/** Int data type. ... */byte T_LONG;/** Long data type. ... */byte T_VOID;/** Void data type (non-standard). */byte T_ARRAY;/** Array data type. */// Non-standardbyte T_OBJECT;/** Object data type. */byte T_REFERENCE;/** Reference data type (deprecated). */byte T_UNKNOWN;/** Unknown data type. */// Deprecatedbyte T_ADDRESS;/** Address data type. */...[] TYPE_NAMES;/** The primitive type names corresponding to the T_XX constants, e.g., ... */...[] CLASS_TYPE_NAMES;/** The primitive class names corresponding to the T_XX constants, e.g., ... */...[] SHORT_TYPE_NAMES;/** The signature characters corresponding to primitive types, e.g., ... */...[] NO_OF_OPERANDS;/** Number of byte code operands for each opcode, i.e., number of bytes after ... */...[] TYPE_OF_OPERANDS;/** How the byte code operands are to be interpreted for each opcode. Indexed ... */...[] OPCODE_NAMES;/** Names of opcodes. Indexed by opcode. OPCODE_NAMES[ALOAD] = "aload". */int OPCODE_NAMES_LENGTH;...[] CONSUME_STACK;/** Number of words consumed on operand stack by instructions. Indexed by ... */...[] PRODUCE_STACK;/** Number of words produced onto operand stack by instructions. Indexed by ... */byte ATTR_UNKNOWN;/** Attributes and their corresponding names. */byte ATTR_SOURCE_FILE;byte ATTR_CONSTANT_VALUE;byte ATTR_CODE;byte ATTR_EXCEPTIONS;byte ATTR_LINE_NUMBER_TABLE;byte ATTR_LOCAL_VARIABLE_TABLE;byte ATTR_INNER_CLASSES;byte ATTR_SYNTHETIC;byte ATTR_DEPRECATED;byte ATTR_PMG;byte ATTR_SIGNATURE;byte ATTR_STACK_MAP;byte ATTR_RUNTIME_VISIBLE_ANNOTATIONS;byte ATTR_RUNTIME_INVISIBLE_ANNOTATIONS;byte ATTR_RUNTIME_VISIBLE_PARAMETER_ANNOTATIONS;byte ATTR_RUNTIME_INVISIBLE_PARAMETER_ANNOTATIONS;byte ATTR_ANNOTATION_DEFAULT;byte ATTR_LOCAL_VARIABLE_TYPE_TABLE;byte ATTR_ENCLOSING_METHOD;byte ATTR_STACK_MAP_TABLE;byte ATTR_BOOTSTRAP_METHODS;byte ATTR_METHOD_PARAMETERS;short KNOWN_ATTRIBUTES;...[] ATTRIBUTE_NAMES;// count of attributesbyte ITEM_Bogus;/** Constants used in the StackMap attribute. */byte ITEM_Integer;byte ITEM_Float;byte ITEM_Double;byte ITEM_Long;byte ITEM_Null;byte ITEM_InitObject;byte ITEM_Object;byte ITEM_NewObject;...[] ITEM_NAMES;int SAME_FRAME;/** Constants used to identify StackMapEntry types. ... */int SAME_LOCALS_1_STACK_ITEM_FRAME;int SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED;int CHOP_FRAME;int SAME_FRAME_EXTENDED;int APPEND_FRAME;int FULL_FRAME;int SAME_FRAME_MAX;/** Constants that define the maximum value of those constants which store ... */int SAME_LOCALS_1_STACK_ITEM_FRAME_MAX;int CHOP_FRAME_MAX;int APPEND_FRAME_MAX;byte REF_getField;// Constants defining the behavior of the Method Handles (JVMS 5.4.3.5)byte REF_getStatic;byte REF_putField;byte REF_putStatic;byte REF_invokeVirtual;byte REF_invokeStatic;byte REF_invokeSpecial;byte REF_newInvokeSpecial;byte REF_invokeInterface;...[] METHODHANDLE_NAMES;/** The names of the reference_kinds of a CONSTANT_MethodHandle_info. *//* Copyright (c) 2017, Oracle and/or its affiliates. All rights reserved. *//* Licensed to the Apache Software Foundation (ASF) under one or more ... *//* nop *//* aconst_null *//* iconst_m1 *//* iconst_0 *//* iconst_1 *//* iconst_2 *//* iconst_3 *//* iconst_4 *//* iconst_5 *//* lconst_0 *//* lconst_1 *//* fconst_0 *//* fconst_1 *//* fconst_2 *//* dconst_0 *//* dconst_1 *//* bipush *//* sipush *//* ldc *//* ldc_w *//* ldc2_w *//* iload *//* lload *//* fload *//* dload *//* aload *//* iload_0 *//* iload_1 *//* iload_2 *//* iload_3 *//* lload_0 *//* lload_1 *//* lload_2 *//* lload_3 *//* fload_0 *//* fload_1 *//* fload_2 *//* fload_3 *//* dload_0 *//* dload_1 *//* dload_2 *//* dload_3 *//* aload_0 *//* aload_1 *//* aload_2 *//* aload_3 *//* iaload *//* laload *//* faload *//* daload *//* aaload *//* baload *//* caload *//* saload *//* istore *//* lstore *//* fstore *//* dstore *//* astore *//* istore_0 *//* istore_1 *//* istore_2 *//* istore_3 *//* lstore_0 *//* lstore_1 *//* lstore_2 *//* lstore_3 *//* fstore_0 *//* fstore_1 *//* fstore_2 *//* fstore_3 *//* dstore_0 *//* dstore_1 *//* dstore_2 *//* dstore_3 *//* astore_0 *//* astore_1 *//* astore_2 *//* astore_3 *//* iastore *//* lastore *//* fastore *//* dastore *//* aastore *//* bastore *//* castore *//* sastore *//* pop *//* pop2 *//* dup *//* dup_x1 *//* dup_x2 *//* dup2 *//* dup2_x1 *//* dup2_x2 *//* swap *//* iadd *//* ladd *//* fadd *//* dadd *//* isub *//* lsub *//* fsub *//* dsub *//* imul *//* lmul *//* fmul *//* dmul *//* idiv *//* ldiv *//* fdiv *//* ddiv *//* irem *//* lrem *//* frem *//* drem *//* ineg *//* lneg *//* fneg *//* dneg *//* ishl *//* lshl *//* ishr *//* lshr *//* iushr *//* lushr *//* iand *//* land *//* ior *//* lor *//* ixor *//* lxor *//* iinc *//* i2l *//* i2f *//* i2d *//* l2i *//* l2f *//* l2d *//* f2i *//* f2l *//* f2d *//* d2i *//* d2l *//* d2f *//* i2b *//* i2c *//* i2s *//* lcmp *//* fcmpl *//* fcmpg *//* dcmpl *//* dcmpg *//* ifeq *//* ifne *//* iflt *//* ifge *//* ifgt *//* ifle *//* if_icmpeq *//* if_icmpne *//* if_icmplt *//* if_icmpge *//* if_icmpgt *//* if_icmple *//* if_acmpeq *//* if_acmpne *//* goto *//* jsr *//* ret *//* tableswitch *//* lookupswitch *//* ireturn *//* lreturn *//* freturn *//* dreturn *//* areturn *//* return *//* getstatic *//* putstatic *//* getfield *//* putfield *//* invokevirtual *//* invokespecial *//* invokestatic *//* invokeinterface *//* invokedynamic *//* new *//* newarray *//* anewarray *//* arraylength *//* athrow *//* checkcast *//* instanceof *//* monitorenter *//* monitorexit *//* wide *//* multianewarray *//* ifnull *//* ifnonnull *//* goto_w *//* jsr_w *//* breakpoint *//* impdep1 *//* impdep2 */// not instantiable/** Exception constants. ... */LinkageError.classClassCircularityError.classClassFormatError.classExceptionInInitializerError.classIncompatibleClassChangeError.classAbstractMethodError.classIllegalAccessError.classInstantiationError.classNoSuchFieldError.classNoSuchMethodError.classNoClassDefFoundError.classUnsatisfiedLinkError.classVerifyError.classNullPointerException.classArrayIndexOutOfBoundsException.classArithmeticException.classNegativeArraySizeException.classClassCastException.classIllegalMonitorStateException.classClass<Throwable> THROWABLE;/** The mother of all exceptions */Class<RuntimeException> RUNTIME_EXCEPTION;/** Super class of any run-time exception */Class<LinkageError> LINKING_EXCEPTION;/** Super class of any linking exception (aka Linkage Error) */Class<ClassCircularityError> CLASS_CIRCULARITY_ERROR;/** Linking Exceptions */Class<ClassFormatError> CLASS_FORMAT_ERROR;Class<ExceptionInInitializerError> EXCEPTION_IN_INITIALIZER_ERROR;Class<IncompatibleClassChangeError> INCOMPATIBLE_CLASS_CHANGE_ERROR;Class<AbstractMethodError> ABSTRACT_METHOD_ERROR;Class<IllegalAccessError> ILLEGAL_ACCESS_ERROR;Class<InstantiationError> INSTANTIATION_ERROR;Class<NoSuchFieldError> NO_SUCH_FIELD_ERROR;Class<NoSuchMethodError> NO_SUCH_METHOD_ERROR;Class<NoClassDefFoundError> NO_CLASS_DEF_FOUND_ERROR;Class<UnsatisfiedLinkError> UNSATISFIED_LINK_ERROR;Class<VerifyError> VERIFY_ERROR;Class<NullPointerException> NULL_POINTER_EXCEPTION;/** Run-Time Exceptions *///    public static final Class UnsupportedClassVersionError = UnsupportedClassVersionError.class;/* UnsupportedClassVersionError is new in JDK 1.2 */Class<ArrayIndexOutOfBoundsException> ARRAY_INDEX_OUT_OF_BOUNDS_EXCEPTION;Class<ArithmeticException> ARITHMETIC_EXCEPTION;Class<NegativeArraySizeException> NEGATIVE_ARRAY_SIZE_EXCEPTION;Class<ClassCastException> CLASS_CAST_EXCEPTION;Class<IllegalMonitorStateException> ILLEGAL_MONITOR_STATE;...[] EXCS_CLASS_AND_INTERFACE_RESOLUTION;/** Pre-defined exception arrays according to chapters 5.1-5.4 of the Java Virtual ... */...[] EXCS_FIELD_AND_METHOD_RESOLUTION;// Chapter 5.1...[] EXCS_INTERFACE_METHOD_RESOLUTION;// Chapter 5.2...[] EXCS_STRING_RESOLUTION;// Chapter 5.3 (as below)...[] EXCS_ARRAY_EXCEPTION;// Chapter 5.4 (no errors but the ones that _always_ could happen! How stupid.)ExceptionConst$EXCS/** Enum corresponding to the various Exception Class arrays, ... */new EXCS(...)EXCS EXCS_CLASS_AND_INTERFACE_RESOLUTION;EXCS EXCS_FIELD_AND_METHOD_RESOLUTION;EXCS EXCS_INTERFACE_METHOD_RESOLUTION;EXCS EXCS_STRING_RESOLUTION;EXCS EXCS_ARRAY_EXCEPTION;// helper method to merge exception class arraysint extraLenextraClasses.lengthClass<?>[] excsinput.length/** Creates a copy of the specified Exception Class array combined with any additional Exception classes. ... */mergeExceptions(...)/* Copyright (c) 2007, 2020, Oracle and/or its affiliates. All rights reserved. ... */import JavaClassimport SyntheticRepository/** The repository maintains informations about class interdependencies, e.g., ... *//** Set repository instance to be used for class loading *//** Lookup class somewhere found on your CLASSPATH, or whereever the ... *//** Try to find class source using the internal repository instance. ... *//** Clear the repository. *//** Add clazz to repository if there isn't an equally named class already in ... */JavaClass oldstoreClass(...)/** Remove class with given (fully qualified) name from repository. */removeClass(...)/** Remove given class from repository. */getSuperClasses(...)JavaClass jclookupClass(...)getAllInterfaces(...)/** Equivalent to runtime "instanceof" operator. ... */instanceOf(...)implementationOf(...)import Const/** Super class for all objects that have modifiers like private, final, ... I.e. ... */int access_flags;/** Set access flags aka "modifiers". ... */this.access_flagssetAccessFlags(...)Const.ACC_PUBLICConst.ACC_PRIVATEConst.ACC_PROTECTEDConst.ACC_STATICConst.ACC_FINALConst.ACC_SYNCHRONIZEDConst.ACC_VOLATILEConst.ACC_TRANSIENTConst.ACC_NATIVEConst.ACC_INTERFACEConst.ACC_ABSTRACTConst.ACC_STRICTConst.ACC_SYNTHETICConst.ACC_ANNOTATIONConst.ACC_ENUMConst.ACC_VARARGS// Flag is set already// Flag not setimport DataInput/** Represents the default value of a annotation for a method info ... */ElementValue default_value;readElementValue(...)Const.ATTR_ANNOTATION_DEFAULTthis.default_value/** Called by objects that are traversing the nodes of the tree implicitely ... */visitAnnotationDefault(...)AnnotationEntry annotationEntry;// For annotation element values, this is the annotationthis.annotationEntrystringifyValue(...)// u1 type of value (ANNOTATION == '@')/** represents one annotation in the annotation table ... */int type_index;ConstantPool constant_pool;boolean isRuntimeVisible;List<ElementValuePair> element_value_pairs;/* Factory method to create an AnnotionEntry from a DataInput ... */AnnotationEntry annotationEntrynew AnnotationEntry(...)int num_element_value_pairsannotationEntry.element_value_pairsnew ArrayList<ElementValuePair>(...)new ElementValuePair(...)this.type_indexthis.constant_poolthis.isRuntimeVisible/** Called by objects that are traversing the nodes of the tree implicitely defined by the contents of a Java class. ... */visitAnnotationEntry(...)ConstantUtf8 cgetConstant(...)Const.CONSTANT_Utf8new ElementValuePair[]ElementValuePair envpStringBuilder resultElementValuePair[] evPairsgetElementValuePairs(...)getAnnotationType(...)evPairs.lengthElementValuePair elementtoShortString(...)List<AnnotationEntry> accumulatedAnnotationsnew ArrayList<AnnotationEntry>(...)Annotations runtimeAnnotationsgetAnnotationEntries(...)new AnnotationEntry[]// TODO return List// u2 index of type name in cpool// u2 element_value pair// count// Find attributes that contain annotation data/** base class for annotations ... */...[] annotation_table;int annotation_table_lengththis.annotation_tablevisitAnnotation(...)/** returns the array of annotation entries in this annotation */annotation_table.lengthAnnotationEntry element...[] evalues;// For array types, this is the arrayevalues.lengththis.evaluesElementValue evalue// u1 type of value (ARRAY == '[')/** Abstract super class for <em>Attribute</em> objects. Currently the ... */int name_index;// Points to attribute name in constant poolbyte tag;// Content length of attribute field// Tag to distinguish subclassesthis.name_index/** Dump attribute to file stream in binary format. ... */Map<String,Object> readers;/** Add an Attribute reader capable of parsing (user-defined) attributes ... *//** Remove attribute reader ... *//** Class method reads one attribute from the input data stream. This method ... */readAttribute(...)byte tagConst.ATTR_UNKNOWNint name_indexbyte iConst.KNOWN_ATTRIBUTESObject rcreateAttribute(...)new Unknown(...)Const.ATTR_CONSTANT_VALUEnew ConstantValue(...)Const.ATTR_SOURCE_FILEnew SourceFile(...)Const.ATTR_CODEnew Code(...)Const.ATTR_EXCEPTIONSnew ExceptionTable(...)Const.ATTR_LINE_NUMBER_TABLEnew LineNumberTable(...)Const.ATTR_LOCAL_VARIABLE_TABLEnew LocalVariableTable(...)Const.ATTR_INNER_CLASSESnew InnerClasses(...)Const.ATTR_SYNTHETICnew Synthetic(...)Const.ATTR_DEPRECATEDnew Deprecated(...)Const.ATTR_PMGnew PMGClass(...)Const.ATTR_SIGNATUREnew Signature(...)Const.ATTR_STACK_MAPnew StackMap(...)Const.ATTR_RUNTIME_VISIBLE_ANNOTATIONSnew RuntimeVisibleAnnotations(...)Const.ATTR_RUNTIME_INVISIBLE_ANNOTATIONSnew RuntimeInvisibleAnnotations(...)Const.ATTR_RUNTIME_VISIBLE_PARAMETER_ANNOTATIONSnew RuntimeVisibleParameterAnnotations(...)Const.ATTR_RUNTIME_INVISIBLE_PARAMETER_ANNOTATIONSnew RuntimeInvisibleParameterAnnotations(...)new AnnotationDefault(...)Const.ATTR_LOCAL_VARIABLE_TYPE_TABLEnew LocalVariableTypeTable(...)Const.ATTR_ENCLOSING_METHODnew EnclosingMethod(...)Const.ATTR_STACK_MAP_TABLEConst.ATTR_BOOTSTRAP_METHODSnew BootstrapMethods(...)Const.ATTR_METHOD_PARAMETERSnew MethodParameters(...)/** Use copy() if you want to have a deep copy(), i.e., with all references ... */// Get class name from constant pool via `name_index' indirection// Length of data in bytes// Compare strings to find known attribute// found!// Call proper constructor, depending on `tag'// Never reached// never happens/** Unknown (non-standard) attributes may be read via user-defined factory ... *//** When this attribute reader is added via the static method ... *//** This class represents a bootstrap method attribute, i.e., the bootstrap ... */int bootstrap_method_ref;/** Index of the CONSTANT_MethodHandle_info structure in the constant_pool table */...[] bootstrap_arguments;/** Array of references to the constant_pool table *//** Initialize from another object. */getBootstrapMethodRef(...)getBootstrapArguments(...)/** Construct object from input stream. ... */bootstrap_arguments.length// helper methodthis.bootstrap_method_refthis.bootstrap_argumentsStringBuilder bufString bootstrap_method_nameint num_bootstrap_argumentsconstantToString(...)Const.CONSTANT_MethodHandlecompactClassName(...)/** Dump object to file stream in binary format. ... */int bootstrap_argument// TODO should this throw?/** This class represents a BootstrapMethods attribute. ... */...[] bootstrap_methods;/** Initialize from another object. Note that both objects use the same ... */// TODO this could be made final (setter is not used)getNameIndex(...)getBootstrapMethods(...)getConstantPool(...)this.bootstrap_methods/** Construct object from Input stream. ... */int num_bootstrap_methodsnew BootstrapMethod[]new BootstrapMethod(...)visitBootstrapMethods(...)BootstrapMethods cc.bootstrap_methodsbootstrap_methods.lengthsetConstantPool(...)/** Dump bootstrap methods attribute to file stream in binary format. ... */BootstrapMethod bootstrap_methodint idx;// For 'class' this points to the class entry in the cpool// the cpool// For primitive types and string type, this points to the value entry inthis.idxConstantUtf8 cu8// u1 kind of value/** Thrown when the BCEL attempts to read a class file and determines ... */import ZipEntryimport ZipFile/** Wrapper class that parses a given Java .class file. The method <A ... */DataInputStream dataInputStream;boolean fileOwned;String file_name;String zip_file;int class_name_index;int superclass_name_index;int major;int minor;// Compiler version...[] interfaces;// Access rights of parsed class// Names of implemented interfaces// collection of constants// class fields, i.e., its variables...[] attributes;// methods defined in the classboolean is_zip;// attributes defined in the classint BUFSIZE;// Loaded from zip file/** Parse class from the given stream. ... */String clazzthis.file_namethis.dataInputStream/** Parse class from given .class file. ... *//** Parse class from given .class file in a ZIP-archive ... */this.zip_file/** Parse the given Java class file and return an object that represents ... */ZipFile zipZipEntry entrynew ZipFile(...)readID(...)readVersion(...)readConstantPool(...)readClassInfo(...)readInterfaces(...)readMethods(...)readAttributes(...)new JavaClass(...)JavaClass.ZIPJavaClass.FILE/** Read information about the attributes of the class. ... */int attributes_countnew Attribute[]/** Read information about the class and its super class. ... */new ClassFormatException(...)/** Read constant pool entries. ... */new ConstantPool(...)/** Read information about the fields of the class, i.e., its variables. ... */int fields_countnew Field(...)/** Check whether the header of the file is ok. ... *//** ****************** Private utility methods ********************* */Const.JVM_CLASSFILE_MAGIC/** Read information about the interfaces implemented by this class. ... */int interfaces_count/** Read information about the methods of the class. ... */int methods_countnew Method(...)/** Read major and minor version of compiler which created the file. ... */// Not a very clean solution .../** **************** Read headers ******************************* */// Check magic tag of class file// Get compiler version/** **************** Read constant pool and related ************* */// Read constant pool entries// Get class information// Get interface information, i.e., implemented interfaces/** **************** Read class fields and methods ************** */// Read class fields, i.e., the variables of the class// Read class methods, i.e., the functions in the class// Read class attributes// Check for unknown variables//Unknown[] u = Unknown.getUnknownAttributes();//for (int i=0; i < u.length; i++)//  System.err.println("WARNING: " + u[i]);// Everything should have been read now//      if(file.available() > 0) {//        int bytes = file.available();//        byte[] buf = new byte[bytes];//        file.read(buf);//        if(!(is_zip && (buf.length == 1))) {//      System.err.println("WARNING: Trailing garbage at end of " + file_name);//      System.err.println(bytes + " extra bytes: " + Utility.toHexString(buf));// Read everything of interest, so close the file//ignore close exceptions// Return the information we have gathered in a new object/* Interfaces are implicitely abstract, the flag should be set ... *//** This class represents a chunk of Java byte code contained in a ... */int max_stack;int max_locals;// Maximum size of stack used by this method  // TODO this could be made final (setter is not used)...[] code;// Number of local variables  // TODO this could be made final (setter is not used)...[] exception_table;// Actual byte code// Table of handled exceptions// or LocalVariablegetMaxStack(...)getMaxLocals(...)getExceptionTable(...)int code_lengthint exception_table_lengthnew CodeException[]new CodeException(...)this.max_stackthis.max_localsthis.codethis.exception_tablethis.attributescalculateLength(...)visitCode(...)/** Dump code attribute to file stream in binary format. ... */code.lengthexception_table.lengthCodeException exceptiongetInternalLength(...)codeToString(...)Code cc.codec.exception_tablec.attributes// Initialize with some default values which will be overwritten later// Read byte code/* Read exception table that contains all regions where an exception ... *//* Read all attributes, currently `LineNumberTable' and ... *//* Adjust length, because of setAttributes in this(), s.b.  length ... */// Adjust length/* max_stack *//* max_locals *//* code length *//* byte-code *//* exception-table length *//* exception table *//* attributes count *//* attribute header size */// CHECKSTYLE IGNORE MagicNumber/** This class represents an entry in the exception table of the <em>Code</em> ... */int start_pc;int end_pc;// Range in the code the exception handler isint handler_pc;// active. start_pc is inclusive, end_pc exclusiveint catch_type;/* Starting address of exception handler, i.e., ... *//* If this is zero the handler catches any ... */getStartPC(...)getEndPC(...)getHandlerPC(...)getCatchType(...)/** Construct object from file stream. ... */this.start_pcthis.end_pcthis.handler_pcthis.catch_typevisitCodeException(...)/** Dump code exception to file stream in binary format. ... */getConstantString(...)Const.CONSTANT_Class// TODO unusedimport BCELComparator/** Abstract superclass for classes to represent the different constant types in ... */new BCELComparator(...) { ... }Constant$1Constant THISConstant THATBCELComparator bcelComparator;/* In fact this tag is redundant since we can distinguish different ... */getConstantName(...)/** Read one constant from the given input, the type depends on a tag byte. ... */new ConstantClass(...)Const.CONSTANT_Fieldrefnew ConstantFieldref(...)Const.CONSTANT_Methodrefnew ConstantMethodref(...)Const.CONSTANT_InterfaceMethodrefnew ConstantInterfaceMethodref(...)Const.CONSTANT_Stringnew ConstantString(...)Const.CONSTANT_Integernew ConstantInteger(...)Const.CONSTANT_Floatnew ConstantFloat(...)Const.CONSTANT_Longnew ConstantLong(...)Const.CONSTANT_Doublenew ConstantDouble(...)Const.CONSTANT_NameAndTypenew ConstantNameAndType(...)new ConstantMethodHandle(...)Const.CONSTANT_MethodTypenew ConstantMethodType(...)Const.CONSTANT_InvokeDynamicnew ConstantInvokeDynamic(...)/** Return value as defined by given BCELComparator strategy. By default two ... *//** Return value as defined by given BCELComparator strategy. By default ... */// Read tag byte/** Abstract super class for Fieldref, Methodref, InterfaceMethodref and ... */int class_index;// bootstrap_method_attr_index of a ConstantInvokeDynamic.// Note that this field is used to store the/** References to the constants containing the class and the field signature */int name_and_type_index;// This field has the same meaning for all subclasses.getClassIndex(...)getNameAndTypeIndex(...)/** Initialize instance from file data. ... */this.class_indexthis.name_and_type_index/** Dump constant field reference to file stream in binary format. ... *//** This class is derived from the abstract {@link Constant} ... */// Identical to ConstantString except for the namevisitConstantClass(...)/** Dump constant class to file stream in binary format. ... */Constant cgetConstantValue(...)/** This class is derived from the abstract  {@link Constant} ... */double bytes;this.bytesvisitConstantDouble(...)/** Dump constant double to file stream in binary format. ... *//** This class represents a constant pool reference to a field. ... *//** Initialize instance from input data. ... */visitConstantFieldref(...)float bytes;visitConstantFloat(...)/** Dump constant float to file stream in binary format. ... */int bytes;visitConstantInteger(...)/** Dump constant integer to file stream in binary format. ... *//** This class represents a constant pool reference to an interface method. ... */visitConstantInterfaceMethodref(...)getBootstrapMethodAttrIndex(...)/** Called by objects that are traversing the nodes of the tree implicitly ... */visitConstantInvokeDynamic(...)// AKA bootstrap_method_attr_indexlong bytes;visitConstantLong(...)/** Dump constant long to file stream in binary format. ... */int reference_kind;int reference_index;getReferenceKind(...)getReferenceIndex(...)this.reference_kindthis.reference_indexvisitConstantMethodHandle(...)/** Dump method kind and index to file stream in binary format. ... */int descriptor_index;getDescriptorIndex(...)this.descriptor_indexvisitConstantMethodType(...)/** Dump name and signature index to file stream in binary format. ... *//** This class represents a constant pool reference to a method. ... */visitConstantMethodref(...)int signature_index;// Name of field/method// and its signature.getSignatureIndex(...)this.signature_indexvisitConstantNameAndType(...)/** This interface denotes those constants that have a "natural" value, ... *//** This class represents the constant pool, i.e., a table of constants, of ... */...[] constant_pool;/** Read constants from given input stream. ... */int constant_pool_countnew Constant[]readConstant(...)visitConstantPool(...)/** Resolve constant to a string representation. ... */ConstantMethodHandle cmhConstantMethodType cmtConstantInvokeDynamic cidgetStringIndex(...)escape(...)getMethodHandleName(...)char[] ch/** Retrieve constant at `index' from constant pool and resolve it to ... *//** Dump constant pool to file stream in binary format. ... */constant_pool.length/** Get constant from constant pool. ... *//** Get constant from constant pool and check whether it has the ... *//** Get string from constant pool and bypass the indirection of ... */ConstantPool cc.constant_pool/* constant_pool[0] is unused by the compiler and may be used freely ... *//* Quote from the JVM specification: ... */// Note that the ReferenceIndex may point to a Fieldref, Methodref or// InterfaceMethodref - so we need to peek ahead to get the actual type./* This switch() is not that elegant, since the two classes have the ... */// Finally get the string from the constant poolint string_index;// Identical to ConstantClass except for this namethis.string_indexvisitConstantString(...)ConstantUtf8$1printStats(...)String bytes;int considered;// TODO these should perhaps be AtomicInt?int hits;int skipped;int created;int MAX_CACHED_SIZE;// Set the size to 0 or below to skip caching entirelyboolean BCEL_STATISTICS;ConstantUtf8$CACHE_HOLDERnew LinkedHashMap<String,ConstantUtf8>(...) { ... }ConstantUtf8$CACHE_HOLDER$1Map<>.Entry<String,ConstantUtf8>int MAX_CACHE_ENTRIES;int INITIAL_CACHE_CAPACITY;HashMap<String,ConstantUtf8> CACHE;// for accesss by test codenew ConstantUtf8(...)ConstantUtf8.classConstantUtf8 resultCACHE_HOLDER.CACHEvisitConstantUtf8(...)/** Dump String in Utf8 format to file stream. ... */// might be better with a specific lock object/** This class is derived from <em>Attribute</em> and represents a constant ... */int constantvalue_index;getConstantValueIndex(...)this.constantvalue_indexvisitConstantValue(...)/** Dump constant value attribute to file stream on binary format. ... */String bufconvertString(...)ConstantValue c// Print constant to string depending on its type/** This class is derived from <em>Attribute</em> and denotes that this is a ... */visitDeprecated(...)/** Dump source file attribute to file stream in binary format. ... */Deprecated cc.bytes/** Traverses a JavaClass with another Visitor object 'piggy-backed' that is ... */new Stack<Object>(...)JavaClass clazz;Visitor visitor;Stack<Object> stack;predecessor(...)this.visitor/** Start traversal. */Attribute[] attributesAnnotationEntry[] entriesAnnotationEntry entrieCodeException[] tableCodeException elementLineNumber[] numbersgetLineNumberTable(...)LineNumber numberLocalVariable[] varsgetLocalVariableTable(...)LocalVariable varStackMapEntry[] varsgetStackMap(...)StackMapEntry varConstant[] constantsconstants.lengthInnerClass[] icsgetInnerClasses(...)InnerClass ic2getLocalVariableTypeTable(...)/* Copyright (c) 2013, 2017, Oracle and/or its affiliates. All rights reserved. */// size - 1 == current// BootstrapMethod[] bms = bm.getBootstrapMethods();// for (int i = 0; i < bms.length; i++)//     bms[i].accept(this);/** @version ... */ConstantPool cpool;this.cpoolbyte STRING;byte ENUM_CONSTANT;byte CLASS;byte ANNOTATION;byte ARRAY;byte PRIMITIVE_INT;byte PRIMITIVE_BYTE;byte PRIMITIVE_CHAR;byte PRIMITIVE_DOUBLE;byte PRIMITIVE_FLOAT;byte PRIMITIVE_LONG;byte PRIMITIVE_SHORT;byte PRIMITIVE_BOOLEAN;byte typeint numArrayValsElementValue[] evaluesnew ElementValue[]new SimpleElementValue(...)new EnumElementValue(...)new ClassElementValue(...)new AnnotationElementValue(...)new ArrayElementValue(...)// TODO isRuntimeVisible/** an annotation's element value pair ... */ElementValue elementValue;ConstantPool constantPool;int elementNameIndex;this.elementValuethis.elementNameIndexthis.constantPoolgetNameString(...)// u2 name of the element/** Visitor with empty method bodies, can be extended and used in conjunction ... *//** @since ... *//** This attribute exists for local or ... */int classIndex;// innermost class that encloses the declaration of the current class.// Pointer to the CONSTANT_Class_info structure representing theint methodIndex;// lexically enclosing method that includes the local/anonymous class.// ensure that the method identified by this index is the closest// to in the class_index.  *It is the compiler responsibility* to// type of a method in the class referenced by the class we point// CONSTANT_NameAndType_info structure representing the name and the// Otherwise, the value of the  method_index item must point to a// constructor, then the value of the method_index item must be zero.// If the current class is not immediately enclosed by a method or// Ctors - and code to read an attribute in.visitEnclosingMethod(...)// AccessorsConstantClass cConstantNameAndType natint typeIdx;// For enum types, these two indices point to the type and valueint valueIdx;this.typeIdxthis.valueIdx// u1 type of value (ENUM_CONSTANT == 'e')// u2// Utility.signatureToString(cu8.getBytes());/** This class represents the table of exceptions that are thrown by a ... */...[] exception_index_table;// constant poolgetExceptionIndexTable(...)this.exception_index_tableint number_of_exceptionsvisitExceptionTable(...)/** Dump exceptions attribute to file stream in binary format. ... */exception_index_table.lengthExceptionTable cc.exception_index_table/** This class represents the field info structure, i.e., the representation ... */Field$1Field THISField THATvisitField(...)/** Return string representation close to declaration format, ... */String accessConstantValue cvaccessToString(...)getAccessFlags(...)signatureToString(...)copy_(...)/** Return value as defined by given BCELComparator strategy. ... */// Short cuts to constant pool// Get names from constant pool/** Abstract super class for fields and methods. ... */// Points to field name in constant pool// Points to encoded signatureint attributes_count;// Collection of attributes...[] annotationEntries;// @since 6.0// No. of attributes// annotations defined on the field or methodString signatureAttributeString;boolean searchedForSignatureAttribute;/** Dump object to file stream on binary format. ... */this.attributes_countFieldOrMethod cc.attributes_countcreateAnnotationEntries(...)/** Hunts for a signature attribute on the member and returns its contents. ... */// ignored, but will cause NPE .../** This class represents a inner class attribute, i.e., the class ... */int inner_class_index;int outer_class_index;int inner_name_index;int inner_access_flags;getInnerClassIndex(...)getOuterClassIndex(...)getInnerNameIndex(...)getInnerAccessFlags(...)this.inner_class_indexthis.outer_class_indexthis.inner_name_indexthis.inner_access_flagsvisitInnerClass(...)/** Dump inner class attribute to file stream in binary format. ... */String outer_class_nameString inner_nameString inner_class_name/** This class is derived from <em>Attribute</em> and denotes that this class ... */...[] inner_classes;this.inner_classesnew InnerClass[]int number_of_classesnew InnerClass(...)visitInnerClasses(...)inner_classes.lengthInnerClass inner_classInnerClasses cc.inner_classes// TODO this could be recoded to use a lower level constructor after creating a copy of the inner classesimport ClassQueueimport SecuritySupport/** Represents a Java class, i.e., the data structures, constant pool, fields, ... */JavaClass$1JavaClass THISJavaClass THATString package_name;String source_file_name;String class_name;String superclass_name;// Constant pool...[] interface_names;// implemented interfaces// Fields, i.e., variables of class...[] annotations;byte source;// annotations defined on the classboolean isAnonymous;// Generated in memoryboolean isNested;boolean computedNestedTypeStatus;byte HEAP;byte FILE;byte ZIP;/** In cases where we go ahead and create something, use the default ... *//** Constructor gets all contents as arguments. ... */this.class_name_indexthis.superclass_name_indexthis.interfacesthis.methodsthis.sourcegetSourceFileName(...)visitJavaClass(...)/** Dump class to a file. ... */String parentmkdirs(...)DataOutputStream dos/** Dump class to a file named file_name. ... */ByteArrayOutputStream sDataOutputStream dsIOException e2/** Dump Java class to output stream in binary format. ... */int interface1/** returns the super class name of this class. In the case that this class ... */this.class_name/** Set File name of class, aka SourceFile attribute value */this.interface_names/** Set absolute path to file this class was read from. */this.source_file_namethis.superclass_nameAnnotationEntry[] annotationsclassOrInterface(...)isSuper(...)annotations.lengthAnnotationEntry annotationJavaClass cc.interfacesc.interface_namesc.fieldsc.methodsConst.ACC_SUPERcomputeNestedTypeStatus(...)this.isAnonymousthis.isNestedInnerClass[] innerClassesInnerClass innerClasseboolean innerClassAttributeRefersToMethis.computedNestedTypeStatus/** Gets the ClassRepository which holds its definition. By default this is ... *//** ******************* New repository functionality ******************** *//** Sets the ClassRepository which loaded the JavaClass. Should be called ... */JavaClass[] super_classesJavaClass super_classeJavaClass[] super_interfacesJavaClass super_interfacegetSuperclassName(...)JavaClass clazzList<JavaClass> allSuperClassesnew ArrayList<JavaClass>(...)getSuperClass(...)new JavaClass[]/** Get interfaces directly implemented by this JavaClass. */String[] _interfacesgetInterfaceNames(...)JavaClass[] classes_interfaces.length/** Get all interfaces implemented by this JavaClass (transitively). */ClassQueue queuenew ClassQueue(...)Set<JavaClass> allInterfacesnew TreeSet<JavaClass>(...)JavaClass souperJavaClass[] _interfacesJavaClass _interface/** Return the natural ordering of two JavaClasses. This ordering is based on ... */// Get source file name if available/* According to the specification the following entries must be of type ... */// May be zero -> class is java.lang.Object// either was not created or already existed/** This class represents a (PC offset, line number) pair, i.e., a line number in ... */short start_pc;/** Program Counter (PC) corresponds to line */short line_number;/** number in source file *//** Initialize from another object. ... */this.line_numbervisitLineNumber(...)/** Dump line number/pc pair to file stream in binary format. ... *//** This class represents a table of line numbers for debugging purposes. This ... */int MAX_LINE_LENGTH;...[] line_number_table;/* Initialize from another object. Note that both objects use the same ... */// Table of line/numbers pairs/* @param name_index Index of name ... */this.line_number_tableint line_number_table_lengthnew LineNumber[]new LineNumber(...)visitLineNumberTable(...)/** Dump line number table attribute to file stream in binary format. ... */line_number_table.lengthLineNumber lineNumberStringBuilder lineSecuritySupport.NEWLINE/** Map byte code positions to source code lines. ... */int min_indexLineNumberTable cc.line_number_table/* Do a binary search since the array is ordered. *//* If exact match can't be found (which is the most common case) ... *//* It's possible that we did not find any valid entry for the bytecode ... */// TODO could use the lower level constructor and thereby allow// line_number_table to be made final/** This class represents a local variable within a method. It contains its ... */// Range in which the variable is valid// Index in constant pool of variable name// Index of variable signature/* Variable is `index'th local variable on ... */visitLocalVariable(...)/** Dump local variable to file stream in binary format. ... *//* Helper method shared with LocalVariableTypeTable */String labeltoStringShared(...)/** This class represents colection of local variables in a ... */...[] local_variable_table;// variablesthis.local_variable_tableint local_variable_table_lengthnew LocalVariable[]new LocalVariable(...)visitLocalVariableTable(...)/** Dump local variable table attribute to file stream in binary format. ... */local_variable_table.lengthLocalVariable variableint start_pcint end_pcLocalVariableTable cc.local_variable_table// J5TODO: Needs some testing !//    } local_variable_type_table[local_variable_type_table_length];//      u2 index;//      u2 signature_index;//      u2 name_index;//      u2 length;//      u2 start_pc;//    {//    u2 local_variable_type_table_length;//    u4 attribute_length;//    u2 attribute_name_index;//LocalVariableTypeTable_attribute {//       } local_variable_table[local_variable_table_length];//          u2 index;//          u2 descriptor_index;//          u2 name_index;//          u2 length;//       {  u2 start_pc;//       u2 local_variable_table_length;//       u4 attribute_length;//       u2 attribute_name_index;//LocalVariableTable_attribute {// The new table is used when generic types are about......[] local_variable_type_table;this.local_variable_type_tableint local_variable_type_table_lengthvisitLocalVariableTypeTable(...)local_variable_type_table.lengthLocalVariableTypeTable cc.local_variable_type_table/** This class represents the method info structure, i.e., the representation for ... */Method$1Method THISMethod THAT...[] parameterAnnotationEntries;// annotations defined on the parameters of a method/** Empty constructor, all attributes have to be defined via `setXXX' ... */visitMethod(...)Code code/** Return string representation close to declaration format, e.g. ... */ExceptionTable emethodSignatureToString(...)getArgumentTypes(...)createParameterAnnotationEntries(...)// Get name and signature from constant pool/** Entry of the parameters table. ... *//** Index of the CONSTANT_Utf8_info structure in the constant_pool table representing the name of the parameter *//** The access flags *//** Returns the name of the parameter. */Const.ACC_MANDATED/** This class represents a MethodParameters attribute. ... */new MethodParameter[]...[] parameters;int parameters_countnew MethodParameter(...)this.parametersvisitMethodParameters(...)MethodParameters cc.parameters/** Dump method parameters attribute to file stream in binary format. ... */MethodParameter parameter/** Denote class to have an accept method(); ... *//** This class is derived from <em>Attribute</em> and represents a reference ... */int pmg_class_index;int pmg_index;getPMGIndex(...)getPMGClassIndex(...)this.pmg_indexthis.pmg_class_indexgetPMGClassName(...)getPMGName(...)/** represents one parameter annotation in the parameter annotation table ... */visitParameterAnnotationEntry(...)AnnotationEntry entryList<ParameterAnnotationEntry> accumulatedAnnotationsnew ArrayList<ParameterAnnotationEntry>(...)ParameterAnnotations runtimeAnnotationsgetParameterAnnotationEntries(...)new ParameterAnnotationEntry[]// Find attributes that contain parameter annotation data/** base class for parameter annotations ... */...[] parameter_annotation_table;/** Table of parameter annotations */int num_parametersnew ParameterAnnotationEntry(...)this.parameter_annotation_tablevisitParameterAnnotation(...)/** returns the array of parameter annotation entries in this parameter annotation */parameter_annotation_table.lengthParameterAnnotationEntry element/** represents an annotation that is represented in the class file but is not ... */writeAnnotations(...)/** Represents a parameter annotation that is represented in the class file ... *//** represents an annotation that is represented in the class file and is ... */visitSignature(...)Signature$MyByteArrayInputStream/** Extends ByteArrayInputStream to make 'unreading' chars possible. */int chStringBuilder buf2identStart(...)unread(...)matchIdent(...)matchGJIdent(...)new MyByteArrayInputStream(...)// @since 6.0 is no longer final//System.err.println("Visiting non-standard Signature object");//System.out.println("return from ident:" + (char)ch);// Ok, formal parameter//System.out.println("so far:" + buf2 + ":next:" +(char)ch);//System.out.println("within ident:"+ (char)ch);//System.out.println("regular return ident:"+ (char)ch + ":" + buf2);// Parameterized or method//System.out.println("Enter <");// List of parameters//System.out.println("Still no >");// Recursive call//System.out.println("Exit >");//System.out.println("Sig:" + s);ConstantInteger cConstantLong jConstantFloat fConstantDouble dConstantInteger boConstantInteger s// Whatever kind of value it is, return it as a stringConstantPool cpoolint _typeConstantInteger bConstantInteger chint sourcefile_index;getSourceFileIndex(...)this.sourcefile_indexvisitSourceFile(...)/** This class represents a stack map attribute used for ... */// Table of stack map entriesthis.mapint map_lengthnew StackMapEntry[]new StackMapEntry(...)map.lengthStackMapEntry entryStackMapEntry elementgetMapEntrySize(...)StackMap cc.mapvisitStackMap(...)// Length of 'number_of_entries' field prior to the array of stack maps/** This class represents a stack map entry recording the types of ... */int frame_type;int byte_code_offset;...[] types_of_locals;...[] types_of_stack_items;Const.SAME_FRAMEConst.SAME_FRAME_MAXConst.SAME_LOCALS_1_STACK_ITEM_FRAMEConst.SAME_LOCALS_1_STACK_ITEM_FRAME_MAXnew StackMapType[]new StackMapType(...)Const.SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDEDConst.CHOP_FRAMEConst.CHOP_FRAME_MAXConst.SAME_FRAME_EXTENDEDConst.APPEND_FRAMEConst.APPEND_FRAME_MAXint number_of_localsConst.FULL_FRAMEint number_of_stack_items/** DO NOT USE ... */this.byte_code_offsetthis.types_of_localsthis.types_of_stack_items/** Create an instance ... */this.frame_type/** Dump stack map entry ... */StackMapType typetypes_of_locals.lengthtypes_of_stack_items.length/** Calculate stack map entry size */hasIndex(...)StackMapType types_of_localStackMapType types_of_stack_item/** Update the distance (as an offset delta) from this StackMap ... */setByteCodeOffset(...)StackMapEntry eCloneNotSupportedException exe.types_of_localse.types_of_stack_itemsvisitStackMapEntry(...)/* Can't happen */// nothing to be done// CHECKSTYLE IGNORE EmptyBlock/** This class represents the type of a local variable or item on stack ... */byte type;// Index to CONSTANT_Class or offsetConst.ITEM_BogusConst.ITEM_NewObject/** Dump type entries to file. ... */Const.ITEM_ObjectprintIndex(...)getItemName(...)/** This class is derived from <em>Attribute</em> and declares this class as ... */visitSynthetic(...)Synthetic c/** This class represents a reference to an unknown (i.e., ... */new HashMap<String,Unknown>(...)Map<String,Unknown> unknown_attributes;Unknown[] unknownsnew Unknown[]/** Create a non-standard attribute. ... */visitUnknown(...)/** Dump unknown bytes to file stream. ... */Unknown c/** When this attribute reader is added via the static method Attribute.addAttributeReader, ... */import CharArrayReaderimport CharArrayWriterimport FilterReaderimport FilterWriterimport Readerimport Writerimport GZIPInputStreamimport GZIPOutputStreamimport ByteSequence// @since 6.0 methods are no longer final/** Utility functions that do not really belong to any class in particular. ... */new ThreadLocal<Integer>(...) { ... }Utility$1ThreadLocal<Integer> consumed_chars;boolean wide;/* How many chars have been consumed ... *//** Convert bit field of flags into string such as `static final'. ... *//* The `WIDE' instruction is used in the ... */Const.MAX_ACC_FLAGpow2(...)getAccessName(...)/** Disassemble a byte array of JVM byte codes starting from code line ... */ByteSequence streamnew ByteSequence(...)String indicesfillup(...)/** Disassemble a stream of byte codes and return the string representation. ... */short opcodeint default_offsetint highint npairsint vindexint constantint[] matchint[] jump_tableint no_pad_bytesgetOpcodeName(...)Const.TABLESWITCHConst.LOOKUPSWITCHint nargsjump_table.lengthConst.GOTOConst.IFEQConst.IFGEConst.IFGTConst.IFLEConst.IFLTConst.JSRConst.IFNEConst.IFNONNULLConst.IFNULLConst.IF_ACMPEQConst.IF_ACMPNEConst.IF_ICMPEQConst.IF_ICMPGEConst.IF_ICMPGTConst.IF_ICMPLEConst.IF_ICMPLTConst.IF_ICMPNEConst.GOTO_WConst.JSR_WConst.ALOADConst.ASTOREConst.DLOADConst.DSTOREConst.FLOADConst.FSTOREConst.ILOADConst.ISTOREConst.LLOADConst.LSTOREConst.RETConst.WIDEConst.NEWARRAYConst.GETFIELDConst.GETSTATICConst.PUTFIELDConst.PUTSTATICConst.NEWConst.CHECKCASTConst.INSTANCEOFConst.INVOKESPECIALConst.INVOKESTATICConst.INVOKEVIRTUALConst.INVOKEINTERFACEConst.INVOKEDYNAMICConst.LDC_WConst.LDC2_WConst.LDCConst.ANEWARRAYConst.MULTIANEWARRAYConst.IINCgetNoOfOperands(...)getOperandTypeCount(...)getOperandType(...)Const.T_BYTEConst.T_SHORTConst.T_INT/** Shorten long class names, <em>java/lang/String</em> becomes ... *//** Shorten long class name <em>str</em>, i.e., chop off the <em>prefix</em>, ... */int bit/** Converts string containing the method return and argument types to a byte ... */methodSignatureArgumentTypes(...)List<String> vecunwrap(...)StringIndexOutOfBoundsException emethodSignatureReturnType(...)/** Converts method signature to string with all class names compacted. ... *//** A returntype signature represents the return value from a method. It is a ... */int var_indexString param_typeLocalVariable lgetLocalVariable(...)// Guess what this does/** Replace all occurrences of <em>old</em> in <em>str</em> with ... */int old_index/** Converts signature to string with all class names compacted. ... *//** The field signature represents the value of an argument to a function or ... */int fromIndexint bracketIndexStringBuilder typeint consumed_charsUtility.consumed_charsStringBuilder bracketsint _temp/** Parse Java type such as "char", or "java.lang.String[]" and return the ... */char[] charsboolean char_foundboolean delimint bracketscountBrackets(...)Const.T_BOOLEANConst.T_VOIDgetShortTypeName(...)boolean open/** Return type of method signature as a byte value as defined in ... */typeOfSignature(...)/** Return type of signature as a byte value as defined in <em>Constants</em> ... */Const.T_CHARConst.T_DOUBLEConst.T_FLOATConst.T_LONGConst.T_REFERENCEConst.T_ARRAY/** Map opcode names to opcode numbers. E.g., return Constants.ALOAD for ... */Const.OPCODE_NAMES_LENGTH/** Convert (signed) byte to (unsigned) short value, i.e., all negative ... *//** Convert bytes into hexadecimal string ... */short bbyteToShort(...)/** Return a string for an integer justified left or right and filled up with ... *//** Fillup char with up to length characters with char `fill' and justify it ... */printArray(...)/** Encode byte array it into Java identifier string, i.e., a string that ... */CharArrayWriter cawnew CharArrayWriter(...)GZIPOutputStream gosnew GZIPOutputStream(...)JavaWriter jwnew JavaWriter(...)int in/** Decode a string back to a byte array. ... */JavaReader jrnew JavaReader(...)new CharArrayReader(...)ByteArrayOutputStream bosGZIPInputStream gisnew GZIPInputStream(...)int FREE_CHARS;// A-Z, g-z, _, $...[] CHAR_MAP;...[] MAP_CHAR;char ESCAPE_CHAR;// Reverse map/** Decode characters into bytes. Used by <a ... */char[] tmp/** Encode bytes into valid java identifier characters. Used by <a ... */tmp.length/** Escape all occurences of newline chars '\n', quotes \", etc. */char element// Loop through known flags/* Special case: Classes compiled with new compilers and with the ... */// Should be sufficient // CHECKSTYLE IGNORE MagicNumber/* Special case: Skip (0-3) padding bytes, i.e., the ... */// Both cases have a field default_offset in common/* Table switch has variable length arguments. *//* Lookup switch has variable length arguments. *//* Two address bytes + offset from start of byte stream form the ... *//* 32-bit wide jumps *//* Index byte references local variable (register) */// Clear flag/* Remember wide byte which is used to form a 16-bit address in the ... *//* Array of basic type. *//* Access object/class fields. *//* Operands are references to classes in constant pool *///$FALL-THROUGH$/* Operands are references to methods in constant pool */// With Java8 operand may be either a CONSTANT_Methodref// or a CONSTANT_InterfaceMethodref.   (markro)// historical, redundant// Last byte is a reserved space// Thrid byte is a reserved space/* Operands are references to items in constant pool *//* Array of references. *//* Multidimensional array of references. *//* Increment local variable. */// Is `/' on all systems, even DOS// If string starts with `prefix' and contains no further dots// Read all declarations between for `(' and `)'// current string position//corrected concurrent private static field acess// update position// Should never occur// Read return type after `)'// May be an empty string// `old' found in str// String start offset// While we have something to replace// append prefix// append replacement// Skip `old'.length chars// append rest of string// Should not occur// This is the default, read just one char like `B'// TypeVariableSignature// Look for closing `;'// "Tblabla;" `T' and `;' are removed// Full class name// should this be a while loop? can there be more than// one generic clause?  (markro)// generic type?// check to see if there are any TypeArguments// just a class identifier// "Lblabla;" `L' and `;' are removed// we have TypeArguments; build up partial result// as we recurse for each TypeArgument// Shadows global var// check for wildcards// must be at end of signature// remove final "*>;"// get the first TypeArgument// update our consumed count by the number of characters the for type argument// are there more TypeArguments?// remove final ">;"// Array declaration// Accumulate []'s// Count opening brackets and look for optional size argument// Remember value// The rest of the string denotes a `<field_type>'//Utility.consumed_chars += consumed_chars; is replaced by:// Don't care// Normalize to unsigned// Rough estimate// Normal escape// Escape character// Special escape/** Interface to make use of the Visitor pattern programming style. I.e. a class ... *//** AALOAD - Load reference from array ... *//** Load reference from array */Const.AALOAD/** Call corresponding visitor method(s). The order is: ... */visitStackProducer(...)visitExceptionThrower(...)visitTypedInstruction(...)visitArrayInstruction(...)visitAALOAD(...)/** AASTORE -  Store into reference array ... *//** Store into reference array */Const.AASTOREvisitStackConsumer(...)visitAASTORE(...)/** ACONST_NULL - Push null reference ... *//** Push null reference */Const.ACONST_NULLvisitPushInstruction(...)visitACONST_NULL(...)/** ALOAD - Load reference from local variable ... *//** Empty constructor needed for the Class.newInstance() statement in ... */Const.ALOAD_0/** Load reference from local variable ... */visitALOAD(...)import ExceptionConst/** ANEWARRAY -  Create new array of references ... */createExceptions(...)ExceptionConst.EXCS.EXCS_CLASS_AND_INTERFACE_RESOLUTIONExceptionConst.NEGATIVE_ARRAY_SIZE_EXCEPTIONExceptionConst.EXCSvisitLoadClass(...)visitAllocationInstruction(...)visitCPInstruction(...)visitANEWARRAY(...)getBasicType(...)/** ARETURN -  Return reference from method ... *//** Return reference from method */Const.ARETURNvisitReturnInstruction(...)visitARETURN(...)/** ARRAYLENGTH -  Get length of array ... *//** Get length of array */Const.ARRAYLENGTHExceptionConst.NULL_POINTER_EXCEPTIONvisitARRAYLENGTH(...)/* since 6.0 *//** ASTORE - Store reference into local variable ... */Const.ASTORE_0/** Store reference into local variable ... *//** Call corresponding visitor method(s). The order is: Call visitor methods ... */visitASTORE(...)/** ATHROW -  Throw exception ... *//** Throw exception */Const.ATHROWExceptionConst.THROWABLEvisitUnconditionalBranch(...)visitATHROW(...)/** Denote family of instructions that allocates space in the heap. ... */import AnnotationElementValueimport ElementValueAnnotationEntryGen a;this.anew AnnotationEntryGen(...)getAnnotationEntry(...)getElementValueType(...)/** Return immutable variant of this AnnotationElementValueGen */import AnnotationEntryimport ConstantUtf8import ElementValuePairimport RuntimeInvisibleAnnotationsimport RuntimeInvisibleParameterAnnotationsimport RuntimeVisibleAnnotationsimport RuntimeVisibleParameterAnnotationsint typeIndex;List<ElementValuePairGen> evs;ConstantPoolGen cpool;/** Here we are taking a fixed annotation of type Annotation and building a ... */addUtf8(...)getAnnotationTypeIndex(...)isRuntimeVisible(...)copyValues(...)List<ElementValuePairGen> outnew ArrayList<ElementValuePairGen>(...)ElementValuePair nvpnew ElementValuePairGen(...)/** Retrieve an immutable version of this AnnotationGen */AnnotationEntry aElementValuePairGen elementaddElementNameValuePair(...)getElementNameValuePair(...)this.typeIndexAnnotationEntryGen aint elemValuePairCounta.typeIndexint nidxElementValuePairGen envpConstantUtf8 utf8getTypeSignature(...)/** Returns list of ElementNameValuePair objects *//** Converts a list of AnnotationGen objects into a set of attributes ... */annotationEntryGens.lengthint countVisibleint countInvisibleByteArrayOutputStream rvaBytesByteArrayOutputStream riaBytesbyte[] rvaDatabyte[] riaDataint rvaIndexint riaIndexList<Attribute> newAttributesnew ArrayList<Attribute>(...)DataOutputStream rvaDosDataOutputStream riaDosrvaData.lengthriaData.length/** Annotations against a class are stored in one of four attribute kinds: ... */int[] visCountvec.lengthint totalVisCountint[] invisCountint totalInvisCountAnnotationEntryGen element// u2 element_value pair count// ConstantClass c = (ConstantClass)cpool.getConstant(typeIndex);/* c.getNameIndex() */// BCELBUG: Should I use this instead?// Utility.signatureToString(getTypeSignature());//  put the annotations in the right output stream// put the annotations in the right output stream/* Array of lists, array size depends on #params */// Lets do the visible ones// First goes number of parameters// Lets do the invisible ones/** Super class for the family of arithmetic instructions. ... */short _opcodegetOpcode(...)Const.DADDConst.DDIVConst.DMULConst.DNEGConst.DREMConst.DSUBConst.FADDConst.FDIVConst.FMULConst.FNEGConst.FREMConst.FSUBConst.IADDConst.IANDConst.IDIVConst.IMULConst.INEGConst.IORConst.IREMConst.ISHLConst.ISHRConst.ISUBConst.IUSHRConst.IXORConst.LADDConst.LANDConst.LDIVConst.LMULConst.LNEGConst.LORConst.LREMConst.LSHLConst.LSHRConst.LSUBConst.LUSHRConst.LXORnew ClassGenException(...)import ArrayElementValueList<ElementValueGen> evalues;// modify ...// J5TODO: Should we make this an array or a list? A list would be easier tonew ArrayList<ElementValueGen>(...)ElementValue datum/** Return immutable variant of this ArrayElementValueGen */ElementValue[] immutableDataElementValueGen elementgetElementValue(...)ElementValue[] ingetElementValuesArray(...)ElementValue elementString comma/** Super class for instructions dealing with array access such as IALOAD. ... */ExceptionConst.EXCS.EXCS_ARRAY_EXCEPTIONConst.IALOADConst.IASTOREConst.CALOADConst.CASTOREType.CHARConst.BALOADConst.BASTOREConst.SALOADConst.SASTOREConst.LALOADConst.LASTOREConst.DALOADConst.DASTOREConst.FALOADConst.FASTORE/** Denotes array type, such as int[][] ... */int dimensions;Type basic_type;/** Convenience constructor for array type, e.g. int[] ... *//** Convenience constructor for reference array type, e.g. Object[] ... *//** Constructor for array of given type ... */Const.MAX_BYTEArrayType arraythis.dimensionsarray.dimensionsarray.basic_typesetSignature(...)new ArrayType(...)// Basic type or reference/** BALOAD - Load byte or boolean from array ... *//** Load byte or boolean from array */visitBALOAD(...)/** BASTORE - Store into byte or boolean array ... *//** Store byte or boolean into array */visitBASTORE(...)/** BIPUSH - Push byte on stack ... */byte b;/** Push byte on stack */Const.BIPUSHthis.b/** Dump instruction as byte code to stream out. *//** Read needed data (e.g. index) from file. */visitConstantPushInstruction(...)visitBIPUSH(...)/** BREAKPOINT, JVM dependent, ignored by default ... */Const.BREAKPOINTvisitBREAKPOINT(...)/** Denotes basic type such as int. ... *//** Constructor for basic types such as int, long, `void' ... */// @since 6.0 no longer final/** BranchHandle is returned by specialized InstructionList.append() whenever a ... */BranchInstruction bi;// See BCEL-273// This is also a cache in case the InstructionHandle#swapInstruction() method is used// An alias in fact, but saves lots of castsBranchHandle bh_list;/** Factory methods. */// List of reusable handlesBranchHandle bhnew BranchHandle(...)setInstruction(...)/** Handle adds itself to the list of resuable handles. */setNext(...)/* Override InstructionHandle methods: delegate to branch instruction. ... */updatePosition(...)/** Pass new target to instruction. *//** Update target of instruction. */updateTarget(...)/** Set new contents. Old instruction is disposed and may not be used ... */// Original code: i_position = bi.position = pos;// This is only done in order to apply the additional type check; could be merged with super impl.// TODO could be package-protected?/** Abstract super class for branching instructions like GOTO, IFEQ, etc.. Branch ... */InstructionHandle target;// Branch target relative to this instructionint position;// Target object in instruction list// Byte code offset/** Common super constructor ... *//** Dump instruction as byte code to stream out. ... */getTargetOffset(...)isValidShort(...)/** Called by InstructionList.setPositions when setting the position for ... *//** Long output format: ... */getInstruction(...)/** Read needed data (e.g. index) from file. Conversion to a ... *//** Set branch target ... */notifyTarget(...)/** Used by BranchInstruction, LocalVariableGen, CodeExceptionGen, ... */removeTargeter(...)addTargeter(...)/** Inform target that it's not targeted anymore. */this.position// May be negative, i.e., point backwards// I'm more interested in the address of the target then// the instruction located there.//t = target.getInstruction().toString(false); // Avoid circles// index = getTargetOffset();  crashes if positions haven't been set// t = "" + (index + position);/** CALOAD - Load char from array ... *//** Load char from array */visitCALOAD(...)/** CASTORE -  Store into char array ... *//** Store char into array */visitCASTORE(...)/** CHECKCAST - Check whether object is of given type ... *//** Check whether object is of given type ... */ExceptionConst.CLASS_CAST_EXCEPTIONvisitCHECKCAST(...)import ConstantClassimport ConstantPool/** Abstract super class for instructions that use an index into the constant ... */// index to constant pool/** Read needed data (i.e., index) from file. ... *//** Set the index to constant pool. ... */ConstantPool cpimport ClassElementValueElementValueGen.CLASS/** Return immutable variant of this ClassElementValueGen */getClassString(...)// this.idx = cpool.addClass(t);// idx = cpool.addClass(value.getClassString());// ConstantClass c = (ConstantClass)getConstantPool().getConstant(idx);// ConstantUtf8 utf8 =// (ConstantUtf8)getConstantPool().getConstant(c.getNameIndex());// return utf8.getBytes();import AccessFlagsimport Annotationsimport SourceFile/** Template class for building up a java class. May be initialized with an ... */Const.MAJORConst.MINORnew ArrayList<Field>(...)new ArrayList<Method>(...)new ArrayList<AnnotationEntryGen>(...)ClassGen$1ClassGen THISClassGen THAT/* Corresponds to the fields found in a JavaClass object. */String super_class_name;ConstantPoolGen cp;List<Field> field_vec;// ArrayLists instead of arrays to gather fields, methods, etc.// Template for building up constant poolList<Method> method_vec;List<Attribute> attribute_vec;List<String> interface_vec;List<AnnotationEntryGen> annotation_vec;BCELComparator _cmp;/** Convenience constructor to set up some important values initially. ... */this.super_class_namethis.cpaddClass(...)String interface1addInterface(...)new ConstantPoolGen(...)/** Initialize with existing class. ... */AnnotationEntryGen[] annotationsunpackAnnotations(...)String[] interfacesgetClassNameIndex(...)getSuperclassNameIndex(...)AnnotationEntryGen annotationaddAnnotationEntry(...)addMethod(...)addField(...)/** Look for attributes representing annotations and unpack them. */List<AnnotationEntryGen> annotationGenObjsRuntimeVisibleAnnotations rvaAnnotationEntry[] annosRuntimeInvisibleAnnotations rianew AnnotationEntryGen[]int[] interfacesConstantPool _cpgetFinalConstantPool(...)Attribute[] annAttributesgetAnnotationAttributes(...)annAttributes.length/** Add an interface to this class, i.e., this class has to implement it. ... *//** Remove an interface from this class. ... *//** Set major version number of class file, default value is 45 (JDK 1.1) ... *//** Set minor version number of class file, default value is 3 (JDK 1.1) ... *//** Add an attribute to this class. ... *//** Add a method to this class. ... *//** Convenience method. ... */InstructionList ilnew InstructionList(...)MethodGen mgnew MethodGen(...)Type.VOIDInstructionConst.THISnew INVOKESPECIAL(...)addMethodref(...)InstructionConst.RETURNsetMaxStack(...)/** Add a field to this class. ... *//** Remove an attribute from this class. ... *//** Remove a method from this class. ... *//** Replace given method with new one. If the old one does not exist add the ... *//** Replace given field with new one. If the old one does not exist add the ... *//** Remove a field to this class. ... *///  J5TODO: Should we make calling unpackAnnotations() lazy and put it in here?List<ClassObserver> observers;/** Add observer for this object. */new ArrayList<ClassObserver>(...)/** Remove observer for this object. *//** Call notify() method on all observers. This method is not called ... */ClassObserver observer// Put everything needed by default into the constant pool and the vectors// J5TODO: Could make unpacking lazy, done on first reference// TODO: Sometime later, trash any attributes called 'RuntimeVisibleAnnotations' or 'RuntimeInvisibleAnnotations'// Must be last since the above calls may still add something to it// TODO could be package-protected - only called by test code// Push `this'/** Thrown on internal errors. Extends RuntimeException so it hasn't to be declared ... *//** Implement this interface if you're interested in changes to a ClassGen object ... */import CodeException/** This class represents an exception handler, i.e., specifies the region where ... */InstructionHandle start_pc;InstructionHandle end_pc;InstructionHandle handler_pc;ObjectType catch_type;/** Add an exception handler, i.e., specify region where a handler is active ... */setStartPC(...)setEndPC(...)setHandlerPC(...)/** Get CodeException object.<BR> ... *//* Set start of handler ... *//* Set end of handler ... *//* Set handler code ... */boolean targeted/** Sets the type of the Exception to catch. Set 'null' for ANY. *//** Gets the type of the Exception to catch, 'null' for ANY. *//** Wrapper class for `compound' operations, virtual instructions that ... */import ConstantCPimport ConstantDoubleimport ConstantFieldrefimport ConstantFloatimport ConstantIntegerimport ConstantInterfaceMethodrefimport ConstantInvokeDynamicimport ConstantLongimport ConstantMethodrefimport ConstantNameAndTypeimport ConstantString/** This class is used to build up a constant pool. The user adds constants via ... */new HashMap<String,Index>(...)...[] constants;String METHODREF_DELIM;// First entry (0) used by JVMString IMETHODREF_DELIM;String FIELDREF_DELIM;String NAT_DELIM;ConstantPoolGen$Index// Name and Type/** Initialize with given array of constants. ... */cs.lengthConstantString sConstantUtf8 u8new Index(...)ConstantClass sConstantNameAndType nConstantUtf8 u8_2ConstantUtf8 uConstantCP mString class_nameString method_nameString delimConstantClass clazz/** Initialize with given constant pool. *//** Create empty constant pool. *//** Resize internal array of constants. */Constant[] csMap<String,Index> string_table;/** Look for ConstantString in ConstantPool containing String `str'. ... */Index indexindex.index/** Add a new String constant to the ConstantPool, if it is not already in ... */int utf8lookupString(...)adjustSize(...)Map<String,Index> class_table;/** Look for ConstantClass in ConstantPool named `str'. ... *//** Add a new Class reference to the ConstantPool, if it is not already in ... */addClass_(...)/** Add a new Class reference to the ConstantPool for a given type. ... *//** Add a reference to an array class (e.g. String[][]) as needed by ... *//** Look for ConstantInteger in ConstantPool. ... *//** Add a new Integer constant to the ConstantPool, if it is not already in ... */lookupInteger(...)/** Look for ConstantFloat in ConstantPool. ... */ConstantFloat c/** Add a new Float constant to the ConstantPool, if it is not already in ... */lookupFloat(...)Map<String,Index> utf8_table;/** Look for ConstantUtf8 in ConstantPool. ... *//** Add a new Utf8 constant to the ConstantPool, if it is not already in ... */lookupUtf8(...)/** Look for ConstantLong in ConstantPool. ... */ConstantLong c/** Add a new long constant to the ConstantPool, if it is not already in ... */lookupLong(...)/** Look for ConstantDouble in ConstantPool. ... */long bitsConstantDouble c/** Add a new double constant to the ConstantPool, if it is not already in ... */lookupDouble(...)Map<String,Index> n_a_t_table;/** Look for ConstantNameAndType in ConstantPool. ... */Index _index_index.index/** Add a new NameAndType constant to the ConstantPool if it is not already ... */int signature_indexlookupNameAndType(...)Map<String,Index> cp_table;/** Look for ConstantMethodref in ConstantPool. ... */lookupMethodref(...)/** Add a new Methodref constant to the ConstantPool, if it is not already in ... */int class_indexint name_and_type_indexaddNameAndType(...)/** Look for ConstantInterfaceMethodref in ConstantPool. ... */lookupInterfaceMethodref(...)/** Add a new InterfaceMethodref constant to the ConstantPool, if it is not ... */addInterfaceMethodref(...)/** Look for ConstantFieldref in ConstantPool. ... *//** Add a new Fieldref constant to the ConstantPool, if it is not already in ... */lookupFieldref(...)/** Use with care! ... *//** Import constant from another ConstantPool and return new index. */addString(...)addDouble(...)addFloat(...)addLong(...)addInteger(...)addFieldref(...)// since name can't begin with digit, can  use// METHODREF_DELIM with out fear of duplicates.// entries may be null// nothing to do// TODO should this be handled somehow?// Already in CP// Wastes one entry according to spec/** Denotes a push instruction that produces a literal on the stack ... *//** Super class for the x2y family of instructions. ... */Const.D2IConst.F2IConst.L2IConst.D2FConst.I2FConst.L2FConst.D2LConst.F2LConst.I2LConst.F2DConst.I2DConst.L2DConst.I2BConst.I2CConst.I2S/** D2F - Convert double to float ... *//** Convert double to float */visitConversionInstruction(...)visitD2F(...)/** D2I - Convert double to int ... *//** Convert double to int */visitD2I(...)/** D2L - Convert double to long ... *//** Convert double to long */visitD2L(...)/** DADD - Add doubles ... *//** Add doubles */visitArithmeticInstruction(...)visitDADD(...)/** DALOAD - Load double from array ... *//** Load double from array */visitDALOAD(...)/** DASTORE -  Store into double array ... *//** Store double into array */visitDASTORE(...)/** DCMPG - Compare doubles: value1 &gt; value2 ... */Const.DCMPGvisitDCMPG(...)/** DCMPL - Compare doubles: value1 &lt; value2 ... */Const.DCMPLvisitDCMPL(...)/** DCONST - Push 0.0 or 1.0, other values cause an exception ... */double value;Const.DCONST_0setOpcode(...)Const.DCONST_1visitDCONST(...)/** DDIV -  Divide doubles ... *//** Divide doubles */visitDDIV(...)/** DLOAD - Load double from local variable ... */Const.DLOAD_0/** Load double from local variable ... */visitDLOAD(...)/** DMUL - Multiply doubles ... *//** Multiply doubles */visitDMUL(...)/** DNEG - Negate double ... */visitDNEG(...)/** DREM - Remainder of doubles ... *//** Remainder of doubles */visitDREM(...)/** DRETURN -  Return double from method ... *//** Return double from method */Const.DRETURNvisitDRETURN(...)/** DSTORE - Store double into local variable ... */Const.DSTORE_0/** Store double into local variable ... */visitDSTORE(...)/** DSUB - Substract doubles ... *//** Substract doubles */visitDSUB(...)/** DUP - Duplicate top operand stack word ... */Const.DUPvisitStackInstruction(...)visitDUP(...)/** DUP2 - Duplicate two top operand stack words ... */Const.DUP2visitDUP2(...)/** DUP2_X1 - Duplicate two top operand stack words and put three down ... */Const.DUP2_X1visitDUP2_X1(...)/** DUP2_X2 - Duplicate two top operand stack words and put four down ... */Const.DUP2_X2visitDUP2_X2(...)/** DUP_X1 - Duplicate top operand stack word and put two down ... */Const.DUP_X1visitDUP_X1(...)/** DUP_X2 - Duplicate top operand stack word and put three down ... */Const.DUP_X2visitDUP_X2(...)import EnumElementValueimport SimpleElementValueConstantPoolGen cpGen;this.cpGen/** Subtypes return an immutable variant of the ElementValueGen */int STRING;int ENUM_CONSTANT;int CLASS;int ANNOTATION;int ARRAY;int PRIMITIVE_INT;int PRIMITIVE_BYTE;int PRIMITIVE_CHAR;int PRIMITIVE_DOUBLE;int PRIMITIVE_FLOAT;int PRIMITIVE_LONG;int PRIMITIVE_SHORT;int PRIMITIVE_BOOLEAN;new SimpleElementValueGen(...)new EnumElementValueGen(...)new ClassElementValueGen(...)new AnnotationElementValueGen(...)new ArrayElementValueGen(...)/** Creates an (modifiable) ElementValueGen copy of an (immutable) ... */// byte// int// Enum constant// Annotation// TODO: isRuntimeVisible ??????????// Arrayint nameIdx;ElementValueGen value;/** Retrieve an immutable version of this ElementNameValuePairGen */ElementValue immutableValuethis.nameIdx// J5ASSERT:// Could assert nvp.getNameString() points to the same thing as// cpool.getConstant(nvp.getNameIndex())// if// (!nvp.getNameString().equals(((ConstantUtf8)cpool.getConstant(nvp.getNameIndex())).getBytes()))// throw new RuntimeException("envp buggered");// ConstantString cu8 = (ConstantString)cpool.getConstant(nameIdx);/** Supplies empty method bodies to be overridden by subclasses. ... *//** This ctor assumes the constant pool already contains the right type and ... */ElementValueGen.ENUM_CONSTANT/** Return immutable variant of this EnumElementValue */getEnumValueString(...)getEnumTypeString(...)getTypeIndex(...)getValueIndex(...)// here?// BCELBUG: Should we need to call utility.signatureToString() on the output// was addClass(t);// was addString(value);// was// addClass(value.getEnumTypeString());// addString(value.getEnumValueString());// ConstantString cu8 =// (ConstantString)getConstantPool().getConstant(valueIdx);// return// ((ConstantUtf8)getConstantPool().getConstant(cu8.getStringIndex())).getBytes();// Constant cc = getConstantPool().getConstant(typeIdx);// ConstantClass cu8 =// (ConstantClass)getConstantPool().getConstant(typeIdx);// ((ConstantUtf8)getConstantPool().getConstant(cu8.getNameIndex())).getBytes();// return Utility.signatureToString(cu8.getBytes());/** Denote an instruction that may throw a run-time or a linking ... *//** F2D - Convert float to double ... *//** Convert float to double */visitF2D(...)/** F2I - Convert float to int ... *//** Convert float to int */visitF2I(...)/** F2L - Convert float to long ... *//** Convert float to long */visitF2L(...)/** FADD - Add floats ... *//** Add floats */visitFADD(...)/** FALOAD - Load float from array ... *//** Load float from array */visitFALOAD(...)/** FASTORE -  Store into float array ... *//** Store float into array */visitFASTORE(...)/** FCMPG - Compare floats: value1 &gt; value2 ... */Const.FCMPGvisitFCMPG(...)/** FCMPL - Compare floats: value1 &lt; value2 ... */Const.FCMPLvisitFCMPL(...)/** FCONST - Push 0.0, 1.0 or 2.0, other values cause an exception ... */float value;Const.FCONST_0Const.FCONST_1Const.FCONST_2visitFCONST(...)/** FDIV - Divide floats ... *//** Divide floats */visitFDIV(...)/** FLOAD - Load float from local variable ... */Const.FLOAD_0/** Load float from local variable ... */visitFLOAD(...)/** FMUL - Multiply floats ... *//** Multiply floats */visitFMUL(...)/** FNEG - Negate float ... */visitFNEG(...)/** FREM - Remainder of floats ... *//** Remainder of floats */visitFREM(...)/** FRETURN -  Return float from method ... *//** Return float from method */Const.FRETURNvisitFRETURN(...)/** FSTORE - Store float into local variable ... */Const.FSTORE_0/** Store float into local variable ... */visitFSTORE(...)/** FSUB - Substract floats ... *//** Substract floats */visitFSUB(...)import ConstantObjectimport ConstantValue/** Template class for building up a field. The only extraordinary thing one can ... */FieldGen$1FieldGen THISFieldGen THAT/** Declare a field. If it is static (isStatic() == true) and has a basic ... */setType(...)/** Instantiate from existing field. ... */Attribute[] attrsAnnotationEntry[] annotationEntries/** Set (optional) initial value of field, otherwise it will be set to ... */checkType(...)Type.BOOLEAN/** Remove any initial value. */Type superType/** Get field object after having set up all necessary values. */addConstant(...)addAnnotationsAsAttribute(...)List<FieldObserver> observers;new ArrayList<FieldObserver>(...)FieldObserver observer/** Return string representation close to declaration format, `public static ... */getInitValue(...)FieldGen fg// sic/** Super class for FieldGen and MethodGen objects, since they have some methods ... */Type type;Const.T_ADDRESS/** Add an attribute to this method. Currently, the JVM knows about the ... *//** Remove an attribute. *//** Remove all attributes. */// TODO could this be package protected?/** Super class for the GET/PUTxxx family of instructions. ... */getTypeSize(...)getFieldType(...)/** Imnplement this interface if you're interested in changes to a FieldGen object ... *//** Super class for InvokeInstruction and FieldInstruction, since they have ... */ConstantCP cmrConstantNameAndType cnat/** Return the reference type representing the class, interface, ... *//** Get the ObjectType of the method return or field. ... */ReferenceType rtgetReferenceType(...)// Turn array classes into java.lang.Object./** GETFIELD - Fetch field from object ... */getFieldSize(...)ExceptionConst.EXCS.EXCS_FIELD_AND_METHOD_RESOLUTIONExceptionConst.INCOMPATIBLE_CLASS_CHANGE_ERRORvisitFieldOrMethod(...)visitFieldInstruction(...)visitGETFIELD(...)/** GETSTATIC - Fetch static field from class ... */visitGETSTATIC(...)/** GOTO - Branch always (to relative offset, not absolute address) ... *//** Called in pass 2 of InstructionList.setPositions() in order to update ... */short old_lengthvisitVariableLengthInstruction(...)visitBranchInstruction(...)visitGotoInstruction(...)visitGOTO(...)// GOTO_W// Depending on old position value// Position may be shifted by preceding expansions// to large for short (estimate)/** GOTO_W - Branch always (to relative offset, not absolute address) ... */visitGOTO_W(...)/** Super class for GOTO ... *//** I2B - Convert int to byte ... *//** Convert int to byte */visitI2B(...)/** I2C - Convert int to char ... *//** Convert int to char */visitI2C(...)/** I2D - Convert int to double ... *//** Convert int to double */visitI2D(...)/** I2F - Convert int to float ... *//** Convert int to float */visitI2F(...)/** I2L - Convert int to long ... *//** Convert int to long */visitI2L(...)/** I2S - Convert int to short ... */visitI2S(...)/** IADD - Add ints ... *//** Add ints */visitIADD(...)/** IALOAD - Load int from array ... *//** Load int from array */visitIALOAD(...)/** IAND - Bitwise AND int ... */visitIAND(...)/** IASTORE -  Store into int array ... *//** Store into int array */visitIASTORE(...)/** ICONST - Push value between -1, ..., 5, other values cause an exception ... */Const.ICONST_0visitICONST(...)// Even works for i == -1/** IDIV - Divide ints ... *//** Divide ints */ExceptionConst.ARITHMETIC_EXCEPTIONvisitIDIV(...)/** IFEQ - Branch if int comparison with zero succeeds ... */new IFNE(...)visitIfInstruction(...)visitIFEQ(...)/** IFGE - Branch if int comparison with zero succeeds ... */new IFLT(...)visitIFGE(...)/** IFGT - Branch if int comparison with zero succeeds ... */new IFLE(...)visitIFGT(...)/** IFLE - Branch if int comparison with zero succeeds ... */new IFGT(...)visitIFLE(...)/** IFLT - Branch if int comparison with zero succeeds ... */new IFGE(...)visitIFLT(...)/** IFNE - Branch if int comparison with zero succeeds ... */new IFEQ(...)visitIFNE(...)/** IFNONNULL - Branch if reference is not null ... */new IFNULL(...)visitIFNONNULL(...)/** IFNULL - Branch if reference is not null ... */new IFNONNULL(...)visitIFNULL(...)/** IF_ACMPEQ - Branch if reference comparison succeeds ... */new IF_ACMPNE(...)visitIF_ACMPEQ(...)/** IF_ACMPNE - Branch if reference comparison doesn't succeed ... */new IF_ACMPEQ(...)visitIF_ACMPNE(...)/** IF_ICMPEQ - Branch if int comparison succeeds ... */new IF_ICMPNE(...)visitIF_ICMPEQ(...)/** IF_ICMPGE - Branch if int comparison succeeds ... */new IF_ICMPLT(...)visitIF_ICMPGE(...)/** IF_ICMPGT - Branch if int comparison succeeds ... */new IF_ICMPLE(...)visitIF_ICMPGT(...)/** IF_ICMPLE - Branch if int comparison succeeds ... */new IF_ICMPGT(...)visitIF_ICMPLE(...)/** IF_ICMPLT - Branch if int comparison succeeds ... */new IF_ICMPGE(...)visitIF_ICMPLT(...)/** IF_ICMPNE - Branch if int comparison doesn't succeed ... */new IF_ICMPEQ(...)visitIF_ICMPNE(...)/** IINC - Increment local variable by constant ... */setIncrement(...)Byte.MAX_VALUEthis.widesetIndexOnly(...)/** Set index of local variable. */setWide(...)/** Set increment factor. */visitLocalVariableInstruction(...)visitIINC(...)// Default behaviour of LocalVariableInstruction causes error// May set wide as side effect// wide byte included/** ILOAD - Load int from local variable onto stack ... */Const.ILOAD_0/** Load int from local variable ... */visitILOAD(...)/** IMPDEP1 - Implementation dependent ... */Const.IMPDEP1visitIMPDEP1(...)/** IMPDEP2 - Implementation dependent ... */Const.IMPDEP2visitIMPDEP2(...)/** IMUL - Multiply ints ... *//** Multiply ints */visitIMUL(...)/** INEG - Negate int ... */visitINEG(...)/** INSTANCEOF - Determine if object is of given type ... */visitINSTANCEOF(...)/** Class for INVOKEDYNAMIC. Not an instance of InvokeInstruction, since that class ... *//** Read needed data (i.e., index) from file. */initFromFile(...)ExceptionConst.EXCS.EXCS_INTERFACE_METHOD_RESOLUTIONExceptionConst.UNSATISFIED_LINK_ERRORExceptionConst.ABSTRACT_METHOD_ERRORExceptionConst.ILLEGAL_ACCESS_ERRORvisitInvokeInstruction(...)visitINVOKEDYNAMIC(...)/** Override the parent method because our classname is held elsewhere. */// Skip 0 byte/** INVOKEINTERFACE - Invoke interface method ... */int nargs;// Number of arguments on stack (number of stack slots), called "count" in vmspec2this.nargs/** The <B>count</B> argument according to the Java Language Specification, ... */visitINVOKEINTERFACE(...)// nargs is given in byte-code// nargs includes this reference/** INVOKESPECIAL - Invoke instance method; special handling for superclass, private ... */visitINVOKESPECIAL(...)/** INVOKESTATIC - Invoke a class (static) method ... */visitINVOKESTATIC(...)/** INVOKEVIRTUAL - Invoke instance method; dispatch based on class ... */visitINVOKEVIRTUAL(...)/** IOR - Bitwise OR int ... */visitIOR(...)/** IREM - Remainder of int ... *//** Remainder of ints */visitIREM(...)/** IRETURN -  Return int from method ... *//** Return int from method */Const.IRETURNvisitIRETURN(...)/** ISHL - Arithmetic shift left int ... */visitISHL(...)/** ISHR - Arithmetic shift right int ... */visitISHR(...)/** ISTORE - Store int from stack into local variable ... */Const.ISTORE_0/** Store int into local variable ... */visitISTORE(...)/** ISUB - Substract ints ... *//** Substract ints */visitISUB(...)/** IUSHR - Logical shift right int ... */visitIUSHR(...)/** IXOR - Bitwise XOR int ... */visitIXOR(...)/** Super class for the IFxxx family of instructions. ... *//** Denote entity that refers to an index, e.g. local variable instructions, ... *//** Abstract super class for all Java byte codes. ... */InstructionComparator.DEFAULTshort length;short opcode;// Length of instruction in bytesInstructionComparator cmp;// Opcode numberthis.opcode/** Use with caution, since `BranchInstruction's have a `target' reference ... */Instruction i/** Read needed data (e.g. index) from file. ... *//** Read an instruction from (byte code) input stream and return the ... */boolean wideInstruction objInstruction instructionnew BIPUSH(...)Const.SIPUSHnew SIPUSH(...)new LDC(...)new LDC_W(...)new LDC2_W(...)new ILOAD(...)new LLOAD(...)new FLOAD(...)new DLOAD(...)new ALOAD(...)Const.ILOAD_1Const.ILOAD_2Const.ILOAD_3Const.LLOAD_0Const.LLOAD_1Const.LLOAD_2Const.LLOAD_3Const.FLOAD_1Const.FLOAD_2Const.FLOAD_3Const.DLOAD_1Const.DLOAD_2Const.DLOAD_3Const.ALOAD_1Const.ALOAD_2Const.ALOAD_3new ISTORE(...)new LSTORE(...)new FSTORE(...)new DSTORE(...)new ASTORE(...)Const.ISTORE_1Const.ISTORE_2Const.ISTORE_3Const.LSTORE_0Const.LSTORE_1Const.LSTORE_2Const.LSTORE_3Const.FSTORE_1Const.FSTORE_2Const.FSTORE_3Const.DSTORE_1Const.DSTORE_2Const.DSTORE_3Const.ASTORE_1Const.ASTORE_2Const.ASTORE_3new IINC(...)new GOTO(...)new JSR(...)new RET(...)new TABLESWITCH(...)new LOOKUPSWITCH(...)new GETSTATIC(...)new PUTSTATIC(...)new GETFIELD(...)new PUTFIELD(...)new INVOKEVIRTUAL(...)new INVOKESTATIC(...)new INVOKEINTERFACE(...)new INVOKEDYNAMIC(...)new NEW(...)new NEWARRAY(...)new ANEWARRAY(...)new CHECKCAST(...)new INSTANCEOF(...)new MULTIANEWARRAY(...)new GOTO_W(...)new JSR_W(...)new BREAKPOINT(...)new IMPDEP1(...)new IMPDEP2(...)/** This method also gives right results for instructions whose effect on the ... */getConsumeStack(...)getProduceStack(...)/** Needed in readInstruction and subclasses in this package *//** Needed in readInstruction and subclasses in this package ... *//** Some instructions may be reused, so don't do anything by default. *//** Get Comparator object used in the equals() method to determine equality ... *//** Set comparator to be used for equals(). ... *//** Check for equality, delegated to comparator ... *//** calculate the hashCode of this object ... *//** Check if the value can fit in a byte (signed) ... */Byte.MIN_VALUE/** Check if the value can fit in a short (signed) ... */Short.MIN_VALUE// Common for all instructions// "Constant" instruction, no need to duplicate// Read next opcode after wide byte// Used predefined immutable object, if available// Do further initializations, if any// TODO check range?/** Equality of instructions isn't clearly to be defined. You might ... */new InstructionComparator(...) { ... }InstructionComparator$1getTypecode(...)InstructionComparator DEFAULT;// BIs are never equal to make targeters work correctly (BCEL-195)//                } else if (i1 == i2) { TODO consider adding this shortcut//                    return true; // this must be AFTER the BI test/** This interface contains shareable instruction objects. ... */new NOP(...)new ACONST_NULL(...)new ICONST(...)new LCONST(...)new FCONST(...)new DCONST(...)new IALOAD(...)new LALOAD(...)new FALOAD(...)new DALOAD(...)new AALOAD(...)new BALOAD(...)new CALOAD(...)new SALOAD(...)new IASTORE(...)new LASTORE(...)new FASTORE(...)new DASTORE(...)new AASTORE(...)new BASTORE(...)new CASTORE(...)new SASTORE(...)new POP(...)new POP2(...)new DUP(...)new DUP_X1(...)new DUP_X2(...)new DUP2(...)new DUP2_X1(...)new DUP2_X2(...)new SWAP(...)new IADD(...)new LADD(...)new FADD(...)new DADD(...)new ISUB(...)new LSUB(...)new FSUB(...)new DSUB(...)new IMUL(...)new LMUL(...)new FMUL(...)new DMUL(...)new IDIV(...)new LDIV(...)new FDIV(...)new DDIV(...)new IREM(...)new LREM(...)new FREM(...)new DREM(...)new INEG(...)new LNEG(...)new FNEG(...)new DNEG(...)new ISHL(...)new LSHL(...)new ISHR(...)new LSHR(...)new IUSHR(...)new LUSHR(...)new IAND(...)new LAND(...)new IOR(...)new LOR(...)new IXOR(...)new LXOR(...)new I2L(...)new I2F(...)new I2D(...)new L2I(...)new L2F(...)new L2D(...)new F2I(...)new F2L(...)new F2D(...)new D2I(...)new D2L(...)new D2F(...)new I2B(...)new I2C(...)new I2S(...)new LCMP(...)new FCMPL(...)new FCMPG(...)new DCMPL(...)new DCMPG(...)new IRETURN(...)new LRETURN(...)new FRETURN(...)new DRETURN(...)new ARETURN(...)new RETURN(...)new ARRAYLENGTH(...)new ATHROW(...)new MONITORENTER(...)new MONITOREXIT(...)new Instruction[]Const.NOPConst.ICONST_M1Const.ICONST_1Const.ICONST_2Const.ICONST_3Const.ICONST_4Const.ICONST_5Const.LCONST_0Const.LCONST_1Const.POPConst.POP2Const.SWAPConst.LCMPConst.LRETURNConst.RETURNConst.MONITORENTERConst.MONITOREXITInstruction NOP;/* NOTE these are not currently immutable, because Instruction ... *//** Predefined instruction objects */Instruction ACONST_NULL;Instruction ICONST_M1;Instruction ICONST_0;Instruction ICONST_1;Instruction ICONST_2;Instruction ICONST_3;Instruction ICONST_4;Instruction ICONST_5;Instruction LCONST_0;Instruction LCONST_1;Instruction FCONST_0;Instruction FCONST_1;Instruction FCONST_2;Instruction DCONST_0;Instruction DCONST_1;ArrayInstruction IALOAD;ArrayInstruction LALOAD;ArrayInstruction FALOAD;ArrayInstruction DALOAD;ArrayInstruction AALOAD;ArrayInstruction BALOAD;ArrayInstruction CALOAD;ArrayInstruction SALOAD;ArrayInstruction IASTORE;ArrayInstruction LASTORE;ArrayInstruction FASTORE;ArrayInstruction DASTORE;ArrayInstruction AASTORE;ArrayInstruction BASTORE;ArrayInstruction CASTORE;ArrayInstruction SASTORE;StackInstruction POP;StackInstruction POP2;StackInstruction DUP;StackInstruction DUP_X1;StackInstruction DUP_X2;StackInstruction DUP2;StackInstruction DUP2_X1;StackInstruction DUP2_X2;StackInstruction SWAP;ArithmeticInstruction IADD;ArithmeticInstruction LADD;ArithmeticInstruction FADD;ArithmeticInstruction DADD;ArithmeticInstruction ISUB;ArithmeticInstruction LSUB;ArithmeticInstruction FSUB;ArithmeticInstruction DSUB;ArithmeticInstruction IMUL;ArithmeticInstruction LMUL;ArithmeticInstruction FMUL;ArithmeticInstruction DMUL;ArithmeticInstruction IDIV;ArithmeticInstruction LDIV;ArithmeticInstruction FDIV;ArithmeticInstruction DDIV;ArithmeticInstruction IREM;ArithmeticInstruction LREM;ArithmeticInstruction FREM;ArithmeticInstruction DREM;ArithmeticInstruction INEG;ArithmeticInstruction LNEG;ArithmeticInstruction FNEG;ArithmeticInstruction DNEG;ArithmeticInstruction ISHL;ArithmeticInstruction LSHL;ArithmeticInstruction ISHR;ArithmeticInstruction LSHR;ArithmeticInstruction IUSHR;ArithmeticInstruction LUSHR;ArithmeticInstruction IAND;ArithmeticInstruction LAND;ArithmeticInstruction IOR;ArithmeticInstruction LOR;ArithmeticInstruction IXOR;ArithmeticInstruction LXOR;ConversionInstruction I2L;ConversionInstruction I2F;ConversionInstruction I2D;ConversionInstruction L2I;ConversionInstruction L2F;ConversionInstruction L2D;ConversionInstruction F2I;ConversionInstruction F2L;ConversionInstruction F2D;ConversionInstruction D2I;ConversionInstruction D2L;ConversionInstruction D2F;ConversionInstruction I2B;ConversionInstruction I2C;ConversionInstruction I2S;Instruction LCMP;Instruction FCMPL;Instruction FCMPG;Instruction DCMPL;Instruction DCMPG;ReturnInstruction IRETURN;ReturnInstruction LRETURN;ReturnInstruction FRETURN;ReturnInstruction DRETURN;ReturnInstruction ARETURN;ReturnInstruction RETURN;Instruction ARRAYLENGTH;Instruction ATHROW;Instruction MONITORENTER;Instruction MONITOREXIT;LocalVariableInstruction THIS;/** You can use these constants in multiple places safely, if you can guarantee ... */LocalVariableInstruction ALOAD_0;LocalVariableInstruction ALOAD_1;LocalVariableInstruction ALOAD_2;LocalVariableInstruction ILOAD_0;LocalVariableInstruction ILOAD_1;LocalVariableInstruction ILOAD_2;LocalVariableInstruction ASTORE_0;LocalVariableInstruction ASTORE_1;LocalVariableInstruction ASTORE_2;LocalVariableInstruction ISTORE_0;LocalVariableInstruction ISTORE_1;LocalVariableInstruction ISTORE_2;...[] INSTRUCTIONS;/** Get object via its opcode, for immutable instructions like ... *//** Gets the Instruction. ... */// non-instantiable/** Instances of this class may be used, e.g., to generate typed versions of ... */new MethodObject[]new MethodObject(...)new Type[]...[] short_names;// N.N. These must agree with the order of Constants.T_CHAR through T_LONGClassGen cg;this.cg/** Initialize with ClassGen object *//** Initialize just with ConstantPoolGen object *//** Create an invoke instruction. (Except for invokedynamic.) ... */getMethodSignature(...)Type arg_type/** Create a call to the most popular System.out.println() method. ... *//* createInvokeDynamic only needed if instrumention code wants to generate ... *//** Create an invokedynamic instruction. ... */int outint printlnnew PUSH(...)/** Uses PUSH to push a constant value onto the stack. ... */PUSH pushInstructionFactory$MethodObject...[] arg_types;Type result_type;createInvoke(...)m.class_namem.namem.result_typem.arg_types...[] append_mos;byte tisString(...)Const.T_OBJECT/** Create a field instruction. ... *//** Create reference to `this' *//** Create typed return */InstructionConst.ARETURNInstructionConst.IRETURNInstructionConst.FRETURNInstructionConst.DRETURNInstructionConst.LRETURNInstructionConst.ISUBInstructionConst.IADDInstructionConst.IREMInstructionConst.IMULInstructionConst.IDIVInstructionConst.IANDInstructionConst.IORInstructionConst.IXORInstructionConst.ISHLInstructionConst.IUSHRInstructionConst.ISHRInstructionConst.LSUBInstructionConst.LADDInstructionConst.LREMInstructionConst.LMULInstructionConst.LDIVInstructionConst.LANDInstructionConst.LORInstructionConst.LXORInstructionConst.LSHLInstructionConst.LUSHRInstructionConst.LSHRInstructionConst.FSUBInstructionConst.FADDInstructionConst.FMULInstructionConst.FDIVInstructionConst.FREMInstructionConst.DSUBInstructionConst.DADDInstructionConst.DMULInstructionConst.DDIVInstructionConst.DREM/** Create binary operation for simple basic types, such as int and float. ... */char firstcreateBinaryIntOp(...)createBinaryLongOp(...)createBinaryFloatOp(...)createBinaryDoubleOp(...)InstructionConst.POP2InstructionConst.POPInstructionConst.DUP2InstructionConst.DUPInstructionConst.DUP2_X2InstructionConst.DUP_X2InstructionConst.DUP2_X1InstructionConst.DUP_X1InstructionConst.BALOADInstructionConst.CALOADInstructionConst.SALOADInstructionConst.IALOADInstructionConst.FALOADInstructionConst.DALOADInstructionConst.LALOADInstructionConst.AALOADInstructionConst.BASTOREInstructionConst.CASTOREInstructionConst.SASTOREInstructionConst.IASTOREInstructionConst.FASTOREInstructionConst.DASTOREInstructionConst.LASTOREInstructionConst.AASTORE/** Create conversion operation for two stack operands, this may be an I2C, ... */byte destbyte srcaddArrayClass(...)createNew(...)/** Create new array of given size and type. ... */ArrayType at/** Create "null" value for reference types, 0 for basic types like int */InstructionConst.ACONST_NULLInstructionConst.ICONST_0InstructionConst.FCONST_0InstructionConst.DCONST_0InstructionConst.LCONST_0InstructionConst.NOP/** Create branch instruction by given opcode, except LOOKUPSWITCH and ... */// indices 2, 3// No append(byte)// No append(short)/** Instances of this class give users a handle to the instructions contained in ... */InstructionHandle next;InstructionHandle prev;Instruction instruction;int i_position;Set<InstructionTargeter> targeters;// byte code offset of instructionMap<Object,Object> attributes;/** Replace current instruction contained in this handle. Old instruction is ... */BranchHandle.class// TODO remove this method in any redesign of BCEL/** Temporarily swap the current instruction, without disturbing anything. ... */Instruction oldInstruction/* private */InstructionHandle ih_list;/** Factory method. */InstructionHandle ihnew InstructionHandle(...)ih.next/** Set the position, i.e., the byte code offset of the contained ... *//** Overridden in BranchHandle *//** Delete contents, i.e., remove user access and make handle reusable. */removeAllTargeters(...)addHandle(...)/** Remove all targeters, if any. *//** Denote this handle isn't referenced anymore by t. *//** Denote this handle is being referenced by t. */new HashSet<InstructionTargeter>(...)InstructionTargeter[] tnew InstructionTargeter[]hasTargeters(...)/** Add an attribute to an instruction handle. ... */new HashMap<Object,Object>(...)/** Delete an attribute of an instruction handle. ... *//** Get attribute of an instruction handle. ... *//** Convenience method, simply calls accept() on the contained instruction. ... */this.nextthis.prev// Overridden in BranchHandle TODO could be package-protected?//if(!targeters.contains(t))/** This class is a container for a list of <a ... */InstructionHandle start;InstructionHandle end;...[] byte_positions;// number of elements in list/** Create (empty) instruction list. */// byte code offsets corresponding to instructions/** Create instruction list containing one instruction. ... *//** Initialize list with (nonnull) compound instruction. Consumes argument ... */getInstructionList(...)/** Test for empty list. *//** Find the target instruction (handle) that corresponds to the given target ... */// && end == null/** Get instruction handle for instruction at byte code position pos. This ... */int[] positions/** Initialize instruction list from byte array. ... */int[] posInstructionHandle[] ihsByteSequence bytesnew InstructionHandle[]readInstruction(...)BranchInstruction biint targetfindHandle(...)Select sint[] indicesgetIndices(...)indices.length/** Append another list after instruction (handle) ih contained in this list. ... */InstructionHandle nextInstructionHandle retil.startsetPrev(...)il.endil.length/** Append another list after instruction i contained in this list. Consumes ... */findInstruction2(...)/** Append another list to this one. Consumes argument list, i.e., it becomes ... *//** Append an instruction to the end of this list. ... */getInstructionHandle(...)/** Append a branch instruction to the end of this list. ... */BranchHandle ihgetBranchHandle(...)/** Append a single instruction j after another instruction i, which must be ... *//** Append a compound instruction, after instruction i. ... *//** Append a compound instruction. ... *//** Append an instruction after instruction (handle) ih contained in this ... *//** Insert another list before Instruction handle ih contained in this list. ... */InstructionHandle prevgetPrev(...)/** Insert another list. ... *//** Insert an instruction at start of this list. ... *//** Insert another list before Instruction i contained in this list. Consumes ... */findInstruction1(...)/** Insert a branch instruction at start of this list. ... *//** Insert a single instruction j before another instruction i, which must be ... *//** Insert a compound instruction before instruction i. ... *//** Insert a compound instruction. ... *//** Insert an instruction before instruction (handle) ih contained in this ... *//** Take all instructions (handles) from "start" to "end" and append them ... */this.startthis.end/** Move a single instruction (handle) to a new location. ... */move(...)/** Remove from instruction `prev' to instruction `next' both contained in ... */InstructionHandle firstInstructionHandle lastList<InstructionHandle> target_vecnew ArrayList<InstructionHandle>(...)InstructionHandle[] targetednew TargetLostException(...)/** Remove instruction from this list. The corresponding Instruction handles ... *//** Remove instructions from instruction `from' to instruction `to' contained ... */InstructionHandle from_ihInstructionHandle to_ih/** Search for given Instruction reference, start at beginning of list. ... *//** Search for given Instruction reference, start at end of list ... */setPositions(...)/** Give all instructions their position number (offset in byte stream), ... */int max_additional_bytesint additional_bytesInstruction instInstructionHandle[] targetsgetTargets(...)InstructionHandle target/** When everything is finished, use this method to convert the instruction ... */ByteArrayOutputStream bDataOutputStream outList<Instruction> instructionsnew ArrayList<Instruction>(...)getByteCode(...)new Iterator<InstructionHandle>(...) { ... }InstructionList$1InstructionHandle ih;InstructionHandle i/** Get positions (offsets) of all instructions in the list. This relies on ... */Map<InstructionHandle,InstructionHandle> mapnew HashMap<InstructionHandle,InstructionHandle>(...)InstructionHandle chInstruction cBranchInstruction bcInstructionHandle itargetInstructionHandle[] itargetsInstructionHandle[] ctargetsitargets.length/** Replace all references to the old constant pool with references to the ... */CPInstruction ci/** Delete contents of list. Provides better memory utilization, because the ... *//** Redirect all references from old_target to new_target, i.e., update ... */BranchInstruction btargets.length/** Redirect all references of local variables from old_target to new_target. ... */LocalVariableGen elementInstructionHandle startgetStart(...)InstructionHandle endgetEnd(...)setStart(...)setEnd(...)/** Redirect all references of exception handlers from old_target to ... */CodeExceptionGen exceptionList<InstructionListObserver> observers;new ArrayList<InstructionListObserver>(...)InstructionListObserver observer/* Do a binary search since the pos array is orderd. */// Contains actual length// Can't be more than that/* Pass 1: Create an object for each byte code and append them to the list. */// Remember byte offset and associate it with the instruction/* Read one instruction from the byte stream, the byte position is set accordingly. */// Trim to proper size/* Pass 2: Look for BranchInstruction and update their targets, i.e., convert offsets to instruction handles. *//* Byte code position: relative -> absolute. */// Search for target position// Update target// If it is a Select instruction, update all branch targets// Either LOOKUPSWITCH or TABLESWITCH// Update end ...// Update length// was end.instruction// Update start ...// Code is identical for this case// Step 1: Check constraints// Step 2: Temporarily remove the given instructions from the list// Step 3: append after target// append to start of list// First and last deleted instruction// At start of list// At end of list// Completely separated from rest of list// e.g. BranchInstructions release their targets// Still got targeters?// TODO could be package-protected? (some test code would need to be repackaged)// called by code in other packages/* Pass 0: Sanity checks */// target instruction within list?/* Pass 1: Set position numbers and sum up the maximum number of bytes an instruction may be shifted. *//* Get an estimate about how many additional bytes may be added, ... *//* Pass 2: Expand the variable-length (Branch)Instructions depending on ... *//* Pass 3: Update position numbers (which may have changed due to the ... */// Update position indices of instructions// Traverse list/* Pass 1: Make copies of all instructions, append them to the new list and associate old instruction references with the new ones, i.e., a 1:1 mapping. */// Use clone for shallow copy/* Pass 2: Update branch targets. */// old target// New target is in hash map// Update all targets// Traverse in reverse order, because ih.next is overwritten/* Causes BranchInstructions to release target and targeters, ... *//** Implement this interface if you're interested in changes to an InstructionList object ... *//** Denote that a class targets InstructionHandles within an InstructionList. Namely ... *//** Checks whether this targeter targets the specified instruction handle. *//** Replaces the target of this targeter from this old handle to the new handle. ... *//** Super class for the INVOKExxx family of instructions. ... *//** Also works for instructions whose stack effect depends on the ... */getArgumentTypesSize(...)getReturnTypeSize(...)/** This overrides the deprecated version as we know here that the referenced class ... */// this reference/** JSR - Jump to subroutine ... */visitJsrInstruction(...)visitJSR(...)// JSR_W/** JSR_W - Jump to subroutine ... */visitJSR_W(...)/** Super class for JSR - Jump to subroutine ... */new ReturnaddressType(...)physicalSuccessor(...)/** Returns an InstructionHandle to the physical successor ... */InstructionHandle toThis// Rewind!// Find the handle for "this" JsrInstruction object.// Return the physical successor/** L2D - Convert long to double ... */visitL2D(...)/** L2F - Convert long to float ... */visitL2F(...)/** L2I - Convert long to int ... */visitL2I(...)/** LADD - Add longs ... */visitLADD(...)/** LALOAD - Load long from array ... *//** Load long from array */visitLALOAD(...)/** LAND - Bitwise AND longs ... */visitLAND(...)/** LASTORE -  Store into long array ... *//** Store long into array */visitLASTORE(...)/** LCMP - Compare longs: ... */visitLCMP(...)/** LCONST - Push 0 or 1, other values cause an exception ... */visitLCONST(...)/** LDC - Push item from constant pool. ... */// Adjust to proper size/** Set the index to constant pool and adjust size. */int nameIndexnew ObjectType(...)Type.CLASSExceptionConst.EXCS.EXCS_STRING_RESOLUTIONvisitLDC(...)// Fits in one byte?// TODO useless check?/** LDC2_W - Push long or double from constant pool ... */visitLDC2_W(...)/** LDC_W - Push item from constant pool (wide index) ... */// Override just in case it has been changed/** LDIV - Divide longs ... */visitLDIV(...)/** LLOAD - Load long from local variable ... */visitLLOAD(...)/** LMUL - Multiply longs ... */visitLMUL(...)/** LNEG - Negate long ... */visitLNEG(...)/** LOOKUPSWITCH - Switch with unordered set of values ... */short _lengthgetMatch_length(...)setFixed_length(...)int _match_lengthgetMatch(...)setIndices(...)short _fixed_lengthgetPadding(...)setMatch_length(...)setMatches(...)setTargets(...)setMatch(...)visitSelect(...)visitLOOKUPSWITCH(...)/* alignment remainder assumed 0 here, until dump time. */// npairs// match-offset pairs// reads padding/** LOR - Bitwise OR long ... */visitLOR(...)/** LREM - Remainder of long ... */visitLREM(...)/** LRETURN -  Return long from method ... */visitLRETURN(...)/** LSHL - Arithmetic shift left long ... */visitLSHL(...)/** LSHR - Arithmetic shift right long ... */visitLSHR(...)/** LSTORE - Store long into local variable ... */visitLSTORE(...)/** LSUB - Substract longs ... */visitLSUB(...)/** LUSHR - Logical shift right long ... */visitLUSHR(...)/** LXOR - Bitwise XOR long ... */visitLXOR(...)import LineNumber/** This class represents a line number within a method, i.e., give an instruction ... */int src_line;/** Create a line number. ... */setSourceLine(...)this.ih/** Get LineNumber attribute . ... */this.src_line/** Denotes that an instruction may start the process of loading and resolving ... *//** Returns the ObjectType of the referenced class or interface ... *//** Returns the type associated with this instruction. ... *//** Denotes an unparameterized instruction to load a value from a local ... */visitLoadInstruction(...)import LocalVariable/** Generate a local variable that with index `index'. Note that double and ... */Const.MAX_SHORT/** Get LocalVariable object. ... *//** Clear the references from and to this variable when it's removed. *//** We consider to local variables to be equal, if the use the same index and ... */LocalVariableGen ll.indexl.startl.end// If the user changes the name or type, problems with the targeter hashmap will occur.// Note: index cannot be part of hash as it may be changed by the user./** Abstract super class for instructions dealing with local variables. ... */int n;short c_tag;// index of referenced variableshort canon_tag;// compact version, such as ILOAD_0// canonical tag such as ILOADthis.canon_tagthis.c_tagwide(...)/** Set the local variable index. also updates opcode and length TODO Why? ... */this.n/** Returns the type associated with the instruction - in case of ALOAD or ... *//** Sets the index of the referenced variable (n) only ... */// Otherwise ILOAD_n, instruction, e.g.// compact load instruction such as ILOAD_2// Assert ISTORE_0 <= tag <= ASTORE_3// Cannot be < 0 as this is checked above// Use more compact instruction xLOAD_n/** MONITORENTER - Enter monitor for object ... */visitMONITORENTER(...)/** MONITOREXIT - Exit monitor for object ... */visitMONITOREXIT(...)/** MULTIANEWARRAY - Create new mutidimensional array of references ... */short dimensions;/** Read needed data (i.e., no. dimension) from file. */visitMULTIANEWARRAY(...)import Codeimport ExceptionTableimport LineNumberTableimport LocalVariableTableimport LocalVariableTypeTableimport ParameterAnnotationEntryimport ParameterAnnotations/** Template class for building up a method. This is done by defining exception ... */new ArrayList<LocalVariableGen>(...)new ArrayList<LineNumberGen>(...)new ArrayList<CodeExceptionGen>(...)MethodGen$1MethodGen THISMethodGen THAT...[] arg_names;InstructionList il;boolean strip_attributes;List<LocalVariableGen> variable_vec;List<LocalVariableGen> type_vec;List<LineNumberGen> line_number_vec;List<CodeExceptionGen> exception_vec;List<String> throws_vec;List<Attribute> code_attrs_vec;...[] param_annotations;boolean hasParameterAnnotations;// Array of lists containing AnnotationGen objectsboolean haveUnpackedParameterAnnotations;/** Declare method. If the method is non-static the constructor automatically ... */boolean abstract_isNative(...)setArgumentTypes(...)setArgumentNames(...)setClassName(...)setInstructionList(...)addLocalVariable(...)arg_types.lengtharg_names.length/** Instantiate from existing method. ... */CodeException[] cesAttribute[] c_attributessetMaxLocals(...)CodeException ceObjectType c_typegetCode(...).lengthString cenaddExceptionHandler(...)Attribute c_attributeLineNumber[] lnLineNumber laddLineNumber(...)LocalVariable[] lvremoveLocalVariables(...)repairHandles(...)removeLocalVariableTypes(...)addCodeAttribute(...)getExceptionNames(...)String name2addException(...)AnnotationEntry[] aeslv.lengthaddLocalVariableType(...)/** Adds a local variable to this method. ... */int addnew LocalVariableGen(...)/** Adds a local variable to this method and assigns an index automatically. ... *//** Remove a local variable, its slot will not be reused, if you do not use ... *//** Remove all local variables. *//* If the range of the variable has not been set yet, it will be set to be valid from ... */getLocalVariableOrTypes(...)/* If the range of the variable has not been set yet, it will be set to be ... *//* If the range of the variable or type has not been set yet, it will be set ... */LocalVariableGen[] lgnew LocalVariableGen[]new Comparator<LocalVariableGen>(...) { ... }MethodGen$2getLocalVariables(...)lg.lengthgetLocalVariableTypes(...)/** Adds a local variable type to this method. ... *//** Remove all local variable types. *//** Give an instruction a line number corresponding to the source code line. ... */LineNumberGen lnew LineNumberGen(...)/** Remove a line number. *//** Remove all line numbers. *//* @return array of line numbers */LineNumberGen[] lgnew LineNumberGen[]ln.lengthCodeExceptionGen cnew CodeExceptionGen(...)/** Remove an exception handler. *//* @return array of declared exception handlers */CodeExceptionGen[] cgnew CodeExceptionGen[]CodeException[] c_excgetCodeException(...)/** Add an exception possibly thrown by this method. ... *//** Remove an exception. *//** Remove all exceptions. *//* @return array of thrown exceptions */String[] eint[] ex/** Add an attribute to the code. Currently, the JVM knows about the ... *//** Remove a code attribute. *//** Remove all code attributes. */getParameterAnnotationAttributes(...)/** Get method object. Never forget to call setMaxStack() or ... */ConstantPoolGen _cpbyte[] byte_codeLineNumberTable lntLocalVariableTable lvtLocalVariableTypeTable lvttAttribute[] code_attrsgetCodeAttributes(...)int attrs_lengetCodeExceptions(...)int exc_lenc_exc.lengthExceptionTable etAttribute code_attrremoveAttribute(...)byte_code.lengthaddParameterAnnotationsAsAttribute(...)removeCodeAttribute(...)/** Remove all NOPs from the instruction list (if possible) and update every ... */TargetLostException eInstructionTargeter targetergetTargeters(...)/** Set maximum number of local variables. *//** Set maximum stack size for this method. */this.arg_typesthis.arg_namesthis.il/** Computes max. stack size by performing control flow analysis. */getExceptionHandlers(...)/** Compute maximum number of local variables. */Instruction ins/** Do not/Do produce attributes code attributesLineNumberTable and ... */MethodGen$BranchTargetint stackDepth;this.stackDepthMethodGen$BranchStacknew Stack<BranchTarget>(...)new HashMap<InstructionHandle,BranchTarget>(...)Stack<BranchTarget> branchTargets;Map<InstructionHandle,BranchTarget> visitedTargets;BranchTarget btnew BranchTarget(...)/** Computes stack usage of an instruction list by performing control flow ... */BranchStack branchTargetsnew BranchStack(...)int stackDepthint maxStackDepthCodeExceptionGen elementInstructionHandle handler_pcproduceStack(...)consumeStack(...)BranchInstruction branchSelect selectbt.targetbt.stackDepthList<MethodObserver> observers;new ArrayList<MethodObserver>(...)MethodObserver observer/** Return string representation close to declaration format, e.g. public ... */String throwsDescriptorreplaceConstantPool(...)/** Return a list of AnnotationGen objects representing parameter annotations ... */// is more likely to suggest to the caller it is readonly (which a List does not).//J5TODO: Should param_annotations be an array of arrays? Rather than an array of lists, thisensureExistingParameterAnnotationsUnpacked(...)/** Goes through the attributes on the method and identifies any that are ... */ParameterAnnotations paramAnnVisAttrParameterAnnotations paramAnnInvisAttrParameterAnnotations rpaList<AnnotationEntryGen>[] parmListnew List<>[]ParameterAnnotationEntry immutableArrayList<AnnotationEntryGen> mutablemakeMutableVersion(...)List<AnnotationEntryGen> resultList<AnnotationEntryGen> existingAnnotationsList<AnnotationEntryGen> l/* Add local variables, namely the implicit `this' and the arguments */// Instance method -> `this' is local var 0// Names for variables provided?// Give them dummy names/* may be overridden anyway */// May happen, because end_pc is exclusive// Make it inclusive// Repair malformed handles// Overwrite if necessary/* Also updates positions of instructions, i.e., their indices *//* Create LocalVariableTable, LocalvariableTypeTable, and LineNumberTable ... *//* Each attribute causes 6 additional header bytes */// Every entry takes 8 bytes// Remove any stale code attribute// prologue byte code// exceptions// Add `Exceptions' if there are "throws" clauses// Undo effects of adding attributes/* Check branch instructions. */// TODO could be package-protected? (some tests would need repackaging)/* Initially, populate the branch stack with the exception ... */// choose the next instruction based on whether current is a branch.// explore all of the select's targets. the default target is handled below.// nothing to fall through to.// if an instruction that comes back to following PC,// push next instruction, with stack depth reduced by 1.// for all branches, the target of the branch is pushed on the branch stack.// conditional branches have a fall through case, selects don't, and// jsr/jsr_w return to the next instruction.// check for instructions that terminate the method.// normal case, go to the next instruction.// if we have no more instructions, see if there are any deferred branches to explore.// Initialize param_annotations// OK// This returns Annotation[] ...// ... which needs transforming into an AnnotationGen[] ...// ... then add these to any we already know about/** Implement this interface if you're interested in changes to a MethodGen object ... *//** NEW - Create new object ... */ExceptionConst.INSTANTIATION_ERRORvisitNEW(...)/** NEWARRAY -  Create new array of basic type (int, short, ...) ... */visitNEWARRAY(...)/** NOP - Do nothing ... */visitNOP(...)/** Super class for FieldOrMethod and INVOKEDYNAMIC, since they both have ... */getNameAndType(...)/** Denote entity that has both name and type. This is true for local variables, ... *//** Denotes reference such as java.lang.String. ... */// Class name of type(...).class_name/** If "this" doesn't reference a class, it references an interface ... */isClass(...)/** If "this" doesn't reference an interface, it references a class ... *//** Return true if this type references a class, ... *//** Return true if this type references an interface, ... *//** Return true if this type is a subclass of given ObjectType. ... */referencesInterfaceExact(...)superclass.class_name/** Java Virtual Machine Specification edition 2,  5.4.4 Access Control ... */JavaClass accaccessor.class_name/** POP - Pop top operand stack word ... */visitPopInstruction(...)visitPOP(...)/** POP2 - Pop two top operand stack words ... */visitPOP2(...)/** Wrapper class for push operations, which are implemented either as BIPUSH, ... *//** This constructor also applies for values of type short, char, byte ... */isValidByte(...)InstructionConst.FCONST_1InstructionConst.FCONST_2InstructionConst.LCONST_1InstructionConst.DCONST_1new PUSH(...).instruction/** creates a push object from a Character value. Warning: Make sure not to attempt to allow ... *//** PUTFIELD - Put field in object ... */visitPUTFIELD(...)/** PUTSTATIC - Put static field in class ... */visitPUTSTATIC(...)/** Denotes an unparameterized instruction to pop a value on top from the stack, ... *//** Denotes an unparameterized instruction to produce a value on top of the stack, ... *//** RET - Return from subroutine ... */// index to local variable containg the return address/** Set index of local variable containg the return address */ReturnaddressType.NO_TARGETvisitRET(...)// Including the wide byte/** RETURN -  Return from void method ... */visitRETURN(...)/** Super class for object and array types. ... *//** Class is non-abstract but not instantiable from the outside *//** Return true iff this type is castable to another type t as defined in ... */isAssignmentCompatibleWith(...)/** Return true iff this is assignment compatible with another type t ... */ReferenceType TreferencesClassExact(...)Type scgetElementType(...)Type tcgetInterfacesImplementedByArrays(...)/** This commutative operation returns the first common superclass (narrowest ReferenceType ... */ObjectType thizObjectType otherJavaClass[] thiz_supsJavaClass[] other_supsJavaClass[] this_supsthiz_sups.lengthJavaClass[] t_supsother_sups.lengthArrayType arrType1ArrayType arrType2getDimensions(...)getFirstCommonSuperclass(...)JavaClass t_supJavaClass this_supreferencesInterface(...)// If this is ever changed in isAssignmentCompatible()/* Yes, it's true: It's the same definition. ... */// This is not explicitely stated, but clear. Isn't it?/* If this is a class type then *//* If T is a class type, then this must be the same class as T, ... *//* If T is an interface type, this must implement interface T. *//* If this is an interface type, then: *//* If T is a class type, then T must be Object (2.4.7). *//* If T is an interface type, then T must be the same interface ... *//* If this is an array type, namely, the type SC[], that is, an ... *//* If T is an array type TC[], that is, an array of components ... *//* TC and SC are the same primitive type (2.4.1). *//* TC and SC are reference types (2.4.6), and type SC is ... *//* If T is an interface type, T must be one of the interfaces implemented by arrays (2.15). */// TODO: Check if this is still valid or find a way to dynamically find out which// interfaces arrays implement. However, as of the JVM specification edition 2, there// are at least two different pages where assignment compatibility is defined and// on one of them "interfaces implemented by arrays" is exchanged with "'Cloneable' or// 'java.io.Serializable'"// default./* TODO: Above sounds a little arbitrary. On the other hand, there is ... *//* This code is from a bug report by Konstantin Shagin <konst@cs.technion.ac.il> */// TODO: Is there a proof of OBJECT being the direct ancestor of every ArrayType?// TODO: The above line is correct comparing to the vmspec2. But one could// make class file verification a bit stronger here by using the notion of// superinterfaces or even castability or assignment compatibility.// this and t are ObjectTypes, see above.// Waaahh...// Huh? Did you ask for Type.OBJECT's superclass??/** Super class for the xRETURN family of instructions. ... */ExceptionConst.ILLEGAL_MONITOR_STATE/** Returnaddress, the type JSR or JSR_W instructions push upon the stack. ... */ReturnaddressType NO_TARGET;InstructionHandle returnTarget;/** A Returnaddress [that doesn't know where to return to]. *//** Creates a ReturnaddressType object with a target. */this.returnTarget/** Returns if the two Returnaddresses refer to the same target. */ReturnaddressType thatthat.returnTarget/** SALOAD - Load short from array ... */visitSALOAD(...)/** SASTORE - Store into short array ... */visitSASTORE(...)/** SIPUSH - Push short ... */short b;/** Dump instruction as short code to stream out. */visitSIPUSH(...)/** SWAP - Swa top operand stack word ... */visitSWAP(...)/** SWITCH - Branch depending on int value, generates either LOOKUPSWITCH or ... */...[] match;...[] targets;Select instruction;int match_length;/** Template for switch() constructs. If the match array can be ... */this.matchthis.targetsmatch.lengthmatchIsOrdered(...)int max_sizeint[] m_vecInstructionHandle[] t_vecint prev/** Sort match and targets array with QuickSort. */InstructionHandle h2// Swap elements// Swap instructions, too/** Select - Abstract super class for LOOKUPSWITCH and TABLESWITCH instructions. ... */...[] indices;// matches, i.e., case 1: ... TODO could be package-protected?// target offsets TODO could be package-protected?int fixed_length;// target objects in instruction list TODO could be package-protected?// fixed length defined by subclasses TODO could be package-protected?int padding;// number of cases TODO could be package-protected?// number of pad bytes for alignment TODO could be package-protected?/** (Match, target) pairs for switch. `Match' and `targets' must have the ... */InstructionHandle target2/** Since this is a variable length instruction, it may shift the following ... *//** Set branch target for `i'th case */Select copycopy.matchcopy.indicescopy.targets/** Inform targets that they're not targeted anymore. */this.fixed_lengththis.match_length/* @since 6.0 */// don't set default target before instuction is built// now it's safe to set default target// Additional offset caused by preceding SWITCHs, GOTOs, etc./* Alignment on 4-byte-boundary, + 1, because of tag byte. */// Write default target offset// Compute number of pad bytes// Default branch target common for both cases (TABLESWITCH, LOOKUPSWITCH)// Allow use in nested calls// For 'class' this points to the class entry in the cpGen// the cpGen/** Protected ctor used for deserialization, doesn't *put* an entry in the ... */// force it to be passed// ctors for each supported type... type could be inferred but for now lets/** The boolean controls whether we copy info from the 'old' constant pool to ... */getValueString(...)getValueInt(...)getValueByte(...)getValueChar(...)getValueLong(...)getValueFloat(...)getValueDouble(...)getValueBoolean(...)getValueShort(...)/** Return immutable variant */// J5ASSERT: Could assert value.stringifyValue() is the same as// cpool.getConstant(SimpleElementValuevalue.getIndex())/** Denote an instruction that may consume a value from the stack. ... *//** Super class for stack operations like DUP and POP. ... *//** Denote an instruction that may produce a value on top of the stack ... *//** Denotes an unparameterized instruction to store a value into a local variable, ... */visitStoreInstruction(...)/** TABLESWITCH - Switch within given range of values, i.e., low..high ... */visitTABLESWITCH(...)/* Alignment remainder assumed 0 here, until dump time *//** Thrown by InstructionList.remove() when one or multiple disposed instructions ... */import ClassFormatException/** Abstract super class for all possible java types, namely basic types such as ... */new BasicType(...)new ReferenceType(...) { ... }Type$1new Type(...) { ... }Type$2Const.T_UNKNOWNType$3BasicType VOID;/** Predefined constants */// signature for the typeBasicType BOOLEAN;BasicType INT;BasicType SHORT;BasicType BYTE;BasicType LONG;BasicType DOUBLE;BasicType FLOAT;BasicType CHAR;ObjectType OBJECT;ObjectType CLASS;ObjectType STRING;ObjectType STRINGBUFFER;ObjectType THROWABLE;...[] NO_ARGS;ReferenceType NULL;// EMPTY, so immutableType UNKNOWN;t.typet.signature/** boolean, short and char variable are considered as int in the stack or ... *//** Convert type to Java method signature, e.g. int[] f(java.lang.String x) ... *///int consumed_chars=0; // Remember position in string, see getArgumentTypes/** Convert signature to a Type object. ... */int dimString parsedSignature/** Convert return value of a method (signature) to a Type object. ... *//** Convert arguments of a method (signature) to an array of Type objects. ... */List<Type> vecnew ArrayList<Type>(...)Type[] types/** Convert runtime java.lang.Class to BCEL Type object. ... *//** Convert runtime java.lang.Class[] to BCEL Type objects. ... */Type[] retret.lengthClass<?> paramint resint codedconsumed(...)int consumed/* Currently only used by the ArrayType constructor. ... */// Count dimensions// Recurse, but just once, if the signature is ok//  consumed_chars += dim; // update counter - is replaced by// type == T_REFERENCE// Utility.signatureToString understands how to parse// generic types./* That's an amzingly easy case, because getName() returns ... */// "Real" class/** Get the type associated with an instruction, int for ILOAD, or the type ... *//** Denotes an instruction to perform an unconditional branch, i.e., GOTO, JSR. ... *//** Denotes an instruction to be a variable length instruction, such as ... *//** Interface implementing the Visitor pattern programming style. ... */import InnerClassimport InnerClasses/** Convert found attributes into HTML file. ... */PrintWriter file;// name of current classint attr_count;// file to write toConstantHTML constant_html;this.constant_htmlwriteAttribute(...)CodeException[] cece.lengthLineNumber[] line_numbersInnerClass[] classesCodeException cexint catch_typereferenceConstant(...)codeLink(...)int indiceline_numbers.lengthreferenceType(...)InnerClass classe// Increment number of attributes found so far/* Handle different attributes */// Some directly printable values// Get handled exceptions and list them// Index in constant pool// Create Link to _cp.html// Reference _cp.html// List thrown exceptions// List line number pairs// breakable// List name, range and type// List inner classes// Such as Unknown attribute or Deprecated/** Used for BCEL comparison strategy ... *//** Compare two objects and return what THIS.equals(THAT) should return ... *//** Return hashcode for THIS.hashCode() ... */import AllocationInstructionimport ArrayInstructionimport BranchHandleimport BranchInstructionimport CHECKCASTimport CPInstructionimport CodeExceptionGenimport ConstantPoolGenimport ConstantPushInstructionimport EmptyVisitorimport FieldInstructionimport IINCimport INSTANCEOFimport Instructionimport InstructionConstimport InstructionHandleimport InvokeInstructionimport LDCimport LDC2_Wimport LocalVariableInstructionimport MULTIANEWARRAYimport MethodGenimport NEWARRAYimport ObjectTypeimport RETimport ReturnInstructionimport Select/** Factory creates il.append() statements, and sets instruction targets. ... */new HashMap<Instruction,InstructionHandle>(...)new ArrayList<BranchInstruction>(...)getSimpleName(...)Const.classString CONSTANT_PREFIX;MethodGen _mg;PrintWriter _out;ConstantPoolGen _cp;Map<Instruction,InstructionHandle> branch_map;visitInstruction(...)updateBranchTargets(...)updateExceptionHandlers(...)Type typegetIncrement(...)printType(...)String field_nameType[] arg_typesprintArgumentTypes(...)String embedObjectType otcreateConstant(...)List<BranchInstruction> branches;// Memorize BranchInstructions that need an updateStringBuilder argsint[] matchsgetMatchs(...)matchs.lengthint t_posString targetihs.lengthCodeExceptionGen[] handlersCodeExceptionGen h// memorize container// Handled belowimport ClassParser/** This class takes a given JavaClass object and converts it to a ... */BCELifier$FLAGS/** Enum corresponding to flag source. */new FLAGS(...)FLAGS UNKNOWN;FLAGS CLASS;FLAGS METHOD;String BASE_PACKAGE;// N.B we use the class so renames will be detected by the compiler/IDE// The base package name for imports; assumes Const is at the top levelJavaClass _clazz;/** Start Java code generation */String super_nameString package_nameString interprintFlags(...)FLAGS.CLASSprintCreate(...)printMain(...)BCELFactory factorynew BCELFactory(...)FLAGS.METHODgetArgumentNames(...)FLAGS.UNKNOWN/** Return a string with the flag settings ... */int powConst.ACCESS_NAMES_LENGTH/** Default main method */JavaClass java_classgetJavaClass(...)BCELifier bcelifiernew BCELifier(...)argv.length// Needs to be accessible from unit test codenew ClassParser(...)// May throw IOException/** Utility class that implements a sequence of bytes which can be read ... */ByteArrayStream byteStream;new ByteArrayStream(...)unreadByte(...)ByteSequence$ByteArrayStream// pos is protected in ByteArrayInputStream/** Read class file(s) and convert them into HTML files. ... */JavaClass java_class;String dir;// current class objectString class_package;// name of package, unclean to make it static, but ...// name of current class, ditoSet<String> basic_types;/** Write contents of the given JavaClass into HTML files. ... */ConstantHTML constant_htmlnew ConstantHTML(...)AttributeHTML attribute_htmlnew AttributeHTML(...)this.java_classthis.dirnew MethodHTML(...)writeMainHTML(...)new CodeHTML(...)String[] file_nameint filesClassParser parserString zip_filechar sepString dirFile storeboolean creatednew Class2HTML(...)/** Utility method that converts a class reference in the constant pool, ... */String short_typeString base_typePrintWriter file// Remember full name// Get package name by tacking off everything after the last `.'// default package/* Attributes can't be written in one step, so we just open a file ... */// Write main file (with frames, yuk)// Where to store HTML files/* Parse command line arguments. */// command line switch// Specify target directory, default '.'// Create target directory if necessary// Loop through files ...// Create parser object from file// Create parser object from zip file// Type is an array?// Tack of the `['// test for basic typeimport java.util.zip.*/** Responsible for loading (class) files from the CLASSPATH. Inspired by ... */new ClassPath(...)ClassPath SYSTEM_CLASS_PATH;...[] paths;String class_path;/** Search for classes in given path. */ArrayList<> vecthis.class_pathisFileExists(...)new Dir(...)new Zip(...)new PathEntry[]/** Search for classes in CLASSPATH. ... */(...).class_pathFile.pathSeparator/** Checks for class path components in the following properties: ... */String class_pathString boot_pathString ext_pathArrayList<> dirsgetPathComponents(...)Iterator<> eFile ext_dirString[] extensionsgetFileList(...)new FilenameFilter(...) { ... }ClassPath$1extensions.lengthFile.pathSeparatorChar/** Return stream for class or resource on CLASSPATH. ... */getClassFile(...)paths.lengthClassFile cfDataInputStream disClassPath$PathEntry/** Contains information about file/ZIP entry of the Java class. */ClassPath$Dirnew ClassFile(...) { ... }ClassPath$Dir$1getCanonicalPath(...)ClassPath$ZipZipFile zip;ClassPath$Zip$1/* ==================================================================== ... */// this(getClassPath());/** Utility class implementing a (typesafe) queue of JavaClass objects. ... */new LinkedList<JavaClass>(...)LinkedList<JavaClass> vec;/** Utility class implementing a (typesafe) set of JavaClass objects. ... */new HashMap<String,JavaClass>(...)Map<String,JavaClass> map;Collection<JavaClass> values/** Utility class implementing a (typesafe) stack of JavaClass objects. ... */new Stack<JavaClass>(...)Stack<JavaClass> stack;/** Convert code into HTML file. ... *///    private Method[] methods; // Methods to printBitSet goto_set;writeMethod(...)/** Disassemble a stream of byte codes and return the ... */int windexConstantFieldref c1int m_indexConstantNameAndType c2int elementint matchConstantInterfaceMethodref creferenceClass(...)ConstantInvokeDynamic cConstantMethodref ctoHTML(...)/** Find all target addresses in code, so that they can be marked ... */int opcodecodeToHTML(...)/** Write a single method with the byte code associated with it. */String html_namebyte[] codeAttribute[] attributes2attributes2.lengthfindGotos(...)String anchorString anchor2//        this.methods = methods;// Print switch indices in first row (and default)// Print target and default indices in second row/* Same for 32-bit wide jumps */// Local field// Special treatment needed// Redundant// Reserved//                    int nargs = bytes.readUnsignedByte(); // Redundant//                    int reserved = bytes.readUnsignedByte(); // Reserved// UNDONE: Java8 now allows INVOKESPECIAL and INVOKESTATIC to// reference EITHER a Methodref OR an InterfaceMethodref.// Not sure if that affects this code or not.  (markro)// Get signature, i.e., types// List arguments// Attach return type// Either branch or index/* First get Code attribute from method and the exceptions handled ... */// Look for local variables and their range// Get target addresses from GOTO, JSR, TABLESWITCH, etc.//System.out.println(getOpcodeName(opcode));//bytes.readByte(); // Skip already read byte// LOOKUPSWITCH//                            int match = bytes.readInt();// Ignore output// Get raw signature// Get array of strings containing the argument types// Get return type string// Get method name// Get method's access flags// Get the method's attributes, the Code Attribute in particular// No code, an abstract method, e.g.//System.out.println(name + "\n" + Utility.codeToString(code, constant_pool, 0, -1));// Print the byte code/* Set an anchor mark if this line is targetted by a goto, jsr, etc. Defining an anchor for every ... */// Mark last line, may be targetted from Attributes window/** Convert constant pool into HTML file. ... */// name of package// reference to constant pool...[] constant_ref;// String to return for cp[i]// The constants in the cpthis.class_packagewriteConstant(...)String refString html_method_nameString method_classString short_method_classString ret_typeString arg_typesConstantFieldref c3String field_classString short_field_classConstantClass c4String class_name2String short_class_nameConstantString c5ConstantNameAndType c6ConstantInterfaceMethodref c1getMethodNumber(...)String cmp// Loop through constants, constants[0] is reserved// The header is always the same/* For every constant type get the needed parameters and print them appropiately */// Get class_index and name_and_type_index, depending on type// Get method name and its class// Partially compacted class name, i.e., / -> .// I.e., remove java.lang.// Remove class package prefix// Get method signature// Get class_index and name_and_type_index// Get method name and its class (compacted)// / -> .// switchimport Matcherimport ClassGenExceptionimport InstructionList/** InstructionFinder is a tool to search for given instructions patterns, i.e., ... */precompile(...)makeChar(...)compilePattern(...)Const.UNDEFINEDint NO_OPCODES;// char + OFFSET is outside of LATIN-1Map<String,String> map;// Potential number, some are not usedString il_string;...[] handles;// instruction list as string// list to array// map instructionreread(...)/** Reread the instruction list, e.g., after you've altered the list upon a ... */getInstructionHandles(...)/** Map symbolic instruction names like "getfield" to a single character. ... *//** Replace symbolic names of instructions with the appropiate character and ... */String lowerStringBuilder namemapName(...)InstructionHandle[] match/** Search for the given pattern in the instruction list. You can search for ... */String searchPattern regexcompile(...)List<InstructionHandle[]> matchesnew ArrayList<InstructionHandle[]>(...)Matcher matchermatcher(...)handles.lengthint startExprint endExprint lenExprcheckCode(...)/** Start search beginning from the start of the given instruction list. ... */search(...)/** Start search beginning from `from'. ... *//** Start search beginning from the start of the given instruction list. Check ... *//** Convert opcode number to char. *//** Code patterns found may be checked using an additional user-defined ... */// Create a string with length equal to il length// Map opcodes to characters//Bug: BCEL-77 - Instructions are assumed to be english, to avoid odd Locale issues// Where to start search from (index)// Initialize pattern map// Some aliases// Precompile some aliases first// Compile strings// Omit already precompiled patterns// precompile all patterns// Add instruction alias to match anything// Not an invalid opcode/* Internal debugging routines. *///    private static final String pattern2string( String pattern ) {//        return pattern2string(pattern, true);//    private static final String pattern2string( String pattern, boolean make_string ) {//        StringBuffer buf = new StringBuffer();//        for (int i = 0; i < pattern.length(); i++) {//            char ch = pattern.charAt(i);//            if (ch >= OFFSET) {//                if (make_string) {//                    buf.append(Constants.getOpcodeName(ch - OFFSET));//                } else {//                    buf.append((ch - OFFSET));//                }//            } else {//                buf.append(ch);//            }//        return buf.toString();/** Java interpreter replacement, i.e., wrapper that uses its own ClassLoader ... *//** Runs the _main method of the given class with the arguments passed in argv ... */Class<> rNoSuchMethodException no/** Default _main method used as wrapper, expects the fully qualified class name ... */String[] new_argvJavaWrapper wrappernew JavaWrapper(...)new_argv.lengthrunMain(...)/* Method _main is sane ? *//* Expects class name as first argument, other arguments are by-passed. *//** Convert methods and fields into HTML file. ... */AttributeHTML attribute_html;this.attribute_html/** Print field of class. ... */int[] exceptionsAttribute[] c_ac_a.length// Write them to the Attributes.html file with anchor "<name>[<i>]"// Default value// Reference attribute in _attributes.html/* HTML doesn't like names like <clinit> and spaces are places to break ... */// Check for thrown exceptions/** Abstract definition of a class repository. Instances may be used to load ... *//** Store the provided class under "clazz.getClassName()" *//** Remove class from repository *//** Find the class with the name provided, if the class isn't there, return ... *//** Find the class with the name provided, if the class isn't there, make an ... *//** Find the JavaClass instance for the given run-time class object *//** Clear all entries from cache. *//** This repository is used in situations where a Class is created outside the ... */new HashMap<String,SoftReference<JavaClass>>(...)Map<String,SoftReference<JavaClass>> loadedClasses;// CLASSNAME X JAVACLASSnew SyntheticRepository(...)/** Store a new JavaClass instance into this Repository. */new SoftReference<JavaClass>(...)setRepository(...)/** Find an already defined (cached) JavaClass object by name. */SoftReference<JavaClass> ref/** Finds a JavaClass object by name. If it is already in this Repository, the ... *//** Find the JavaClass object for a runtime Class object. If a class with the ... */JavaClass repositoryClassJavaClass clsInputStream clsStream// Just in case, canonical form// ignored/** Administrative class to keep track of the version number of ... *//** Get the basic version string for the current Xalan release. ... */getReleaseVersionNum(...)getMajorVersionNum(...)getImplementationLanguage(...)getProduct(...)getDevelopmentVersionNum(...)getMaintenanceVersionNum(...)/** Print the processor version to the command line. ... *//** Name of product: Xalan. *//** Implementation Language: Java. *//** Major version number. ... *//** Release Number. ... *//** Maintenance Drop Number. ... *//** Development Drop Number. ... *//* Copyright 2003-2004 The Apache Software Foundation. ... *//* $Id: Version.java,v 1.1.2.1 2005/08/01 02:11:19 jeffsuttor Exp $ *//** Commonly used constants. ... */isJavaVersionAtLeast(...)String SECURITY_MANAGER;//Xerces security managerString ORACLE_JAXP_PROPERTY_PREFIX;/** Oracle JAXP property prefix ("http://www.oracle.com/xml/jaxp/properties/"). */// Implementation limits: API propertiesString JDK_ENTITY_EXPANSION_LIMIT;/** JDK entity expansion limit; Note that the existing system property ... */String JDK_ELEMENT_ATTRIBUTE_LIMIT;/** JDK element attribute limit; Note that the existing system property ... */String JDK_MAX_OCCUR_LIMIT;/** JDK maxOccur limit; Note that the existing system property ... */String JDK_TOTAL_ENTITY_SIZE_LIMIT;/** JDK total entity size limit */String JDK_GENERAL_ENTITY_SIZE_LIMIT;/** JDK maximum general entity size limit */String JDK_ENTITY_REPLACEMENT_LIMIT;/** JDK node count limit in entities that limits the total number of nodes ... */String JDK_PARAMETER_ENTITY_SIZE_LIMIT;/** JDK maximum parameter entity size limit */String JDK_XML_NAME_LIMIT;/** JDK maximum XML name limit */String JDK_MAX_ELEMENT_DEPTH;/** JDK maxElementDepth limit */String JDK_ENTITY_COUNT_INFO;/** JDK property indicating whether the parser shall print out entity ... */String SP_ENTITY_EXPANSION_LIMIT;// API properties// Implementation limits: corresponding System Properties of the aboveString SP_ELEMENT_ATTRIBUTE_LIMIT;String SP_MAX_OCCUR_LIMIT;String SP_TOTAL_ENTITY_SIZE_LIMIT;String SP_GENERAL_ENTITY_SIZE_LIMIT;String SP_ENTITY_REPLACEMENT_LIMIT;String SP_PARAMETER_ENTITY_SIZE_LIMIT;String SP_XML_NAME_LIMIT;String SP_MAX_ELEMENT_DEPTH;String JDK_EXTENSION_CLASSLOADER;/** JDK TransformerFactory and Transformer attribute that specifies a class ... */String ENTITY_EXPANSION_LIMIT;//legacy System PropertiesString ELEMENT_ATTRIBUTE_LIMIT;String MAX_OCCUR_LIMIT;String JDK_YES;/** A string "yes" that can be used for properties such as getEntityCountInfo */String ORACLE_FEATURE_SERVICE_MECHANISM;/** <p>Use Service Mechanism</p> ... */// Oracle Feature:String SP_ACCESS_EXTERNAL_STYLESHEET;//System Properties corresponding to ACCESS_EXTERNAL_* propertiesString SP_ACCESS_EXTERNAL_DTD;String ACCESS_EXTERNAL_ALL;//all access keywordString EXTERNAL_ACCESS_DEFAULT_FSP;/** Default value when FEATURE_SECURE_PROCESSING (FSP) is set to true */String EXTERNAL_ACCESS_DEFAULT;/** FEATURE_SECURE_PROCESSING (FSP) is false by default */String XML_SECURITY_PROPERTY_MANAGER;String ORACLE_ENABLE_EXTENSION_FUNCTION;/** Feature enableExtensionFunctions */String SP_ORACLE_ENABLE_EXTENSION_FUNCTION;String FEATURE_TRUE;/** Values for a feature */String FEATURE_FALSE;boolean IS_JDK8_OR_ABOVE;/** Check if we're in jdk8 or above *//* Check the version of the current JDK against that specified in the ... */String javaVersionString[] versions/* Copyright (c) 2011, 2015, Oracle and/or its affiliates. All rights reserved. ... */// class Constantsimport ErrorListenerimport XObjectimport NodeIterator/** An object that implements this interface can supply ... *//** Get the current context node. ... *//** Get the current context node list. ... *//** Get the error listener. ... *//** Get the value of a node as a number. ... *//** Get the value of a node as a string. ... *//** Get a variable based on it's qualified name. ... *//** Get the XPathContext that owns this ExpressionContext. ... */import DTMNodeProxy/** The base class for some EXSLT extension classes. ... *//** Return the string value of a Node ... */getStringValue(...)NodeList nodelist/** Convert the string value of a Node to a number. ... */double dDouble.NaNimport ExpressionContextimport DTMIteratorimport DTMNodeIteratorimport NodeSet/** This class contains EXSLT common extension functions. ... *//** The exsl:object-type function returns a string giving the type of the object passed ... */DTMIterator dtmIgetDTMIterator(...)/** The exsl:node-set function converts a result tree fragment (which is what you get ... */nodeset(...)import ParseExceptionimport SimpleDateFormatimport Calendarimport TimeZoneimport XBooleanimport XNumber/** This class contains EXSLT dates and times extension functions. ... */String dt;// Datetime formats (era and zone handled separately).String d;String gym;String gy;String gmd;String gm;String gd;String t;String EMPTY_STR;/** The date:date-time function returns the current date and time as a date/time string. ... */Calendar calDate datetimeSimpleDateFormat dateFormatnew SimpleDateFormat(...)Calendar.ZONE_OFFSETCalendar.DST_OFFSETint hrschar posnegformatDigits(...)/** Represent the hours and minutes with two-digit strings. ... */String dd/** The date:date function returns the date specified in the date/time string given ... */String[] edzgetEraDatetimeZone(...)String leaderString datetimeString zoneString[] formatsInString formatOuttestFormats(...)String dateOutsetLenient(...)/** See above. */dateTime(...)String dategetZoneStart(...)/** The date:time function returns the time specified in the date/time string given ... */String timeString out/** The date:year function returns the year of a date as a number. If no ... */boolean adString[] formatsdouble yrCalendar.YEAR/** The date:month-in-year function returns the month of a date as a number. If no argument ... */Calendar.MONTH/** The date:week-in-year function returns the week of the year as a number. If no argument ... */Calendar.WEEK_OF_YEAR/** The date:day-in-year function returns the day of a date in a year ... */Calendar.DAY_OF_YEAR/** The date:day-in-month function returns the day of a date as a number. ... */double dayCalendar.DAY_OF_MONTH/** The date:day-of-week-in-month function returns the day-of-the-week ... */Calendar.DAY_OF_WEEK_IN_MONTH/** The date:day-in-week function returns the day of the week given in a ... */Calendar.DAY_OF_WEEK/** The date:hour-in-day function returns the hour of the day as a number. ... */Calendar.HOUR_OF_DAY/** The date:minute-in-hour function returns the minute of the hour ... */Calendar.MINUTE/** The date:second-in-minute function returns the second of the minute ... */Calendar.SECOND/** The date:leap-year function returns true if the year given in a date ... */double dblint yrnew XNumber(...)new XBoolean(...)/** The date:month-name function returns the full name of the month of a date. ... */getNameOrAbbrev(...)/** The date:month-abbreviation function returns the abbreviation of the month of ... *//** The date:day-name function returns the full name of the day of the week ... *//** The date:day-abbreviation function returns the abbreviation of the day ... *//** Returns an array with the 3 components that a datetime input string ... */int z/** Get the start of zone information if the input ends ... */Date dParseException pegetErrorOffset(...)/** Attempt to parse an input string with the allowed formats, returning ... */formats.length/** Parse the input string and return the corresponding calendar field ... *//** Get the full name or abbreviation of the month or day. */formatsIn.lengthDate dtapplyPattern(...)/** Get the full name or abbreviation for the current month or day ... *//** The date:format-date function formats a date/time according to a pattern. ... */String yearSymbolsString monthSymbolsString daySymbolsTimeZone timeZonegetTimeZone(...)String offsetSimpleDateFormat inFormatSimpleDateFormat outFormatstrip(...)setTimeZone(...)/** Strips occurrences of the given character from a date format pattern. ... */int quoteSemaphoreint endQuote// Format for date and time.// Must also include offset from UTF.// Get the offset (in milliseconds).// If there is no offset, we have "Coordinated// Universal Time."// Convert milliseconds to hours and minutes// In a few cases, the time zone may be +/-hh:30.// The datetime() function returns the zone on the datetime string.  If we// append it, we get the zone substring duplicated.// Fix for JIRA 2013// String zone = datetime.substring(getZoneStart(datetime));// return (time + zone);// AD (Common Era -- empty leader)//  '+' is implicit , not allowed//System.out.println("'" + leader + "' " + datetime + " " + zone);// Invalid.// No zone information.// Try the allowed formats, from longest to shortest.// from longest to shortest.// Get the timezone information if it was supplied and modify the// dateTime so that SimpleDateFormat will understand it.// Need to adjust it since SimpleDateFormat requires GMT+hh:mm but// we have +hh:mm.// Assume local time.// Leave off the timezone since SimpleDateFormat will assume local// time if time zone is not included.// Try the time format first. We need to do this to prevent// SimpleDateFormat from interpreting a time as a year. i.e we just need// to check if it's a time before we check it's a year.// Try the right truncated formats.// Now try the left truncated ones. The Java format() function doesn't// return the correct strings in this case. We strip any pattern// symbols that shouldn't be output so that they are not defaulted to// inappropriate values in the output.// Assume it's an openening quote so simply copy the quoted// text to the result. There is nothing to strip here.// The char needs to be stripped.import DocumentBuilderimport DocumentBuilderFactoryimport TransformerExceptionimport XSLMessagesimport XSLTErrorResourcesimport NodeSetDTMimport XPathimport XPathContextimport XNodeSetimport JdkXmlUtilsimport Documentimport Elementimport Textimport SAXNotSupportedException/** This class contains EXSLT dynamic extension functions. ... */String EXSL_URI;/** The dyn:max function calculates the maximum value for the nodes passed as ... */XPathContext xctxtNodeSetDTM contextNodesnew NodeSetDTM(...)double maxValueXPathContext.XPathExpressionContextgetXPathContext(...)new SAXNotSupportedException(...)createMessage(...)XSLTErrorResources.ER_INVALID_CONTEXT_PASSEDpushContextNodeList(...)int contextNodedouble resultpushCurrentNode(...)XPath dynamicXPathnew XPath(...)getSAXLocator(...)getNamespaceContext(...)XPath.SELECTnum(...)TransformerException epopCurrentNode(...)popContextNodeList(...)/** The dyn:min function calculates the minimum value for the nodes passed as the ... */double minValue/** The dyn:sum function calculates the sum for the nodes passed as the first argument, ... */double sum/** The dyn:map function evaluates the expression passed as the second argument for ... */Document lDocNodeSet resultSetnew NodeSet(...)setShouldCacheNodes(...)XObject objectnodelist(...)Node naddNode(...)Element elementText textNodecreateTextNode(...)str(...)getDOMDocument(...)createElementNS(...)/** The dyn:evaluate function evaluates a string as an XPath expression and returns ... */getContextNode(...)new XNodeSet(...)getDTMManager(...)/** The dyn:closure function creates a node set resulting from transitive closure of ... */NodeSet closureSetNodeList iterationListNodeSet iterationSet//"Invalid context passed to evaluate "/** This class contains EXSLT math extension functions. ... */String PI;String E;String SQRRT2;String LN2;String LN10;String LOG2E;String SQRT1_2;/** The math:max function returns the maximum value of the nodes passed as the argument. ... */double mtoNumber(...)isNaN(...)/** The math:min function returns the minimum value of the nodes passed as the argument. ... *//** The math:highest function returns the nodes in the node set whose value is the maximum ... */NodeSet highNodes/** The math:lowest function returns the nodes in the node set whose value is the minimum value ... */NodeSet lowNodes/** The math:abs function returns the absolute value of a number. ... *//** The math:acos function returns the arccosine value of a number. ... *//** The math:asin function returns the arcsine value of a number. ... */asin(...)/** The math:atan function returns the arctangent value of a number. ... *//** The math:atan2 function returns the angle ( in radians ) from the X axis to a point (y,x). ... */atan2(...)/** The math:cos function returns cosine of the passed argument. ... *//** The math:exp function returns e (the base of natural logarithms) raised to a power. ... */exp(...)/** The math:log function returns the natural logarithm of a number. ... *//** The math:power function returns the value of a base expression taken to a specified power. ... */pow(...)/** The math:random function returns a random number from 0 to 1. ... */random(...)/** The math:sin function returns the sine of the number. ... *//** The math:sqrt function returns the square root of a number. ... *//** The math:tan function returns the tangent of the number passed as an argument. ... *//** The math:constant function returns the specified constant to a set precision. ... */parseDouble(...)// empty Nodesetimport DOM2Helper/** This class contains EXSLT set extension functions. ... *//** The set:leading function returns the nodes in the node set passed as the first argument that ... */NodeSet ns1NodeSet leadNodesNode endNodeNode testNodeisNodeAfter(...)isNodeTheSame(...)/** The set:trailing function returns the nodes in the node set passed as the first argument that ... */NodeSet trailNodesNode startNode/** The set:intersection function returns a node set comprising the nodes that are within ... */NodeSet ns2NodeSet inter/** The set:difference function returns the difference between two node sets - those nodes that ... */NodeSet diff/** The set:distinct function returns a subset of the nodes contained in the node-set NS passed ... */NodeSet distMap<String,Node> stringTablenew HashMap<String,Node>(...)Node currNode/** The set:has-same-node function returns true if the node set passed as the first argument shares ... *//* Copyright (c) 2005, 2017, Oracle and/or its affiliates. All rights reserved. *//* $Id: ExsltSets.java,v 1.1.2.1 2005/08/01 02:08:50 jeffsuttor Exp $ */// empty NodeSet/** This class contains EXSLT strings extension functions. ... *//** The str:align function aligns a string within another string. ... */int startIndex/** See above *//** The str:concat function takes a node set and returns the concatenation of the ... *//** The str:padding function creates a padding string of a certain length. ... */int numAddedpadding(...)/** The str:split function splits up a string and returns a node set of token ... */int matchIndexcreateElement(...)Text text/** The str:tokenize function splits up a string and returns a node set of token ... */StringTokenizer lTokenizertokenize(...)// Default is left// If the delimiter is an empty string, create one token Element for// every single character.import ObjectFactoryimport EnvironmentCheckimport DocumentFragment/** This class contains many of the Xalan-supplied extensions. ... *//** Constructor Extensions *//** This method is an extension that implements as a Xalan extension ... */// Make sure class cannot be instantiatedString textNodeValueDocument myDocDocumentFragment docFragcreateDocumentFragment(...)/** Returns the intersection of two node-sets. ... *//** Returns the difference between two node-sets. ... */difference(...)/** Returns node-set containing distinct string values. ... */distinct(...)/** Returns true if both node-sets contain the same set of nodes. ... *//** Returns the result of evaluating the argument as a string containing ... *//** Returns a NodeSet containing one text node for each token in the first argument. ... */// This no longer will work right since the DTM.// Document myDoc = myProcessor.getContextNode().getOwnerDocument();import SourceLocator/** <code>NodeInfo</code> defines a set of XSLT extension functions to be ... *//** <code>systemId</code> returns the system id of the current ... */Node contextNodeint nodeHandlergetDTMNodeNumber(...)SourceLocator locatorgetSourceLocatorFor(...)getDTM(...)getSystemId(...)/** <code>systemId</code> returns the system id of the node passed as ... *//** <code>publicId</code> returns the public identifier of the current ... */getPublicId(...)/** <code>publicId</code> returns the public identifier of the node passed as ... *//** <code>lineNumber</code> returns the line number of the current ... *//** <code>lineNumber</code> returns the line number of the node ... *//** <code>columnNumber</code> returns the column number of the ... */getColumnNumber(...)/** <code>columnNumber</code> returns the column number of the node ... */import XPATHMessages/** Sets things up for issuing error messages. This class is misnamed, and should ... */ListResourceBundle XSLTBundle;/** The language specific resource object for Xalan messages. */String XSLT_ERROR_RESOURCES;/** The class name of the Xalan error message string table. *//** Creates a message from the specified key and replacement arguments, ... */createMsg(...)//throws Exception/** Set up error messages. ... */String ER_INVALID_NAMESPACE_URI_VALUE_FOR_RESULT_PREFIX;/* Static variables *//* This file contains error and warning messages related to Xalan Error ... */String ER_INVALID_NAMESPACE_URI_VALUE_FOR_RESULT_PREFIX_FOR_DEFAULT;String ER_NO_CURLYBRACE;String ER_FUNCTION_NOT_SUPPORTED;String ER_ILLEGAL_ATTRIBUTE;String ER_NULL_SOURCENODE_APPLYIMPORTS;String ER_CANNOT_ADD;String ER_NULL_SOURCENODE_HANDLEAPPLYTEMPLATES;String ER_NO_NAME_ATTRIB;String ER_TEMPLATE_NOT_FOUND;String ER_CANT_RESOLVE_NAME_AVT;String ER_REQUIRES_ATTRIB;String ER_MUST_HAVE_TEST_ATTRIB;String ER_BAD_VAL_ON_LEVEL_ATTRIB;String ER_PROCESSINGINSTRUCTION_NAME_CANT_BE_XML;String ER_PROCESSINGINSTRUCTION_NOTVALID_NCNAME;String ER_NEED_MATCH_ATTRIB;String ER_NEED_NAME_OR_MATCH_ATTRIB;String ER_CANT_RESOLVE_NSPREFIX;String ER_ILLEGAL_VALUE;String ER_NO_OWNERDOC;String ER_ELEMTEMPLATEELEM_ERR;String ER_NULL_CHILD;String ER_NEED_SELECT_ATTRIB;String ER_NEED_TEST_ATTRIB;String ER_NEED_NAME_ATTRIB;String ER_NO_CONTEXT_OWNERDOC;String ER_COULD_NOT_CREATE_XML_PROC_LIAISON;String ER_PROCESS_NOT_SUCCESSFUL;String ER_NOT_SUCCESSFUL;String ER_ENCODING_NOT_SUPPORTED;String ER_COULD_NOT_CREATE_TRACELISTENER;String ER_KEY_REQUIRES_NAME_ATTRIB;String ER_KEY_REQUIRES_MATCH_ATTRIB;String ER_KEY_REQUIRES_USE_ATTRIB;String ER_REQUIRES_ELEMENTS_ATTRIB;String ER_MISSING_PREFIX_ATTRIB;String ER_BAD_STYLESHEET_URL;String ER_FILE_NOT_FOUND;String ER_IOEXCEPTION;String ER_NO_HREF_ATTRIB;String ER_STYLESHEET_INCLUDES_ITSELF;String ER_PROCESSINCLUDE_ERROR;String ER_MISSING_LANG_ATTRIB;String ER_MISSING_CONTAINER_ELEMENT_COMPONENT;String ER_CAN_ONLY_OUTPUT_TO_ELEMENT;String ER_PROCESS_ERROR;String ER_UNIMPLNODE_ERROR;String ER_NO_SELECT_EXPRESSION;String ER_CANNOT_SERIALIZE_XSLPROCESSOR;String ER_NO_INPUT_STYLESHEET;String ER_FAILED_PROCESS_STYLESHEET;String ER_COULDNT_PARSE_DOC;String ER_COULDNT_FIND_FRAGMENT;String ER_NODE_NOT_ELEMENT;String ER_FOREACH_NEED_MATCH_OR_NAME_ATTRIB;String ER_TEMPLATES_NEED_MATCH_OR_NAME_ATTRIB;String ER_NO_CLONE_OF_DOCUMENT_FRAG;String ER_CANT_CREATE_ITEM;String ER_XMLSPACE_ILLEGAL_VALUE;String ER_NO_XSLKEY_DECLARATION;String ER_CANT_CREATE_URL;String ER_XSLFUNCTIONS_UNSUPPORTED;String ER_PROCESSOR_ERROR;String ER_NOT_ALLOWED_INSIDE_STYLESHEET;String ER_RESULTNS_NOT_SUPPORTED;String ER_DEFAULTSPACE_NOT_SUPPORTED;String ER_INDENTRESULT_NOT_SUPPORTED;String ER_ILLEGAL_ATTRIB;String ER_UNKNOWN_XSL_ELEM;String ER_BAD_XSLSORT_USE;String ER_MISPLACED_XSLWHEN;String ER_XSLWHEN_NOT_PARENTED_BY_XSLCHOOSE;String ER_MISPLACED_XSLOTHERWISE;String ER_XSLOTHERWISE_NOT_PARENTED_BY_XSLCHOOSE;String ER_NOT_ALLOWED_INSIDE_TEMPLATE;String ER_UNKNOWN_EXT_NS_PREFIX;String ER_IMPORTS_AS_FIRST_ELEM;String ER_IMPORTING_ITSELF;String ER_XMLSPACE_ILLEGAL_VAL;String ER_PROCESSSTYLESHEET_NOT_SUCCESSFUL;String ER_SAX_EXCEPTION;String ER_XSLT_ERROR;String ER_CURRENCY_SIGN_ILLEGAL;String ER_DOCUMENT_FUNCTION_INVALID_IN_STYLESHEET_DOM;String ER_CANT_RESOLVE_PREFIX_OF_NON_PREFIX_RESOLVER;String ER_REDIRECT_COULDNT_GET_FILENAME;String ER_CANNOT_BUILD_FORMATTERLISTENER_IN_REDIRECT;String ER_INVALID_PREFIX_IN_EXCLUDERESULTPREFIX;String ER_MISSING_NS_URI;String ER_MISSING_ARG_FOR_OPTION;String ER_INVALID_OPTION;String ER_MALFORMED_FORMAT_STRING;String ER_STYLESHEET_REQUIRES_VERSION_ATTRIB;String ER_ILLEGAL_ATTRIBUTE_VALUE;String ER_CHOOSE_REQUIRES_WHEN;String ER_NO_APPLY_IMPORT_IN_FOR_EACH;String ER_CANT_USE_DTM_FOR_OUTPUT;String ER_CANT_USE_DTM_FOR_INPUT;String ER_CALL_TO_EXT_FAILED;String ER_PREFIX_MUST_RESOLVE;String ER_INVALID_UTF16_SURROGATE;String ER_XSLATTRSET_USED_ITSELF;String ER_CANNOT_MIX_XERCESDOM;String ER_TOO_MANY_LISTENERS;String ER_IN_ELEMTEMPLATEELEM_READOBJECT;String ER_DUPLICATE_NAMED_TEMPLATE;String ER_INVALID_KEY_CALL;String ER_REFERENCING_ITSELF;String ER_ILLEGAL_DOMSOURCE_INPUT;String ER_CLASS_NOT_FOUND_FOR_OPTION;String ER_REQUIRED_ELEM_NOT_FOUND;String ER_INPUT_CANNOT_BE_NULL;String ER_URI_CANNOT_BE_NULL;String ER_FILE_CANNOT_BE_NULL;String ER_SOURCE_CANNOT_BE_NULL;String ER_CANNOT_INIT_BSFMGR;String ER_CANNOT_CMPL_EXTENSN;String ER_CANNOT_CREATE_EXTENSN;String ER_INSTANCE_MTHD_CALL_REQUIRES;String ER_INVALID_ELEMENT_NAME;String ER_ELEMENT_NAME_METHOD_STATIC;String ER_EXTENSION_FUNC_UNKNOWN;String ER_MORE_MATCH_CONSTRUCTOR;String ER_MORE_MATCH_METHOD;String ER_MORE_MATCH_ELEMENT;String ER_INVALID_CONTEXT_PASSED;String ER_POOL_EXISTS;String ER_NO_DRIVER_NAME;String ER_NO_URL;String ER_POOL_SIZE_LESSTHAN_ONE;String ER_INVALID_DRIVER;String ER_NO_STYLESHEETROOT;String ER_ILLEGAL_XMLSPACE_VALUE;String ER_PROCESSFROMNODE_FAILED;String ER_RESOURCE_COULD_NOT_LOAD;String ER_BUFFER_SIZE_LESSTHAN_ZERO;String ER_UNKNOWN_ERROR_CALLING_EXTENSION;String ER_NO_NAMESPACE_DECL;String ER_ELEM_CONTENT_NOT_ALLOWED;String ER_STYLESHEET_DIRECTED_TERMINATION;String ER_ONE_OR_TWO;String ER_TWO_OR_THREE;String ER_COULD_NOT_LOAD_RESOURCE;String ER_CANNOT_INIT_DEFAULT_TEMPLATES;String ER_RESULT_NULL;String ER_RESULT_COULD_NOT_BE_SET;String ER_NO_OUTPUT_SPECIFIED;String ER_CANNOT_TRANSFORM_TO_RESULT_TYPE;String ER_CANNOT_TRANSFORM_SOURCE_TYPE;String ER_NULL_CONTENT_HANDLER;String ER_NULL_ERROR_HANDLER;String ER_CANNOT_CALL_PARSE;String ER_NO_PARENT_FOR_FILTER;String ER_NO_STYLESHEET_IN_MEDIA;String ER_NO_STYLESHEET_PI;String ER_NOT_SUPPORTED;String ER_PROPERTY_VALUE_BOOLEAN;String ER_COULD_NOT_FIND_EXTERN_SCRIPT;String ER_RESOURCE_COULD_NOT_FIND;String ER_OUTPUT_PROPERTY_NOT_RECOGNIZED;String ER_FAILED_CREATING_ELEMLITRSLT;String ER_VALUE_SHOULD_BE_NUMBER;String ER_VALUE_SHOULD_EQUAL;String ER_FAILED_CALLING_METHOD;String ER_FAILED_CREATING_ELEMTMPL;String ER_CHARS_NOT_ALLOWED;String ER_ATTR_NOT_ALLOWED;String ER_BAD_VALUE;String ER_ATTRIB_VALUE_NOT_FOUND;String ER_ATTRIB_VALUE_NOT_RECOGNIZED;String ER_NULL_URI_NAMESPACE;String ER_NUMBER_TOO_BIG;String ER_CANNOT_FIND_SAX1_DRIVER;String ER_SAX1_DRIVER_NOT_LOADED;String ER_SAX1_DRIVER_NOT_INSTANTIATED;String ER_SAX1_DRIVER_NOT_IMPLEMENT_PARSER;String ER_PARSER_PROPERTY_NOT_SPECIFIED;String ER_PARSER_ARG_CANNOT_BE_NULL;String ER_FEATURE;String ER_PROPERTY;String ER_NULL_ENTITY_RESOLVER;String ER_NULL_DTD_HANDLER;String ER_NO_DRIVER_NAME_SPECIFIED;String ER_NO_URL_SPECIFIED;String ER_POOLSIZE_LESS_THAN_ONE;String ER_INVALID_DRIVER_NAME;String ER_ERRORLISTENER;String ER_ASSERT_NO_TEMPLATE_PARENT;String ER_ASSERT_REDUNDENT_EXPR_ELIMINATOR;String ER_NOT_ALLOWED_IN_POSITION;String ER_NONWHITESPACE_NOT_ALLOWED_IN_POSITION;String ER_NAMESPACE_CONTEXT_NULL_NAMESPACE;String ER_NAMESPACE_CONTEXT_NULL_PREFIX;String ER_XPATH_RESOLVER_NULL_QNAME;String ER_XPATH_RESOLVER_NEGATIVE_ARITY;String INVALID_TCHAR;String INVALID_QNAME;String INVALID_ENUM;String INVALID_NMTOKEN;String INVALID_NCNAME;String INVALID_BOOLEAN;String INVALID_NUMBER;String ER_ARG_LITERAL;String ER_DUPLICATE_GLOBAL_VAR;String ER_DUPLICATE_VAR;String ER_TEMPLATE_NAME_MATCH;String ER_INVALID_PREFIX;String ER_NO_ATTRIB_SET;String ER_FUNCTION_NOT_FOUND;String ER_CANT_HAVE_CONTENT_AND_SELECT;String ER_INVALID_SET_PARAM_VALUE;String ER_SET_FEATURE_NULL_NAME;String ER_GET_FEATURE_NULL_NAME;String ER_UNSUPPORTED_FEATURE;String ER_EXTENSION_ELEMENT_NOT_ALLOWED_IN_SECURE_PROCESSING;String WG_FOUND_CURLYBRACE;String WG_COUNT_ATTRIB_MATCHES_NO_ANCESTOR;String WG_EXPR_ATTRIB_CHANGED_TO_SELECT;String WG_NO_LOCALE_IN_FORMATNUMBER;String WG_LOCALE_NOT_FOUND;String WG_CANNOT_MAKE_URL_FROM;String WG_CANNOT_LOAD_REQUESTED_DOC;String WG_CANNOT_FIND_COLLATOR;String WG_FUNCTIONS_SHOULD_USE_URL;String WG_ENCODING_NOT_SUPPORTED_USING_UTF8;String WG_ENCODING_NOT_SUPPORTED_USING_JAVA;String WG_SPECIFICITY_CONFLICTS;String WG_PARSING_AND_PREPARING;String WG_ATTR_TEMPLATE;String WG_CONFLICT_BETWEEN_XSLSTRIPSPACE_AND_XSLPRESERVESPACE;String WG_ATTRIB_NOT_HANDLED;String WG_NO_DECIMALFORMAT_DECLARATION;String WG_OLD_XSLT_NS;String WG_ONE_DEFAULT_XSLDECIMALFORMAT_ALLOWED;String WG_XSLDECIMALFORMAT_NAMES_MUST_BE_UNIQUE;String WG_ILLEGAL_ATTRIBUTE;String WG_COULD_NOT_RESOLVE_PREFIX;String WG_STYLESHEET_REQUIRES_VERSION_ATTRIB;String WG_ILLEGAL_ATTRIBUTE_NAME;String WG_ILLEGAL_ATTRIBUTE_VALUE;String WG_EMPTY_SECOND_ARG;String WG_PROCESSINGINSTRUCTION_NAME_CANT_BE_XML;String WG_PROCESSINGINSTRUCTION_NOTVALID_NCNAME;String WG_ILLEGAL_ATTRIBUTE_POSITION;String NO_MODIFICATION_ALLOWED_ERR;/** Get the lookup table for error messages. ... */// Error messages.../* Now fill in the message text. ... */String BAD_CODE;/** String for use when a bad error code was encountered. */// ================= INFRASTRUCTURE ======================String FORMAT_FAILED;/** String for use when formatting of the error string failed. */String ERROR_STRING;/** General error string. */String ERROR_HEADER;/** String to prepend to error messages. */String WARNING_HEADER;/** String to prepend to warning messages. */String XSL_HEADER;/** String to specify the XSLT module. */String XML_HEADER;/** String to specify the XML parser module. */String QUERY_HEADER;/** I don't think this is used any more. ... *//** Error message ID that has a null message, but takes in a single object. *///  add this message to fix bug 21478//Earlier (JDK 1.4 XALAN 2.2-D11) at key code '204' the key name was ER_PRIORITY_NOT_PARSABLE// In latest Xalan code base key name is  ER_VALUE_SHOULD_BE_NUMBER. This should also be taken care//in locale specific files like XSLTErrorResources_de.java, XSLTErrorResources_fr.java etc.//NOTE: Not only the key name but message has also been changed.// Note to translators:  The following message should not normally be displayed//   to users.  It describes a situation in which the processor has detected//   an internal consistency problem in itself, and it provides this message//   for the developer to help diagnose the problem.  The name//   'ElemTemplateElement' is the name of a class, and should not be//   translated.//   for the developer to help diagnose the problem.  The substitution text//   provides further information in order to diagnose the problem.  The name//   'RedundentExprEliminator' is the name of a class, and should not be// This code is shared with warning codes.// SystemId Unknown// Note to translators:  The following message is used if the value of// an attribute in a stylesheet is invalid.  "QNAME" is the XML data-type of// the attribute, and should not be translated.  The substitution text {1} is// the attribute value and {0} is the attribute name.//The following codes are shared with the warning codes...// an attribute in a stylesheet is invalid.  "ENUM" is the XML data-type of// the attribute value, {0} is the attribute name, and {2} is a list of valid// an attribute in a stylesheet is invalid.  "NMTOKEN" is the XML data-type// of the attribute, and should not be translated.  The substitution text {1} is// an attribute in a stylesheet is invalid.  "NCNAME" is the XML data-type// an attribute in a stylesheet is invalid.  "boolean" is the XSLT data-type// an attribute in a stylesheet is invalid.  "number" is the XSLT data-type// End of shared codes...// Note to translators:  A "match pattern" is a special form of XPath expression// that is used for matching patterns.  The substitution text is the name of// a function.  The message indicates that when this function is referenced in// a match pattern, its argument must be a string literal (or constant.)// ER_ARG_LITERAL - new error message for bugzilla //5202// Note to translators:  The following message indicates that two definitions of// a variable.  A "global variable" is a variable that is accessible everywher// in the stylesheet.// ER_DUPLICATE_GLOBAL_VAR - new error message for bugzilla #790// a variable were encountered.// ER_DUPLICATE_VAR - new error message for bugzilla #790// Note to translators:  "xsl:template, "name" and "match" are XSLT keywords// which must not be translated.// ER_TEMPLATE_NAME_MATCH - new error message for bugzilla #789// Note to translators:  "exclude-result-prefixes" is an XSLT keyword which// should not be translated.  The message indicates that a namespace prefix// encountered as part of the value of the exclude-result-prefixes attribute// was in error.// ER_INVALID_PREFIX - new error message for bugzilla #788// Note to translators:  An "attribute set" is a set of attributes that can// be added to an element in the output document as a group.  The message// indicates that there was a reference to an attribute set named {0} that// was never defined.// ER_NO_ATTRIB_SET - new error message for bugzilla #782// Note to translators:  This message indicates that there was a reference// to a function named {0} for which no function definition could be found.// Note to translators:  This message indicates that the XSLT instruction// that is named by the substitution text {0} must not contain other XSLT// instructions (content) or a "select" attribute.  The word "select" is// an XSLT keyword in this case and must not be translated.// Note to translators:  This message indicates that the value argument// of setParameter must be a valid Java Object.// Warnings...//Following are the new WARNING keys added in XALAN code base after Jdk 1.4 (Xalan 2.2-D11)// Note to translators:  "name" and "xsl:processing-instruction" are keywords// and must not be translated.// and must not be translated.  "NCName" is an XML data-type and must not be// translated.// Note to translators:  This message is reported if the stylesheet that is// being processed attempted to construct an XML document with an attribute in a// place other than on an element.  The substitution text specifies the name of// the attribute.//Check: WHY THERE IS A GAP B/W NUMBERS in the XSLTErrorResources properties file?// Other miscellaneous text used inside the code...// Note to translators:  The following messages provide usage information// for the Xalan Process command line.  "Process" is the name of a Java class,// and should not be translated.// Note to translators: The option name and the parameter name do not need to// be translated. Only translate the messages in parentheses.  Note also that// leading whitespace in the messages is used to indent the usage information// for each option in the English messages.// Do not translate the keywords: XSLTC, SAX, DOM and DTM.// Following are the new options added in XSLTErrorResources.properties files after Jdk 1.4 (Xalan 2.2-D11)// Added by sboag/scurcuru; experimental//AddITIONAL  STRINGS that need L10n// Note to translators:  The following message describes usage of a particular// command-line option that is used to enable the "template inlining"// optimization.  The optimization involves making a copy of the code// generated for a template in another template that refers to it./** Default implementation of XSLTErrorResources.  This is just ... *//** Primary constants used in the TransformerImpl classes. ... */int ELEMNAME_UNDEFINED, ...;/** IDs for XSL element types. These are associated ... */String ELEMNAME_ANCHOR_STRING, ...;/** Literals for XSL element names.  Note that there are more ... */// Next free number: 90 (88 and 89 used for EXSLT elements);String EXSLT_ELEMNAME_FUNCTION_STRING, ...;/** Literals for EXSLT function elements. */int EXSLT_ELEMNAME_FUNCTION, ...;String ATTRNAME_AMOUNT, ...;/** Literals for XSL attribute names.  Note that there may be more ... */int TATTRNAME_OUTPUT_METHOD, ...;/** IDs for XSL attribute types. These are associated ... */String ATTRVAL_OUTPUT_METHOD_HTML, ...;/** Mnemonics for the possible values of the xsl:output element's ... */int ATTRVAL_PRESERVE, ...;/* For space-att */boolean ATTRVAL_YES, ...;/** For indent-result */String ATTRVAL_ALPHABETIC, ...;/** For letter-value attribute (part of conversion attributes). */String ATTRVAL_SINGLE, ...;/** For level attribute in xsl:number. */String ATTRVAL_DEFAULT_PREFIX;/** For Stylesheet-prefix and result-prefix in xsl:namespace-alias */int NUMBERLETTER_ALPHABETIC, ...;/** Integer equivalents for above */int NUMBERLEVEL_SINGLE, ...;/** Integer equivelents for above */String ATTRVAL_THIS, ...;/** some stuff for my patterns-by-example */String ATTRVAL_DATATYPE_TEXT, ...;/** Stuff for sorting */int SORTDATATYPE_TEXT, ...;/** Integer equivelents for DATATYPE attribute */int SORTORDER_ASCENDING, ...;/** Integer equivelents for ORDER attribute */int SORTCASEORDER_UPPERFIRST, ...;/** Integer equivelents for CASE-ORDER attribute */String ATTRVAL_INFINITY, ...;/** some stuff for Decimal-format */String ATTRNAME_XXXX;/** temp dummy *///  ELEMNAME_ANCHOR_PATTERN = 23,// my own//  ELEMNAME_DEFINECONSTANT = 29,//  ELEMNAME_DEFINEMACRO = 10,// Pattern by example support//  ELEMNAME_WITHPARAM = 56,// pattern-by-example support// qname,// namespace declaration prefix -- NOT an attribute by itself// default namespace/** A configuration error. This was an internal class in ObjectFactory previously *//** Exception. */// Data/** Construct a new instance with the specified detail string and ... *//** Returns the exception associated to this error. */// methods// <init>(String,Exception)// getException():Exception// class ConfigurationErrorimport XalanConstants/** This is the base class for features and properties */State.DEFAULTFeaturePropertyBase$State/** States of the settings of a property, in the order: default value, value ... */State DEFAULT;//this order reflects the overriding orderState FSP;State JAXPDOTPROPERTIES;State SYSTEMPROPERTY;State APIPROPERTY;/** Values of the properties as defined in enum Properties */...[] states;/** States of the settings for each property in Properties above *//** Set the value for a specific property. ... *//** Set the value of a property by its index ... *//** Set value by property name and state ... */XalanConstants.FEATURE_TRUEXalanConstants.FEATURE_FALSE/** Return the value of the specified property ... */getValueByIndex(...)/** Return the value of the specified property. ... *//** Return the value of a property by its ordinal ... *//** Get the index by property name ... */Enum<E> enumItemgetEnumConstants(...)/** Read from system properties, or those in jaxp.properties ... */State.SYSTEMPROPERTYreadJAXPProperty(...)State.JAXPDOTPROPERTIES/* Copyright (c) 2011, 2013, Oracle and/or its affiliates. All rights reserved. ... *///only update if it shall override//internally, ordinal is used as index//invalid setting ignored/** This class is duplicated for each JAXP subpackage so keep it in sync. ... */String JAXP_INTERNAL;String STAX_INTERNAL;/** Set to true for debugging *//** Prints a message to standard error if debugging is enabled. *//** Figure out which ClassLoader to use.  For JDK 1.2 and later use ... */// debugPrintln(String)ClassLoader contextClassLoader systemClassLoader chainClassLoader currentObjectFactory.classgetParentClassLoader(...)/** Create an instance of a class using the same class loader for the ObjectFactory by default ... */// findClassLoader():ClassLoaderfindClassLoader(...)/** Create an instance of a class using the specified ClassLoader */Class<> providerClassfindProviderClass(...)Object instancedebugPrintln(...)ClassNotFoundException xnew ConfigurationError(...)/** Find a Class using the same class loader for the ObjectFactory by default ... *//** Find a Class using the specified ClassLoader */SecurityManager securityClass<?> providerClass//this will ensure bootclassloader is used// Figure out which ClassLoader to use for loading the provider// class.  If there is a Context ClassLoader then use it.// Assert: we are on JDK 1.1 or we have no Context ClassLoader// or any Context ClassLoader in chain of system classloader// (including extension ClassLoader) so extend to widest// ClassLoader (always look in system ClassLoader if Xalan// is in boot/extension/system classpath and in current// ClassLoader otherwise); normal classloaders delegate// back to system ClassLoader first so this widening doesn't// change the fact that context ClassLoader will be consulted// Assert: Current ClassLoader in chain of// boot/extension/system ClassLoaders// Assert: Current ClassLoader not in chain of// boot ClassLoader reached// Check for any extension ClassLoaders in chain up to// boot ClassLoader// Assert: Context ClassLoader not in chain of// assert(className != null);//throw security exception if the calling thread is not allowed to access the//class. Restrict the access to the package classes as specified in java.security policy.// Fall back to current classloader// class ObjectFactory/** This class is duplicated for each subpackage so keep it in sync. It is ... */new SecuritySupport(...)SecuritySupport securitySupport;/** Return an instance of this class. */SecuritySupport$1SecurityException exSecuritySupport$2SecuritySupport$3SecuritySupport$4SecuritySupport$5SecuritySupport$6/** Return resource using the same classloader for the ObjectFactory by ... */SecuritySupport$7InputStream ris/** Gets a resource bundle using the specified base name, the default locale, and the caller's class loader. ... *//** Gets a resource bundle using the specified base name and locale, and the caller's class loader. ... */new PrivilegedAction<ListResourceBundle>(...) { ... }SecuritySupport$8new Locale(...)MissingResourceException e2new MissingResourceException(...)SecuritySupport$9SecuritySupport$10/** Strip off path from an URI ... *//** Check the protocol used in the systemId against allowed protocols ... */String protocolisProtocolAllowed(...)/** Check if the protocol is in the allowed list of protocols. The check ... */String[] temp/** Read JAXP system property in this order: system property, ... */String accessExternal/** Read from $java.home/lib/jaxp.properties for the specified property ... */String configFilegetFileExists(...)getFileInputStream(...)Properties cacheProps;/** Cache for properties in java.home/lib/jaxp.properties *//** Flag indicating if the program has tried reading java.home/lib/jaxp.properties */// eliminate loops in case of the boot// ClassLoader returning itself as a parent//access allowedimport CopyOnWriteArrayList/** This class is not the same as that in Xerces. It is used to manage the ... */new CopyOnWriteArrayList<String>(...)XMLSecurityManager$StateString literal;this.literalXMLSecurityManager$Limit/** Limits managed by the security manager */new Limit(...)XalanConstants.JDK_ENTITY_EXPANSION_LIMITXalanConstants.SP_ENTITY_EXPANSION_LIMITXalanConstants.JDK_MAX_OCCUR_LIMITXalanConstants.SP_MAX_OCCUR_LIMITXalanConstants.JDK_ELEMENT_ATTRIBUTE_LIMITXalanConstants.SP_ELEMENT_ATTRIBUTE_LIMITXalanConstants.JDK_TOTAL_ENTITY_SIZE_LIMITXalanConstants.SP_TOTAL_ENTITY_SIZE_LIMITXalanConstants.JDK_GENERAL_ENTITY_SIZE_LIMITXalanConstants.SP_GENERAL_ENTITY_SIZE_LIMITXalanConstants.JDK_PARAMETER_ENTITY_SIZE_LIMITXalanConstants.SP_PARAMETER_ENTITY_SIZE_LIMITXalanConstants.JDK_MAX_ELEMENT_DEPTHXalanConstants.SP_MAX_ELEMENT_DEPTHXalanConstants.JDK_XML_NAME_LIMITXalanConstants.SP_XML_NAME_LIMITXalanConstants.JDK_ENTITY_REPLACEMENT_LIMITXalanConstants.SP_ENTITY_REPLACEMENT_LIMITLimit ENTITY_EXPANSION_LIMIT;Limit MAX_OCCUR_NODE_LIMIT;Limit ELEMENT_ATTRIBUTE_LIMIT;Limit TOTAL_ENTITY_SIZE_LIMIT;Limit GENERAL_ENTITY_SIZE_LIMIT;Limit PARAMETER_ENTITY_SIZE_LIMIT;Limit MAX_ELEMENT_DEPTH_LIMIT;Limit MAX_NAME_LIMIT;Limit ENTITY_REPLACEMENT_LIMIT;String apiProperty;String systemProperty;int defaultValue;int secureValue;this.apiPropertythis.systemPropertythis.secureValueXMLSecurityManager$NameMap/** Map old property names with the new ones */new NameMap(...)XalanConstants.ENTITY_EXPANSION_LIMITXalanConstants.MAX_OCCUR_LIMITXalanConstants.ELEMENT_ATTRIBUTE_LIMITNameMap ENTITY_EXPANSION_LIMIT;NameMap MAX_OCCUR_NODE_LIMIT;NameMap ELEMENT_ATTRIBUTE_LIMIT;String newName;String oldName;this.newNamethis.oldName/** Values of the properties *//** States of the settings for each property */...[] isSet;/** States that determine if properties are set explicitly */int indexEntityCountInfo;/** Index of the special entityCountInfo property */String printEntityCountInfo;/** Default constructor. Establishes default values for known security ... *//** Instantiate Security Manager in accordance with the status of ... */values(...).lengthLimit limitsecureValue(...)State.FSPdefaultValue(...)readSystemProperties(...)/** Setting FEATURE_SECURE_PROCESSING explicitly */setLimit(...)/** Set limit by property name and state ... *//** Set the value for a specific limit. ... */XalanConstants.JDK_YESgetLimitValueByIndex(...)/** Return the value of a property by its index ... *//** Return the state of the limit property ... */literal(...)equalsAPIPropertyName(...)XalanConstants.JDK_ENTITY_COUNT_INFO/** Indicate if a property is set explicitly ... *//** Read from system properties, or those in jaxp.properties */systemProperty(...)NameMap nameMapString oldNamegetOldName(...)CopyOnWriteArrayList<String> printedWarnings;// Array list to store printed warnings for each SAX parser used/** Prints out warnings if a parser does not support the specified feature/property. ... */addIfAbsent(...)/* Copyright (c) 2013, 2016, Oracle and/or its affiliates. All rights reserved. ... *///read system properties or jaxp.properties//if it's explicitly set, it's treated as yes no matter the value//special property to return entity count info//if system property is not found, try the older form if any//invalid settingimport XMLConstants/** This class manages security related properties */XMLSecurityPropertyManager$Property/** Properties managed by the security property manager */new Property(...)XMLConstants.ACCESS_EXTERNAL_DTDXalanConstants.EXTERNAL_ACCESS_DEFAULTXMLConstants.ACCESS_EXTERNAL_STYLESHEETProperty ACCESS_EXTERNAL_DTD;Property ACCESS_EXTERNAL_STYLESHEET;String defaultValue;/** Default constructor. Establishes default values */Property propertyequalsName(...)Property.ACCESS_EXTERNAL_DTDXalanConstants.SP_ACCESS_EXTERNAL_DTDProperty.ACCESS_EXTERNAL_STYLESHEETXalanConstants.SP_ACCESS_EXTERNAL_STYLESHEETimport FileWriter/** Utility class to report simple information about the environment. ... */Map<Long,String> jarVersionsnew HashMap<Long,String>(...)unmodifiableMap(...)/** Command line runnability: checks for [-out outFilename] arg. ... */PrintWriter sendOutputToEnvironmentCheck appnew EnvironmentCheck(...)new FileWriter(...)checkEnvironment(...)/** Programmatic entrypoint: Report on basic Java environment ... */Map<String,Object> hashgetEnvironmentHash(...)boolean environmentHasErrorswriteEnvironmentReport(...)logMsg(...)/** Fill a hash with basic environment settings that affect Xalan. ... */checkJAXPVersion(...)checkProcessorVersion(...)checkParserVersion(...)checkAntVersion(...)checkDOML3(...)checkDOMVersion(...)checkSAXVersion(...)checkSystemProperties(...)/** Dump a basic Xalan environment report to outWriter. ... */boolean errorsEntry<String,Object> entryMap<>.Entry<String,Object>String keyStrList<Map<>> vlogFoundJars(...)String ERROR;/** Prefixed to hash keys that signify serious problems. */String WARNING;/** Added to descriptions that signify potential problems. */String ERROR_FOUND;/** Value for any error found. *//** Prefixed to hash keys that signify version numbers. */String FOUNDCLASSES;/** Prefixed to hash keys that signify .jars found in classpath. */String CLASS_PRESENT;/** Marker that a class or .jar was found. */String CLASS_NOTPRESENT;/** Marker that a class or .jar was not found. */...[] jarNames;/** Listing of common .jar files that include Xalan-related classes. *//** Print out report of .jars found in a classpath. ... */Map<String,String> v1/** Stylesheet extension entrypoint: Dump a basic Xalan ... */Element envCheckNodeElement hashNodeElement statusNodeappendFoundJars(...)Element node/** Fillin hash with info about SystemProperties. ... */String cpList<Map<>> classpathJarscheckPathForJars(...)String othercp/** Cheap-o listing of specified .jars found in the classpath. ... */new ArrayList<Map<>>(...)jars.lengthMap<String,String> hgetApparentVersion(...)/** Cheap-o method to determine the product version of a .jar. ... */String foundSize/** Report version information about JAXP interfaces. ... */String JAXP1_CLASS/** Report product version information from Xalan-J. ... */String XALAN1_VERSION_CLASSString XALAN2_VERSION_CLASSString XALAN2_2_VERSION_CLASSString XALAN2_2_VERSION_METHODClass<>[] noArgsObject returnValue/** Report product version information from common parsers. ... */String XERCES1_VERSION_CLASSString parserVersionString XERCES2_VERSION_CLASSString CRIMSON_CLASS/** Report product version information from Ant. ... */String ANT_VERSION_CLASSString ANT_VERSION_METHOD/** Report version info from DOM interfaces. ... */String DOM_CLASSString DOM_LEVEL3_METHODString DOM_LEVEL2_CLASSString DOM_LEVEL2_METHODString DOM_LEVEL2WD_CLASSString DOM_LEVEL2WD_METHODString DOM_LEVEL2FD_CLASSString DOM_LEVEL2FD_METHODClass<>[] twoStringArgsException e3/** Report version info from SAX interfaces. ... */String SAX_VERSION1_CLASSString SAX_VERSION1_METHODString SAX_VERSION2_CLASSString SAX_VERSION2_METHODString SAX_VERSION2BETA_CLASSNFString SAX_VERSION2BETA_METHODNFClass<>[] oneStringArgClass<>[] attributesArgAttributes.classMap<Long,String> JARVERSIONS;/** Manual table of known .jar sizes. ... */PrintWriter outWriter;/** Simple PrintWriter we send output to; defaults to System.out. *//** Bottleneck output: calls outWriter.println(s). ... *//* Copyright (c) 2005, 2015, Oracle and/or its affiliates. All rights reserved. *//* $Id: EnvironmentCheck.java,v 1.2.4.1 2005/09/09 07:13:59 pvedula Exp $ */// Default to System.out, autoflushing// Read our simplistic input args, if supplied// Use user-specified output writer if non-null// Setup a hash to store various environment information in// Check for ERROR keys in the hashtable, and print report// Note: many logMsg calls have # at the start to//  fake a property-file like output// Call various worker methods to fill in the hash//  These are explicitly separate for maintenance and so//  advanced users could call them standalone// Fake the Properties-like output// Special processing for classes found..// ..normal processing for all other entries// Note: we could just check for the ERROR key by itself,//    since we now set that, but since we have to go//    through the whole hash anyway, do it this way,//    which is safer for maintenance// Serializer (shared between Xalan & Xerces)// Xerces-J 1.x// Xerces-J 2.x// errors |= logFoundJars(v, keyStr);// end of for...// Grab java version for later use// For applet context, etc.// Printout jar files on classpath(s) that may affect operation//  Do this in order// This is present in all JVM's// Also check for JDK 1.2+ type classpaths//@todo also check other System properties' paths?//  v2 = checkPathForJars(System.getProperty("sun.boot.library.path"), jarNames);   // ?? may not be needed//  v3 = checkPathForJars(System.getProperty("java.library.path"), jarNames);   // ?? may not be needed// Look at each classpath entry for each of our requested jarNames// If any requested jarName exists, report on//  the details of that .jar file// Note "-" char is looked for in appendFoundJars// We won't bother reporting on the xalan.jar apparent version// since this requires knowing the jar size of the xalan.jar// before we build it.// For other jars, eg. xml-apis.jar and xercesImpl.jar, we// report the apparent version of the file we've found/* no-op, don't add it */// If we found a matching size and it's for our//  jar, then return it's description// Lookup in static JARVERSIONS Map//              || "xalan.jar".equalsIgnoreCase(jarName))// For xalan.jar and xerces.jar/xercesImpl.jar, which we ship together:// The jar is not from a shipped copy of xalan-j, so//  it's up to the user to ensure that it's compatible// Otherwise, it's just a jar we don't have the version info calculated for// If we succeeded, we have JAXP 1.4 available// Found Xalan-J 1.x, grab it's version fields// NOTE: This is the old Xalan 2.0, 2.1, 2.2 version class,//    is being replaced by class below// Found Xalan-J 2.x, grab it's version fields// NOTE: This is the new Xalan 2.2+ version class// Found Xerces-J 1.x, grab it's version fields// Look for xerces1 and xerces2 parsers separately// Found Xerces-J 2.x, grab it's version fields//@todo determine specific crimson version// noArgs// no parameter// If we succeeded, we have loaded interfaces from a//  level 3 DOM somewhere// String, String//  level 2 DOM somewhere// Check for the working draft version, which is//  commonly found, but won't work anymore// Check for the final draft version as well//@todo load an actual DOM implmementation and query it as well//@todo load an actual DOM implmementation and check if//  isNamespaceAware() == true, which is needed to parse//  xsl stylesheet files into a DOM// Attributes// Note this introduces a minor compile dependency on SAX...// This method was only added in the final SAX 2.0 release;//  see changes.html "Changes from SAX 2.0beta2 to SAX 2.0prerelease"//  real, final SAX version 2.0 somewhere// If we didn't find the SAX 2.0 class, look for a 2.0beta2//  SAX version 2.0beta2 or earlier; these might work but//  you should really have the final SAX 2.0// If we didn't find the SAX 2.0beta2 class, look for a 1.0 one//  SAX version 1.0 somewhere; which won't work very//  well for JAXP 1.1 or beyond!// If we didn't find the SAX 2.0 class, look for a 1.0 one// Note that either 1.0 or no SAX are both errors/** Static initializer for JARVERSIONS table. ... */// Stop recording xalan.jar sizes as of Xalan Java 2.5.0// Stop recording xsltc.jar sizes as of Xalan Java 2.5.0// If the below were more common I would update it to report//  errors better; but this is so old hardly anyone has it// Stop recording xalanservlet.jar sizes as of Xalan Java 2.5.0; now a .war file// For those who've downloaded JAXP from sun// jakarta-ant: since many people use ant these daysimport StringReaderimport ParserConfigurationExceptionimport OutputKeysimport Sourceimport Templatesimport Transformerimport TransformerConfigurationExceptionimport TransformerFactoryimport TransformerFactoryConfigurationErrorimport URIResolverimport DOMResultimport DOMSourceimport SAXResultimport SAXSourceimport SAXTransformerFactoryimport TransformerHandlerimport StreamResultimport StreamSourceimport Versionimport ConfigurationErrorimport DefaultErrorHandlerimport ContentHandlerimport EntityResolverimport InputSourceimport XMLReaderimport XMLReaderFactory/** The main() method handles the Xalan command-line interface. ... *//** Prints argument options. ... */waitForReturnKey(...)// main -> _main// J2SE does not support Xalan interpretive/** Command line interface to transform an XML document according to ... */boolean doStackDumpOnErrorboolean setQuietModeboolean doDiagboolean isSecureProcessingPrintWriter diagnosticsWriterPrintWriter dumpWriterResourceBundle resbundleXResourceBundle.ERROR_RESOURCESString flavorprintArgOptions(...)boolean useXSLTCTransformerFactory tfactoryboolean formatOutputboolean useSourceLocationString inFileNameString outFileNameString dumpFileNameString xslFileNameString treedumpFileNameString outputTypeString mediaVector<> paramsboolean quietConflictWarningsURIResolver uriResolverEntityResolver entityResolverContentHandler contentHandlerint recursionLimitsetProperties(...)setErrorListener(...)new DefaultErrorHandler(...)TransformerFactoryConfigurationError pfeXSLTErrorResources.ER_NOT_SUCCESSFULdoExit(...)int indentAmountXSLTErrorResources.ER_MISSING_ARG_FOR_OPTIONString expressionsetURIResolver(...)ConfigurationError cnfeXSLTErrorResources.ER_CLASS_NOT_FOUND_FOR_OPTIONprintInvalidXalanOption(...)setFeature(...)XMLConstants.FEATURE_SECURE_PROCESSINGTransformerConfigurationException eXSLTErrorResources.ER_INVALID_OPTIONTemplates stylesheetPrintWriter resultWriterStreamResult strResultSAXTransformerFactory stflong stoplong millisecondsDurationDocumentBuilderFactory dfactoryDocumentBuilder docBuilderNode xslDOMnew InputSource(...)setNamespaceAware(...)ParserConfigurationException pcenewTemplates(...)new DOMSource(...)new StreamSource(...)new StreamResult(...)setSystemId(...)Source sourcegetAssociatedStylesheet(...)new TransformerException(...)XSLTErrorResources.ER_NO_STYLESHEET_IN_MEDIAXSLTErrorResources.ER_NO_STYLESHEET_PITransformer transformernewTransformer(...)setOutputProperty(...)OutputKeys.METHODsetParameter(...)Node xmlDocnewDocument(...)DocumentFragment outNodeTransformer serializerProperties serializationPropsgetOutputProperties(...)setCoalescing(...)setEntityResolver(...)new DOMResult(...)setOutputProperties(...)SAXResult resultnew SAXResult(...)XMLReader readerTransformerHandler thnewTransformerHandler(...)SAXParserFactory factorySAXParser jaxpParsernewSAXParser(...)SAXException segetXMLReader(...)new SAXException(...)FactoryConfigurationError ex1NoSuchMethodError ex2AbstractMethodError amecreateXMLReader(...)setContentHandler(...)setDTDHandler(...)setErrorHandler(...)SAXNotRecognizedException eSAXNotSupportedException esetResult(...)new SAXSource(...)StringReader readernew StringReader(...)Writer writergetWriter(...)Object[] msgArgsprintLocation(...)XSLTErrorResources.ER_XSLT_ERROR/** It is _much_ easier to debug under VJ++ if I can set a single breakpoint ... *//** Wait for a return key to continue ... *//** Print a message if an option cannot be used with -XSLTC. ... *//** Print a message if an option can only be used with -XSLTC. ... *//* Copyright 1999-2004 The Apache Software Foundation. ... *//* $Id: Process.java,v 1.2.4.2 2005/09/15 18:21:57 jeffsuttor Exp $ *///J2SE does not support Xalan interpretive/* import com.sun.org.apache.xalan.internal.trace.PrintTraceListener; ... *///"xslproc options: ");//"    [-XSLTC (use XSLTC for transformation)]//"    [-IN inputXMLURL]");//"   [-XSL XSLTransformationURL]");//"   [-OUT outputFileName]");// System.out.println(resbundle.getString("optionE")); //"   [-E (Do not expand entity refs)]");//"   [-V (Version info)]");// System.out.println(resbundle.getString("optionVALIDATE")); //"   [-VALIDATE (Set whether validation occurs.  Validation is off by default.)]");//"   [-EDUMP {optional filename} (Do stackdump on error.)]");//"   [-XML (Use XML formatter and add XML header.)]");//"   [-TEXT (Use simple Text formatter.)]");//"   [-HTML (Use HTML formatter.)]");//"   [-PARAM name expression (Set a stylesheet parameter)]");//"   [-URIRESOLVER full class name (URIResolver to be used to resolve URIs)]");//"   [-ENTITYRESOLVER full class name (EntityResolver to be used to resolve entities)]");//"   [-CONTENTHANDLER full class name (ContentHandler to be used to serialize output)]");//"   [-SECURE (set the secure processing feature to true)]");/* System.out.println("\n\t\t\t" + resbundle.getString("xslProc_xalan_options") + "\n"); ... */// Runtime.getRuntime().traceMethodCalls(false); // turns Java tracing off// Runtime.getRuntime().traceMethodCalls(false);// Runtime.getRuntime().traceInstructions(false);/** The default diagnostic writer... */// false -> true//      "XSL Process was not successful.");// shut up compiler/* PrintTraceListener tracer = null; */// The -XSLTC option has been processed./* else if ("-TT".equalsIgnoreCase(argv[i])) ... */// TBD:// xmlProcessorLiaison.setIndent(indentAmount);//"Missing argument for);// xmlProcessorLiaison.setShouldExpandEntityRefs(false);//">>>>>>> Xalan Version "/* xmlProcessorLiaison.getParserDescription()+ */// "<<<<<<<");/* else if ("-QC".equalsIgnoreCase(argv[i])) ... *///            "Missing argument for);/* else if ("-L".equalsIgnoreCase(argv[i])) ... */// Generate the translet class and optionally specify the name// of the translet class.// Specify the destination directory for the translet classes.// Specify the jar file name which the translet classes are packaged into.// Specify the package name prefix for the generated translet classes.// Enable template inlining.// Turns on additional debugging message output// Create the Transformer from the translet if the translet class is newer// than the stylesheet.//"Invalid argument:);// Print usage instructions if no xml and xsl file is specified in the command line// Note that there are usage cases for calling us without a -IN arg// The main XSL transformation occurs here!// Parse in the xml data into a DOM// System.out.println("Calling newTemplates: "+xslFileName);// System.out.println("Done calling newTemplates: "+xslFileName);// One possible improvement might be to ensure this is//  a valid URI before setting the systemId, but that//  might have subtle changes that pre-existing users//  might notice; we can think about that later -sc r1.46// We used to default to incremental mode in this case.// We've since decided that since the -INCREMENTAL switch is// available, that default is probably not necessary nor// necessarily a good idea./* // This is currently controlled via TransformerFactoryImpl. ... */// Did they pass in a stylesheet, or should we get it from the// document?//"No stylesheet found in: "// + inFileName + ", media="// + media);//"No xml-stylesheet PI found in: "//+ inFileName);// Override the output format?/* if (transformer instanceof com.sun.org.apache.xalan.internal.transformer.TransformerImpl) ... */// Now serialize output to disk with identity transformer// Loop for diagnosing bugs with inconsistent behavior// System.out.println("Testing the TransformerHandler...");// Use JAXP1.1 ( if possible )/* if (!useXSLTC) ... */// System.out.println("Starting transform");// System.out.println("Done with transform");//          "XSL Process was not successful.");// close output streams// diagnosticsWriter.println(XSLMessages.createMessage(XSLTErrorResources.ER_NOT_SUCCESSFUL, null)); //"XSL Process was not successful.");// diagnosticsWriter.close();// if(!setQuietMode)//  diagnosticsWriter.println(resbundle.getString("xsldone")); //"Xalan: done");// diagnosticsWriter.println("");  //"Xalan: done");import Collatorimport DTMAxisIteratorimport SerializationHandlerint FIRST_TYPE;int NO_TYPE;int NULL;// 0 is reserved for NodeIterator.ENDint RETURN_CURRENT;// used by some node iterators to know which node to returnint RETURN_PARENT;int SIMPLE_RTF;// Constants used by getResultTreeFrag to indicate the types of the RTFs.int ADAPTIVE_RTF;int TREE_RTF;/** returns singleton iterator containg the document root *//* Copyright (c) 2005, 2016, Oracle and/or its affiliates. All rights reserved. *//** This method is responsible for: ... *//** Interface for SAXImpl which adds methods used at run-time, over and above ... */import DTMDTM.NULLint END;/** Callers should not call next() after it returns END. *//** Resets the iterator to the last start node. *//** Returns the number of elements in this iterator. *//** Returns the position of the current node in the set. *//** Remembers the current node for the next call to gotoMark(). *//** Restores the current node remembered by setMark(). *//** Set start to END should 'close' the iterator, ... *//** True if this iterator has a reversed axis. *//** Returns a deep copy of this iterator. *//** Prevents or allows iterator restarts. *//** Admin class that assigns a version number to the XSLTC software. ... */int MAJOR;int MINOR;import JdkXmlFeaturesimport GetOptimport GetOptsExceptionimport XSLTCimport ErrorMsgint VERSION_MAJOR;// Versioning numbers  for the compiler -v option outputint VERSION_MINOR;int VERSION_DELTA;boolean _allowExit;// this class being used in other ways as well.// calling System.exit() is normally OK, but we also want to allow for// class from calling System.exit(). As this is a command-line tool,// This variable should be set to false to prevent any methods in thisnew ErrorMsg(...)ErrorMsg.COMPILE_USAGE_STR/** This method implements the command line compiler. See the USAGE_STRING ... */boolean inputIsURLboolean useStdInboolean classNameSetGetOpt getoptnew GetOpt(...)XSLTC xsltcnew XSLTC(...)new JdkXmlFeatures(...)boolean compileOKprintUsage(...)getNextOption(...)getOptionArg(...)setDestDirectory(...)setPackageName(...)setJarFileName(...)setDebug(...)setTemplateInlining(...)ErrorMsg.COMPILE_STDIN_ERRString[] stylesheetNamesgetCmdArgs(...)Vector<> stylesheetVectorstylesheetNames.lengthprintWarnings(...)getJarFileName(...)outputToJar(...)printErrors(...)GetOptsException ex/* Copyright 2001-2004 The Apache Software Foundation. ... *//* $Id: Compile.java,v 1.2.4.1 2005/08/31 11:24:13 pvedula Exp $ */// used to be 'false'// fall through to case h// Generate a vector containg URLs for all stylesheets specified// Compile the stylesheet and output class/jar file(s)// exits with code '-1'import DOMEnhancedForDTMimport StripFilterimport TransletExceptionimport DOMWSFilterimport XSLTCDTMManagerimport AbstractTransletimport Constantsimport TransletOutputHandlerFactoryimport DTMWSFilterimport SAXParserimport SAXParserFactorySerializationHandler _handler;String _fileName;String _className;String _jarFileSrc;boolean _isJarFileSpecified;Vector<> _params;boolean _uri, ...;int _iterations;AbstractTranslet transletSAXParser parserXSLTCDTMManager dtmManagercreateNewDTMManagerInstance(...)DTMWSFilter wsfilterDOMEnhancedForDTM domhasIdCall(...)TransletOutputHandlerFactory tohFactorypostInitialization(...)Constants.NAMESPACE_FEATUREnew DOMWSFilter(...)setDocumentURI(...)prepassDocument(...)Parameter paramaddParameter(...)param._nameparam._valuesetOutputType(...)TransletOutputHandlerFactory.STREAMsetEncoding(...)translet._encodingsetOutputMethod(...)translet._methodgetSerializationHandler(...)long mmTransletException eErrorMsg.RUNTIME_ERROR_KEYErrorMsg errErrorMsg.FILE_NOT_FOUND_ERRErrorMsg.INVALID_URI_ERRErrorMsg.CLASS_NOT_FOUND_ERRSAXException eErrorMsg.TRANSFORM_USAGE_STRint iterationsboolean uriboolean isJarFileSpecifiedString jarFileTransform handlernew Transform(...)setJarFileInputSrc(...)int equaldoTransform(...)/* $Id: Transform.java,v 1.2.4.1 2005/09/12 09:07:33 pvedula Exp $ */// TODO: at this time we do not do anything with this// information, attempts to add the jarfile to the CLASSPATH// were successful via System.setProperty, but the effects// were not visible to the running JVM. For now we add jarfile// to CLASSPATH in the wrapper script that calls this program.// TODO verify jarFile exists...// Create a SAX parser and get the XMLReader object it uses// Set the DOM's DOM builder as the XMLReader's SAX2 content handler// Pass global parameters// Transform the document// Parse options starting with '-'// Enough arguments left ?// Get document file and class name// Parse stylesheet parameters/** GetOpt is a Java equivalent to the C getopt() library function ... */int currOptIndexnew OptionMatcher(...)int tokenLengthnew Option(...)int indexoflastOption opchar opLettergetArgLetter(...)hasArg(...)setArg(...)/** debugging routine to print out all options collected */ListIterator<> itOption optgetArgument(...)/** gets the next option found in the commandline. Distinguishes ... */boolean shouldHaveArgErrorMsg msgErrorMsg.ILLEGAL_CMDLINE_OPTION_ERRErrorMsg.CMDLINE_OPT_MISSING_ARG_ERRnew MissingOptArgException(...)/** gets the argument for the current parsed option. For example, ... */String tmp/** gets list of the commandline arguments. For example, in command ... */String[] retvalOption theCurrentOption;ListIterator<> theOptionsIterator;List<> theOptions;List<> theCmdArgs;OptionMatcher theOptionMatcher;GetOpt$Option// inner class to model an option//   Inner Classeschar theArgLetter;String theArgument;GetOpt$OptionMatcher// and whether or not a given legal option takes an argument.// inner class to query optString for a possible option match,// end class OptionString theOptString;/* $Id: GetOpt.java,v 1.2.4.1 2005/08/31 11:46:04 pvedula Exp $ */// fill in the options list// end of opts// set index of first operand// end of options// simple option token such as '-s' found// stacked options found, such as '-shm'// iterate thru the tokens after the dash and// add them to theOptions list// case 1- there are not options stored yet therefore// this must be an command argument, not an option argument// stop processing options// case 2-// there are options stored, check to see if// this arg belong to the last arg stored// case 3 -// the last option stored does not take// an argument, so again, this argument// must be a command argument, not// an option argument// end option does not start with "-"// end for args loop//  attach an iterator to list of options// options are done, now fill out cmd arg list with remaining args// reached end of theOptString// end class OptionMatcher// end class GetOpt/* $Id: GetOptsException.java,v 1.2.4.1 2005/08/31 11:47:06 pvedula Exp $ *//* $Id: IllegalArgumentException.java,v 1.2.4.1 2005/08/31 11:47:56 pvedula Exp $ *//* $Id: MissingOptArgException.java,v 1.2.4.1 2005/08/31 11:49:21 pvedula Exp $ */import ALOADimport ASTOREimport INVOKEINTERFACEimport INVOKESPECIALimport LocalVariableGenimport NEWimport ClassGeneratorimport MethodGeneratorimport NodeTypeimport TypeCheckErrorExpression _path;// may be nullType ptypetypeCheck(...)new CastExpr(...)Type.NodeSetConstantPoolGen cpgint initAILocalVariableGen relPathIteratorgetJCRefType(...)int gitrloadDOM(...)// promote to node-set// Compile relative path iterator(s)// Backwards branches are prohibited if an uninitialized object is// on the stack by section 4.9.4 of the JVM Specification, 2nd Ed.// We don't know whether this code might contain backwards branches,// so we mustn't create the new object until after we've created// this argument to its constructor.  Instead we calculate the// value of the argument to the constructor first, store it in// a temporary variable, create the object and reload the argument// from the temporary to avoid the problem.// Create new AbsoluteIterator// Initialize AbsoluteIterator with iterator from the stackimport GOTO_Wimport IF_ICMPEQimport ILOADimport ISTOREimport PUSHRelativePathPattern _left;Type.RootgetKernelPattern(...)reduceKernelPattern(...)int getParentint getTypeInstructionHandle beginBranchHandle skipLocalVariableGen localaddLocalVariable2(...)removeLocalVariable(...)DTM.DOCUMENT_NODEbackPatchTrueList(...)AncestorPattern ancestorbackPatch(...)getLoopHandle(...)_left._falseList// absolute path pattern temporary/* If _left is an ancestor pattern, backpatch this pattern's false ... */// clears listimport GOTOPattern _left;Pattern _right;/** Construct an alternative pattern. The method <code>setParent</code> ... *//** The type of an '|' is not really defined, hence null is returned. */double leftdouble rightInstructionHandle gototloadContextNode(...)_left._trueList_right._trueList_right._falseListimport IFLTRelativePathPattern _right;InstructionHandle _loop;InstructionHandle parentInstruction loadLocalInstruction storeLocalSyntaxTreeNode pBranchHandle exitbackPatchFalseList(...)//!!! can be wildcard/* The scope of this local var must be the entire method since ... *//* If _right is an ancestor pattern, backpatch this pattern's false ... */import INVOKEVIRTUALQName _modeName;int _precedence;/** Returns true if this <xsl:apply-imports/> element has parameters */hasContents(...)/** Determine the lowest import precedence for any stylesheet imported ... */Stylesheet includeRootgetStylesheet(...)includeRoot._includedFromgetMinimumDescendantPrecedence(...)/** Parse the attributes and contents of an <xsl:apply-imports/> element. */Stylesheet stylesheetTemplate templategetModeName(...)getImportPrecedence(...)getTopLevelStylesheet(...)parseChildren(...)/** Type-check the attributes/contents of an <xsl:apply-imports/> element. */typeCheckContents(...)Type.Void/** Translate call-template. A parameter frame is pushed only if ... */getLocalIndex(...)int maxPrecedenceint minPrecedencegetMinPrecedence(...)Mode modegetMode(...)String functionNamefunctionName(...)getApplyTemplatesSigForImport(...)int applyTemplatesloadTranslet(...)loadIterator(...)loadHandler(...)loadCurrentNode(...)hasLocalParams(...)int pushFrame// Move to root of include tree// Indicate to the top-level stylesheet that all templates must be// compiled into separate methods.// Get the mode we are currently in (might not be any)// Get the method name for <xsl:apply-imports/> in this mode// with-params// Push the arguments that are passed to applyTemplates()// Push a new parameter frame in case imported template might expect// parameters.  The apply-imports has nothing that it can pass.// Get the [min,max> precedence of all templates imported under the// current stylesheet// Get name of appropriate apply-templates function for this// xsl:apply-imports instruction// Construct the translet class-name and the signature of the method// Pop any parameter frame that was pushed above.import NodeSetTypeimport ReferenceTypeimport ResultTreeTypeimport XML11CharExpression _select;Type _type;String _functionName;String selectString modeparseExpression(...)isXML11ValidQName(...)ErrorMsg.INVALID_QNAME_ERRreportError(...)Constants.ERRORgetQNameIgnoreDefaultNs(...)new TypeCheckError(...)boolean setStartNodeCalledVector<Sort> sortObjectsnew Vector<Sort>(...)String applyTemplatesSiggetApplyTemplatesSig(...)SyntaxTreeNode childgetContents(...)translateContents(...)ErrorMsg.RESULT_TREE_SORT_ERRgetParser(...)translateTo(...)int setStartNodetranslateSortIterator(...)compileGetChildren(...)startIterator(...)releaseResultTree(...)int popFrame/* Copyright (c) 2015, 2016, Oracle and/or its affiliates. All rights reserved. */// instantiate Mode if needed, cache (apply temp) function name// check if sorting nodes is required// Push a new parameter frame// translate with-params// The 'select' expression is a result-tree// <xsl:sort> cannot be applied to a result tree - issue warning// Put the result tree (a DOM adapter) on the stack// Get back the DOM and iterator (not just iterator!!!)// compute node iterator for applyTemplates//!!! need to instantiate all needed modes// unmap parameters to release temporary result trees// Pop parameter frameExpression _arg;ArgumentList _rest;QName _name;displayContents(...)getQName(...)//!!! add text nodes//!!! take care of value templatesimport AttributeSetMethodGeneratorString AttributeSetPrefix;// This prefix is used for the method name of attribute set methods// Element contentsUseAttributeSets _useSets;AttributeSet _mergeSet;String _method;boolean _ignore;/** Returns the QName of this attribute set *//** Returns the method name of this attribute set. This method name is ... *//** Call this method to prevent a method for being compiled for this set. ... *//** Parse the contents of this attribute set. Recognised attributes are ... */String useSetsList<SyntaxTreeNode> contentsErrorMsg.UNNAMED_ATTRIBSET_ERRisValidQNames(...)new UseAttributeSets(...)setCurrentNode(...)getSymbolTable(...)parseContents(...)ErrorMsg.ILLEGAL_CHILD_ERR/** Type check the contents of this element */addAttributeSet(...)nextAttributeSetSerial(...)getXSLTC(...)/** Compile a method that outputs the attributes in this set */Iterator<SyntaxTreeNode> attributesnew AttributeSetMethodGenerator(...)SyntaxTreeNode elementXslAttribute attribute/* Copyright (c) 2015, Oracle and/or its affiliates. All rights reserved. *//* $Id: AttributeSet.java,v 1.5 2005/09/28 13:48:04 pvedula Exp $ */// Get this attribute set's name// Get any included attribute sets (similar to inheritance...)// Parse the contents of this node. All child elements must be// <xsl:attribute> elements. Other elements cause an error.// Point the symbol table back at us...// _mergeSet Point to any previous definition of this attribute set// Create a new method generator for an attribute set method// Generate a reference to previous attribute-set definitions with the// same name first.  Those later in the stylesheet take precedence.// Translate other used attribute sets first, as local attributes// take precedence (last attributes overrides first)// Translate all local attributesAttributeValue resultnew AttributeValueTemplate(...)new SimpleAttributeValue(...)int OUT_EXPR;int IN_EXPR;int IN_EXPR_SQUOTES;int IN_EXPR_DQUOTES;String DELIMITER;// A Unicode noncharparseAVTemplate(...)ErrorMsg.ATTR_VAL_TEMPLATE_ERR/** Two-pass parsing of ATVs. In the first pass, double curly braces are ... */String lookaheadnew LiteralExpr(...)Expression expidenticalTo(...)Type.StringelementCount(...)int initBufferInstruction appendint toStringIterator<SyntaxTreeNode> elements/* $Id: AttributeValueTemplate.java,v 1.2.4.1 2005/09/01 10:26:57 pvedula Exp $ *//* First pass: replace double curly braces and delimit expressions ... */// Use lookahead if available// replace {{ by {// replace }} by }// Must be in OUT_EXPR at the end of parsing/* Second pass: split up buffer into literal and non-literal expressions. */// consume other delimiter// StringBuffer is on the stackimport MethodTypeint PLUS;int MINUS;int TIMES;int DIV;int MOD;...[] Ops;int _op;Expression _left, ...;/** Returns true if this expressions contains a call to position(). This is ... */hasPositionCall(...)/** Returns true if this expressions contains a call to last() */hasLastCall(...)Type tleftType trightMethodType ptypelookupPrimop(...)new MethodType(...)Type arg1argsType(...)Type arg2resultType(...)ErrorMsg.ILLEGAL_BINARY_OP_ERRADD(...)SUB(...)MUL(...)DIV(...)REM(...)/* Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved. ... */argument(...)Type.BooleanType targ/* Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved. ... *//** This class implements inlined calls to the XSLT standard functions ... */boolean _value;// true list falls through/** Name of template to call. */...[] _parameters;/** The array of effective parameters in this CallTemplate. An object in ... */Template _calleeTemplate;/** The corresponding template which this CallTemplate calls. */ErrorMsg.REQUIRED_ATTR_ERR/** Verify that a template with this name exists. */lookupTemplate(...)ErrorMsg.TEMPLATE_UNDEF_ERRStringBuffer methodSiggetCalleeTemplate(...)buildParameterList(...)int pushint numParams_parameters.lengthSyntaxTreeNode nodeint pop/** Return the simple named template which this CallTemplate calls. ... */Template foundTemplateisSimpleNamedTemplate(...)/** Build the list of effective parameters in this CallTemplate. ... */Vector<Param> defaultParamsgetParameters(...)new SyntaxTreeNode[]Object nodeWithParam withParamQName nameSyntaxTreeNode parmsetDoParameterOptimization(...)/* Copyright (c) 2016, Oracle and/or its affiliates. All rights reserved. */// If there are Params in the stylesheet or WithParams in this call?// Build the parameter list if the called template is simple named// This is only needed when the called template is not// a simple named template.// Push parameter frame// Generate a valid Java method name// Load standard arguments// Initialize prefix of method signature// If calling a simply named template, push actual arguments// append Object to signature// Push 'null' if Param to indicate no actual parameter specified// translate WithParam// Complete signature and generate invokevirtual call// release temporary result trees// Do not need to call Translet.popParamFrame() if we are// calling a simple named template.// Put the parameters from the called template into the array first.// This is to ensure the order of the parameters.// Replace a Param with a WithParam if they have the same name.// Ignore if not WithParam// Search for a Param with the same name/** Name of the class that is the target of the cast. Must be a ... */Expression _right;/** A reference to the expression being casted. *//** Type check the two parameters for this function */argumentCount(...)ErrorMsg.ILLEGAL_ARG_ERRnewObjectType(...)ErrorMsg.NEED_LITERAL_ERRType.ReferenceErrorMsg.DATA_CONVERSION_ERR// Check that the function was passed exactly two arguments// The first argument must be a literal String// Second argument must be of type reference or objectimport IF_ICMPNEimport SIPUSHimport BooleanTypeimport MultiHashtableimport Axisnew MultiHashtable<Type,Type>(...)Type.RealType.ObjectType.IntType.NodeType.ResultTreemakeUnmodifiable(...)Expression _left;MultiHashtable<Type,Type> InternalTypeMap;/** Legal conversions between internal types. */boolean _typeTest;/** Construct a cast expression and check that the conversion is ... */Step stepgetAxis(...)Axis.SELF/** Type checking a cast expression amounts to verifying that the ... */maps(...)FlowList flType ltypetranslateToDesynthesized(...)/* $Id: CastExpr.java,v 1.2.4.1 2005/09/12 10:06:35 pvedula Exp $ */// Possible type conversions between internal types// use inherited field// check if conversion is valid// multiple instances// throw new TypeCheckError(this);// This is a special case for the self:: axis. Instead of letting// the Step object create and iterator that we cast back to a single// node, we simply ask the DOM for the node type.import INVOKESTATICimport IFEQ/** Display the element contents (a lot of when's and an otherwise) *//** Translate this Choose element. Generate a test-chain for the various ... */Vector<> whenElementsOtherwise otherwiseErrorMsg errorint lineBranchHandle nextElementVector<> exitHandlesInstructionHandle exitEnumeration<> whensEnumeration<> exitGotosErrorMsg.MULTIPLE_OTHERWISE_ERRignore(...)ErrorMsg.WHEN_ELEMENT_ERRErrorMsg.MISSING_WHEN_ERRWhen whenExpression testgetTest(...)InstructionHandle truectranslateDesynthesized(...)FunctionCall calltest._falseListTypeCheckError eBranchHandle gotoExit/* $Id: Choose.java,v 1.2.4.1 2005/09/01 12:00:14 pvedula Exp $ */// These two are for reporting errors only// Traverse all child nodes - must be either When or Otherwise// Add a When child element// Add an Otherwise child element// It is an error if we find some other element here// Make sure that there is at least one <xsl:when> element// next element will hold a handle to the beginning of next// When/Otherwise if test on current When fails// handled later!// remember end of condition// The When object should be ignored completely in case it tests// for the support of a non-available element// goto exit after executing the body of when// Translate any <xsl:otherwise> element// now that end is known set targets of exit gotos/** Returns true if this closure is compiled in an inner class (i.e. ... *//** Returns a reference to its parent closure or null if outermost. *//** Returns the name of the auxiliary class or null if this predicate ... *//** Add new variable to the closure. */import GETFIELDText rawTextObject contentcanLoadAsArrayOffsetLength(...)int commentloadAsArrayOffsetLength(...)storeHandler(...)// Shortcut for literal strings// If the content is literal text, call comment(char[],int,int) or// comment(String), as appropriate.  Otherwise, use a// StringValueHandler to gather the textual content of the xsl:comment// and call comment(String) with the result.// Save the current handler base on the stack// first arg to "comment" call// Get the translet's StringValueHandler// translate contents with substituted handler// get String out of the handler// call "comment"// Restore old handler base from stackString _msg;setArgument(...)/** translate leaves a String on the stack */int nArgsimport ArithmeticInstructionimport ConversionInstructionimport StackInstructionInstructionConst.ATHROWInstructionConst.DCMPGInstructionConst.ICONST_1InstructionConst.SWAPInstructionConst.ALOAD_0InstructionConst.ALOAD_1InstructionConst.ALOAD_2InstructionConst.ILOAD_1InstructionConst.ILOAD_2InstructionConst.D2FInstructionConst.D2IInstructionConst.D2LInstructionConst.F2DInstructionConst.I2BInstructionConst.I2CInstructionConst.I2DInstructionConst.I2FInstructionConst.I2LInstructionConst.I2SInstructionConst.L2DInstructionConst.L2Iint INTERNAL;// Immediately terminates compilation, no translet produced// Unexpected internal errors, such as null-ptr exceptions, etc.// Error categories used to report errors to Parser.reportError()int UNSUPPORTED;// XSLT elements that are not implemented and unsupported ext.int FATAL;// Fatal error in the stylesheet input (parsing or content)int ERROR;// Does not terminate compilation, no translet produced// Other error in the stylesheet input (parsing or content)int WARNING;// Does not terminate compilation, a translet is produced// Other error in the stylesheet input (content errors only)String EMPTYSTRING;String NAMESPACE_FEATURE;String TRANSLET_INTF;String TRANSLET_INTF_SIG;String ATTRIBUTES_SIG;String NODE_ITERATOR_SIG;String DOM_INTF_SIG;String DOM_IMPL_CLASS;String SAX_IMPL_CLASS;// xml/dtm/ref/DTMDefaultBaseIterators"; //xalan/xsltc/dom/DOMImpl";String DOM_IMPL_SIG;String SAX_IMPL_SIG;//xml/dtm/ref/DTMDefaultBaseIterators"; //xalan/xsltc/dom/DOMImpl;";String DOM_ADAPTER_CLASS;String DOM_ADAPTER_SIG;String MULTI_DOM_CLASS;String MULTI_DOM_SIG;String STRING;int ACC_PUBLIC;int ACC_SUPER;int ACC_FINAL;int ACC_PRIVATE;int ACC_PROTECTED;int ACC_STATIC;String STRING_SIG;String STRING_BUFFER_SIG;String OBJECT_SIG;String DOUBLE_SIG;String INTEGER_SIG;String COLLATOR_CLASS;String COLLATOR_SIG;String NODE;String NODE_ITERATOR;String NODE_ITERATOR_BASE;String SORT_ITERATOR;String SORT_ITERATOR_SIG;String NODE_SORT_RECORD;String NODE_SORT_FACTORY;String NODE_SORT_RECORD_SIG;String NODE_SORT_FACTORY_SIG;String LOCALE_CLASS;String LOCALE_SIG;String STRING_VALUE_HANDLER;String STRING_VALUE_HANDLER_SIG;String OUTPUT_HANDLER;String OUTPUT_HANDLER_SIG;String FILTER_INTERFACE;String FILTER_INTERFACE_SIG;String UNION_ITERATOR_CLASS;String STEP_ITERATOR_CLASS;String CACHED_NODE_LIST_ITERATOR_CLASS;String NTH_ITERATOR_CLASS;String ABSOLUTE_ITERATOR;String DUP_FILTERED_ITERATOR;String CURRENT_NODE_LIST_ITERATOR;String CURRENT_NODE_LIST_FILTER;String CURRENT_NODE_LIST_ITERATOR_SIG;String CURRENT_NODE_LIST_FILTER_SIG;String FILTER_STEP_ITERATOR;String FILTER_ITERATOR;String SINGLETON_ITERATOR;String MATCHING_ITERATOR;String NODE_SIG;String GET_PARENT;String GET_PARENT_SIG;String NEXT_SIG;String NEXT;String NEXTID;String MAKE_NODE;String MAKE_NODE_LIST;String GET_UNPARSED_ENTITY_URI;String STRING_TO_REAL;String STRING_TO_REAL_SIG;String STRING_TO_INT;String STRING_TO_INT_SIG;String XSLT_PACKAGE;String COMPILER_PACKAGE;String RUNTIME_PACKAGE;String TRANSLET_CLASS;String TRANSLET_SIG;String UNION_ITERATOR_SIG;String TRANSLET_OUTPUT_SIG;String MAKE_NODE_SIG;String MAKE_NODE_SIG2;String MAKE_NODE_LIST_SIG;String MAKE_NODE_LIST_SIG2;String STREAM_XML_OUTPUT;String OUTPUT_BASE;String LOAD_DOCUMENT_CLASS;String KEY_INDEX_CLASS;String KEY_INDEX_SIG;String KEY_INDEX_ITERATOR_SIG;String DOM_INTF;String DOM_IMPL;String SAX_IMPL;String STRING_CLASS;String OBJECT_CLASS;String BOOLEAN_CLASS;String STRING_BUFFER_CLASS;String STRING_WRITER;String WRITER_SIG;String TRANSLET_OUTPUT_BASE;String TRANSLET_OUTPUT_INTERFACE;// output interfaceString BASIS_LIBRARY_CLASS;String ATTRIBUTE_LIST_IMPL_CLASS;String DOUBLE_CLASS;String INTEGER_CLASS;String RUNTIME_NODE_CLASS;String MATH_CLASS;String BOOLEAN_VALUE;String BOOLEAN_VALUE_SIG;String INT_VALUE;String INT_VALUE_SIG;String DOUBLE_VALUE;String DOUBLE_VALUE_SIG;String DOM_PNAME;String NODE_PNAME;String TRANSLET_OUTPUT_PNAME;String ITERATOR_PNAME;String DOCUMENT_PNAME;String TRANSLET_PNAME;String INVOKE_METHOD;String GET_NODE_NAME;String CHARACTERSW;String GET_CHILDREN;String GET_TYPED_CHILDREN;String CHARACTERS;String APPLY_TEMPLATES;String GET_NODE_TYPE;String GET_NODE_VALUE;String GET_ELEMENT_VALUE;String GET_ATTRIBUTE_VALUE;String HAS_ATTRIBUTE;String ADD_ITERATOR;String SET_START_NODE;String RESET;String ATTR_SET_SIG;String GET_NODE_NAME_SIG;String CHARACTERSW_SIG;String CHARACTERS_SIG;String GET_CHILDREN_SIG;String GET_TYPED_CHILDREN_SIG;String GET_NODE_TYPE_SIG;String GET_NODE_VALUE_SIG;String GET_ELEMENT_VALUE_SIG;String GET_ATTRIBUTE_VALUE_SIG;String HAS_ATTRIBUTE_SIG;String GET_ITERATOR_SIG;String NAMES_INDEX;String NAMES_INDEX_SIG;String URIS_INDEX;String URIS_INDEX_SIG;String TYPES_INDEX;String TYPES_INDEX_SIG;String NAMESPACE_INDEX;String NAMESPACE_INDEX_SIG;String HASIDCALL_INDEX;String HASIDCALL_INDEX_SIG;String TRANSLET_VERSION_INDEX;String TRANSLET_VERSION_INDEX_SIG;String DOM_FIELD;String STATIC_NAMES_ARRAY_FIELD;String STATIC_URIS_ARRAY_FIELD;String STATIC_TYPES_ARRAY_FIELD;String STATIC_NAMESPACE_ARRAY_FIELD;String STATIC_CHAR_DATA_FIELD;String STATIC_CHAR_DATA_FIELD_SIG;String FORMAT_SYMBOLS_FIELD;String ITERATOR_FIELD_SIG;String NODE_FIELD;String NODE_FIELD_SIG;String EMPTYATTR_FIELD;String ATTRIBUTE_LIST_FIELD;String CLEAR_ATTRIBUTES;String ADD_ATTRIBUTE;String ATTRIBUTE_LIST_IMPL_SIG;String CLEAR_ATTRIBUTES_SIG;String ADD_ATTRIBUTE_SIG;String ADD_ITERATOR_SIG;String ORDER_ITERATOR;String ORDER_ITERATOR_SIG;String SET_START_NODE_SIG;String NODE_COUNTER;String NODE_COUNTER_SIG;String DEFAULT_NODE_COUNTER;String DEFAULT_NODE_COUNTER_SIG;String TRANSLET_FIELD;String TRANSLET_FIELD_SIG;String RESET_SIG;String GET_PARAMETER;String ADD_PARAMETER;String PUSH_PARAM_FRAME;String PUSH_PARAM_FRAME_SIG;String POP_PARAM_FRAME;String POP_PARAM_FRAME_SIG;String GET_PARAMETER_SIG;String ADD_PARAMETER_SIG;String STRIP_SPACE;String STRIP_SPACE_INTF;String STRIP_SPACE_SIG;String STRIP_SPACE_PARAMS;String GET_NODE_VALUE_ITERATOR;String GET_NODE_VALUE_ITERATOR_SIG;String GET_UNPARSED_ENTITY_URI_SIG;int POSITION_INDEX;int LAST_INDEX;String XMLNS_PREFIX;String XMLNS_STRING;String XMLNS_URI;String XSLT_URI;String XHTML_URI;String TRANSLET_URI;String REDIRECT_URI;String FALLBACK_CLASS;int RTF_INITIAL_SIZE;/* Copyright (c) 2016, 2017, Oracle and/or its affiliates. All rights reserved. *//* $Id: Constants.java,v 1.7 2006/06/19 19:49:04 spericas Exp $ */Expression _base;Expression _token;/** Create a contains() call - two arguments, both strings *//** This XPath function returns true/false values */Type baseTypeType tokenType/** Compile the expression - leave boolean expression on stack */synthesize(...)/** Compile expression and update true/false-lists */// The first argument must be a String, or cast to a String// The second argument must also be a String, or cast to a Stringimport IFNULLLocalVariableGen nameLocalVariableGen lengthint cpyBranchHandle ifBlock1int lengthMethodBranchHandle ifBlock4BranchHandle ifBlock3SyntaxTreeNode parentBranchHandle ifBlock2endElement(...)// Get the name of the node to copy and save for later// Get the length of the node name and save for later// Ignore attribute sets if current node is ROOT. DOM.shallowCopy()// returns "" for ROOT, so skip attribute sets if length == 0// Copy in attribute sets if specified// If the parent of this element will result in an element being// output then we know that it is safe to copy out the attributes// If not we have to check to see if the copy will result in an// element being output.// check if element; if not skip to translate body// length != 0 -> element -> do attribute sets// not an element; root// Instantiate body of xsl:copy// Call the output handler's endElement() if we copied an element// (The DOM.shallowCopy() method calls startElement().)isDummy(...)Type tselectString CPY1_SIGint cpy1String CPY2_SIGint cpy2String getDoc_SIGint getDocint copy// make sure required attribute(s) have been set// falls through// push NodeIterator// call copy from the DOM 'library'// We want the whole tree, so we start with the root node//need a pointer to the DOM ;//ICONST_0);import GETSTATICString DFS_CLASS;String DFS_SIG;/** No type check needed for the <xsl:decimal-formatting/> element *//** Parse the name of the <xsl:decimal-formatting/> element */SymbolTable stablegetDecimalFormatting(...)reportWarning(...)ErrorMsg.SYMBOLS_REDEF_ERRaddDecimalFormatting(...)/** This method is called when the constructor is compiled in ... */int initint nAttributesint putint nanint infboolean valid/** Creates the default, nameless, DecimalFormat object in ... */// Get the name of these decimal formatting symbols// Check if a set of symbols has already been registered under this name// DecimalFormatSymbols.<init>(Locale);// xsl:decimal-format - except for the NaN and infinity attributes.// Push the format name on the stack for call to addDecimalFormat()// Manufacture a DecimalFormatSymbols on the stack// for call to addDecimalFormat()// Use the US Locale as the default, as most of its settings// are equivalent to the default settings required of// DecimalFormatSymbols.setDecimalSeparator();// Push the format name, which is empty, on the stack// Manufacture a DecimalFormatSymbols on the stack for// call to addDecimalFormat().  Use the US Locale as the// default, as most of its settings are equivalent to// the default settings required of xsl:decimal-format -// except for the NaN and infinity attributes.Expression _arg1;Expression _arg2;Type _arg1Type;/** Default function call constructor *//** Type checks the arguments passed to the document() function. The first ... */int acErrorMsg.DOCUMENT_ARG_ERRType arg2Type/** Translates the document() function call to a call to LoadDocument()'s ... */int domFieldString docParamListint docIdx// At least one argument - two at most// Parse the first argument// should not happened// Parse the second argument// documentF(Object,String,AbstractTranslet,DOM)//ac == 2; ac < 1 or as >2  was tested in typeChec()// documentF(Object,DTMAxisIterator,String,AbstractTranslet,DOM)// The URI can be either a node-set or something else cast to a string//_arg2 == null was tested in typeChec()// Feck the rest of the parameters on the stack/** Force the argument to this function to be a literal string. *//** Returns an object representing the compile-time evaluation ... */getResult(...)/** Returns the result that this function will return */LiteralExpr argString qnameString localNameelementSupported(...)getNamespace(...)/** Calls to 'element-available' are resolved at compile time since ... */import IFNEimport IntTypeimport NumberTypeimport RealTypeimport StringTypeimport OperatorsgetOpNames(...)Operators.NEExpression temp/** Typing rules: see XSLT Reference by M. Kay page 345. */isSimple(...)swapArguments(...)Operators.EQdesynthesize(...)BranchHandle truecBranchHandle falsecint comparetoSignature(...)int equals// both compared as strings// the following 2 cases optimize @attr|.|.. = 'string'// optimize node/node// compare(Node, NodeSet) will be invoked// for compare(Node, NodeSet)// At least one argument is of type node, node-set or result-tree// Promote an expression of type node to node-set// If one arg is a node-set then make it the left one// Promote integers to doubles to have fewer compares// not x <-> x xor 1// Next, result-tree/string and result-tree/result-tree comparisons// x != y <-> x xor y// needed ?// Next, node-set/t for t in {real, string, node-set, result-tree}// Cast a result tree to a string to use an existing compare// Call the appropriate compare() from the BasisLibrarynew FlowList(...)/** The type of this expression. It is set after calling ... */FlowList _trueList;/** Instruction handles that comprise the true list. */FlowList _falseList;/** Instruction handles that comprise the false list. *//** Type check all the children of this node. *//** Translate this node into JVM bytecodes. */ErrorMsg.NOT_IMPLEMENTED_ERR/** Translate this node into a fresh instruction list. ... */InstructionList resultInstructionList save/** Redefined by expressions of type boolean that use flow lists. *//** If this expression is of type node-set and it is not a variable ... */Expression exprgetExpr(...)setStartNode(...)/** Synthesize a boolean expression, i.e., either push a 0 or 1 onto the ... *//** Search for a primop in the symbol table that matches the method type ... */MethodType resultVector<> primopint minDistanceint distancedistanceTo(...)argsCount(...)// default should be 'false' for StepPattern// Ignore if type is not node-set// setStartNode() should not be called if expr is a variable ref// Skip if different arity// The first method with the right arity is the default// default method// Check if better than last one foundboolean _active;/** This element never produces any data on the stack *//** Activate this fallback element *//** Parse contents only if this fallback element is put in place of ... *//** Translate contents only if this fallback element is put in place of ... */Expression _primary;/** Primary expression of this filter. I.e., 'e' in '(e)[p1]...[pn]'. */List<Expression> _predicates;/** Array of predicates in '(e)[p1]...[pn]'. *//** Type check a FilterParentPath. If the filter is not a node-set add a ... */boolean canOptimizePredicate preddontOptimize(...)/** Translate a filter expression by pushing the appropriate iterator ... */translateFilterExpr(...)translatePredicates(...)/** Translate a sequence of predicates. Each predicate is translated ... */Predicate predicateisNthPositionFilter(...)int nthIteratorIdxLocalVariableGen iteratorTempLocalVariableGen predicateValueTempint initCNLILocalVariableGen nodeIteratorTempLocalVariableGen filterTemp// Type check predicates and turn all optimizations off if appropriate// If not predicates left, translate primary expression// Get the next predicate to be translated// Translate the rest of the predicates from right to left// Backwards branches are prohibited if an uninitialized object// is on the stack by section 4.9.4 of the JVM Specification,// 2nd Ed.  We don't know whether this code might contain// backwards branches, so we mustn't create the new object unti// after we've created the suspect arguments to its constructor// Instead we calculate the values of the arguments to the// constructor first, store them in temporary variables, create// the object and reload the arguments from the temporaries to// avoid the problem.// Translate predicates from right to left// the suspect arguments to its constructor.  Instead we calculate// the values of the arguments to the constructor first, store them// in temporary variables, create the object and reload the// arguments from the temporaries to avoid the problem.// Create a CurrentNodeListIterator// Initialize CurrentNodeListIteratorExpression _filterExpr;boolean _hasDescendantAxis;Type ftypeint initSILocalVariableGen pathTempboolean parentAlreadyOrderedint inclint order/* else if (ftype instanceof ResultTreeType)  { ... */// Wrap single node path in a node set// Create new StepIterator// Recursively compile 2 iterators// Initialize StepIterator with iterators from the stack// This is a special case for the //* path with or without predicatesint initDFIint git// Create new Dup Filter Iterator// Initialize Dup Filter Iterator with iterator from the stackVector<> _elements;list._elementsright._elementsVector<> temp/** Back patch a flow list. All instruction handles must be branch handles. *//** Redirect the handles from oldList to newList. "This" flow list ... */FlowList resultIterator<> oldIterIterator<> newIterInstructionHandle oldIhInstructionHandle newIh// avoid backpatching more than onceimport IFGTVector<> sortObjectsIterator<SyntaxTreeNode> childrenBranchHandle nextNodeInstructionHandle loopstoreDOM(...)storeIterator(...)initializeVariables(...)nextNode(...)storeCurrentNode(...)/** The code that is generated by nested for-each loops can appear to some ... */Variable var/* $Id: ForEach.java,v 1.2.4.1 2005/09/01 15:23:46 pvedula Exp $ */// Save current node and current iterator on the stack// Collect sort objects associated with this instruction// Store existing DOM on stack - must be restored when loop is done// Put the result tree on the stack (DOM)// Get an iterator for the whole DOM - excluding the root node// Store the result tree as the default DOM// Compile node iterator// Overwrite current iterator// Give local variables (if any) default values before starting loop// Restore current DOM (if result tree was used instead for this loop)// Restore current node and current iterator from the stackExpression _value;Expression _format;Expression _name;QName _resolvedQName;Type tvalueType tformatnumberFormattingUsed(...)Type tnameLiteralExpr literalint fn3argint get// Inform stylesheet to instantiate a DecimalFormat objectString _nameOfFunct;String _namespaceOfFunct;boolean _isFunctionAvailable;/** Constructs a FunctionAvailableCall FunctionCall. Takes the ... */isInternalNamespace(...)hasMethods(...)/** Argument of function-available call must be literal, typecheck ... *//** for external java functions only: reports on whether or not ... */getClassNameFromUri(...)int colonIndexint lastDotIndexreplaceDash(...)/** Reports on whether the function specified in the argument to ... */functionSupported(...)getLocalName(...)/** Return true if the namespace uri is null or it is the XSLTC translet uri. *//** Calls to 'function-available' are resolved at compile time since ... */// Get the class name from the namespace uri// Get the method name from the argument to function-available// Replace the '-' characters in the method namenew ArrayList<Expression>(...)new MultiHashtable<Type,JavaType>(...)Class<?> nodeClassClass<?> nodeListClassMap<Class<?>,Type> java2Internalnew HashMap<Class<?>,Type>(...)Map<String,String> extensionNamespaceTableMap<String,String> extensionFunctionTablenew JavaType(...)Double.classQName _fname;// Name of this function callList<Expression> _arguments;// Arguments to this function call (might not be any)List<Expression> EMPTY_ARG_LIST;// Empty argument list, used for certain functionsString EXT_XSLTC;// Valid namespaces for Java function-call extensionString JAVA_EXT_XSLTC;String EXT_XALAN;String JAVA_EXT_XALAN;String JAVA_EXT_XALAN_OLD;String EXSLT_COMMON;String EXSLT_MATH;String EXSLT_SETS;String EXSLT_DATETIME;String EXSLT_STRINGS;String XALAN_CLASSPACKAGE_NAMESPACE;int NAMESPACE_FORMAT_JAVA;// Namespace format constantsint NAMESPACE_FORMAT_CLASS;int NAMESPACE_FORMAT_PACKAGE;int NAMESPACE_FORMAT_CLASS_OR_PACKAGE;int _namespace_format;// Namespace formatExpression _thisArgument;/** Stores reference to object for non-static Java calls */// External Java function's class/method/signatureClass<?> _clazz;Method _chosenMethod;Constructor<?> _chosenConstructor;MethodType _chosenMethodType;boolean unresolvedExternal;// Encapsulates all unsupported external function callsboolean _isExtConstructor;// If FunctionCall is a external java constructorboolean _isStatic;// If the java method is staticMultiHashtable<Type,JavaType> _internal2Java;// Legal conversions between internal and Java types.Map<Class<?>,Type> JAVA2INTERNAL;// Legal conversions between Java and internal types.Map<String,String> EXTENSIONNAMESPACE;// The mappings between EXSLT extension namespaces and implementation classesMap<String,String> EXTENSIONFUNCTION;// Extension functions that are implemented in BasisLibrary/** inner class to used in internal2Java mappings, contains ... */Class<?> type;int distance;this.distanceJavaType.class/** Type check a function call. Since different type conversions apply, ... */String namespaceString localgetLocalPart(...)isExtension(...)new QName(...)typeCheckStandard(...)isStandard(...)String extFunctiontypeCheckExternal(...)ErrorMsg errorMsggetErrorMsg(...)ErrorMsg.METHOD_NOT_FOUND_ERR/** Type check a call to a standard function. Insert CastExprs when needed. ... */List<Type> argsTypetypeCheckArgs(...)MethodType argsclearNamespace(...)Type argTypeList<Constructor<?>> constructorsint nConstructorsint bestConstrDistanceErrorMsg.CONSTRUCTOR_NOT_FOUNDConstructor<?> constructorClass<?> extTypeint currConstrDistanceType intTypeJavaType matchmatch.distanceObjectType objectTypeErrorMsg.ARGUMENT_CONVERSION_ERR/** Type check a call to an external (Java) method. ... */findMethods(...)int nMethodsint bestMethodDistancetypeCheckConstructor(...)boolean hasThisArgumentExpression firstArgType firstArgTypegetJavaClassName(...)ErrorMsg.NO_JAVA_FUNCT_THIS_REFErrorMsg.FUNCTION_RESOLVE_ERRint currMethodDistanceObjectType objectsetMultiDocument(...)/** Type check the actual arguments of this function call. */List<Type> result/** Compile the function call and treat as an expression ... *//** Translate a function call. The compiled code will leave the function's ... */isSecureProcessing(...)boolean isExtensionFunctionEnabledgetFeature(...)JdkXmlFeatures.XmlFeature.ENABLE_EXTENSION_FUNCTIONJdkXmlFeatures.XmlFeatureConstants.EMPTYSTRINGClass<>[] paramTypesLocalVariableGen[] paramTemptranslateUnallowedExtension(...)Type expTypetoJCType(...)STORE(...)Expression argLOAD(...)translateFrom(...)/** Returns a vector with all methods named <code>_fname</code> ... */loadExternalFunction(...)/** Returns a vector with all constructors named <code>_fname</code> ... */List<Constructor<?>> resultConstructor<?>[] constructorsnew ArrayList<Constructor<?>>(...)ErrorMsg.UNKNOWN_SIG_TYPE_ERR/** Compute the JVM method descriptor for the method. *//** Compute the JVM constructor descriptor for the constructor. *//** Return the signature of the current method *//** To support EXSLT extensions, convert names with dash to allowable Java names: ... */char dash/** Translate code to call the BasisLibrary.unallowed_extensionF(String) ... *//* $Id: FunctionCall.java,v 1.2.4.1 2005/09/12 10:31:32 pvedula Exp $ *//** Defines 2 conversion tables: ... */// -- Internal to Java --------------------------------------------// Type.Boolean -> { boolean(0), Boolean(1), Object(2) }// Type.Real -> { double(0), Double(1), float(2), long(3), int(4),//                short(5), byte(6), char(7), Object(8) }// Type.Int must be the same as Type.Real// Type.String -> { String(0), Object(1) }// Type.NodeSet -> { NodeList(0), Node(1), Object(2), String(3) }// Type.Node -> { Node(0), NodeList(1), Object(2), String(3) }// Type.ResultTree -> { NodeList(0), Node(1), Object(2), String(3) }// Possible conversions between Java and internal types// Conversions from org.w3c.dom.Node/NodeList to internal NodeSet// Initialize the extension namespace table// Initialize the extension function table// Handle extension functions (they all have a namespace)// HACK!!!// invalid conversion// Constructor not found in this class// Try all constructors// reset// Check if all parameters to this constructor can be converted// Convert from internal (translet) type to external (Java) type// no mapping available// check if function is a contructor 'new'// check if we are calling an instance method/* Warn user if external function could not be resolved. ... */// use "Int" as "unknown"// Method not found in this class// Try all methods to identify the best fit// reset internal type// Check if all paramteters to this method can be converted// Allow a Reference type to match any external (Java) type at// the moment. The real type checking is performed at runtime.// Check if the return type can be converted// Use this method if all parameters & return type match// It is an error if the chosen method is an instance menthod but we don't// have a this argument.// Translate calls to methods in the BasisLibrary// append "F" to the function's name// Special precautions for some method calls// Invoke the method in the basis library// Add call to BasisLibrary.unresolved_externalF() to generate// run-time error message for unsupported external functions// We don't know whether this code might contain backwards branches// Convert the argument to its Java type// Convert the return type back to our internal type// Invoke function calls that are handled in separate classes// Push "this" if it is an instance method//Check if FSP and SM - only then proceed with loading// Is it public and same number of args ?// Is it public, static and same number of args ?// one argument// reuse signatureString _index;String _value;int getKeyIndexint lookupIdint lookupKeyint getNodeIdent// Returns the KeyIndex object of a given name// Initialises a KeyIndex to return nodes with specific values// Call getKeyIndex in AbstractTranslet with the name of the key// to get the index for this key (which is also a node iterator).// Now use the value in the second argument to determine what nodes// the iterator should return.Expression _test;/** Display the contents of this element *//** Parse the "test" expression and contents of this element. */evaluateAtCompileTime(...)/** Type-check the "test" expression and contents of this element. ... *//** Translate the "test" expression and contents of this element. ... */// Parse the "test" expression// Make sure required attribute(s) have been set// Ignore xsl:if when test is false (function-available() and// element-available())// Type-check the "test" expression// Type check the element contentsimport SystemIDResolverStylesheet _imported;Stylesheet contextgetCurrentStylesheet(...)String docToLoadInputSource inputString currLoadedDocSourceLoader loadergetSourceLoader(...)SyntaxTreeNode rootint currPrecedencegetCurrentImportPrecedence(...)int nextPrecedencegetNextImportPrecedence(...)Stylesheet topStylesheetcheckForLoop(...)ErrorMsg.CIRCULAR_INCLUDE_ERRConstants.FATALloadSource(...)errorsFound(...)String accessErrorXalanConstants.ACCESS_EXTERNAL_ALLgetAbsoluteURI(...)ErrorMsg.ACCESSING_XSLT_TARGET_ERRsanitizePath(...)makeStylesheet(...)setSourceLoader(...)setParentStylesheet(...)setImportingStylesheet(...)getTemplateInlining(...)setImportPrecedence(...)setCurrentStylesheet(...)addVariable(...)addParam(...)/* Copyright (c) 2007, 2015, Oracle and/or its affiliates. All rights reserved. *//* $Id: Import.java,v 1.8 2007/04/09 21:30:40 joehw Exp $ */// Use SourceLoader if available// No SourceLoader or not resolved by SourceLoader// Return if we could not resolve the URL// precedence for the including stylesheetStylesheet _included;int precedencesetIncludingStylesheet(...)/* $Id: Include.java,v 1.8 2007/04/09 21:30:41 joehw Exp $ */// An included stylesheet gets the same import precedence// as the stylesheet that included it.int _value;import IFGE/** The name of this key as defined in xsl:key. */Pattern _match;/** The pattern to match starting at the root node. */Expression _use;/** The expression that generates the values for this key. */Type _useType;/** The type of the _use expression. *//** Parse the <xsl:key> element and attributes ... */addKey(...)parsePattern(...)/** Returns a String-representation of this key's name ... *//** This method is called if the "use" attribute of the key contains a ... */int getNodeValueint keyDomLocalVariableGen parentNode/** Gather all nodes that match the expression in the attribute "match" ... */int keyBranchHandle skipNodeInstructionHandle skipAxis.DESCENDANTtraverseNodeSet(...)/* $Id: Key.java,v 1.6 2006/04/25 02:25:08 jeffsuttor Exp $ */// Get the required attributes and parser XPath expressions// Parse key name and add to symbol table// Type check match pattern// Cast node values to string values (except for nodesets)// DOM.getStringValueX(nodeIndex) => String// AbstractTranslet.SetKeyIndexDom(name, Dom) => void// This variable holds the id of the node we found with the "match"// attribute of xsl:key. This is the id we store, with the value we// get from the nodes we find here, in the index for this key.// Get the 'parameter' from the stack and store it in a local var.// Overwrite current iterator with one that gives us only what we want// Prepare to call buildKeyIndex(String name, int node, String value);// Now get the node value and push it on the parameter stack// Finally do the call to add an entry in the index for this key.// Go on to next matching node....// AbstractTranslet.buildKeyIndex(name,node_id,value) => void// DOM.getAxisIterator(root) => NodeIterator// Get an iterator for all nodes in the DOM// Reset the iterator to start with the root node// Loop for traversing all nodes in the DOM// Check if the current node matches the pattern in "match"// Leaves 0 or 1 on stack// If this is a node-set we must go through each node in the set// Pass current node as parameter (we're indexing on that node)// Get the next node from the iterator and do loop again.../** The name of the key. *//** The value to look up in the key/index. */Type _valueType;/** The value's data type. *//** Expanded qname when name is literal. */// The value's data type/** Get the parameters passed to function: ... *//** If this call to key() is in a top-level element like  another variable ... */TopLevelElement parentaddDependency(...)/** Type check the parameters for the id() or key() function. ... */Type returnTypeType nameTypeaddParentDependency(...)int getKeyIterator// If name unknown statically, there's nothing we can do// Run type check on the key name (first argument) - must be a string,// and if it is not it must be converted to one using string() rules.// Run type check on the value for this key. This value can be of// any data type, so this should never cause any type-check errors.// If the value is a reference, then we have to defer the decision// of how to process it until run-time.// If the value is known not to be a node-set, then it should be// converted to a string before the lookup is done. If the value is// known to be a node-set then this process (convert to string, then// do lookup) should be applied to every node in the set, and the// result from all lookups should be added to the resulting node-set.// If in a top-level element, create dependency to the referenced key// KeyIndex.setDom(Dom, node) => void// Initialise the index specified in the first parameter of key()// Generate following byte code://   KeyIndex ki = translet.getKeyIndex(_name)//   ki.setDom(translet.dom);//   ki.getKeyIndexIterator(_value, true)  - for key()//        OR//   ki.getKeyIndexIterator(_value, false)  - for id()import FilterGeneratorExpression _lang;Type _langType;int tstimport CompareGeneratorimport TestGeneratorloadLastNode(...)int getLastimport ElemDescAttributeValue _value;// Attribute name (incl. prefix)/** Creates a new literal attribute (but does not insert it into the AST). ... */// Attribute valuecontextDependent(...)allAttributesUnique(...)int flagsboolean isHTMLAttrEmptyElemDesc elemDescgetElemDesc(...)isAttrFlagSet(...)ElemDesc.ATTREMPTYSerializationHandler.HTML_ATTREMPTYElemDesc.ATTRURLSerializationHandler.HTML_ATTRURLString attrValuehasBadChars(...)SerializationHandler.NO_BAD_CHARSuniqueAttribute(...)attribute(...)/** Return true if at least one character in the String is considered to ... *//** Return the name of the attribute *//** Return the value of the attribute */// push handler// push attribute name - namespace prefix set by parent node// push attribute value// Generate code that calls SerializationHandler.addUniqueAttribute()// if all attributes are unique.// Set the HTML flags// call attributeimport ToHTMLStreamLiteralElement _literalElemParent;List<SyntaxTreeNode> _attributeElements;Map<String,String> _accessedPrefixes;boolean _allAttributesUnique;// names are not known at compile time.// different names. This flag is set to false if some attribute// True if all attributes of this LRE are unique, i.e. they all have/** Returns the QName for this literal element *//** Displays the contents of this literal element *//** Returns the namespace URI for which a prefix is pointing to */accessedNamespace(...)/** Method used to keep track of what namespaces that are references by ... */String parentUrinew Hashtable<String,String>(...)String oldgenerateNamespacePrefix(...)/** Translates the prefix of a QName according to the rules set in ... */String localnamegetPrefix(...)String alternativelookupPrefixAlias(...)String urilookupNamespace(...)excludeNamespaces(...)registerNamespace(...)/** Add an attribute to this element */new ArrayList<SyntaxTreeNode>(...)/** Set the first attribute of this element *//** Type-check the contents of this element. The element itself does not ... *//** This method starts at a given node, traverses all namespace mappings, ... */Map<String,String> allMap<String,String> mappinggetPrefixMapping(...)/** Determines the final QName for the element and its attributes. ... */Set<Entry<String,String>> includegetNamespaceScope(...)translateQName(...)QName qnamegetUseAttributeSets(...)setFirstAttribute(...)getExtensionElementPrefixes(...)getExcludeResultPrefixes(...)LiteralAttribute attrnew LiteralAttribute(...)isExcludedNamespace(...)unExcludeNamespaces(...)dependentContents(...)/** Compiles code that emits the literal element to the output handler, ... */checkAttributesUnique(...)startElement(...)SyntaxTreeNode itemnamespace(...)/** Return true if the output method is html. */getOutputMethod(...)Stylesheet.HTML_OUTPUT/** Return the ElemDesc object for an HTML element. ... */isHTMLOutput(...)/** Return true if all attributes of this LRE have unique names. *//** Check whether all attributes are unique. */boolean hasHiddenXslAttributecanProduceAttributeNodes(...)int numAttrsMap<String,SyntaxTreeNode> attrsTableXslAttribute xslAttrAttributeValue attrNamenew HashMap<String,SyntaxTreeNode>(...)SyntaxTreeNode nLiteralAttribute literalAttrSimpleAttributeValue simpleAttr/** Return true if the instructions under the given SyntaxTreeNode can produce attribute nodes ... */isIgnore(...)List<SyntaxTreeNode> chooseContentsSyntaxTreeNode chooseChild// Check if the parent has a declaration for this namespace// Check if we have any declared namespaces// Check if this node has a declaration for this namespace// Break up the QName and get prefix:localname strings// Treat default namespace as "" and not null// Check if we must translate the prefix// Get the namespace this prefix refers to// Register the namespace as accessed// Construct the new name for the element (may be unchanged)// Type-check all attributes// Check if in a literal element context// Process all attributes and register all namespaces they use// Handle xsl:use-attribute-sets. Attribute sets are placed first// in the vector or attributes to make sure that later local// attributes can override an attributes in the set.// Handle xsl:extension-element-prefixes// Handle xsl:exclude-result-prefixes// Ignore special attributes (e.g. xmlns:prefix and xmlns)// Handle all other literal attributes// Register all namespaces that are in scope, except for those that// are listed in the xsl:stylesheet element's *-prefixes attributes// Check whether all attributes are unique.// Compile code to emit element start tag// duplicate these 2 args for endElement// The value of an attribute may depend on a (sibling) variable// Compile code to emit namespace attributes// Output all attributes// Compile code to emit attributes and child elements// Compile code to emit element end tag// Cannot add an attribute to an element after children have been added to it.// We can safely return false when the instruction can produce an output node.// In general, there is no way to check whether <xsl:call-template> or// <xsl:apply-templates> can produce attribute nodes. <xsl:copy> and// <xsl:copy-of> can also copy attribute nodes to an element. Return// true in those cases to be safe.String _namespace;/** Creates a new literal expression node. ... *//** Handles calls with no parameter (current node is implicit parameter). *//** Handles calls with one parameter (either node or node-set). */int getNodeNameint getLocalName// Returns the name of a node in the DOMTemplate _template;int _importPrecedence;double _priority;int _position;getDefaultPriority(...)/** This method is used by the Mode class to prioritise patterns and ... */other._importPrecedenceother._priorityother._positionStepPattern spAxis.CHILD// TODO: What does it mean to translate a Pattern ?int OR;int AND;// operator// first operand// second operand/** Creates a new logical expression - either OR or AND. Note that the ... */Object leftbObject rightb/** Returns this logical expression's operator - OR or AND represented ... *//** Override the SyntaxTreeNode.setParser() method to make sure that the ... *//** Returns a string describing this expression *//** Type-check this expression, and possibly child expressions. */MethodType wantTypeMethodType haveTypeInstructionHandle middleInstructionHandle aftergetOp(...)// Return null if we can't evaluate at compile time// Get the left and right operand types// Check if the operator supports the two operand types// Yes, the operation is supported// Check if left-hand side operand must be type casted// Check if right-hand side operand must be type casted// Return the result type for the operator we will use// Compile AND-expression// Translate left hand side - must be true// Need this for chaining any OR-expression children// Translate left right side - must be true// Append child expression false-lists to our false-list// Special case for OR-expression as a left child of AND.// The true-list of OR must point to second clause of AND.// Special case for OR-expression as a right child of AND// The true-list of OR must point to true-list of AND.// Compile OR-expression// Translate left-hand side expression and produce true/false list// This GOTO is used to skip over the code for the last test// in the case where the the first test succeeds// Translate right-hand side expression and produce true/false listboolean _terminate;String termstrint einit// Load the translet (for call to displayMessage() function)// Push current output handler onto the stack// Replace the current output handler by a ToXMLStream// Push a reference to a StringWriter// Load ToXMLStream// Invoke output.setWriter(STRING_WRITER)// Invoke output.setEncoding("UTF-8")// other encodings?// Invoke output.setOmitXMLDeclaration(true)// Inline translation of contents// Call toString() on StringWriter// Restore old output handler// Send the resulting string to the message handling method// If 'terminate' attribute is set to 'yes': Instanciate a// RunTimeException, but it on the stack and throw an exception// Create a new instance of RunTimeExceptionimport DUPimport SWITCHimport TargetLostExceptionimport InstructionFinderimport DOMimport NamedMethodGenerator/** Mode gathers all the templates belonging to a given mode; ... */new HashMap<Template,Object>(...)new HashMap<Template,Mode>(...)new HashMap<Template,InstructionHandle>(...)new HashMap<Template,InstructionList>(...)/** The name of this mode as defined in the stylesheet. */Stylesheet _stylesheet;/** A reference to the stylesheet object that owns this mode. */String _methodName;/** The name of the method in which this mode is compiled. */Vector<> _templates;/** A vector of all the templates in this mode. */Vector<> _childNodeGroup;/** Group for patterns with node()-type kernel and child axis. */TestSeq _childNodeTestSeq;/** Test sequence for patterns with node()-type kernel and child axis. */Vector<> _attribNodeGroup;/** Group for patterns with node()-type kernel and attribute axis. */TestSeq _attribNodeTestSeq;/** Test sequence for patterns with node()-type kernel and attribute axis. */Vector<> _idxGroup;/** Group for patterns with id() or key()-type kernel. */TestSeq _idxTestSeq;/** Test sequence for patterns with id() or key()-type kernel. */...[] _patternGroups;/** Group for patterns with any other kernel type. */...[] _testSeq;/** Test sequence for patterns with any other kernel type. */Map<Template,Object> _neededTemplates;/** A mapping between templates and test sequences. */Map<Template,Mode> _namedTemplates;/** A mapping between named templates and Mode objects. */Map<Template,InstructionHandle> _templateIHs;/** A mapping between templates and instruction handles. */Map<Template,InstructionList> _templateILs;/** A mapping between templates and instruction lists. */LocationPathPattern _rootPattern;/** A reference to the pattern matching the root node. */Map<Integer,Integer> _importLevels;/** Stores ranges of template precendences for the compilation ... */Map<String,Key> _keys;/** A mapping between key names and keys. */int _currentIndex;/** Variable index for the current node used in code generation. *//** Creates a new Mode. ... */new Vector<>[]/** Returns the name of the method (_not_ function) that will be ... */new HashMap<Integer,Integer>(...)/** Shortcut to get the class compiled for this mode (will be inlined). */partition(...)quicksort(...)Template x/** Process all the test patterns in this mode */Enumeration<> templatesPattern patterngetPattern(...)isNamed(...)disabled(...)flattenAlternative(...)prepareTestSequences(...)/** This method will break up alternative patterns (ie. unions of patterns, ... */IdKeyPattern idkeysetTemplate(...)AlternativePattern altgetLeft(...)getRight(...)LocationPathPattern lppaddPatternToGroup(...)/** Group patterns by NodeTests of their last Step ... */addPattern(...)StepPattern kernelnoSmallerThan(...)/** Adds a pattern to a pattern group */_patternGroups.lengthVector<> patternsVector<>[] newGroupsDOM.NO_TYPEAxis.ATTRIBUTEboolean insertedLocationPathPattern lppToCompare/** Complete test sequences of a given type by adding all patterns ... *//** Build test sequences. The first step is to complete the test sequences ... */Vector<> starGroupDTM.ELEMENT_NODEVector<> atStarGroupDTM.ATTRIBUTE_NODEVector<> namesgetNamesIndex(...)completeTestSequences(...)DTM.TEXT_NODEDTM.PROCESSING_INSTRUCTION_NODEDTM.COMMENT_NODEDTM.NTYPESisAttributeName(...)new TestSeq[]TestSeq testSeqnew TestSeq(...)reduce(...)findTemplates(...)NamedMethodGenerator methodGennew NamedMethodGenerator(...)Vector<> parametersSet<Template> templatescompileNamedTemplate(...)InstructionList tilInstructionList iList_testSeq.length/** Compiles the default handling for DOM elements: traverse all children *//** Compiles the default action for DOM text nodes and attribute nodes: ... */int charsVector<> namespacesgetNamespaceIndex(...)int namespaceCountint namesCountint[] typestypes.lengthboolean compiledint getNSnew SWITCH(...)/** Compiles the applyTemplates() method and adds it to the translet. ... */Type[] argTypesString[] argNamesInstructionList mainILMethodGenerator methodGennew MethodGenerator(...)LocalVariableGen currentInstructionList bodyInstructionList ilLoopBranchHandle ifeqBranchHandle loopInstructionHandle ihLoopInstructionList ilRecursecompileDefaultRecursion(...)InstructionHandle ihRecurseInstructionList ilTextcompileDefaultText(...)InstructionHandle ihTextboolean[] isAttributeboolean[] isNamespaceTestSeq elemTestInstructionHandle ihElemTestSeq attrTestInstructionHandle ihAttrInstructionList ilKeyInstructionHandle elemNamespaceHandleInstructionList nsElemcompileNamespaces(...)InstructionHandle attrNamespaceHandleInstructionList nsAttrInstructionHandle ihPIInstructionHandle ihCommentInstructionHandle dispisNamespaceName(...)compileTemplates(...)double nodePrioint nodePosdouble elemPrioint elemPosTestSeq textTestdouble textPrioint textPosDTM.ROOT_NODEgetTemplateInstructionHandle(...)DTM.NAMESPACE_NODEDTM.CDATA_SECTION_NODEDTM.DOCUMENT_FRAGMENT_NODEDTM.DOCUMENT_TYPE_NODEDTM.ENTITY_NODEDTM.ENTITY_REFERENCE_NODEDTM.NOTATION_NODEappendTestSequences(...)appendTemplateCode(...)peepHoleOptimization(...)Entry<Integer,Integer> entryMap<>.Entry<Integer,Integer>compileApplyImports(...)int precVector<> oldTemplatesaddTemplate(...)processPatterns(...)compileTemplateCalls(...)/** Peephole optimization. */InstructionFinder findnew InstructionFinder(...)String patternILOAD iload1ILOAD iload2ISTORE istoreInstruction load_mALOAD aload1ALOAD aload2/** Auxiliary method to determine if a qname is an attribute. *//** Auxiliary method to determine if a qname is a namespace ... *//* $Id: Mode.java,v 1.2.4.1 2005/09/19 05:18:11 pvedula Exp $ *//* System.out.println("Before Sort " + _name); ... *//* System.out.println("\n After Sort " + _name); ... */// Traverse all templates// Get the next template/* Add this template to a table of named templates if it has a name. ... */// Add this template to a test sequence if it has a pattern// Patterns on type id() and key() are special since they do not have// any kernel node type (it can be anything as long as the node is in// the id's or key's index).// Alternative patterns are broken up and re-processed recursively// Finally we have a pattern that can be added to a test sequence!// id() and key()-type patterns do not have a kernel type// Otherwise get the kernel pattern from the LPP// kernel pattern is the last (maybe only) Step// Make sure the array of pattern groups is long enough// Find the vector to put this pattern into// Complete test sequence for "text()" with "child::node()"// Complete test sequence for "*" with "child::node()"// Complete test sequence for "pi()" with "child::node()"// Complete test sequence for "comment()" with "child::node()"// Complete test sequence for "@*" with "attribute::node()"// Complete test sequence for user-defined types// If an attribute then copy "@*" to its test sequence// And also copy "attribute::node()" to its test sequence// If an element then copy "*" to its test sequence// And also copy "child::node()" to its test sequence// System.out.println("testSeq[" + i + "] = " + testSeq);/* if (_attribNodeGroup != null && _attribNodeGroup.size() > 0) { ... */// doesn't matter what is 'put', only key matters// Initialize the types and names arrays for the NamedMethodGenerator.// For simple named templates, the signature of the generated method// is not fixed. It depends on the number of parameters declared in the// template.// !!! TODO templates both named and matched// empty template// else trivial TestSeq// Append switch() statement - namespace test dispatch loop// Initialize targets for namespace() switch statement// Add test sequences for known namespace types// Return "null" if no test sequences were compiled// Append first code in applyTemplates() - get type of current node// Create the applyTemplates() method// Insert an extra NOP just to keep "current" from appearing as if it// has a value before the start of the loop.// Create a local variable to hold the current node// Create the "body" instruction list that will eventually hold the// code for the entire method (other ILs will be appended).// Create an instruction list that contains the default next-node// iteration// The body of this code can get very large - large than can be handled// by a single IFNE(body.getStart()) instruction - need workaround:// applyTemplates() ends here!// Live range of "current" ends at end of loop// Compile default handling of elements (traverse children)// Compile default handling of text/attribute nodes (output text)// Distinguish attribute/element/namespace tests for further processing// Initialize isAttribute[] and isNamespace[] arrays// Compile all templates - regardless of pattern type// Handle template with explicit "*" pattern// Handle template with explicit "@*" pattern// Do tests for id() and key() patterns first// If there is a match on node() we need to replace ihElem// and ihText if the priority of node() is higher// Compare priorities of node() and "*"// Compare priorities of node() and text()// Handle templates with "ns:*" pattern// Handle templates with "ns:@*" pattern// Handle templates with "ns:elem" or "ns:@attr" pattern// Jump straight to namespace tests ?// Test first, then jump to namespace tests// Handle pattern with match on root node - default: traverse children// Handle any pattern with match on text nodes - default: output text// This DOM-type is not in use - default: process next node// Match unknown element in DOM - default: check for namespace match// Match unknown attribute in DOM - default: check for namespace match// Match on processing instruction - default: process next node// Match on comments - default: process next node// Now compile test sequences for various match patterns:// Match on node type// Append switch() statement - main dispatch loop in applyTemplates()// Append all the "case:" statements// Append the actual template code// Append NS:* node tests (if any)// Append NS:@* node tests (if any)// Append default action for element and root nodes// Append default action for text and attribute nodes// putting together constituent instruction lists// fall through to ilLoop// Compile method(s) for <xsl:apply-imports/> for this mode// Clear some datastructures// IMPORTANT: Save orignal & complete set of templates!!!!// Gather templates that are within the scope of this import// Process all patterns from those templates// Create the local variable to hold the current node// %HZ%:  Was ihLoop in XSLTC_DTM branch// Handle any pattern with match on text nodes - default: loop// Match on processing instruction - default: loop// Mark the end of the live range for the "current" variable// Restore original (complete) set of templates for this transformation// LoadInstruction, POP => (removed)// pattern = "LoadInstruction POP";// changed to lower case - changing to all lower case although only the instruction with capital I// is creating a problem in the Turkish locale// TODO: move target down into the list// ILOAD_N, ILOAD_N, SWAP, ISTORE_N => ILOAD_N// pattern = "ILOAD ILOAD SWAP ISTORE";// LoadInstruction_N, LoadInstruction_M, SWAP => LoadInstruction_M, LoadInstruction_N// pattern = "LoadInstruction LoadInstruction SWAP";// ALOAD_N ALOAD_N => ALOAD_N DUP// pattern = "ALOAD ALOAD";Expression _param;Type _paramType;/** Check that we either have no parameters or one parameter that is ... *//** Translate the code required for getting the node for which the ... */// Check the argument type (if any)// The argument has to be a node, a node-set or a node reference// Function was called with no parameters// Function was called with node parameter// Function was called with node-set parameter/** Translate code that leaves a node's QName (as a String) on the stack */int getNameString sPrefix;String rPrefix;/* The namespace alias definitions given here have an impact only on ... */addPrefixAlias(...)// do nada/** Translate code that leaves a node's namespace URI (as a String) ... */int getNamespace// Returns the string value for a node in the DOMDOM.FIRST_TYPEint TEXT;int COMMENT;int PI;int ROOT;int ELEMENT;int ATTRIBUTE;int GTYPE;// generalized typeint ANODE;BranchHandle gotohexp._falseListexp._trueList// swap flow listsimport IFNONNULLimport D2Iimport PUTFIELDimport MatchGeneratorimport NodeCounterGeneratorint LEVEL_SINGLE;int LEVEL_MULTIPLE;int LEVEL_ANY;...[] ClassNames;...[] FieldNames;Pattern _from;Pattern _count;AttributeValueTemplate _lang;AttributeValueTemplate _format;AttributeValueTemplate _letterValue;AttributeValueTemplate _groupingSeparator;AttributeValueTemplate _groupingSize;int _level;boolean _formatNeeded;ArrayList<> _closureVars;// -- Begin Closure interface --------------------// -- End Closure interface ----------------------/** True if the has specified a value for this instance of number. *//** Returns <tt>true</tt> if this instance of number has neither ... */int[] fieldIndexesgetNumberFieldIndexes(...)Field defaultNode/** Compiles a constructor for the class <tt>_className</tt> that ... */MethodGenerator cons/** This method compiles code that is common to matchesFrom() and ... */int fieldsetIteratorIndex(...)setTransletIndex(...)setDomIndex(...)MatchGenerator matchGenNodeCounterGenerator nodeCounterGenint closureLengetHelperClassName(...)new NodeCounterGenerator(...)VariableBase vargetVariable(...)getEscapedName(...)compileConstructor(...)new MatchGenerator(...)compileLocals(...)dumpClass(...)VariableRefBase varRefType varTypeloadInstruction(...)hasValue(...)compileDefault(...)isDefault(...)compilePatterns(...)// LEVEL_SINGLE// LEVEL_MULTIPLE// LEVEL_ANY// Only one reference per variable// Add a new private field to this class// Get a reference to the newly added field// Check if field is initialized (runtime)// Create an instance of DefaultNodeCounter// Store the node counter in the field// Backpatch conditionals// this// translet// DOM// iterator// hasFrom// Get NodeCounter._iterator and store locally// 'this' pointer on stack// Get NodeCounter._translet and store locally// Get NodeCounter._document and store locally// Make sure we have the correct DOM type on the stack!!!// Add a new instance variable for each var in closure// Add a single constructor to the class/* Compile method matchesFrom() */// Translate Pattern/* Compile method matchesCount() */// Push an instance of the newly created class// Initialize closure variables// Store variable in new closure// Push "this" for the call to characters()// Using java.lang.Math.floor(number + 0.5) to return a double value// Call setValue on the node counter// Call setStartNode()// Call getCounter() with or without args// TODO ??// Output the resulting string to the handlerErrorMsg.STRAY_OTHERWISE_ERRimport OutputStreamWriterimport EncodingsString _version;// appear as fields (with the same type, only public) in the translet// These attributes are extracted from the xsl:output element. They also// TODO: use three-value variables for boolean values: true/false/defaultString _encoding;boolean _omitHeader;String _standalone;String _doctypePublic;String _doctypeSystem;String _cdata;boolean _indent;String _mediaType;String _indentamount;boolean _disabled;// Disables this output element (when other element has higher precedence)// Some global constantsString XML_VERSION;String HTML_VERSION;/** Displays the contents of this element (for debugging) *//** Disables this <xsl:output> element in case where there are some other ... */hasAttribute(...)lookupPrefix(...)transferAttribute(...)/** Scans the attribute list for the xsl:output instruction */Properties outputPropertiesString attribOutputKeys.VERSIONErrorMsg.INVALID_METHOD_IN_OUTPUTString canonicalEncodingOutputStreamWriter writernew OutputStreamWriter(...)convertMime2JavaEncoding(...)ErrorMsg.UNSUPPORTED_ENCODINGConstants.WARNINGOutputKeys.ENCODINGOutputKeys.OMIT_XML_DECLARATIONOutputKeys.STANDALONEOutputKeys.DOCTYPE_SYSTEMOutputKeys.DOCTYPE_PUBLICStringBuffer expandedNamesStringTokenizer tokensOutputKeys.CDATA_SECTION_ELEMENTSOutputKeys.INDENTOutputKeys.MEDIA_TYPE/** Compile code that passes the information in this <xsl:output> element ... */// Transfer attributes from previous xsl:output// Merge cdata-section-elements// addAttribute works as a setter if it already exists// Transfer non-standard attributes as well// Ask the parser if it wants this <xsl:output> element// Do nothing if other <xsl:output> element has higher precedence// Get the output version// Get the output method - "xml", "html", "text" or <qname> (but not ncname)// Get the output encoding - any value accepted here// Create a write to verify encoding support// Should the XML header be omitted - translate to true/false// Add 'standalone' decaration to output - use text as is// Get system/public identifiers for output DOCTYPE declaration// Names the elements of whose text contents should be output as CDATA// Make sure to store names in expanded form// Get the indent setting - only has effect for xml and html output// indent-amount: extension attribute of xsl:output//  Hack for supporting Old Namespace URI.// Get the MIME type for the output file// Implied properties// Set output properties in current stylesheet// Only update _version field if set and different from default// Only update _method field if "method" attribute used// Only update if _encoding field is "encoding" attribute used// Only update if "omit-xml-declaration" used and set to 'yes'// Set system/public doctype only if both are set// Add 'medye-type' decaration to output - if used// Compile code to set output indentation on/off//Compile code to set indent amount.// Forward to the translet any elements that should be output as CDATA// Cleanup - pop last translet reference off stackimport BasisLibraryboolean _isInSimpleNamedTemplate;/** True if this Param is declared in a simple named template. ... *//** Display variable as single string *//** Set the instruction for loading the value of this variable onto the ... */Instruction tmp/** Set the instruction for storing a value from the stack into this ... *//** Display variable in a full AST dump *//** Parse the contents of the <xsl:param> element. This method must read ... */Param paramlookupParam(...)int usint themErrorMsg.VARIABLE_REDEF_ERRcopyReferences(...)disable(...)/** Type-checks the parameter. The parameter type is determined by the ... */mapQNameToJavaName(...)BranchHandle ifBlocktranslateValue(...)storeInstruction(...)translateUnBox(...)POP(...)containsField(...)// Parse 'name' and 'select' attributes plus parameter contents// Add a ref to this param to its enclosing construct// Mark this as a global parameter// Check if a global variable with this name already exists...// ...and if it does we need to check import precedence// It is an error if the two have the same import precedence// Ignore this if previous definition has higher precedence// Add this variable if we have higher precedence// This element has no type (the parameter does, but the parameter// element itself does not)./* To fix bug 24518 related to setting parameters of the form ... *//* If simple named template then generate a conditional init of the ... */// Call addParameter() from this class// nobody uses the value// normal case// Cache the result of addParameter() in a local variable// Cache the result of addParameter() in a field/** Name of param being referenced. */isExternal(...)Closure variableClosureinInnerClass(...)getParentClosure(...)getInnerClassName(...)int clone// The method cloneIterator() also does resettingExpression _step;RelativeLocationPath _path;Type stype;boolean _orderNodes;boolean _axisMismatch;checkAxisMismatch(...)setAxis(...)enableNodeOrdering(...)/** This method is used to determine if this parent location path is a ... */Axis.ANCESTORAxis.ANCESTORORSELFAxis.DESCENDANTORSELFAxis.PARENTAxis.PRECEDINGAxis.PRECEDINGSIBLINGAxis.FOLLOWINGAxis.FOLLOWINGSIBLINGtranslateStep(...)LocalVariableGen stepTempExpression stpgetStep(...)int pathint step// Special case for '@*/following::*' expressions. The resulting// iterator is initialised with the parent's first child, and this// can cause duplicates in the output if the parent has more than// one attribute that matches the left step.// Compile path iterator// iterator on stack..../* If this pattern contains a sequence of descendant iterators we ... */isWildcard(...)InstructionHandle storeInst/* If _right is an ancestor pattern, backpatch _left false ... */import Symbolimport XMLSecurityManagerimport Attributesimport AttributesImplString XSL;String TRANSLET;// standard prefixLocator _locator;// extension prefixXSLTC _xsltc;XPathParser _xpathParser;// Reference to the compiler object.ArrayList<ErrorMsg> _errors;// Reference to the XPath parser.ArrayList<ErrorMsg> _warnings;// Contains all compilation errorsMap<String,String> _instructionClasses;// Contains all compilation warningsMap<String,String[]> _instructionAttrs;// Maps instructions to classesMap<String,QName> _qNames;// reqd and opt attrsMap<String,Map<String,QName>> _namespaces;QName _useAttributeSets;QName _excludeResultPrefixes;QName _extensionElementPrefixes;Map<String,Object> _variableScope;Stylesheet _currentStylesheet;SymbolTable _symbolTable;Output _output;// Maps QNames to syntax-tree nodesboolean _rootNamespaceDef;// Reference to the template being parsed.SyntaxTreeNode _root;// Used for validity checkString _target;int _currentImportPrecedence;boolean _overrideDefaultParser;new HashMap<String,QName>(...)new HashMap<String,Map<String,QName>>(...)new HashMap<String,String[]>(...)new ArrayList<ErrorMsg>(...)new SymbolTable(...)new XPathParser(...)initStdClasses(...)initInstructionAttrs(...)initExtClasses(...)initSymbolTable(...)mergeOutput(...)addVariableOrParam(...)Object existinggetStringRep(...)Stack<VariableBase> stacknew Stack<VariableBase>(...)int colonErrorMsg.NAMESPACE_UNDEF_ERRString defURIMap<String,QName> spaceString lexicalQName/** Create an instance of the <code>Stylesheet</code> class, ... */new Stylesheet(...)setSimplified(...)addPrefixMapping(...)ErrorMsg.NOT_STYLESHEET_ERRnew CompilerException(...)/** Instanciates a SAX2 parser and generate the AST from the input. */ErrorMsg.ILLEGAL_TEXT_NODE_ERRErrorMsg.JAXP_COMPILE_ERR/** Parses a stylesheet and builds the internal abstract syntax tree ... */CompilerException eString lastPropertysetXMLReaderPropertyIfSupport(...)XMLSecurityManager securityManagerXalanConstants.SECURITY_MANAGERXMLSecurityManager.LimitapiProperty(...)getLimitValueAsString(...)printEntityCountInfo(...)printWarning(...)String _PImedia;String _PItitle;String _PIcharset;/** Set the parameters to use to locate the correct <?xml-stylesheet ...?> ... *//** Extracts the DOM for the stylesheet. In the case of an embedded ... */ErrorMsg.MISSING_XSLT_URI_ERRfindStylesheet(...)ErrorMsg.MISSING_XSLT_TARGET_ERRloadExternalStylesheet(...)/** Find a Stylesheet element with a specific ID attribute value. ... */List<SyntaxTreeNode> children/** For embedded stylesheets: Load an external file with stylesheet */InputSource sourceSyntaxTreeNode externalinitAttrTable(...)/** Initialize the _instructionClasses map, which maps XSL element ... */initStdClass(...)initExtClass(...)/** Add primops and base functions to the symbol table. */MethodType I_VMethodType I_RMethodType I_SMethodType I_DMethodType R_IMethodType R_VMethodType R_RMethodType R_DMethodType R_OMethodType I_IMethodType D_OMethodType D_VMethodType D_SMethodType D_DMethodType A_VMethodType S_VMethodType S_SMethodType S_AMethodType S_DMethodType S_OMethodType B_OMethodType B_VMethodType B_BMethodType B_SMethodType D_XMethodType R_RRMethodType I_IIMethodType B_RRMethodType B_IIMethodType S_SSMethodType S_DSMethodType S_SRMethodType O_SOMethodType D_SSMethodType D_SDMethodType B_BBMethodType B_SSMethodType S_SDMethodType S_DSSMethodType S_SRRMethodType S_SSSaddPrimop(...)int _templateIndex;boolean versionIsOne;/** Creates a new node in the abstract syntax tree. This node can be ... */setQName(...)setLineNumber(...)setStylesheet(...)checkForSuperfluousAttributes(...)ErrorMsg.INTERNAL_ERRUnsupportedElement elementErrorMsg.UNSUPPORTED_XSL_ERRnew UnsupportedElement(...)setErrorMessage(...)ErrorMsg.UNSUPPORTED_EXT_ERRStylesheet sheetUnsupportedElement elemnew LiteralElement(...)/** checks the list of attributes against a list of allowed attributes ... */boolean isStylesheetString[] legalString attrQNamelegal.lengthErrorMsg.ILLEGAL_ATTRIBUTE_ERRsetWarningError(...)/** Parse an XPath expression: ... */parseTopLevel(...)String exp/** Parse an XPath pattern: ... *//** Parse an XPath expression or pattern using the generated XPathParser ... */Symbol resultnew XPathLexer(...)ErrorMsg.XPATH_PARSER_ERRSyntaxTreeNode.Dummy/** Returns true if there were any errors during compilation *//** ********************** ERROR HANDLING SECTION *********************** *//** Prints all compile-time errors */ErrorMsg.COMPILER_ERROR_KEY/** Prints all compile-time warnings */ErrorMsg.COMPILER_WARNING_KEY/** Common error/warning message handler */Constants.INTERNALConstants.UNSUPPORTEDStack<SyntaxTreeNode> _parentStack;/** ********************** SAX2 ContentHandler INTERFACE **************** */Map<String,String> _prefixMapping;/** SAX2: Receive notification of the beginning of a document. */new Stack<SyntaxTreeNode>(...)/** SAX2: Receive notification of the end of a document. *//** SAX2: Begin the scope of a prefix-URI Namespace mapping. ... *//** SAX2: End the scope of a prefix-URI Namespace mapping. ... *//** SAX2: Receive notification of the beginning of an element. ... */makeInstance(...)ErrorMsg.ELEMENT_PARSE_ERRcontainsValue(...)Constants.XSLT_URInew AttributesImpl(...)setPrefixMapping(...)declareExtensionPrefixes(...)/** SAX2: Receive notification of the end of an element. *//** SAX2: Receive notification of character data. */SyntaxTreeNode brolastChild(...)isTextElement(...)new Text(...)int stop/** SAX2: Receive notification of a processing instruction. ... */String hrefString charsetgetTokenValue(...)/** IGNORED - all ignorable whitespace is ignored *//** IGNORED - we do not have to do anything with skipped entities *//** Store the document locator to later retrieve line numbers of all ... *//** Get the line number, or zero ... *//* Copyright (c) 2015, 2017, Oracle and/or its affiliates. All rights reserved. */// parse and retrieve namespace// Get the namespace uri from the symbol table// Map the default NS if not already defined// Parse the input document and build the abstract syntax tree// Find the start of the stylesheet within the tree// Assume that this is a pure XSL stylesheet if there is not// <?xml-stylesheet ....?> processing instruction// Find the xsl:stylesheet or xsl:transform with this reference// Check if the location is URL or a local file/* Standard functions: implemented but not in this table concat(). ... */// The following functions are inlined// The following functions are implemented in the basis library// Extensions// Operators +, -, *, /, % defined on real types.// Operators +, -, * defined on integer types.// Operators / and % are not  defined on integers (may cause exception)// Operators <, <= >, >= defined on real types.// Operators <, <= >, >= defined on int types.// Operators <, <= >, >= defined on boolean types.// Operators 'and' and 'or'.// Unary minus.// Check if the element belongs in our namespace// Check if this is an XSLTC extension element// Check if this is an extension of some other XSLT processor// Ignore if special or if it has a prefix// Workaround for the TCK failure ErrorListener.errorTests.error001..// Get the textual representation of the expression (if any)// Use the default expression if none was found// Invoke the XPath parser// Get the textual representation of the pattern (if any)// Use the default pattern if none was found// Return a dummy pattern (which is an expression)// If this is the root element of the XML document we need to make sure// that it contains a definition of the XSL namespace URI// Extension elements and excluded elements have to be// handled at this point in order to correctly generate// Fallback elements from <xsl:fallback>s.// If this text occurs within an <xsl:text> element we append it// as-is to the existing text element// Ignore text nodes that occur directly under <xsl:stylesheet>// Add it as a regular text node otherwise// We only handle the <?xml-stylesheet ...?> PI// URI of stylesheet found// Media of stylesheet found// Title of stylesheet found// Charset of stylesheet found// Get the attributes from the processing instruction// Set the target to this PI's href if the parameters are// null or match the corresponding attributes of this PI./** Returns the type of a pattern, which is always a <code>NodeType</code>. ... *//** Translate this node into JVM bytecodes. Patterns are translated as ... *//** Returns the priority of this pattern (section 5.5 in the XSLT spec). */Expression _exp;/** The predicate's expression. */boolean _canOptimize;/** This flag indicates if optimizations are turned on. The ... */boolean _nthPositionFilter;/** Flag indicatig if the nth position optimization is on. It ... */boolean _nthDescendant;/** Flag indicatig if the nth position descendant is on. It ... */int _ptype;/** Cached node type of the expression that owns this predicate. *//** Name of the inner class. *//** List of variables in closure. */Closure _parentClosure;/** Reference to parent closure. *//** Cached value of method <code>getCompareValue()</code>. */Step _step;/** Initializes a predicate. *//** Set the parser for this expression. *//** Returns a boolean value indicating if the nth position optimization ... *//** Returns a boolean value indicating if the nth descendant optimization ... *//** Turns off all optimizations for this predicate. *//** Returns true if the expression in this predicate contains a call ... */Closure parentClosure/** Returns the node type of the expression owning this predicate. The ... */AbsoluteLocationPath pathVariableRefBase refgetExpression(...)/** Type check a predicate expression. If the type of the expression is ... */Type texpQName positionPositionCall positionCallnew PositionCall(...)new EqualityExpr(...)/** Create a new "Filter" class implementing ... */TestGenerator testGenFilterGenerator filterGennew FilterGenerator(...)new TestGenerator(...)addEmptyConstructor(...)/** Returns true if the predicate is a test for the existance of an ... *//** Method to see if we can optimise the predicate by using a specialised ... */getCompareValue(...)/** Returns the step in an expression of the form 'step = value'. ... */EqualityExpr expExpression leftExpression right/** Returns the value in an expression of the form 'step = value'. ... *//** Translate a predicate expression. This translation pushes ... */compileFilter(...)/** Translate a predicate expression. If non of the optimizations apply ... */isNodeValueTest(...)translateFilter(...)// way up in the tree// Add variable to parent closure as well// We need explicit type information for reference types - no good!// A result tree fragment should not be cast directly to a number type,// but rather to a boolean value, and then to a numer (0 or 1).// Ref. section 11.2 of the XSLT 1.0 spec// Numerical types will be converted to a position filter// Cast any numerical types to an integer// Nth position optimization. Expression must not depend on context// _nthDescendant optimization - only if _nthPositionFilter is on// Reset optimization flags// Otherwise, expand [e] to [position() = e]// All other types will be handled as boolean values// Store the dom in a local variable// Store the dom index in the test generator// Returned cached value if called more than once// Nothing to do if _exp is null// Ignore if not equality expression// Unwrap and set _step if appropriate// Nothing to to do if _exp is null// Ignore if not an equality expression// Return if left is literal string// Return if left is a variable reference of type string// Return if right is literal string// Return if left is a variable reference whose type is string// Compile auxiliary class for filter// Create new instance of filter// Find nearest closure implemented as an inner class// Use getfield if in an inner class// Use a load of instruction if in translet classAttributeValue _name;boolean _isLiteral;// name treated as AVT (7.1.3)// specified name is not AVTisLiteral(...)isXML11ValidNCName(...)ErrorMsg.INVALID_NCNAME_ERRErrorMsg.ILLEGAL_PI_ERRint processingInstructionLocalVariableGen nameValueint check// if the ncname is an AVT, then the ncname has to be checked at runtime if it is a valid ncname// store the name into a variable first so _name.translate only needs to be called once// call checkNCName if the name is an AVT// first arg to "attributes" call// load name value again// Push attribute name// 2nd arg// call "processingInstruction"boolean _typeChecked;hasPredicates(...)int gnameInstructionHandle restoreBranchHandle skipFalse//if (_name.equals("*")) _typeChecked = true; no wildcard allowed!// Type check all the predicates (e -> position() = e)// context node is on the stack// Push current node on the stack// Overwrite current node with matching node// If pattern not reduced then check kernel// Load the requested processing instruction name// Load the current processing instruction's name// Compare the two strings// Compile the expressions within the predicates// Backpatch true list and restore current iterator/node// Backpatch false list and restore current iterator/node// True list falls throughString _localname;String _prefix;String _stringRep;int _hashCode;// cached for speeddouble _value;hasReferenceArgs(...)Type typeLType typeRhasNodeSetArgs(...)Operators.LTOperators.GTOperators.LEOperators.GEhasNodeArgs(...)boolean tozeroCMP(...)ErrorMsg.ILLEGAL_RELAT_OP_ERRGE(...)LE(...)GT(...)LT(...)//bug fix # 2838, cast to reals if both are result tree fragments// If one is of reference type, then convert the other too// bug fix # 2838// Ensure that the node-set is the left argument// Promote nodes to node sets// Promote integer to doubles to have fewer compares// Promote result-trees to strings// In the node-boolean case, convert node to boolean first// Lookup the table of primops to find the best match// Call compare() from the BasisLibrary// TODO: optimize if one of the args is 0// must be backpatched// Get two copies of the argument on the stack/** Creates a new simple attribute value. ... */// The attributes value (literate string)./** Returns this attribute value's type (String). ... *//** Translate this attribute value into JVM bytecodes that pushes the ... */import ANEWARRAYimport NOPimport TABLESWITCHimport NodeSortRecordFactGeneratorimport NodeSortRecordGeneratorAttributeValue _order;AttributeValue _caseOrder;AttributeValue _dataType;AttributeValue _lang;// bug! see 26869, see XALANJ-2546ArrayList<VariableRefBase> _closureVars;boolean _needsSortRecordFactory;new ArrayList<VariableRefBase>(...)/** Parse the attributes of the xsl:sort element */ErrorMsg.STRAY_SORT_ERR/** Run type checks on the attributes; expression must return a string ... *//** These two methods are needed in the static methods that compile the ... *//** This method compiles code for the select expression for this ... *//** This method should not produce any code *//** Compiles code that instantiates a SortingIterator object. ... */LocalVariableGen nodesTempLocalVariableGen sortRecordFactoryTempint childrencompileSortRecordFactory(...)/** Compiles code that instantiates a NodeSortRecordFactory object which ... */String sortRecordClasscompileSortRecord(...)boolean needsSortRecordFactoryint nsortsString sortRecordFactoryClassLocalVariableGen sortOrderTempLocalVariableGen sortTypeTempLocalVariableGen sortLangTempLocalVariableGen sortCaseOrderTempArrayList<VariableRefBase> dupsSort sortsort._needsSortRecordFactorytranslateSortOrder(...)translateSortType(...)translateLang(...)translateCaseOrder(...)sort._closureVarsNodeSortRecordFactGenerator sortRecordFactorynew NodeSortRecordFactGenerator(...)MethodGenerator constructorMethodGenerator makeNodeSortRecordint ndups/** Create a new auxillary class extending NodeSortRecord. */NodeSortRecordGenerator sortRecordnew NodeSortRecordGenerator(...)MethodGenerator initcompileInit(...)MethodGenerator extractcompileExtract(...)setInnerClassName(...)/** Create a constructor for the new class. Updates the reference to the ... *//** Compiles a method that overloads NodeSortRecord.extractValueFromDOM() */CompareGenerator extractMethodnew CompareGenerator(...)int levelsInstructionHandle[] targetInstructionHandle tblswitchtranslateSelect(...)InstructionHandle defaultTarget// Parse the select expression (node string value if no expression)// Get the sort order; default is 'ascending'// Get the sort data type; default is text// Get the case order; default is language dependant// If the sort data-type is not set we use the natural data-type// of the data we will sort// empty// SortingIterator.SortingIterator(NodeIterator,NodeSortRecordFactory);// Get the current node iterator// apply-templates default// Compile the code for the NodeSortRecord producing class and pass// that as the last argument to the SortingIterator constructor.// Compile code that initializes the static _sortOrder// Initialize closure variables in sortRecordFactory// Discard duplicate variable references// Define a constructor for this class// Push all parameters onto the stack and called super.<init>()// Override the definition of makeNodeSortRecord()// Initialize closure in record class// Get field from factory class// Put field in record class// This generates a new class for handling this specific sort// Set the name of the inner class in this sort object// Call the constructor in the NodeSortRecord superclass// String NodeSortRecord.extractValueFromDOM(dom,node,level);// Values needed for the switch statement// Compile switch statement only if the key has multiple levels// Put the parameter to the swtich statement on the stack// Append the switch statement here later on// Append all the cases for the switch statment// Compile def. target for switch statement if key has multiple levels// Append the default target - it will _NEVER_ be reached/** This interface is used to plug external document loaders into XSLTC ... *//** Create a starts-with() call - two arguments, both strings */import ICONSTint _axis;/** This step's axis as defined in class Axis. */List<Predicate> _predicates;/** A vector of predicates (filters) defined on this step - may be null */boolean _hadPredicates;/** Some simple predicates can be handled by this class (and not by the ... */int _nodeType;/** Type of the node test. *//** Set the parser for this element and all child predicates */Predicate exp/** Define the axis (defined in Axis class) for this step *//** Get the axis (defined in Axis class) for this step *//** Returns the node-type for this step *//** Returns the vector containing all predicates for this step. *//** Returns 'true' if this step has a parent pattern. ... *//** Returns 'true' if this step has a parent location path. *//** Returns 'true' if this step has any predicates *//** Returns 'true' if this step is used within a predicate *//** True if this step is the abbreviated step '.' */NodeTest.ANODE/** True if this step is the abbreviated step '..' *//** Type check this step. The abbreviated steps '.' and '@attr' are ... */isAbbreviatedDot(...)hasParentLocationPath(...)hasParentPattern(...)Expression pred/** Translate a step by pushing the appropriate iterator onto the stack. ... */int starList<String> niNodeTest.ATTRIBUTEint iterNodeTest.ELEMENTint tyint nsTypeint nsDOM.RETURN_CURRENTParentLocationPath pathnew ParentLocationPath(...)step._parentDOM.RETURN_PARENTisNthDescendant(...)getPosType(...)/** Returns a string representation of this step. */getNames(...)// Save this value for later - important for testing for special// combinations of steps and patterns than can be optimised// Special case for '.'//   in the case where '.' has a context such as book/.//   or .[false()] we can not optimize the nodeset to a single node.// Type check all predicates (expressions applied to the step)// Return either Type.Node or Type.NodeSet// If it is an attribute, but not '@*', '@pre:*' or '@node()',// and has no parent// Put context node on stack if using Type.Node// Wrap the context node in a singleton iterator if not.// DOM.getAxisIterator(int axis);// Special case for /foo/*/bar// "ELEMENT" or "*" or "@*" or ".." or "@attr" with a parent.// DOM.getTypedAxisIterator(int axis, int type);// Get the typed iterator we're after// Special case for predicates that can use the NodeValueIterator// instead of an auxiliary class. Certain path/predicates pairs// are translated into a base path, on top of which we place a// node value iterator that tests for the desired value://   foo[@attr = 'str']  ->  foo/@attr + test(value='str')//   foo[bar = 'str']    ->  foo/bar + test(value='str')//   foo/bar[. = 'str']  ->  foo/bar + test(value='str')// If the predicate's Step is simply '.' we translate this Step// and place the node test on top of the resulting iterator// Otherwise we create a parent location path with this Step and// the predicates Step, and place the node test on top of that// Force re-parenting// Handle '//*[n]' expression// il.append(new ICONST(NodeTest.ELEMENT));// Handle 'elem[n]' expression// backwards branches, so we mustn't create the new object until// after we've created the suspect arguments to its constructor.// recursive call// create new CurrentNodeListIteratorimport IF_ICMPLTint SIMPLE_CONTEXT;int GENERAL_CONTEXT;boolean _isEpsilon;int _contextCase;NodeTest.GTYPEboolean noContextnextStepPatternSerial(...)analyzeCases(...)new Step(...)Type.ElementType.AttributeBranchHandle icmpint getETypetranslateKernel(...)LocalVariableGen matchLocalVariableGen stepIteratorTempint iteratorIndexLocalVariableGen iterLocalVariableGen nodeLocalVariableGen node2String iteratorNamegetNextFieldName(...)InstructionHandle iterStoreBranchHandle skipNextField iteratortranslateNoContext(...)translateSimpleContext(...)translateGeneralContext(...)// node()// Analyze context cases// Create an instance of Step to do the translation// Need to allow for long jumps here// Store matching node into a local variable// Push current iterator and current node on the stack// Create a new matching iterator using the matching node// Get the parent of the matching node// Start the iterator with the parent// Overwrite current iterator and current node// Translate the expression of the predicate// Store node on the stack into a local variable// Create a new local to store the iterator// Add a new private field if this is the main class// Compile the step created at type checking time// If in the main class update the field too// If class is not external, start of range for iter variable was// set above// Get the parent of the node on the stack// Initialize the iterator with the parent/* Inline loop: ... */// NodeIterator.ENDint argcimport BasicTypeimport FieldGenimport PUTSTATICnew HashMap<String,Mode>(...)new HashMap<String,Key>(...)/** XSLT version defined in the stylesheet. *//** Internal name of this stylesheet used as a key into the symbol table. */String _systemId;/** A URI that represents the system ID for this stylesheet. */Stylesheet _parentStylesheet;/** A reference to the parent stylesheet or null if topmost. */Vector<> _globals;/** Contains global variables and parameters defined in the stylesheet. */Boolean _hasLocalParams;/** Used to cache the result returned by <code>hasLocalParams()</code>. *//** The name of the class being generated. *//** Contains all templates defined in this stylesheet */Vector<> _allValidTemplates;/** Used to cache result of <code>getAllValidTemplates()</code>. Only ... */int _nextModeSerial;/** Counter to generate unique mode suffixes. */Map<String,Mode> _modes;/** Mapping between mode names and Mode instances. */Mode _defaultMode;/** A reference to the default Mode object. */Map<String,String> _extensions;/** Mapping between extension URIs and their prefixes. */Stylesheet _importedFrom;/** Reference to the stylesheet from which this stylesheet was ... */Stylesheet _includedFrom;Vector<> _includedStylesheets;/** Array of all the stylesheets imported or included from this one. *//** Import precendence for this stylesheet. */int _minimumDescendantPrecedence;/** Minimum precendence of any descendant stylesheet by inclusion or ... *//** Mapping between key names and Key objects (needed by Key/IdPattern). */SourceLoader _loader;/** A reference to the SourceLoader set by the user (a URIResolver ... */boolean _numberFormattingUsed;/** Flag indicating if format-number() is called. */boolean _simplified;/** Flag indicating if this is a simplified stylesheets. A template ... */boolean _multiDocument;/** Flag indicating if multi-document support is needed. */boolean _callsNodeset;/** Flag indicating if nodset() is called. */boolean _hasIdCall;/** Flag indicating if id() is called. */boolean _templateInlining;/** Set to true to enable template inlining optimization. ... */Output _lastOutputElement;/** A reference to the last xsl:output object found in the styleshet. */Properties _outputProperties;/** Output properties for this stylesheet. */int _outputMethod;/** Output method for this stylesheet (must be set to one of ... */int UNKNOWN_OUTPUT;// Output method constantsint XML_OUTPUT;int HTML_OUTPUT;int TEXT_OUTPUT;/** Return the output method *//** Check and set the output method */Stylesheet parentgetParentStylesheet(...)Stylesheet includedgetIncludedStylesheet(...)included._includedFrom/** Get the minimum of the precedence of this stylesheet, any stylesheet ... */int inclImpCountmakeStylesheetName(...)addIncludedStylesheet(...)nextStylesheetSerial(...)/** Returns true if this stylesheet has global vars or params. *//** Returns true if at least one template in the stylesheet has params ... */Vector<> templatesgetAllValidTemplates(...)hasParams(...)/** Adds a single prefix mapping to this syntax tree node. ... *//** Store extension URIs */String extensionPrefixesextensionURI(...)/** Parse the version and uri fields of the stylesheet and add an ... */addStylesheet(...)ErrorMsg.MULTIPLE_STYLESHEET_ERRnew Template(...)excludeURI(...)parseSimplified(...)parseOwnChildren(...)/** Parse all direct children of the <xsl:stylesheet/> element. */String excludePrefixespushExcludedNamespacesContext(...)popExcludedNamespacesContext(...)new Mode(...)compileApplyTemplates(...)/** Translate the stylesheet into JVM bytecodes. */FieldGen fgennew FieldGen(...)/** Add a static field */ClassGenerator classGennew ClassGenerator(...)addDOMField(...)compileTransform(...)Output outputenabled(...)checkOutputMethod(...)processModes(...)compileModes(...)compileStaticInitializer(...)/** Compile the namesArray, urisArray and typesArray into ... */MethodGenerator staticConstint charDataFieldCountgetCharacterDataCount(...)Vector<> namesIndexString[] namesArrayString[] urisArrayint[] typesArrayint namesArrayRefint urisArrayRefint typesArrayRefint namespaceArrayRefint charDataCountint toCharArrayaddStaticField(...)String encodedNamemarkChunkStart(...)markChunkEnd(...)BasicType.INTint nodeTypeString nsgetCharacterData(...)/** Compile the translet's constructor */AbstractTranslet.CURRENT_TRANSLET_VERSIONtranslateDefaultDFS(...)/** Compile a topLevel() method into the output class. This method is ... */MethodGenerator toplevelint setFilterVector<> varDepElementsVector<> whitespaceRulesresolveDependencies(...)TopLevelElement tlegetRules(...)translateRules(...)containsMethod(...)/** This method returns a vector with variables/params and keys in the ... */Vector<> resultboolean changedTopLevelElement vdeVector<> depgetDependencies(...)containsAll(...)ErrorMsg.CIRCULAR_VARIABLE_ERR/** Compile a buildKeys() method into the output class. Note that keys ... */MethodGenerator buildKeysstripAttributes(...)removeNOPs(...)/** Compile transform() into the output class. This method is used to ... */MethodGenerator transfString keySigcompileBuildKeys(...)int keyIdxIterator<SyntaxTreeNode> toplevelisMultiDocument(...)String topLevelSigcompileTopLevel(...)int topLevelIdxstartDocument(...)endDocument(...)/** Peephole optimization: Remove sequences of [ALOAD, POP]. */// do we need this wrapper ?????/* Copyright (c) 2007, 2016, Oracle and/or its affiliates. All rights reserved. *//* $Id: Stylesheet.java,v 1.5 2005/09/28 13:48:16 pvedula Exp $ *//* Fix for bug 23046, if the stylesheet is included, set the ... */// Set import precedence for this stylesheet// Set import precedence for all included stylesheets// Set import precedence for the stylesheet that imported this one// Set import precedence for the stylesheet that included this one// Start with precedence of current stylesheet as a basis.// Recursively examine all imported/included stylesheets.// Return true if this stylesheet includes/imports itself// Then check with any stylesheets that included/imported this one// Otherwise OK/* // Make sure the XSL version set in this stylesheet ... */// Add the implicit mapping of 'xml' to the XML namespace URI// Report and error if more than one stylesheet defined// Error: more that one stylesheet defined// If this is a simplified stylesheet we must create a template that// grabs the root node of the input doc ( <xsl:template match="/"/> ).// This template needs the current element (the one passed to this// method) as its only child, so the Template class has a special// method that handles this (parseSimplified()).// Parse the children of this node// Exclude XSLT uri// We have to scan the stylesheet element's top-level elements for// variables and/or parameters before we parse the other elements// Now go through all the other top-level elements...// All template code should be compiled as methods if the// <xsl:apply-imports/> element was ever used in this stylesheet// Define a new class by extending TRANSLET_CLASS// Compile transform() to initialize parameters, globals & output// and run the transformation// Translate all non-template elements and filter out all templates// xsl:template// Separate templates by modes//_templates.addElement(template);// xsl:attribute-set// save the element for later to pass to compileConstructor// Global variables and parameters are handled elsewhere.// Other top-level non-template elements are ignored. Literal// elements outside of templates will never be output.// Create fields of type char[] that will contain literal text from// the stylesheet.// Put the names array into the translet - used for dom/translet mapping// Put the namespace names array into the translet// Grab all the literal text in the stylesheet and put it in a char[]// Call the constructor in the AbstractTranslet superclass// Compile in code to set the output configuration from <xsl:output>// Set all the output settings files in the translet// Compile default decimal formatting symbols.// This is an implicit, nameless xsl:decimal-format top-level element.// Define and initialize 'current' variable with the root node// Create a new list containing variables/params + keys// Determine a partial order for the variables/params and keys// Translate vars/params and keys in the right order// Compile code for other top-level elements// xsl:decimal-format// xsl:strip/preserve-space// Translate all whitespace strip/preserve rules// Compute max locals + stack and add method to class/* DEBUG CODE - INGORE ... */// If nothing was changed in this pass then we have a circular ref// xsl:key/* Define the the method transform with the following signature: ... */// call resetPrefixIndex at the beginning of transform// Define and initialize current with the root node// push translet for PUTFIELD// prepare appropriate DOM implementation// DOMAdapter is on the stack// MultiDOM is on the stack//store to _dom variable// continue with globals initialization// Transfer the output settings to the output post-processor/* Compile buildKeys() method. Note that this method is not ... */// Look for top-level elements that need handling// Compile method for handling top-level elements// Get a reference to that method// Push all parameters on the stack and call topLevel()// The 'this' pointer// The DOM reference// The output handler// start document// push first arg for applyTemplates// push translet for GETFIELD to get DOM arg// push remaining 2 args// endDocument// Return templates if no imported/included stylesheets// Is returned value cached?//templates.addAll(_templates);// Cache results in top-level stylesheet onlynew HashMap<String,Stylesheet>(...)new HashMap<String,Vector<>>(...)Map<String,Stylesheet> _stylesheets;// These maps are used for all stylesheetsMap<String,Vector<>> _primops;Map<String,VariableBase> _variables;// These maps are used for some stylesheetsMap<String,Template> _templates;Map<String,AttributeSet> _attributeSets;Map<String,String> _aliases;Map<String,Integer> _excludedURI;Stack<Map<String,Integer>> _excludedURIStack;Map<String,DecimalFormatting> _decimalFormats;new HashMap<String,DecimalFormatting>(...)new HashMap<String,Template>(...)new HashMap<String,VariableBase>(...)VariableBase objnew HashMap<String,AttributeSet>(...)/** Add a primitive operator or function to the symbol table. To avoid ... */Vector<> methods/** Lookup a primitive operator or function in the symbol table by ... */int _nsCounter;/** This is used for xsl:attribute elements that have a "namespace" ... */SyntaxTreeNode _current;/** Use a namespace prefix to lookup a namespace URI *//** Adds an alias for a namespace prefix *//** Retrieves any alias for a given namespace prefix *//** Register a namespace URI so that it will not be declared in the output ... */Integer refcnt/** Exclude a series of namespaces given by a list of whitespace ... *//** Check if a namespace should not be declared in the output (unless used) *//** Turn of namespace declaration exclusion *//** Exclusion of namespaces by a stylesheet does not extend to any stylesheet ... *//* $Id: SymbolTable.java,v 1.5 2005/09/28 13:48:16 pvedula Exp $ */// The null-namespace cannot be excluded// Create a new map of exlcuded URIs if none exists// Register the namespace URIimport DUP_X1new AbsolutePathPattern(...)Parser _parser;// Reference to the AST parserSyntaxTreeNode _parent;// AST navigation pointers// Parent node// Stylesheet ancestor nodeList<SyntaxTreeNode> _contents;// Template ancestor nodeQName _qname;// Element description data// Child nodesint _line;// The element QNameAttributesImpl _attributes;// Source file line number// Attributes of this elementSyntaxTreeNode Dummy;// Sentinel - used to denote unrecognised syntaxt tree nodes.// Namespace declarationsint IndentIncrement;// These two are used for indenting nodes in the AST (debug output)...[] _spaces;/** Creates a new SyntaxTreeNode with a 'null' QName and no source file ... *//** Creates a new SyntaxTreeNode with a 'null' QName. ... *//** Creates a new SyntaxTreeNode with no source file line number reference. ... *//** Set the source file line number for this element ... *//** Get the source file line number for this element. If unavailable, lookup ... *//** Set the QName for the syntax tree node. ... *//** Set the QName for the SyntaxTreeNode ... *//** Set the attributes for this SyntaxTreeNode. ... *//** Returns a value for an attribute from the source element. ... *//** Returns a list of all attributes declared for the element represented by ... *//** Sets the prefix mapping for the namespaces that were declared in this ... *//** Returns a Map containing the prefix mappings that were declared ... *//** Returns any namespace URI that is in scope for a given prefix. This ... *//** Returns any namespace prefix that is mapped to a prefix in the current ... */String mapsTo/** Set this node's parser. The parser (the XSLT parser) gives this ... *//** Returns this node's XSLT parser. ... *//** Set this syntax tree node's parent node, if unset. For ... *//** Returns this syntax tree node's parent node. ... *//** Returns 'true' if this syntax tree node is the Sentinal node. ... *//** Get the import precedence of this element. The import precedence equals ... *//** Get the Stylesheet node that represents the <xsl:stylesheet/> element ... *//** Get the Template node that represents the <xsl:template/> element ... *//** Returns a reference to the XSLTC (XSLT compiler) in use. ... *//** Returns the XSLT parser's symbol table. ... *//** Parse the contents of this syntax tree nodes (child nodes, XPath ... *//** Parse all children of this syntax tree node. This method is normally ... */List<QName> localsQName varOrParamNameupdateScope(...)new ArrayList<QName>(...)removeVariable(...)/** Add a node to the current scope and return name of a variable or ... *//** Type check the children of this node. The type check phase may add ... *//** Call typeCheck() on all child syntax tree nodes. ... *//** Translate this abstract syntax tree node into JVM bytecodes. ... *//** Call translate() on all child syntax tree nodes. ... */unmapRegister(...)/** Return true if the node represents a simple RTF. ... *//** Return true if the node represents an adaptive RTF. ... *//** Return true if the node only produces Text content. ... */isAdaptiveRTF(...)isSimpleRTF(...)/** Utility method used by parameters and variables to store result trees ... */boolean isSimpleboolean isAdaptiveint rtfTypeDOM.SIMPLE_RTFDOM.ADAPTIVE_RTFDOM.TREE_RTFgetDOMClass(...)callsNodeset(...)/** Returns true if this expression/instruction depends on the context. By ... *//** Return true if any of the expressions/instructions in the contents of ... *//** Adds a child node to this syntax tree node. ... *//** Inserts the first child node of this syntax tree node. The existing ... *//** Removed a child node of this syntax tree node. ... *//** Returns a List containing all the child nodes of this node. ... *//** Tells you if this node has any child nodes. ... *//** Returns the number of children this node has. ... *//** Returns an Iterator of all child nodes of this node. ... *//** Returns a child node at a given position. ... *//** Returns this element's last child ... *//** Displays the contents of this syntax tree node (to stdout). ... */display(...)/** Set the indentation level for debug output. ... *//** Report an error to the parser. ... *//** Report a recoverable error to the parser. ... *//* Copyright (c) 2006, 2016, Oracle and/or its affiliates. All rights reserved. */// Initialise the output (default is 'null' for undefined)// First look up the prefix/uri mapping in our own map...// ... but if we can't find it there we ask our parent for the mapping// ... and then we return whatever URI we've got.// only create when needed// if variable or parameter, add it to scope// after the last element, remove any locals from scope// Call translate() on all child nodes// After translation, unmap any registers for any variables/parameters// that were declared in this scope. Performing this unmapping in the// same AST scope as the declaration deals with the problems of// references falling out-of-scope inside the for-each element.// (the cause of which being 'lazy' register allocation for references)// Create new instance of DOM class (with RTF_INITIAL_SIZE nodes)//int index = cpg.addMethodref(DOM_IMPL, "<init>", "(I)V");//il.append(new NEW(cpg.addClass(DOM_IMPL)));// Overwrite old handler with DOM handler// Call startDocument on the new handler// Instantiate result tree fragment// Call endDocument on the new handler// Check if we need to wrap the DOMImpl object in a DOMAdapter object.// DOMAdapter is not needed if the RTF is a simple RTF and the nodeset()// function is not used.// new com.sun.org.apache.xalan.internal.xsltc.dom.DOMAdapter(DOMImpl,String[]);/* Give the DOM adapter an empty type mapping if the nodeset ... */// Push name arrays on the stack// Initialized DOM adapter// Add DOM adapter to MultiDOM class by calling addDOMAdapter()// ignore mask returned by addDOMAdapternew Vector<Param>(...)QName _mode;// The name of the template (if any)Pattern _pattern;// Mode in which this template is instantiated.// Matching pattern defined for this template.// Matching priority of this template.// Position within stylesheet (prio. resolution)boolean _compiled;//make sure it is compiled only onceboolean _isSimpleNamedTemplate;// template is a template which only has a name but no match pattern.// True if this is a simple named template. A simple namedVector<Param> _parameters;// for simple named templates.// The list of parameters in this template. This is only used/** Compare this template to another. First checks priority, then position. */Template otherString matchString prioritygetTemplateIndex(...)resolveNamedTemplates(...)ErrorMsg.TEMPLATE_REDEF_ERR/** When the parser realises that it is dealign with a simplified stylesheet ... */NamedMethodGenerator namedMethodGensetLoadInstruction(...)loadParameter(...)setStoreInstruction(...)storeParameter(...)// Add the (named) template to the symbol table// Is this a simple named template?// set current template// clear template// bug fix #4433133, add a call to named template from applyTemplates// %OPT% Special handling for simple named templates.// Update load/store instructions to access Params from the stack/** A test sequence is a sequence of patterns that ... */int _kernelType;/** Integer code for the kernel type of this test sequence */Vector<> _patterns;/** Vector of all patterns in the test sequence. May include ... */Mode _mode;/** A reference to the Mode object. */Template _default;/** Default template for this test sequence */InstructionList _instructionList;/** Instruction list representing this test sequence. */InstructionHandle _start;/** Cached handle to avoid compiling more than once. *//** Creates a new test sequence given a set of patterns and a mode. *//** Returns a string representation of this test sequence. Notice ... */LocationPathPattern pattern/** Returns the instruction list for this test sequence *//** Return the highest priority for a pattern in this test ... *//** Returns the position of the highest priority pattern in ... *//** Reduce the patterns in this test sequence. Creates a new ... */Vector<> newPatterns/** Returns, by reference, the templates that are included in ... *//** Get the instruction handle to a template's code. This is ... *//** Returns pattern n in this test sequence *//** Compile the code for this test sequence. Compile patterns ... */InstructionHandle failgetTemplateHandle(...)InstructionList ilistInstructionList copyOfilistFlowList trueListgetTrueList(...)FlowList falseListgetFalseList(...)InstructionHandle gtmplInstructionHandle successaddInstructionList(...)copyAndRedirect(...)/* $Id: TestSeq.java,v 1.2.4.1 2005/09/12 11:31:38 pvedula Exp $ */// Reduce this pattern// Is this pattern fully reduced?// Ignore following patterns// Returned cached value if already compiled// If not patterns, then return handle for default template// Init handle to jump when all patterns failed// Compile all patterns in reverse order// Patterns expect current node on top of stack// Apply the test-code compiled for the pattern// Make a copy of the instruction list for backpatching// On success branch to the template code// Next pattern's 'fail' target is this pattern's first instruction// Append existing instruction list to the end of this one// Set current instruction list to be this oneString _text;boolean _escaping;boolean _textElement;/** Create a blank Text syntax tree node. *//** Create text syntax tree node. ... *//** Returns the text wrapped inside this node ... *//** Set the text for this node. Appends the given text to any already ... */LiteralElement elementString spaceint textLengthint escint characters/** Check whether this Text node can be stored in a char[] in the translet. ... *//** Generates code that loads the array that will contain the character ... */addCharacterData(...)String charDataFieldName// Turn off character escaping if so is wanted.// Call characters(String) or characters(char[],int,int), as// appropriate.// Restore character escaping setting to whatever it was.// Note: setEscaping(bool) returns the original (old) value// Magic number!  21845*3 == 65535.  BCEL uses a DataOutputStream to// serialize class files.  The Java run-time places a limit on the size// of String data written using a DataOutputStream - it cannot require// more than 64KB when represented as UTF-8.  The number of bytes// required to represent a Java string as UTF-8 cannot be greater// than three times the number of char's in the string, hence the// check for 21845.// The XSLTC object keeps track of character data// that is to be stored in char arrays.Vector<> _dependencies;/* List of dependencies with other variables, parameters or ... *//** Add a dependency with other top-level elements like ... *//** Get the list of dependencies with other top-level elements ... */Expression _filename;boolean _append;/** Displays the contents of this <xsltc:output> element. *//** Parse the contents of this <xsltc:output> element. The only attribute ... */String append/** Type checks the 'file' attribute (must be able to convert it to a str). *//** Compile code that opens the give file for output, dumps the contents of ... */int openint close/* $Id: TransletOutput.java,v 1.2.4.1 2005/09/05 09:19:44 pvedula Exp $ */// Get the output filename from the 'file' attribute// If the 'append' attribute is set to "yes" or "true",// the output is appended to the file.// Verify that the filename is in fact set// Save filename as an attribute value template// Save the current output handler on the stack// Create the new output handler (leave it on stack)// Overwrite current handler// Translate contents with substituted handler// Close the output handler (close file)// Restore old output handler from stackNEG(...)Expression _pathExpr;Expression _rest;boolean _reverse;...[] _components;// linearization for top level UnionPathExprsVector<> componentsflatten(...)new Expression[]int axisisReverse(...)_components.length// find all expressions in this Union// Put attribute iterators first// Check if the union contains a reverse iterator// No need to reverse anything if another expression lies on top of this// Create the UnionIterator and leave it on the stack// Add the various iterators to the UnionIterator// Order the iterator only if strictly neededExpression _entity;Type entity// Feck the this pointer on the stack...// ...then the entity name...// ...to get the URI from the DOM object.QName _variableName;VariableRefBase _ref;ErrorMsg.VARIABLE_UNDEF_ERRVariableBase reflookupVariable(...)lookupName(...)new VariableRef(...)new ParameterRef(...)// At this point the AST is already built and we should be able to// find any declared global variable or parameter// If in a top-level element, create dependency to the referenced varVector<> _fallbacks;ErrorMsg _message;boolean _isExtension;/** Basic consutrcor - stores element uri/prefix/localname *//** There are different categories of unsupported elements (believe it ... *//** Displays the contents of this element *//** Scan and process all fallback children of the unsupported element. */Fallback fallback/** Find any fallback in the descendant nodes; then activate & parse it */processFallbacks(...)/** Run type check on the fallback element (if any). *//** Translate the fallback element (if any). */int unsupportedElem/* $Id: UnsupportedElement.java,v 1.2.4.1 2005/09/05 09:26:51 pvedula Exp $ */// We only go into the else block in forward-compatibility mode, when// the unsupported element has no fallback.// If the unsupported element does not have any fallback child, then// at runtime, a runtime error should be raised when the unsupported// element is instantiated. Otherwise, no error is thrown.String ATTR_SET_NOT_FOUND;// Only error that can occur:Vector<> _sets;// Contains the names of all references attribute sets/** Constructur - define initial attribute sets to use */addAttributeSets(...)/** This method is made public to enable an AttributeSet object to merge ... *//** Do nada. *//** Generate a call to the method compiled for this attribute set */SymbolTable symbolTableAttributeSet attrslookupAttributeSet(...)String atrsErrorMsg.ATTRIBSET_UNDEF_ERR// Go through each attribute set and generate a method call// Get the attribute set name// Get the AttributeSet reference from the symbol table// Compile the call to the set's method if the set exists// Generate an error if the attribute set does not existboolean _isString;int setEscaping// Prefer to handle the value as a node; fall back to String, otherwise/** * ... */// Translate the contents.  If the value is a string, use the// translet.characters(String, TranslatOutputHandler) method.// Otherwise, the value is a node, and the// dom.characters(int node, TransletOutputHandler) method can dispatch// the string value of the node to the output handler more efficiently.import ACONST_NULLimport DCONST/** Parse the contents of the variable *//** Runs a type check on either the variable element body or the ... *//** This method is part of a little trick that is needed to use local ... */boolean createLocalmapRegister(...)// Add a ref to this var to its enclosing construct// Mark this as a global variable// Type check the 'select' expression if present// Type check the element contents otherwise// The return type is void as the variable element does not leave// anything on the JVM's stack. The '_type' global will be returned// by the references to this variable, and not by the variable itself.// This is only done for local variables that are actually used// Create a variable slot if none is allocated// Push the default value on the JVM's stack// 0 for node-id, integer and boolean// 0.0 for floating point numbers// and 'null' for anything else// Mark the store as the start of the live range of the variable// Don't generate code for unreferenced variables// Make sure that a variable instance is only compiled once// Compile variable value computation// Add a new local variable and store value// If the local is just being created, mark the store as the start// of its live range.  Note that it might have been created by// initializeVariables already, which would have set the start of// the live range already.// Global variables are store in class fields// Push a reference to "this" for putfield// Store the variable in the allocated fieldnew Vector<VariableRefBase>(...)String _escapedName;// The name of the variable.// The escaped qname of the variable.boolean _isLocal;// The type of this variable.LocalVariableGen _local;// True if the variable is local.Instruction _loadInstruction;// Reference to JVM variableInstruction _storeInstruction;// Instruction to load JVM variableString select;// Reference to variable expressionVector<VariableRefBase> _refs;// References to this variable (when local)// Textual repr. of variable expr.// Used to make sure parameter field is not added twice/** Disable this variable/parameter *//** Add a reference to this variable. Called by VariableRef when an ... *//** When a variable is overriden by another, e.g. via xsl:import, ... *//** Map this variable to a register *//** Remove the mapping of this variable to a register. ... */int releaseint removeDA/** Returns an instruction for loading the value of this variable onto ... *//** Returns an instruction for storing a value from the JVM stack ... *//** Returns the expression from this variable's select attribute (if any) *//** Returns the type of the variable *//** Returns the name of the variable or parameter as it will occur in the ... *//** Returns the escaped qname of the variable or parameter *//** Set the name of the variable or paremeter. Escape all special chars. *//** Returns the true if the variable is local *//** Parse the contents of the <xsl:decimal-format> element. */VariableBase other/** Compile the value of the variable, which is either in an expression in ... */int initCNIcompileResultTree(...)// TODO: namespace ?// Get the 'name attribute// Check whether variable/param of the same name is already in scope// Children must be parsed first -> static scoping// Compile expression is 'select' attribute if present// Create a CachedNodeListIterator for select expressions// in a variable or parameter.// If not, compile result tree from parameter body if present.// If neither are present then store empty string in variableimplementedAsMethod(...)// Fall-through for variables that are implemented as methodsVariableBase _variable;/** A reference to the associated variable. */Closure _closure;/** A reference to the enclosing expression/instruction for which a ... *//** Returns a reference to the associated variable *//** If this variable reference is in a top-level element like ... */_variable._ignore_variable._name/** Two variable references are deemed equal if they refer to the ... */(...)._variablethis._variable/** Returns a string representation of this variable reference on the ... */// Returned cached type if available// Find nearest closure to add a variable reference// Attempt to get the cached variable type// If that does not work we must force a type-check (this is normally// only needed for globals in included/imported stylesheets// Return the type of the referenced variable/** Type-check this when element. The test should always be type checked, ... *//** This method should never be called. An Otherwise object will explicitly ... */ErrorMsg.STRAY_WHEN_ERR// Type-check the test expression// Type-check the contents (if necessary)int USE_PREDICATE;// Three possible actions for the translet:int STRIP_SPACE;int PRESERVE_SPACE;int RULE_NONE;// The 3 different categories of strip/preserve rules (order important)int RULE_ELEMENT;int RULE_NAMESPACE;// priority 0int RULE_ALL;// priority -1/4String _elementList;// priority -1/2int _action;Whitespace$WhitespaceRule/** Auxillary class for encapsulating a single strip/preserve rule */String _element;// Should be replaced by NS type (int)int _type;// Should be replaced by node type (int)int _priority;/** Strip/preserve rule constructor *//** For sorting rules depending on priority *//** Parse the attributes of the xsl:strip/preserve-space element. ... */StringTokenizer listStringBuffer elements/** De-tokenize the elements listed in the 'elements' attribute and ... */Vector<> rulesnew WhitespaceRule(...)/** Scans through the rules vector and looks for a rule of higher ... */WhitespaceRule currentRulegetStrength(...)getElement(...)/** Orders a set or rules by priority, removes redundant rules and rules ... */int defaultActionboolean stripfindContradictingRule(...)/** Compiles the predicate method *//* private static void compileDebug(ClassGenerator classGen, ... */MethodGenerator stripSpaceint paramDomint paramCurrentint paramTypeBranchHandle[] stripnew BranchHandle[]BranchHandle[] preserveint sCountint pCountWhitespaceRule ruleint gnsint strcmpint elementTyperegisterElement(...)compileStripSpace(...)compilePreserveSpace(...)/** Takes a vector of WhitespaceRule objects and generates a predicate ... */prioritizeRules(...)compilePredicate(...)/** Sorts a range of rules with regard to PRIORITY only *//** Used with quicksort method above */WhitespaceRule xWhitespaceRule tmp/** Type-check contents/attributes - nothing to do... */// Determine the action (strip or preserve) for this rule// Get the namespace and element name for this rule// Determine the initial priority for this rule// Get the strip/preserve type; either "NS:EL", "NS:*" or "*"// Strip/preserve _all_ elements// Lowest priority// Strip/reserve elements within NS// Medium priority// Strip/preserve single element// Determine if this is an xsl:strip- or preserve-space element// Determine the import precedence// Get the list of elements to strip/preserve// Go through each element and instanciate strip/preserve-object// Get the next rule in the prioritized list// We only consider rules with higher priority/* See if there is a contradicting rule with higher priority. ... */// intentional fall-through// Sort all rules with regard to priority// Check if there are any "xsl:strip-space" elements at all.// If there are no xsl:strip elements we can ignore all xsl:preserve// elements and signal that all whitespaces should be preserved// Return with default action: PRESERVE_SPACE// Remove all rules that are contradicted by rules with higher priority// Remove this single rule if it has no purpose// Remove all following rules if this one overrides all// Skip to next rule (there might not be any)...// The rules vector could be empty if first rule has strength RULE_ALL// Now work backwards and strip away all rules that have the same// action as the default rule (no reason the check them at the end).// Signal that whitespace detection predicate must be used.// private boolean Translet.stripSpace(int type) - cannot be static// Traverse all strip/preserve rules// Get the next rule in the prioritised list// Returns the namespace for a node in the DOM// Handle elements="ns:*" type rule// Handle elements="ns:el" type rule// Create the QName for the element// Register the element.// Compare current node type with wanted element type// Get the core rules in prioritized order// The rules vector may be empty after prioritising// Now - create a predicate method and sequence through rules...// Return with the translets required action (// We don't return anything./** Parameter's name. *//** The escaped qname of the with-param. *//** Parameter's default value. */LocalVariableGen _domAdapter;/** Reference to JVM variable holding temporary result tree. */boolean _doParameterOptimization;/** %OPT% This is set to true when the WithParam is used in a CallTemplate ... *//** Returns the escaped qname of the parameter *//** Return the name of this WithParam. *//** Set the do parameter optimization flag *//** The contents of a <xsl:with-param> elements are either in the element's ... *//** Type-check either the select attribute or the element body, depending ... *//** Compile the value of the parameter, which is either in an expression in ... *//** This code generates a sequence of bytecodes that call the ... *//** Release the compiled result tree. */// Store result tree into local variable for releasing it later// If neither are present then store empty string in parameter slot// Translate the value and put it on the stack// Make name acceptable for use as field name in class// Load reference to the translet (method is in AbstractTranslet)// Load the name of the parameter// Generete the value of the parameter (use value in 'select' by def.)// Mark this parameter value is not being the default value// Pass the parameter to the template// cleanup stackunpackFromString(...)int YY_BUFFER_SIZE;int YY_F;int YY_NO_STATE;int YY_NOT_ACCEPT;int YY_START;int YY_END;int YY_NO_ANCHOR;int YY_BOL;int YY_EOF;int YYEOF;int last, ...;/** If symbol is not followed by '::' or '(', then treat it as a ... */newSymbol(...)sym.QNAMEyytext(...)/** If symbol is first token or if it follows any of the operators ... */sym.STARsym.ATSIGNsym.DCOLONsym.LPARENsym.LBRACKsym.COMMAsym.ANDsym.ORsym.MODsym.DIVsym.SLASHsym.DSLASHsym.VBARsym.PLUSsym.MINUSsym.EQsym.NEsym.LTsym.LEsym.GTsym.GEBufferedReader yy_reader;int yy_buffer_index;int yy_buffer_read;int yy_buffer_start;int yy_buffer_end;...[] yy_buffer;boolean yy_at_bol;int yy_lexical_state;boolean yy_eof_done;int YYINITIAL;...[] yy_state_dtrans;int next_readyy_buffer.lengthyy_double(...)boolean yy_last_was_cr;char[] newbufint YY_E_INTERNAL;int YY_E_MATCH;...[] yy_error_string;String lengthStringint sequenceLengthint sequenceIntegerint commaIndexString workStringint[][] res...[] yy_acpt;...[] yy_cmap;...[] yy_rmap;...[] yy_nxt;int yy_lookaheadint yy_anchorint yy_stateint yy_next_stateint yy_last_accept_stateboolean yy_initialint yy_this_acceptyy_mark_start(...)yy_mark_end(...)yy_advance(...)sym.EOFyy_move_end(...)yy_to_mark(...)sym.DOTsym.DOLLARsym.RPARENsym.RBRACKsym.INTdisambiguateAxisOrFunction(...)sym.IDdisambiguateOperator(...)sym.DDOTsym.REALsym.Literalsym.KEYsym.SELFsym.CHILDsym.TEXTsym.NODEsym.PARENTsym.ANCESTORsym.PATTERNsym.NAMESPACEsym.COMMENTsym.PRECEDINGsym.ATTRIBUTEsym.FOLLOWINGsym.DESCENDANTsym.EXPRESSIONsym.ANCESTORORSELFsym.PRECEDINGSIBLINGsym.FOLLOWINGSIBLINGsym.DESCENDANTORSELFsym.PIPARAMsym.PIyy_error(...)/* @author Jacek Ambroziak ... */// Peek in the input buffer without changing the internal state// Skip whitespace// If end of buffer, can't disambiguate :(// Can't disambiguate, so return as symbol// Return symbol if next token is '::' or '('// first token/* LS *//* PS *//* 0 *//* 1 *//* 2 *//* 3 *//* 4 *//* 5 *//* 6 *//* 7 *//* 8 *//* 9 *//* 10 *//* 11 *//* 12 *//* 13 *//* 14 *//* 15 *//* 16 *//* 17 *//* 18 *//* 19 *//* 20 *//* 21 *//* 22 *//* 23 *//* 24 *//* 25 *//* 26 *//* 27 *//* 28 *//* 29 *//* 30 *//* 31 *//* 32 *//* 33 *//* 34 *//* 35 *//* 36 *//* 37 *//* 38 *//* 39 *//* 40 *//* 41 *//* 42 *//* 43 *//* 44 *//* 45 *//* 46 *//* 47 *//* 48 *//* 49 *//* 50 *//* 51 *//* 52 *//* 53 *//* 54 *//* 55 *//* 56 *//* 57 *//* 58 *//* 59 *//* 60 *//* 61 *//* 62 *//* 63 *//* 64 *//* 65 *//* 66 *//* 67 *//* 68 *//* 69 *//* 70 *//* 71 *//* 72 *//* 73 *//* 74 *//* 75 *//* 76 *//* 77 *//* 78 *//* 79 *//* 80 *//* 81 *//* 82 *//* 83 *//* 84 *//* 85 *//* 86 *//* 87 *//* 88 *//* 89 *//* 90 *//* 91 *//* 92 *//* 93 *//* 94 *//* 95 *//* 96 *//* 97 *//* 98 *//* 99 *//* 100 *//* 101 *//* 102 *//* 103 *//* 104 *//* 105 *//* 106 *//* 107 *//* 108 *//* 109 *//* 110 *//* 111 *//* 112 *//* 113 *//* 114 *//* 115 *//* 116 *//* 117 *//* 118 *//* 119 *//* 120 *//* 121 *//* 122 *//* 123 *//* 124 *//* 125 *//* 126 *//* 127 *//* 128 *//* 129 *//* 130 *//* 131 *//* 132 *//* 133 *//* 134 *//* 135 *//* 136 *//* 137 *//* 138 *//* 139 *//* 140 *//* 141 *//* 142 *//* 143 *//* 144 *//* 145 *//* 146 *//* 147 *//* 148 *//* 149 *//* 150 *//* 151 *//* 152 *//* 153 *//* 154 *//* 155 *//* 156 *//* 157 *//* 158 *//* 159 *//* 160 *//* 161 *//* 162 *//* 163 *//* 164 *//* 165 *//* 166 *//* 167 *//* 168 *//* 169 *//* 170 *//* 171 *//* 172 *//* 173 *//* 174 *//* 175 *//* 176 *//* 177 *//* 178 *//* 179 *//* 180 *//* 181 *//* 182 *//* 183 *//* 184 *//* 185 *//* 186 *//* 187 *//* 188 *//* 189 *//* 190 *//* 191 *//* 192 *//* 193 *//* 194 *//* 195 *//* 196 *//* 197 *//* 198 *//* 199 *//* 200 *//* 201 *//* 202 *//* 203 *//* 204 *//* 205 *//* 206 *//* 207 *//* 208 *//* 209 *//* 210 *//* 211 *//* 212 *//* 213 *//* 214 *//* 215 *//* 216 *//* 217 *//* 218 *//* 219 *//* 220 *//* 221 *//* 222 *//* 223 *//* 224 *//* 225 *//* 226 *//* 227 *//* 228 *//* 229 *//* 230 *//* 231 *//* 232 *//* 233 *//* ignore white space. */import com.sun.java_cup.internal.runtime.*/** CUP v0.11b generated parser. ... */unpackFromStrings(...)/** Constructor which sets the default scanner. */...[] _production_table;/** Production table. *//** Access to production table. */...[] _action_table;/** Parse-action table. *//** Access to parse-action table. */...[] _reduce_table;/** <code>reduce_goto</code> table. *//** Access to <code>reduce_goto</code> table. */parser_actions action_obj;/** Instance of action encapsulation class. *//** Action encapsulation object initializer. */new parser_actions(...)/** Invoke a user supplied parse action. */parser_do_action(...)/** Indicates start state. *//** Indicates start production. *//** <code>EOF</code> Symbol index. *//** <code>error</code> Symbol index. */List<Expression> EmptyArgs;/** Used by function calls with no args. */VariableRef DummyVarRef;/** Reference to non-existing variable. *//** Reference to the Parser class. */String _expression;/** String representation of the expression being parsed. */int _lineNumber;/** Line number where this expression/pattern was declared. *//** Reference to the symbol table. */setCallsNodeset(...)setHasIdCall(...)/** This method is similar to findNodeType(int, Object) except that it ... */Axis.NAMESPACEnew StepPattern(...)boolean setPriorityStepPattern resultregisterNamespacePrefix(...)QName namespace_urinew ArrayList<Predicate>(...)new Predicate(...)new NamespaceUriCall(...)registerAttribute(...)/** Parse the expression passed to the current scanner. If this expression ... */IllegalCharException eErrorMsg.ILLEGAL_CHAR_ERR/** Lookup a variable or parameter in the symbol table given its name. ... */SyntaxTreeNode resultErrorMsg.SYNTAX_ERRParentLocationPath plpRelativeLocationPath newrlpinsertStep(...)addError(...)/** Returns true if the axis applies to elements only. The axes child, ... *//** Cup generated class to encapsulate user supplied action code. */XPathParser parser;/** Constructor */this.parser/** Method with the actual generated action code. */Symbol parser_resultSyntaxTreeNode start_valPattern lppPattern pPattern resultnew AlternativePattern(...)RelativePathPattern rppIdKeyPattern ikpnew ParentPattern(...)new AncestorPattern(...)String lIdKeyPattern resultnew IdPattern(...)String l1String l2new KeyPattern(...)new ProcessingInstructionPattern(...)RelativePathPattern resultObject ntget(...).valuecreateStepPattern(...)List<Predicate> ppStepPattern pipsetPredicates(...)Integer axisNodeTest.TEXTNodeTest.COMMENTNodeTest.PIQName qnInteger resultExpression pList<Expression> tempList<Expression> ppExpression eExpression resultExpression exExpression aeExpression oenew LogicalExpr(...)LogicalExpr.ORExpression eeLogicalExpr.ANDExpression renew RelationalExpr(...)Expression menew BinOpExpr(...)BinOpExpr.PLUSBinOpExpr.MINUSExpression ueBinOpExpr.TIMESBinOpExpr.DIVBinOpExpr.MODnew UnaryOpExpr(...)Expression peExpression restnew UnionPathExpr(...)Expression lpExpression fexpExpression rlpnew FilterParentPath(...)FilterParentPath fppisElementAxis(...)setDescendantAxis(...)Expression alpExpression stepExpression arlpnew AbsoluteLocationPath(...)Expression aalpStep rightList<Predicate> predicatesgetPredicates(...)RelativeLocationPath leftStep leftStep midParentLocationPath pplStep middleObject ntestfindNodeType(...)addPredicates(...)Expression abbrevInteger anExpression primarynew FilterExpr(...)Expression vrparser._symbolTableLong numnew RealExpr(...)new IntExpr(...)Double numExpression fcQName varNamenew UnresolvedRef(...)QName fnamenew CurrentCall(...)new NumberCall(...)XPathParser.EmptyArgsnew StringCall(...)new ConcatCall(...)new BooleanExpr(...)new NameCall(...)new GenerateIdCall(...)new StringLengthCall(...)new LastCall(...)new LocalNameCall(...)new FunctionCall(...)List<Expression> arglnew DocumentCall(...)new BooleanCall(...)new NotCall(...)new FormatNumberCall(...)new UnparsedEntityUriCall(...)new KeyCall(...)new CeilingCall(...)new RoundCall(...)new FloorCall(...)new ContainsCall(...)new StartsWithCall(...)new FunctionAvailableCall(...)new ElementAvailableCall(...)new LangCall(...)Constants.TRANSLET_URInew CastCall(...)QName vnameQName result/* Copyright (c) 2005, 2019, Oracle and/or its affiliates. All rights reserved. ... *//* call code in generated class */// "*"// Expand {uri}:* to *[namespace-uri() = 'uri'] - same for @*// Priority is set by hand if no other predicates exist// Set priority for case prefix:* and prefix:@* (no predicates)// *// Is it a local var or param ?/* Symbol object for return from actions *//* select the action based on the action number *//* . . . . . . . . . . . . . . . . . . . . */// $START ::= TopLevel EOF/* ACCEPT */// TopLevel ::= PATTERN Pattern// TopLevel ::= EXPRESSION Expr// Pattern ::= LocationPathPattern// Pattern ::= LocationPathPattern VBAR Pattern// LocationPathPattern ::= SLASH// LocationPathPattern ::= SLASH RelativePathPattern// LocationPathPattern ::= IdKeyPattern// LocationPathPattern ::= IdKeyPattern SLASH RelativePathPattern// LocationPathPattern ::= IdKeyPattern DSLASH RelativePathPattern// LocationPathPattern ::= DSLASH RelativePathPattern// LocationPathPattern ::= RelativePathPattern// IdKeyPattern ::= ID LPAREN Literal RPAREN// IdKeyPattern ::= KEY LPAREN Literal COMMA Literal RPAREN// ProcessingInstructionPattern ::= PIPARAM LPAREN Literal RPAREN// RelativePathPattern ::= StepPattern// RelativePathPattern ::= StepPattern SLASH RelativePathPattern// RelativePathPattern ::= StepPattern DSLASH RelativePathPattern// StepPattern ::= NodeTestPattern// StepPattern ::= NodeTestPattern Predicates// StepPattern ::= ProcessingInstructionPattern// StepPattern ::= ProcessingInstructionPattern Predicates// StepPattern ::= ChildOrAttributeAxisSpecifier NodeTestPattern// StepPattern ::= ChildOrAttributeAxisSpecifier NodeTestPattern Predicates// StepPattern ::= ChildOrAttributeAxisSpecifier ProcessingInstructionPattern// TODO: report error if axis is attribute// StepPattern ::= ChildOrAttributeAxisSpecifier ProcessingInstructionPattern Predicates// NodeTestPattern ::= NameTestPattern// NodeTestPattern ::= NODE// NodeTestPattern ::= TEXT// NodeTestPattern ::= COMMENT// NodeTestPattern ::= PI// NameTestPattern ::= STAR// NameTestPattern ::= QName// ChildOrAttributeAxisSpecifier ::= ATSIGN// ChildOrAttributeAxisSpecifier ::= CHILD DCOLON// ChildOrAttributeAxisSpecifier ::= ATTRIBUTE DCOLON// Predicates ::= Predicate// Predicates ::= Predicate Predicates// Predicate ::= LBRACK Expr RBRACK// Expr ::= OrExpr// OrExpr ::= AndExpr// OrExpr ::= OrExpr OR AndExpr// AndExpr ::= EqualityExpr// AndExpr ::= AndExpr AND EqualityExpr// EqualityExpr ::= RelationalExpr// EqualityExpr ::= EqualityExpr EQ RelationalExpr// EqualityExpr ::= EqualityExpr NE RelationalExpr// RelationalExpr ::= AdditiveExpr// RelationalExpr ::= RelationalExpr LT AdditiveExpr// RelationalExpr ::= RelationalExpr GT AdditiveExpr// RelationalExpr ::= RelationalExpr LE AdditiveExpr// RelationalExpr ::= RelationalExpr GE AdditiveExpr// AdditiveExpr ::= MultiplicativeExpr// AdditiveExpr ::= AdditiveExpr PLUS MultiplicativeExpr// AdditiveExpr ::= AdditiveExpr MINUS MultiplicativeExpr// MultiplicativeExpr ::= UnaryExpr// MultiplicativeExpr ::= MultiplicativeExpr STAR UnaryExpr// MultiplicativeExpr ::= MultiplicativeExpr DIV UnaryExpr// MultiplicativeExpr ::= MultiplicativeExpr MOD UnaryExpr// UnaryExpr ::= UnionExpr// UnaryExpr ::= MINUS UnaryExpr// UnionExpr ::= PathExpr// UnionExpr ::= PathExpr VBAR UnionExpr// PathExpr ::= LocationPath// PathExpr ::= FilterExpr// PathExpr ::= FilterExpr SLASH RelativeLocationPath// PathExpr ::= FilterExpr DSLASH RelativeLocationPath// Expand '//' into '/descendant-or-self::node()/' or// into /descendant-or-self::*/// LocationPath ::= RelativeLocationPath// LocationPath ::= AbsoluteLocationPath// RelativeLocationPath ::= Step// RelativeLocationPath ::= RelativeLocationPath SLASH Step// Remove './' from the middle// Remove '/.' from the end// RelativeLocationPath ::= AbbreviatedRelativeLocationPath// AbsoluteLocationPath ::= SLASH// AbsoluteLocationPath ::= SLASH RelativeLocationPath// AbsoluteLocationPath ::= AbbreviatedAbsoluteLocationPath// AbbreviatedRelativeLocationPath ::= RelativeLocationPath DSLASH Step// Compress './/child:E' into 'descendant::E' - if possible// Expand 'rlp//child::E' into 'rlp/descendant::E'// Expand './/step' -> 'descendant-or-self::*/step'// Expand 'rlp//step' -> 'rlp/descendant-or-self::*/step'// Expand 'rlp//step' -> 'rlp/descendant-or-self::node()/step'// AbbreviatedAbsoluteLocationPath ::= DSLASH RelativeLocationPath// Step ::= NodeTest// Step ::= NodeTest Predicates// Step ::= AxisSpecifier NodeTest Predicates// Step ::= AxisSpecifier NodeTest// Step ::= AbbreviatedStep// AxisSpecifier ::= AxisName DCOLON// AxisSpecifier ::= ATSIGN// AxisName ::= ANCESTOR// AxisName ::= ANCESTORORSELF// AxisName ::= ATTRIBUTE// AxisName ::= CHILD// AxisName ::= DESCENDANT// AxisName ::= DESCENDANTORSELF// AxisName ::= FOLLOWING// AxisName ::= FOLLOWINGSIBLING// AxisName ::= NAMESPACE// AxisName ::= PARENT// AxisName ::= PRECEDING// AxisName ::= PRECEDINGSIBLING// AxisName ::= SELF// AbbreviatedStep ::= DOT// AbbreviatedStep ::= DDOT// FilterExpr ::= PrimaryExpr// FilterExpr ::= PrimaryExpr Predicates// PrimaryExpr ::= VariableReference// PrimaryExpr ::= LPAREN Expr RPAREN// PrimaryExpr ::= Literal/* If the string appears to have the syntax of a QName, store ... */// PrimaryExpr ::= INT// PrimaryExpr ::= REAL// PrimaryExpr ::= FunctionCall// VariableReference ::= DOLLAR VariableName// An empty qname prefix for a variable or parameter reference// should map to the null namespace and not the default URI.// FunctionCall ::= FunctionName LPAREN RPAREN// FunctionCall ::= FunctionName LPAREN NonemptyArgumentList RPAREN// Special case for extension function nodeset()// implies MultiDOM// NonemptyArgumentList ::= Argument// NonemptyArgumentList ::= Argument COMMA NonemptyArgumentList// FunctionName ::= QName// VariableName ::= QName// Argument ::= Expr// NodeTest ::= NameTest// NodeTest ::= NODE// NodeTest ::= TEXT// NodeTest ::= COMMENT// NodeTest ::= PIPARAM LPAREN Literal RPAREN// NodeTest ::= PI// NameTest ::= STAR// NameTest ::= QName// QName ::= QNAME// QName ::= DIV// QName ::= MOD// QName ::= KEY// QName ::= ANCESTOR// QName ::= ANCESTORORSELF// QName ::= ATTRIBUTE// QName ::= CHILD// QName ::= DESCENDANT// QName ::= DESCENDANTORSELF// QName ::= FOLLOWING// QName ::= FOLLOWINGSIBLING// QName ::= NAMESPACE// QName ::= PARENT// QName ::= PRECEDING// QName ::= PRECEDINGSIBLING// QName ::= SELF// QName ::= ID/* . . . . . . */import BufferedOutputStreamimport JarEntryimport JarOutputStreamimport Manifest// A reference to the main stylesheet parser object.XMLReader _reader;// A reference to an external XMLReader (SAX parser) passed to us// A reference to an external SourceLoader (for use with include/import)// A reference to the stylesheet being compiled.int _modeSerial;// private int _variableSerial     = 1;// Counters used by various classes to generate unique names.int _stylesheetSerial;int _stepPatternSerial;int _helperClassSerial;int _attributeSetSerial;...[] _numberFieldIndexes;int _nextGType;// Name index tablesVector<> _namesIndex;// Next available element typeMap<String,Integer> _elements;// Index of all registered QNamesMap<String,Integer> _attributes;// Map of all registered elementsint _nextNSType;// Namespace index tables// Map of all registered attributesVector<> _namespaceIndex;// Next available namespace typeMap<String,Integer> _namespaces;// Index of all registered namespacesMap<String,Integer> _namespacePrefixes;// Map of all registered namespacesVector<> m_characterData;// All literal text in the stylesheet// Map of all registered namespace prefixesint JAR_OUTPUT;// These define the various methods for outputting the transletint BYTEARRAY_OUTPUT;int CLASSLOADER_OUTPUT;int BYTEARRAY_AND_FILE_OUTPUT;int BYTEARRAY_AND_JAR_OUTPUT;boolean _debug;// Compiler options (passed from command line or XSLTC client)String _jarFileName;// -x// -j <jar-file-name>String _packageName;// -o <class-name>File _destDir;// -p <package-name>int _outputType;// -d <directory-name>Vector<> _classes;// by defaultVector<> _bcelClasses;/** Set to true if template inlining is requested. Template ... */boolean _isSecureProcessing;/** State of the secure processing feature. */String _accessExternalStylesheet;/** protocols allowed for external references set by the stylesheet processing instruction, Import and Include element. */String _accessExternalDTD;/** protocols allowed for external DTD references in source file and/or stylesheet. */XMLSecurityManager _xmlSecurityManager;JdkXmlFeatures _xmlFeatures;ClassLoader _extensionClassLoader;/* Class loader reference that will be used for external extension functions loading *//** Extension function class loader variables */Map<String,Class<>> _externalExtensionFunctions;/** HashMap with the loaded classes *//** XSLTC compiler constructor */JdkXmlFeatures.XmlFeature.JDK_OVERRIDE_PARSERnew HashMap<String,Class<>>(...)/** Set the state of the secure processing feature. *//** Return the state of the secure processing feature. *//** Return the value of the specified feature ... *//** Return allowed protocols for accessing external stylesheet. */XalanConstants.JDK_EXTENSION_CLASSLOADER/** Set allowed protocols for accessing external stylesheet. *//** Only for user by the internal TrAX implementation. *//** Initializes the compiler to compile a new stylesheet *//* Function loads an external extension function. ... */Class<> loadedsetExternalExtensionFunctions(...)/* Returns unmodifiable view of HashMap with loaded external extension ... *//** Initializes the compiler to produce a new translet *//** Defines an external SourceLoader to provide the compiler with documents ... *//** Set a flag indicating if templates are to be inlined or not. The ... *//** Return the state of the template inlining feature. */setPIParameters(...)/** Compiles an XSL stylesheet pointed to by a URL ... *//** Compiles an XSL stylesheet passed in through an InputStream ... */String systemIdbaseName(...)createAST(...)/** Compiles a set of stylesheets pointed to by a Vector of URLs ... */Object urlEnumeration<> urls/** Returns an array of bytecode arrays generated by a compilation. ... */byte[][] result/** Compiles a stylesheet pointed to by a URL. The result is put in a ... */getBytecodes(...)/** Set the XMLReader to use for parsing the next input stylesheet ... *//** Get the XMLReader to use for parsing the next input stylesheet *//** Get a list of all compile error messages ... */getErrors(...)/** Get a list of all compile warning messages ... */getWarnings(...)/** Print all compile error messages to standard output *//** Print all compile warning messages to standard output *//** This method is called by the XPathParser when it encounters a call ... *//** Set the class name for the generated translet. This class name is ... */String baseString noextnoExtName(...)toJavaName(...)/** Get the class name for the generated translet. *//** Convert for Java class name of local system file name. ... *//** Generate an output File object to send the translet to */classFileName(...)/** Set the destination directory for the translet. ... *//** Set an optional package name for the translet and auxiliary classes *//** Set the name of an optional JAR-file to dump the translet and ... */String JAR_EXT/** Set the top-level stylesheet *//** Returns the top-level stylesheet *//** Registers an attribute and gives it a type so that it can be mapped to ... */Integer code/** Registers an element and gives it a type so that it can be mapped to ... *//** Registers a namespace prefix and gives it a type so that it can be mapped to ... *//** Registers a namespace and gives it a type so that it can be mapped to ... *//** Returns a unique name for every helper class needed to ... */File outFilegetOutputFile(...)String parentDirFile parentFileByteArrayOutputStream out/** File separators are converted to forward slashes for ZIP files. *//** Generate output JAR-file and packages */Manifest manifestnew Manifest(...)Attributes atrsgetMainAttributes(...)getEntries(...)Enumeration<> classesString nowAttributes.NameName dateAttrnew Name(...)File jarFileJarOutputStream josnew JarOutputStream(...)Attributes.Name.MANIFEST_VERSIONAttributes attrnew Attributes(...)putNextEntry(...)new JarEntry(...)/** Turn debugging messages on/off *//** Get current debugging message setting *//** Retrieve a string representation of the character data to be stored ... *//** Get the number of char[] arrays, thus far, that will be created to ... *//** Add literal text to char arrays that will be used to store character ... */StringBuffer currDataint newDataOffset/* Copyright (c) 2012, 2017, Oracle and/or its affiliates. All rights reserved. *//* Clear the external extension functions HashMap if extension class ... *///Check if the function is not loaded already//Return loaded class//_variableSerial     = 1;// Open input stream from URL and wrap inside InputSource// We have nothing else!!!// Reset globals in case we're called by compile(Vector v);// The systemId may not be set, so we'll have to check the URL// Set the translet class name if not already set// Ensure we have a non-empty class name at this point// default translet name// Get the root node of the abstract syntax tree// Compile the translet - this is where the work is done!// Create a Stylesheet element from the root node// Create AST under the Stylesheet element (parse & type-check)// Generate the bytecodes and output the translet class(es)// Class synchronization is needed for BCEL/* if (_debug) */// reset this here to be sure it is not re-used// Get the number of stylesheets (ie. URLs) in the vector// Return straight away if the vector is empty// Special handling needed if the URL count is one, becuase the// _className global must not be reset if it was set explicitly// Traverse all elements in the vector and compile// reset, so that new name will be computed// Register element (full QName)// namespace::ext2:ped2 will be made empty in TypedNamespaceIterator// create the manifest// create manifest// dump() closes it's output stream// Character data could take up to three-times as much space when// written to the class file as UTF-8.  The maximum size for a// constant is 65535/3.  If we exceed that,// (We really should use some "bin packing".)AttributeValueTemplate _namespace;/** Returns the name of the attribute *//** Displays the contents of the attribute *//** Parses the attribute's contents. Special care taken for namespaces. */boolean generatedList<SyntaxTreeNode> siblingsErrorMsg.ILLEGAL_ATTR_NAME_ERRErrorMsg.STRAY_ATTRIBUTE_ERR/* $Id: XslAttribute.java,v 1.2.4.1 2005/09/12 11:39:32 pvedula Exp $ */// Ignore attribute if preceeded by some other type of element// These three objects result in one or more attribute output// These objects _can_ result in one or more attribute// The output handler will generate an error if not (at runtime)// Report warning but do not ignore attribute// Get namespace from namespace attribute?// Get namespace from prefix in name attribute?// Common handling for namespaces:// Generate prefix if we have none/* TODO: The namespace URI must be passed to the parent ... */// Compile code that emits any needed namespace declaration// public void attribute(final String name, final String value)// if the qname is an AVT, then the qname has to be checked at runtime if it is a valid qname// call checkQName if the name is an AVT// Push attribute value - shortcut for literal strings// call "attribute"boolean _isLiteralName;AttributeValueTemplate _name;/** Displays the contents of the element */ErrorMsg.ILLEGAL_ELEM_NAME_ERRgetQNameSafe(...)StringBuffer newNamesetFirstElement(...)/** Run type check on element name & contents *//** This method is called when the name of the element is known at compile time. ... *//** At runtime the compilation of xsl:element results in code that: (i) ... */translateLiteral(...)/** Override this method to make sure that xsl:attributes are not ... */// Handle the 'name' attribute// Ignore the element if the QName is invalid// Get namespace attribute// Optimize compilation when name is known at compile time// Ignore the element if prefix is undeclared// Prepend prefix to local name// Optimize translation if element name is a literal// Push handler for call to endElement()// Push additional arguments// Invoke BasisLibrary.startXslElemCheckQName()/** CUP generated class containing symbol constants. */int Literal;/* terminals */int GE;int NAMESPACE;int SLASH;int PIPARAM;int FOLLOWINGSIBLING;int ATSIGN;int DSLASH;int LPAREN;int EXPRESSION;int INT;int CHILD;int STAR;int DESCENDANTORSELF;int RPAREN;int LT;int DDOT;int ID;int LE;int QNAME;int DESCENDANT;int PRECEDINGSIBLING;int error;int SELF;int VBAR;int ANCESTORORSELF;int PRECEDING;int EQ;int PATTERN;int LBRACK;int REAL;int ANCESTOR;int RBRACK;int DCOLON;int DOLLAR;int NE;int PARENT;int FOLLOWING;int KEY;int GT;int NODE;//----------------------------------------------------// The following code was generated by CUP v0.10j// Fri Feb 27 13:01:50 PST 2004int CURRENT_INDEX;int PARAM_START_INDEX;...[] argNames;...[] argTypes;import IFLEimport IF_ICMPGEimport IF_ICMPGTimport IF_ICMPLE/** Translates a real into an object of internal type <code>type</code>. The ... *//** Expects a boolean on the stack and pushes a string. If the value on the ... *//** Expects a boolean on the stack and pushes a real. The value "true" is ... *//** Expects a boolean on the stack and pushes a boxed boolean. ... *//** Translates an internal boolean into an external (Java) boolean. *//** Translates an external (Java) boolean into internal boolean. *//** Translates an object of this type to its boxed representation. *//** Translates an object of this type to its unboxed representation. */// Is Boolean <: clazz? I.e. clazz in { Boolean, Object }import ClassGenimport Parserimport Stylesheet/** The class that implements any class that inherits from ... */int TRANSLET_INDEX;int INVALID_INDEX;Instruction _aloadTranslet;// a  single instance cached here// --> can be moved to XSLTString _domClass;String _domClassSig;String _applyTemplatesSig;String _applyTemplatesSigForImport;Constants.TRANSLET_OUTPUT_SIGConstants.NODE_ITERATOR_SIGConstants.DOM_INTF_SIGConstants.NODE_FIELD_SIG/** Pretend this is the stylesheet class. Useful when compiling ... *//** Returns <tt>true</tt> or <tt>false</tt> depending on whether ... */Method[] methodsToAddgetGeneratedMethods(...)methodsToAdd.lengthint DOM_INDEX;int LEVEL_INDEX;int ITERATOR_INDEX;Instruction _iloadCurrent;Instruction _istoreCurrent;Instruction _aloadDom;Instruction _iloadLast;Instruction _aloadIterator;Instruction _astoreIterator;LocalVariableGen iterator//??? may not be used anymore// not available// These message should be read from a locale-specific resource bundle/* XSLTC compile-time error messages. ... */ErrorMsg.FILE_ACCESS_ERRErrorMsg.MISSING_ROOT_ERRErrorMsg.XSL_VERSION_ERRErrorMsg.SAX_PARSER_CONFIG_ERRErrorMsg.KEY_USE_ATTR_ERRErrorMsg.OUTPUT_VERSION_ERRErrorMsg.NO_TRANSLET_CLASS_ERRErrorMsg.NO_MAIN_TRANSLET_ERRErrorMsg.TRANSLET_CLASS_ERRErrorMsg.TRANSLET_OBJECT_ERRErrorMsg.ERROR_LISTENER_NULL_ERRErrorMsg.JAXP_UNKNOWN_SOURCE_ERRErrorMsg.JAXP_NO_SOURCE_ERRErrorMsg.JAXP_INVALID_ATTR_ERRErrorMsg.JAXP_INVALID_ATTR_VALUE_ERRErrorMsg.JAXP_SET_RESULT_ERRErrorMsg.JAXP_NO_TRANSLET_ERRErrorMsg.JAXP_NO_HANDLER_ERRErrorMsg.JAXP_NO_RESULT_ERRErrorMsg.JAXP_UNKNOWN_PROP_ERRErrorMsg.SAX2DOM_ADAPTER_ERRErrorMsg.XSLTC_SOURCE_ERRErrorMsg.ER_RESULT_NULLErrorMsg.JAXP_INVALID_SET_PARAM_VALUEErrorMsg.TYPE_CHECK_ERRErrorMsg.TYPE_CHECK_UNK_LOC_ERRErrorMsg.WARNING_PLUS_WRAPPED_MSGErrorMsg.WARNING_MSGErrorMsg.FATAL_ERR_PLUS_WRAPPED_MSGErrorMsg.FATAL_ERR_MSGErrorMsg.ERROR_PLUS_WRAPPED_MSGErrorMsg.ERROR_MSGErrorMsg.TRANSFORM_WITH_TRANSLET_STRErrorMsg.TRANSFORM_WITH_JAR_STRErrorMsg.COULD_NOT_CREATE_TRANS_FACTErrorMsg.TRANSLET_NAME_JAVA_CONFLICTErrorMsg.JAXP_GET_FEATURE_NULL_NAMEErrorMsg.JAXP_SET_FEATURE_NULL_NAMEErrorMsg.JAXP_UNSUPPORTED_FEATUREErrorMsg.JAXP_SECUREPROCESSING_FEATUREErrorMsg.OUTLINE_ERR_TRY_CATCHErrorMsg.OUTLINE_ERR_UNBALANCED_MARKERSErrorMsg.OUTLINE_ERR_DELETED_TARGETErrorMsg.OUTLINE_ERR_METHOD_TOO_BIGErrorMsg.DESERIALIZE_TRANSLET_ERR/* Note to translators:  The substitution text is the name of a ... *//* Note to translators:  The substitution text is the name of a variable ... *//* Note to translators:  The word "class" here refers to a Java class. ... *//* Note to translators:  The word "method" here refers to a Java method. ... *//* Note to translators:  The file or URI named in the substitution text ... *//* Note to translators:  This message is displayed when the URI ... *//* Note to translators: <xsl:stylesheet> and <xsl:transform> are ... *//* Note to translators:  The stylesheet contained a reference to a ... *//* Note to translators:  The Java function named in the stylesheet could ... *//* Note to translators:  This message indicates there was a syntactic ... *//* Note to translators:  An element in the stylesheet requires a ... *//* Note to translators:  This message indicates that a character not ... *//* Note to translators:  A processing instruction is a mark-up item in ... *//* Note to translators:  This message is reported if the stylesheet ... *//* Note to translators:  An attribute that wasn't recognized was ... *//* Note to translators:  "import" and "include" are keywords that should ... *//* Note to translators:  A result-tree fragment is a portion of a ... *//* Note to translators:  A name can be given to a particular style to be ... *//* Note to translators:  The stylesheet version named in the ... *//* Note to translators:  The definitions of one or more variables or ... *//* Note to translators:  The operator in an expresion with two operands was ... *//* Note to translators:  This message is produced if a reference to a ... *//* Note to translators:  "document()" is the name of function and must ... *//* Note to translators:  "<xsl:when>" and "<xsl:choose>" are keywords ... *//* Note to translators:  "<xsl:otherwise>" and "<xsl:choose>" are ... *//* Note to translators:  "<xsl:when>", "<xsl:otherwise>" and ... *//* Note to translators:  "<xsl:attribute-set>" and "name" are keywords ... *//* Note to translators:  An element in the stylesheet contained an ... *//* Note to translators:  The stylesheet tried to create an element with ... *//* Note to translators:  The stylesheet tried to create an attribute ... *//* Note to translators:  The children of the outermost element of a ... *//* Note to translators:  JAXP is an acronym for the Java API for XML ... *//* Note to translators:  The substitution text names the internal error ... *//* Note to translators:  The stylesheet contained an element that was ... *//* Note to translators:  The stylesheet referred to an extension to the ... *//* Note to translators:  The XML document given to XSLTC as a stylesheet ... *//* Note to translators:  XSLTC could not find the stylesheet document ... *//* Note to translators:  access to the stylesheet target is denied *//* Note to translators:  This message represents an internal error in ... *//* Note to translators:  The element named in the substitution text was ... *//* Note to translators:  "use", "<key>", "node", "node-set", "string" ... *//* Note to translators:  An XML document can specify the version of the ... *//* Note to translators:  The operator in a comparison operation was ... *//* Note to translators:  An attribute set defines as a set of XML ... *//* Note to translators:  The term "attribute value template" is a term ... *//* Note to translators:  ??? *//* Note to translators:  The substitution text refers to data types. ... *//* Note to translators:  "Templates" is a Java class name that should ... *//* Note to translators:  The substitution text is the name of a class. *//* Note to translators:  "ErrorListener" is a Java interface name that ... *//* Note to translators:  StreamSource, SAXSource and DOMSource are Java ... *//* Note to translators:  "Source" is a Java class name that should not ... *//* Note to translators:  The message indicates that XSLTC failed to ... *//* Note to translators:  "TransformerFactory" is a class name.  In this ... *//* Note to translators:  "setResult()" and "startDocument()" are Java ... *//* Note to translators:  "Transformer" is a Java interface name that ... *//* Note to translators:  The XML document that results from a ... *//* Note to translators:  "Result" is a Java interface name in this ... *//* Note to translators:  "Transformer" is a Java interface name.  The ... *//* Note to translators:  SAX2DOM is the name of a Java class that should ... *//* Note to translators:  "XSLTCSource.build()" is a Java method name. ... *//* Note to translators:  This message indicates that the value argument ... *//* Note to translators:  This message contains usage information for a ... *//* Note to translators:  "<xsl:sort>", "<xsl:for-each>" and ... *//* Note to translators:  The message indicates that the encoding ... *//* Note to translators:  The message indicates that the XPath expression ... *//* Note to translators:  The substitution text is the name of a Java ... *//* Note to translators:  "static" is the Java keyword.  The substitution ... *//* Note to translators:  An XPath expression was not of the type ... *//* Note to translators:  The substitution text is the name of a command- ... *//* Note to translators:  This message is used to indicate the severity ... *//* Note to translators:  The first substitution is the name of a class, ... *//* Note to translators:  "TransformerFactory" is the name of a Java ... *//* Note to translators:  This message is produced when the user ... *//* Note to translators:  The following message is used as a header. ... *//* Note to translators:  An attribute whose value is constrained to ... *//* Note to translators:  An attribute whose value is required to ... *//* Note to translators:  An attribute with an incorrect value was ... *//* Note to translators:  This message describes an internal error in the ... */import SyntaxTreeNodeString _code;String _message;String _url;...[] _params;boolean _isWarningError;Throwable _cause;String MULTIPLE_STYLESHEET_ERR;// Compiler error messagesString TEMPLATE_REDEF_ERR;String TEMPLATE_UNDEF_ERR;String VARIABLE_REDEF_ERR;String VARIABLE_UNDEF_ERR;String CLASS_NOT_FOUND_ERR;String METHOD_NOT_FOUND_ERR;String ARGUMENT_CONVERSION_ERR;String FILE_NOT_FOUND_ERR;String INVALID_URI_ERR;String FILE_ACCESS_ERR;String MISSING_ROOT_ERR;String NAMESPACE_UNDEF_ERR;String FUNCTION_RESOLVE_ERR;String NEED_LITERAL_ERR;String XPATH_PARSER_ERR;String REQUIRED_ATTR_ERR;String ILLEGAL_CHAR_ERR;String ILLEGAL_PI_ERR;String STRAY_ATTRIBUTE_ERR;String ILLEGAL_ATTRIBUTE_ERR;String CIRCULAR_INCLUDE_ERR;String RESULT_TREE_SORT_ERR;String SYMBOLS_REDEF_ERR;String XSL_VERSION_ERR;String CIRCULAR_VARIABLE_ERR;String ILLEGAL_BINARY_OP_ERR;String ILLEGAL_ARG_ERR;String DOCUMENT_ARG_ERR;String MISSING_WHEN_ERR;String MULTIPLE_OTHERWISE_ERR;String STRAY_OTHERWISE_ERR;String STRAY_WHEN_ERR;String WHEN_ELEMENT_ERR;String UNNAMED_ATTRIBSET_ERR;String ILLEGAL_CHILD_ERR;String ILLEGAL_ELEM_NAME_ERR;String ILLEGAL_ATTR_NAME_ERR;String ILLEGAL_TEXT_NODE_ERR;String SAX_PARSER_CONFIG_ERR;String INTERNAL_ERR;String UNSUPPORTED_XSL_ERR;String UNSUPPORTED_EXT_ERR;String MISSING_XSLT_URI_ERR;String MISSING_XSLT_TARGET_ERR;String ACCESSING_XSLT_TARGET_ERR;String NOT_IMPLEMENTED_ERR;String NOT_STYLESHEET_ERR;String ELEMENT_PARSE_ERR;String KEY_USE_ATTR_ERR;String OUTPUT_VERSION_ERR;String ILLEGAL_RELAT_OP_ERR;String ATTRIBSET_UNDEF_ERR;String ATTR_VAL_TEMPLATE_ERR;String UNKNOWN_SIG_TYPE_ERR;String DATA_CONVERSION_ERR;String NO_TRANSLET_CLASS_ERR;// JAXP/TrAX error messagesString NO_MAIN_TRANSLET_ERR;String TRANSLET_CLASS_ERR;String TRANSLET_OBJECT_ERR;String ERROR_LISTENER_NULL_ERR;String JAXP_UNKNOWN_SOURCE_ERR;String JAXP_NO_SOURCE_ERR;String JAXP_COMPILE_ERR;String JAXP_INVALID_ATTR_ERR;String JAXP_INVALID_ATTR_VALUE_ERR;String JAXP_SET_RESULT_ERR;String JAXP_NO_TRANSLET_ERR;String JAXP_NO_HANDLER_ERR;String JAXP_NO_RESULT_ERR;String JAXP_UNKNOWN_PROP_ERR;String SAX2DOM_ADAPTER_ERR;String XSLTC_SOURCE_ERR;String JAXP_INVALID_SET_PARAM_VALUE;String JAXP_SET_FEATURE_NULL_NAME;String JAXP_GET_FEATURE_NULL_NAME;String JAXP_UNSUPPORTED_FEATURE;String JAXP_SECUREPROCESSING_FEATURE;String COMPILE_STDIN_ERR;// Command-line error messagesString COMPILE_USAGE_STR;String TRANSFORM_USAGE_STR;String STRAY_SORT_ERR;// Recently added error messagesString UNSUPPORTED_ENCODING;String SYNTAX_ERR;String CONSTRUCTOR_NOT_FOUND;String NO_JAVA_FUNCT_THIS_REF;String TYPE_CHECK_ERR;String TYPE_CHECK_UNK_LOC_ERR;String ILLEGAL_CMDLINE_OPTION_ERR;String CMDLINE_OPT_MISSING_ARG_ERR;String WARNING_PLUS_WRAPPED_MSG;String WARNING_MSG;String FATAL_ERR_PLUS_WRAPPED_MSG;String FATAL_ERR_MSG;String ERROR_PLUS_WRAPPED_MSG;String ERROR_MSG;String TRANSFORM_WITH_TRANSLET_STR;String TRANSFORM_WITH_JAR_STR;String COULD_NOT_CREATE_TRANS_FACT;String TRANSLET_NAME_JAVA_CONFLICT;String INVALID_QNAME_ERR;String INVALID_NCNAME_ERR;String INVALID_METHOD_IN_OUTPUT;String OUTLINE_ERR_TRY_CATCH;String OUTLINE_ERR_UNBALANCED_MARKERS;String OUTLINE_ERR_DELETED_TARGET;String OUTLINE_ERR_METHOD_TOO_BIG;String DESERIALIZE_TRANSLET_ERR;ResourceBundle _bundle;// This array and the following 4 strings are read from that bundle.// All error messages are localized and are stored in resource bundles.String ERROR_MESSAGES_KEY;String COMPILER_ERROR_KEY;String COMPILER_WARNING_KEY;String RUNTIME_ERROR_KEY;/** This version of toString() uses the _params instance variable ... */getErrorMessage(...)formatLine(...)/** Return an ErrorMessages string corresponding to the _code ... */// ErrorListener.errorTests.error001.// to the ErrorListener. This is a workaround for the TCK failure// a warning by the compiler, but should be reported as an error// If the _isWarningError flag is true, the error is treated as/* $Id: ErrorMsg.java,v 1.2.4.1 2005/09/15 10:18:01 pvedula Exp $ *//** This class implements auxliary classes needed to compile ... *//** The index of the translet pointer within the execution of ... *//** Returns <tt>true</tt> since this class is external to the ... */import FlowList/** @see *//** Translates an integer into an object of internal type <code>type</code>. ... *//** Expects an integer on the stack and pushes a real. ... *//** Expects an integer on the stack and pushes its string value by calling ... *//** Expects an integer on the stack and pushes a 0 if its value is 0 and ... *//** Expects an integer on the stack and translates it to a non-synthesized ... *//** Expects an integer on the stack and pushes a boxed integer. ... *//** Translates an integer into the Java type denoted by <code>clazz</code>. ... */InstructionConst.INEG// Is Double <: clazz? I.e. clazz in { Double, Number, Object }/** Marks a class of errors in which XSLTC has reached some incorrect internal ... *//** Construct an <code>InternalError</code> with the specified error message. ... */import Visitor/** A special abstract dummy subclass of ... *//** Zero-argument constructor.  Sets the opcode to an invalid value and ... *//** {@link com.sun.org.apache.bcel.internal.generic.Visitor}s will know nothing about this ... *//** The number of JVM stack entries consumed by the instruction. ... *//** The number of JVM stack entries produced by the instruction. ... *//** Produce a copy of the instruction.  By default a ... *//** Dump instruction as byte code to stream out.  A {@link MarkerInstruction} ... */int _iteratorIndex;/** Get index of the register where the DOM is stored. *//** Set index where the reference to the DOM is stored. *//** Get index of the register where the current iterator is stored. *//** Set index of the register where the current iterator is stored. */import DLOADimport DSTOREimport FLOADimport FSTOREimport IfInstructionimport IndexedInstructionimport InstructionTargeterimport LLOADimport LSTOREnew HashMap<Pattern,InstructionList>(...)String START_ELEMENT_SIG;String END_ELEMENT_SIG;int HANDLER_INDEX;int MAX_METHOD_SIZE;int MAX_BRANCH_TARGET_OFFSET;int MIN_BRANCH_TARGET_OFFSET;int TARGET_METHOD_SIZE;int MINIMUM_OUTLINEABLE_CHUNK_SIZE;Instruction _astoreHandler;Instruction _aloadHandler;Instruction _astoreDom;Instruction _startElement;Instruction _endElement;Instruction _startDocument;Instruction _endDocument;Instruction _attribute;Instruction _uniqueAttribute;Instruction _namespace;Instruction _setStartNode;Instruction _reset;Instruction _nextNode;SlotAllocator _slotAllocator;boolean _allocatorInit;LocalVariableRegistry _localVariableRegistry;Map<Pattern,InstructionList> _preCompiled;/** A mapping between patterns and instruction lists used by ... */int startElementint endElementint attributeint uniqueAttributeint namespacenew SlotAllocator(...)getLocals(...)getLocalVariableRegistry(...)/** Allocates a local variable. If the slot allocator has already been ... */LocalVariableGen lvgregisterLocalVariable(...)allocateSlot(...)new LocalVariableRegistry(...)/** Keeps track of all local variables used in the method. ... */ArrayList<> _variables;/** <p>A <code>java.lang.ArrayList</code> of all ... */HashMap<> _nameToLVGMap;/** Maps a name to a {@link LocalVariableGen} *//** Registers a {@link org.apache.bcel.generic.LocalVariableGen} ... */int slotint registrySizeObject localsInSlotArrayList<> listOfLocalsInSlotregisterByName(...)/** <p>Find which {@link LocalVariableGen}, if any, is registered for a ... */offsetInLocalVariableGenRange(...)/** <p>Set up a mapping of the name of the specified ... */Object duplicateNameEntryArrayList<> sameNameList/** Remove the mapping from the name of the specified ... *//** <p>Given the name of a variable, finds a {@link LocalVariableGen} ... *//** <p>Gets all {@link LocalVariableGen} objects for this method.</p> ... */LocalVariableGen[] localsArrayList<> allVarsEverDeclaredint slotCountObject slotEntriesArrayList<> slotListIterator<> nameVarsPairsIterEntry<> nameVarsPairObject varsArrayList<> varsList/** Determines whether a particular variable is in use at a particular offset ... */InstructionHandle lvgStartInstructionHandle lvgEndreleaseSlot(...)removeByNameTracking(...)/** by default context node is the same as current node. MK437 */lookUpByName(...)int maxLocalsint prevLocalsLocalVariableGen[] localVarslocalVars.length/** Add a pre-compiled pattern to this mode. *//** Get the instruction list for a pre-compiled pattern. Used by ... */MethodGenerator$Chunk/** Used to keep track of an outlineable chunk of instructions in the ... */InstructionHandle m_start;/** {@link InstructionHandle} of the first instruction in the outlineable ... */InstructionHandle m_end;/** {@link org.apache.bcel.generic.InstructionHandle} of the first ... */int m_size;/** Number of bytes in the instructions contained in this outlineable ... *//** <p>Constructor for an outlineable {@link MethodGenerator.Chunk}.</p> ... *//** Determines whether this outlineable {@link MethodGenerator.Chunk} is ... */getChunkStart(...)getChunkEnd(...)/** Getter method for the start of this {@linke MethodGenerator.Chunk} ... *//** Getter method for the end of this {@link MethodGenerator.Chunk} ... *//** The size of this {@link MethodGenerator.Chunk} ... *//** Implements the <code>java.util.Comparable.compareTo(Object)</code> ... */getChunkSize(...)/** Find the outlineable chunks in this method that would be the best choices ... */Iterator<> instructionsArrayList<> candidateChunksArrayList<> currLevelChunksStack<> subChunkStackboolean openChunkAtCurrLevelboolean firstInstructionInstructionHandle currentHandleArrayList<> nestedSubChunksInstructionHandle chunkStartint chunkEndPositionint childChunkCountChunk[] childChunksnew Chunk[]ArrayList<> mergedChildChunksmergeAdjacentChunks(...)new Chunk(...)Chunk mergedChunkint mergedSize/** Merge adjacent sibling chunks to produce larger candidate chunks for ... */int[] adjacencyRunStartchunks.lengthint[] adjacencyRunLengthboolean[] chunkWasMergedint maximumRunOfChunksint startOfCurrentRunint numAdjacentRunsArrayList<> mergedChunksisAdjacentTo(...)int lengthOfRunint numToMergeint runint runStartint runEndboolean foundChunksToMergeint mergeStartint mergeEndint mergeSizeint trailingRunLength/** Breaks up the IL for this {@link MethodGenerator} into separate ... */ArrayList<> methodsOutlinedint currentMethodSizeint outlinedCountboolean moreMethodsOutlinedString originalMethodNameMethod[] methodsArrgetCandidateChunks(...)Chunk chunkToOutlineInstructionHandle lastInstoutline(...)getThisMethod(...)/** Given an outlineable chunk of code in the current {@link MethodGenerator} ... */int outlineChunkStartOffsetint outlineChunkEndOffsetInstructionList newILString argTypeNameint methodAttributesboolean isStaticMethodMethodGenerator outlinedMethodGenClassGenerator copyAreaCGnew ClassGenerator(...) { ... }MethodGenerator$1ConstantPoolGen copyAreaCPGint copyAreaFieldCountInstructionHandle limitInstructionList oldMethCopyInILInstructionList oldMethCopyOutILInstructionList newMethCopyInILInstructionList newMethCopyOutILInstructionHandle outlinedMethodCallSetupInstructionHandle outlinedMethodRefboolean chunkStartTargetMappingsPendingInstructionHandle pendingTargetMappingHandleInstructionHandle lastCopyHandleHashMap<> targetMapHashMap<> localVarMapHashMap<> revisedLocalVarStartHashMap<> revisedLocalVarEndIterator<> revisedLocalVarStartPairIterIterator<> revisedLocalVarEndPairIterInstructionList oldMethodILString[] exceptionsgetExceptions(...)getExceptionHandlers(...).lengthIndexedInstruction lviint oldLocalVarIndexLocalVariableGen oldLVGlookupRegisteredLocalVariable(...)LocalVariableGen newLVGboolean copyInLocalValueboolean copyOutLocalValueString varNameint newLocalVarIndexString varSignatureString copyAreaFieldNameint fieldRefInstructionHandle copyInLoadloadLocal(...)storeLocal(...)InstructionHandle copyOutStoreInstructionHandle newTargetInstructionTargeter[] targeterstargeters.lengthObject newLVGEntry<> lvgRangeStartPairInstructionHandle startInstEntry<> lvgRangeEndPairInstructionHandle endInstInstructionHandle lostTargetLocalVariableGen lvgTargeter/** Helper method to generate an instance of a subclass of ... */int m_totalChunks;/** Track the number of outlineable chunks seen. */int m_openChunks;/** Track the number of outlineable chunks started but not yet ended.  Used ... *//** Mark the end of the method's ... */OutlineableChunkStart.OUTLINEABLECHUNKSTART/** Mark the end of an outlineable chunk of code.  See ... */OutlineableChunkEnd.OUTLINEABLECHUNKEND/** <p>Get all {@link Method}s generated by this {@link MethodGenerator}. ... */Method[] generatedMethodsint instructionListSizeboolean ilChangedwidenConditionalBranchTargetOffsets(...)outlineChunks(...)/** <p>Rewrites branches to avoid the JVM limits of relative branch ... */int maxOffsetChangeIfInstruction oldIfInstBranchHandle oldIfHandleint relativeTargetOffsetInstructionHandle nextHandleIfInstruction invertedIfInstnegate(...)BranchHandle invertedIfHandleBranchHandle gotoHandleTargetLostException tle/* $Id: MethodGenerator.java,v 1.2.4.1 2005/09/05 11:16:47 pvedula Exp $ */// If the LocalVariableGen uses a slot index beyond any previously// encountered, expand the _variables, padding with intervening null// entries as required.// If the LocalVariableGen reuses a slot, make sure the entry// in _variables contains an ArrayList and add the newly// registered LocalVariableGen to the list.  If the entry in// _variables just contains null padding, store the// LocalVariableGen directly.// If this slot index was never used, _variables.get will return// null; if it was used once, it will return the LocalVariableGen;// more than once it will return an ArrayList of all the// LocalVariableGens for variables stored in that slot.  For each// LocalVariableGen, check whether its range includes the// specified offset, and return the first such encountered.// No local variable stored in the specified slot at the specified// If no start handle is recorded for the LocalVariableGen, it is// assumed to be in use from the beginning of the method.// If no end handle is recorded for the LocalVariableGen, it is assumed// to be in use to the end of the method.// Does the range of the instruction include the specified offset?// Note that the InstructionHandle.getPosition method returns the// offset of the beginning of an instruction.  A LocalVariableGen's// range includes the end instruction itself, so that instruction's// length must be taken into consideration in computing whether the// varible is in range at a particular offset.// Get the current number of local variable slots// Get numer of actual variables// We want at least 5 local variable slots (for parameters)// Scan instructions in the method, keeping track of the nesting level// of outlineable chunks.// currLevelChunks//     keeps track of the child chunks of a chunk.  For each chunk,//     there will be a pair of entries:  the InstructionHandles for the//     start and for the end of the chunk// subChunkStack//     a stack containing the partially accumulated currLevelChunks for//     each chunk that's still open at the current position in the//     InstructionList.// candidateChunks//     the list of chunks which have been accepted as candidates chunks//     for outlining// Get the next instruction.  The loop will perform one extra// iteration after it reaches the end of the InstructionList, with// currentHandle set to null.// At the first iteration, create a chunk representing all the// code in the method.  This is done just to simplify the logic -// this chunk can never be outlined because it will be too big.// Found a new chunk// If last MarkerInstruction encountered was an// OutlineableChunkStart, this represents the first chunk// nested within that previous chunk - push the list of chunks// from the outer level onto the stack// Close off an open chunk// If the last MarkerInstruction encountered was an// OutlineableChunkEnd, it means that the current instruction// marks the end of a chunk that contained child chunks.// Those children might need to be examined below in case they// are better candidates for outlining than the current chunk.// Get the handle for the start of this chunk (the last entry// in currLevelChunks)// Two ranges of chunk size to consider:// 1. [0,TARGET_METHOD_SIZE]//      Keep this chunk in consideration as a candidate,//      and ignore its subchunks, if any - there's nothing to be//      gained by outlining both the current chunk and its//      children!// 2. (TARGET_METHOD_SIZE,+infinity)//      Ignore this chunk - it's too big.  Add its subchunks//      as candidates, after merging adjacent chunks to produce//      chunks that are as large as possible// Gather all the child chunks of the current chunk// Merge adjacent siblings// Add chunks that mean minimum size requirements// to the list of candidate chunks for outlining// Drop the chunk which was too big// currLevelChunks contains pairs of InstructionHandles.  If// its size is an odd number, the loop has encountered the// start of a chunk at this level, but not its end.// Loop through chunks, and record in adjacencyRunStart where each// run of adjacent chunks begins and how many are in that run.  For// example, given chunks A B C D E F, if A is adjacent to B, but not// to C, and C, D, E and F are all adjacent,//   adjacencyRunStart[0] == 0; adjacencyRunLength[0] == 2//   adjacencyRunStart[1] == 2; adjacencyRunLength[1] == 4// Track the longest run of chunks found// Try merging adjacent chunks to come up with better sized chunks for// outlining.  This algorithm is not optimal, but it should be// reasonably fast.  Consider an example like this, where four chunks// of the sizes specified in brackets are adjacent.  The best way of// combining these chunks would be to merge the first pair and merge// the last three to form two chunks, but the algorithm will merge the// three in the middle instead, leaving three chunks in all.//    [25000] [25000] [20000] [1000] [20000]// Start by trying to merge the maximum number of adjacent chunks, and// work down from there.// Look at each run of adjacent chunks// Within the current run of adjacent chunks, look at all// "subruns" of length numToMerge, until we run out or find// a subrun that can be merged.// Find out how big the subrun is// If the current subrun is small enough to outline,// merge it, and split the remaining chunks in the run// Adjust the length of the current run of adjacent// chunks to end at the newly merged chunk...// and any chunks that follow the newly merged chunk// in the current run of adjacent chunks form another// new run of adjacent chunks// Make a final pass for any chunk that wasn't merged with a sibling// and include it in the list of chunks after merging.// Special handling for initialization methods.  No other methods can// include the less than and greater than characters in their names,// so we munge the names here.// Loop until the original method comes in under the JVM limit or// the loop was unable to outline any more methods// Get all the best candidates for outlining, and sort them in// ascending order of size// Loop over the candidates for outlining, from the largest to the// smallest and outline them one at a time, until the loop has// outlined all or the original method comes in under the JVM// limit on the size of a method.// Check the size of the method now// Outlining failed to reduce the size of the current method// sufficiently.  Throw an internal error.// We're not equipped to deal with exception handlers yet.  Bail out!// Create new outlined method with signature://   private final outlinedMethodName(CopyLocals copyLocals);// CopyLocals is an object that is used to copy-in/copy-out local// variables that are used by the outlined method.   Only locals whose// value is potentially set or referenced outside the range of the// chunk that is being outlined will be represented in CopyLocals.  The// type of the variable for copying local variables is actually// generated to be unique - it is not named CopyLocals.// The outlined method never needs to be referenced outside of this// class, and will never be overridden, so we mark it private final.// Create class for copying local variables to the outlined method.// The fields the class will need to contain will be determined as the// code in the outlineable chunk is examined.// Number of fields in the copy class// The handle for the instruction after the last one to be outlined.// Note that this should never end up being null.  An outlineable chunk// won't contain a RETURN instruction or other branch out of the chunk,// and the JVM specification prohibits code in a method from just// "falling off the end" so this should always point to a valid handle.// InstructionLists for copying values into and out of an instance of// CopyLocals://      oldMethCoypInIL  - from locals in old method into an instance//                         of the CopyLocals class (oldMethCopyInIL)//      oldMethCopyOutIL - from CopyLocals back into locals in the old//                         method//      newMethCopyInIL  - from CopyLocals into locals in the new//      newMethCopyOutIL - from locals in new method into the instance//                         of the CopyLocals class// Allocate instance of class in which we'll copy in or copy out locals// and make two copies:  last copy is used to invoke constructor;// other two are used for references to fields in the CopyLocals object// Generate code to invoke the new outlined method, and place the code// on oldMethCopyOutIL// Used to keep track of the first in a sequence of// OutlineableChunkStart instructions// Used to keep track of the last instruction that was copied// Keeps track of the mapping from instruction handles in the old// method to instruction handles in the outlined method.  Only need// to track instructions that are targeted by something else in the// generated BCEL// Keeps track of the mapping from local variables in the old method// to local variables in the outlined method.// Pass 1: Make copies of all instructions, append them to the new list// and associate old instruction references with the new ones, i.e.,// a 1:1 mapping.  The special marker instructions are not copied.// Also, identify local variables whose values need to be copied into or// out of the new outlined method, and builds up targetMap and// localVarMap as described above.  The code identifies those local// variables first so that they can have fixed slots in the stack// frame for the outlined method assigned them ahead of all those// variables that don't need to exist for the entirety of the outlined// method invocation.// MarkerInstructions are not copied, so if something else targets// one, the targetMap will point to the nearest copied sibling// InstructionHandle:  for an OutlineableChunkEnd, the nearest// preceding sibling; for an OutlineableChunkStart, the nearest// following sibling.// Copy the instruction and append it to the outlined method's// InstructionList.// For any instruction that touches a local variable,// check whether the local variable's value needs to be// copied into or out of the outlined method.  If so,// generate the code to perform the necessary copying, and// use localVarMap to map the variable in the original// method to the variable in the new method.// Has the code already mapped this local variable to a// local in the new method?// Determine whether the local variable needs to be// copied into or out of the outlined by checking// whether the range of instructions in which the// variable is accessible is outside the range of// instructions in the outlineable chunk.// Special case a chunk start offset of zero:  a local// variable live at that position must be a method// parameter, so the code doesn't need to check whether// the variable is live before that point; being live// at offset zero is sufficient to know that the value// must be copied in to the outlined method.// For any variable that needs to be copied into or out// of the outlined method, create a field in the// CopyLocals class, and generate the necessary code for// copying the value.// Record the mapping from the old local to the new// Generate code for the old method to store the// value of the local into the correct field in// CopyLocals prior to invocation of the// outlined method.// If the end of the live range of the old// variable was in the middle of the outlined// chunk.  Make the load of its value the new// end of its range.// Generate code for start of the outlined// method to copy the value from a field in// CopyLocals to the new local in the outlined// method// Generate code for the end of the outlined// method to copy the value from the new local// variable into a field in CopyLocals// Generate code to copy the value from a field// in CopyLocals into a local in the original// method following invocation of the outlined// If the start of the live range of the old// chunk.  Make this store into it the new start// of its range.// If this is the first instruction copied following a sequence// of OutlineableChunkStart instructions, indicate that the// sequence of old instruction all map to this newly created// instruction// Pass 2: Walk old and new instruction lists, updating branch targets// and local variable references in the new list// i == old instruction; c == copied instruction// New target must be in targetMap// Handle LOOKUPSWITCH or TABLESWITCH which may have many// target instructions// map the location of the variable in the original// method to its location in the new method.// Create new variable based on old variable - use same// name and type, but we will let the variable be active// for the entire outlined method.// LocalVariableGen oldLocal = oldLocals[oldLocalVarIndex];// The old variable's live range was wholly contained in// the outlined chunk.  There should no longer be stores// of values into it or loads of its value, so we can just// mark its live range as the reference to the outlined// If the old instruction marks the end of the range of a local// variable, make sure that any slots on the stack reserved for// local variables are made available for reuse by calling// MethodGenerator.removeLocalVariable// If the current instruction in the original list was a marker,// it wasn't copied, so don't advance through the list of copied// instructions yet.// POP the reference to the CopyLocals object from the stack// Now that the generation of the outlined code is complete, update// the old local variables with new start and end ranges, as required.// Assemble the instruction lists so that the old method invokes the// new outlined method// Insert the copying code into the outlined method// Discard instructions in outlineable chunk from old method// If there were still references to old instructions lingering,// clean those up.  The only instructions targetting the deleted// instructions should have been part of the chunk that was just// deleted, except that instructions might branch to the start of// the outlined chunk; similarly, all the live ranges of local// variables should have been adjusted, except for unreferenced// variables.// In the case of any lingering variable references,// just make the live range point to the outlined// function reference.  Such variables should be unused// anyway.// Make a copy for the new method of all exceptions that might be thrown// m_chunkTree.markChunkStart();// m_chunkTree.markChunkEnd();// Need to look for any branch target offsets that exceed the range// [-32768,32767]// If any branch instructions needed widening, recompute the size// of the byte code for the method// Loop through all the instructions, finding those that would be// affected by inserting new instructions in the InstructionList, and// calculating the maximum amount by which the relative offset between// two instructions could possibly change.// In part this loop duplicates code in// org.apache.bcel.generic.InstructionList.setPosition(), which does// this to determine whether to use 16-bit or 32-bit offsets for GOTO// and JSR instructions.  Ideally, that method would do the same for// conditional branch instructions, but it doesn't, so we duplicate the// processing here.// Instructions that may have 16-bit or 32-bit branch targets.// The size of the branch offset might increase by two bytes.// Instructions that contain padding for alignment purposes// Up to three bytes of padding might be needed.  For greater// accuracy, we should be able to discount any padding already// added to these instructions by InstructionList.setPosition(),// their APIs do not expose that information.// Instructions that might be rewritten by this method as a// conditional branch followed by an unconditional branch.// The unconditional branch would require five bytes.// Now that the maximum number of bytes by which the method might grow// has been determined, look for conditional branches to see which// might possibly exceed the 16-bit relative offset.// Consider the worst case scenario in which the conditional// branch and its target are separated by all the instructions// in the method that might increase in size.  If that results// in a relative offset that cannot be represented as a 32-bit// signed quantity, rewrite the instruction as described above.// Invert the logic of the IF instruction, and append// that to the InstructionList following the original IF// Append an unconditional branch to the target of the// original IF instruction after the new IF instruction// If the original IF was the last instruction in// InstructionList, add a new no-op to act as the target// of the new IF// Make the new IF instruction branch around the GOTO// If anything still "points" to the old IF instruction,// make adjustments to refer to either the new IF or GOTO// Ideally, one should simply be able to use// InstructionTargeter.updateTarget to change// references to the old IF instruction to the new// IF instruction.  However, if a LocalVariableGen// indicated the old IF marked the end of the range// in which the IF variable is in use, the live// range of the variable must extend to include the// newly created GOTO instruction.  The need for// this sort of specific knowledge of an// implementor of the InstructionTargeter interface// makes the code more fragile.  Future implementors// of the interface might have similar requirements// which wouldn't be accommodated seemlessly.// This can never happen - we updated the list of// instructions that target the deleted instruction// prior to deleting it.// Adjust the pointer in the InstructionList to point after// the newly inserted IF instruction// Indicate that this method rewrote at least one IF// Did this method rewrite any IF instructions?Type _resultType;List<Type> _argsType;/** Returns the signature of this method that results by adding ... */MethodType temptemp._resultTypetemp._argsTypeMethodType mtypemtype._argsType// should never be called// return MAX_VALUE// both methods have no argsnew HashMap<K,Set<V>>(...)Map<K,Set<V>> map;boolean modifiable;/** Associates the specified key with a set of values. If the map previously ... */Set<V> setnew HashSet<V>(...)/** Maps a key to a value in a set that is associated with the specified key. ... */V v/** Makes the MultiHashtable unmodifiable.  This method allows modules to set the table ... *//* $Id: MultiHashtable.java,v 1.2.4.1 2005/09/05 11:18:51 pvedula Exp $ *//** This class is used for named templates. Named template methods have access ... */// The index of the first parameter (after dom/iterator/handler/current)/** This class implements auxiliary classes needed to compile ... *//** Set the index of the register where "this" (the pointer to ... *//** Translates a node-set into an object of internal type ... *//** Translates an external Java Class into an internal type. ... */int convert/** Translates a node-set into a synthesized boolean. ... */FlowList falsel/** Translates a node-set into a string. The string value of a node-set is ... */getFirstNode(...)/** Expects a node-set on the stack and pushes a real. ... *//** Expects a node-set on the stack and pushes a node. ... *//** Subsume node-set into ObjectType. ... *//** Translates a node-set into a non-synthesized boolean. It does not ... *//** Expects a node-set on the stack and pushes a boxed node-set. ... *//** Translates a node-set into the Java type denoted by <code>clazz</code>. ... */int next/** Some type conversions require gettting the first node from the node-set. ... *//** Returns the class name of an internal type's external representation. */// w3c NodeList is on the stack from the external Java function call.// call BasisFunction to consume NodeList and leave Iterator on//    the stack.// push translet onto stack// push DOM onto stack// w3c Node is on the stack from the external Java function call.// call BasisLibrary.node2Iterator() to consume Node and leave// Iterator on the stack.// Get next node from the iterator// Get the node's string value (from the DOM)/** Generator for subclasses of NodeSortRecordFactory. ... */import NodeTest/** Translates a node into an object of internal type <code>type</code>. ... *//** Expects a node on the stack and pushes its string value. ... */NodeTest.ROOT/** Translates a node into a synthesized boolean. ... *//** Expects a node on the stack and pushes a real. ... *//** Expects a node on the stack and pushes a singleton node-set. Singleton ... *//** Subsume Node into ObjectType. ... *//** Translates a node into a non-synthesized boolean. It does not push a ... *//** Expects a node on the stack and pushes a boxed node. Boxed nodes ... *//** Translates a node into the Java type denoted by <code>clazz</code>. ... */// dom ref must be below node index// Create a new instance of SingletonIteratorString _javaClassName;Class<> _clazz;/** Used to represent a Java Class type such is required to support ... *//** Must return the same value for all ObjectType instances. This is ... *//** Translates a void into an object of internal type <code>type</code>. ... */BranchHandle ifNullBranchHandle gotobh/** Translates an object of this type to the external (Java) type denoted ... *//** Translates an external Java type into an Object type *//** <p>Marks the end of a region of byte code that can be copied into a new ... */new OutlineableChunkEnd(...)Instruction OUTLINEABLECHUNKEND;/** A constant instance of {@link OutlineableChunkEnd}.  As it has no fields, ... *//** Private default constructor.  As it has no fields, ... *//** Get the name of this instruction.  Used for debugging. ... */OutlineableChunkEnd.class/** <p>This pseudo-instruction marks the beginning of a region of byte code that ... */new OutlineableChunkStart(...)Instruction OUTLINEABLECHUNKSTART;/** A constant instance of {@link OutlineableChunkStart}.  As it has no fields, ... */OutlineableChunkStart.class/** Expects a real on the stack and pushes its string value by calling ... *//** Expects a real on the stack and pushes a 0 if that number is 0.0 and ... *//** Expects a real on the stack and pushes a truncated integer value ... *//** Translates a real into a non-synthesized boolean. It does not push a ... */FlowList flowlist/** Expects a double on the stack and pushes a boxed double. Boxed ... *//** Translates a real into the Java type denoted by <code>clazz</code>. ... *//** Translates an external (primitive) Java type into a real. Expects a java ... */InstructionConst.DNEGInstructionConst.DCMPL// Store real into a local variable// Compare it to 0.0//!!! call isNaN// Compare it to itself to see if NaN// NaN != NaN/** Translates a reference to an object of internal type <code>type</code>. ... *//** Translates reference into object of internal type <code>type</code>. ... */int stringF/** Translates a reference into an object of internal type <code>type</code>. ... *//** Casts a reference into a NodeIterator. ... *//** Casts a reference into a Node. ... *//** Casts a reference into a ResultTree. ... *//** Subsume reference into ObjectType. ... *//** Translates a reference into the Java type denoted by <code>clazz</code>. */int referenceToLongint referenceToDoubleint referenceToBoolean/** Translates an external Java type into a reference. Only conversion ... *//** Expects a reference on the stack and translates it to a non-synthesized ... */// If no current, conversion is a top-level// push root node// Reset this iterator/** Translates a result tree to object of internal type <code>type</code>. ... *//** Expects an result tree on the stack and pushes a boolean. ... *//** Expects an result tree on the stack and pushes a string. ... */LocalVariableGen handler/** Expects an result tree on the stack and pushes a real. ... *//** Expects a result tree on the stack and pushes a boxed result tree. ... */LocalVariableGen domBuilderLocalVariableGen newDom/** Expects a result tree on the stack and pushes a node-set (iterator). ... */int mapping/** Subsume result tree into ObjectType. ... *//** Translates a result tree into a non-synthesized boolean. ... *//** Translates a result tree to a Java type denoted by <code>clazz</code>. ... */// A result tree is always 'true' when converted to a boolean value,// since the tree always has at least one node (the root).// don't need the DOM reference// push 'true' on the stack// Push required parameters// Create a new instance of a StringValueHandler// Store new Handler into a local variable// Call the method that implements this result tree// Restore new handler and call getValue()// Store new DOM into a local variable//index = cpg.addMethodref(DOM_IMPL,//                   "getOutputDomBuilder",//                   "()" + TRANSLET_OUTPUT_SIG);//il.append(new INVOKEVIRTUAL(index));// Store DOM handler in a local in order to call endDocument()// Call endDocument on the DOM handler// Push the new DOM on the stack// Put an extra copy of the result tree (DOM) on the stack// DOM adapters containing a result tree are not initialised with// translet-type to DOM-type mapping. This must be done now for// XPath expressions and patterns to work for the iterator we create.// get names array// get uris array// get types array// get namespaces array// Pass the type mappings to the DOM adapter// Create an iterator for the root node of the DOM adapter/** This class is used for result trees implemented as methods. These ... */int _firstAvailableSlot;int _size;int _free;...[] _slotsTaken;vars.lengthint limitint where// insert/** Translates a string into an object of internal type <code>type</code>. ... */Type.ObjectString/** Translates a string into a synthesized boolean. ... *//** Translates a string into a real by calling stringToReal() from the ... *//** Translates a string into a non-synthesized boolean. It does not push a ... *//** Expects a string on the stack and pushes a boxed string. ... *//** Translates a internal string into an external (Java) string. ... *//** Translates an external (primitive) Java type into a string. ... */BranchHandle ifNonNull// NOP -> same representation// Is String <: clazz? I.e. clazz in { String, Object }// same internal representation, convert null to ""int CONTEXT_NODE_INDEX;int CURRENT_NODE_INDEX;Instruction _iloadContext;Instruction _istoreContext;new IntType(...)new RealType(...)new BooleanType(...)new NodeSetType(...)new StringType(...)new ResultTreeType(...)new ReferenceType(...)new VoidType(...)new NodeType(...)Type Int;Type Real;Type Boolean;Type NodeSet;Type String;Type ResultTree;Type Reference;Type Void;Type Object;Type ObjectString;Type Node;Type Root;Type Element;Type Attribute;Type Text;Type Comment;Type Processing_Instruction;/** Factory method to instantiate object types. Returns a pre-defined ... */new RuntimePermission(...)/** Returns a string representation of this type. *//** Returns true if this and other are identical types. *//** Returns true if this type is a numeric type. Redefined in NumberType. *//** Returns true if this type has no object representaion. Redefined in ... *//** Returns true if this type is a simple type. Redefined in NumberType, ... *//** Returns the distance between two types. This measure is used to select ... *//** Returns the signature of an internal type's external representation. *//** Translates an object of this type to an object of type ... *//** Translates object of this type to an object of type <code>type</code>. ... *//** Translates an object of this type to an non-synthesized boolean. It ... *//** Translates an external (Java) type denoted by <code>clazz</code> to ... */ErrorMsg _error;SyntaxTreeNode _node;char filesep;/** Search for both slashes in order to support URLs and ... */int lastColonIndex/** Replace all illegal Java chars by '_'. *//** Replace a certain character in a string with a new substring. *//** Replace occurances of '.', '-', '/' and ':' *//** Checks if the string is a literal (i.e. not an AVT) or not. *//** Checks if the string is valid list of qnames *//** Translates a void into a string by pushing the empty string ''. ... *//** Translates an external (primitive) Java type into a void. ... */import DTMAxisIteratorBaseimport DTMDefaultBase/** Absolute iterators ignore the node that is passed to setStartNode(). ... */DTMAxisIterator _source;/** Source for this iterator. */setRestartable(...)DTMDefaultBase.ROOTNODEresetPosition(...)returnNode(...)AbsoluteIterator cloneclone._sourcecloneIterator(...)clone._isRestartablerunTimeError(...)BasisLibrary.ITERATOR_CLONE_ERRsetMark(...)gotoMark(...)// System.out.println("AI source = " + source + " this = " + this);// resets sourceimport DTMAxisTraverserimport XMLString/** AdaptiveResultTreeImpl is a adaptive DOM model for result tree fragments (RTF). It is ... */int _documentURIIndex;// Document URI index, which increases by 1 at each getDocumentURI() call.String EMPTY_STRING;SAXImpl _dom;// The SAXImpl object wrapped by this class, if the RTF is a tree.DTMWSFilter _wsfilter;// The whitespace filter/** The following fields are only used for the nested SAXImpl * */int _initSize;// The size of the RTFboolean _buildIdIndex;// True if we want to build the ID index table// The AttributeListString _openElementName;// The element name// Create a AdaptiveResultTreeImpl// Return the DOM object wrapped in this object.// Return the document IDgetDocument(...)// Return the String value of the RTFgetIterator(...)getTypedChildren(...)getAxisIterator(...)getTypedAxisIterator(...)getNthDescendant(...)getNamespaceAxisIterator(...)getNodeValueIterator(...)orderNodes(...)getNodeNameX(...)getNamespaceName(...)// Return the expanded type id of a given nodegetExpandedTypeID(...)getNamespaceType(...)getAttributeNode(...)getStringValueX(...)shallowCopy(...)/** Dispatch the character content of a node to an output handler. ... */characters(...)makeNode(...)makeNodeList(...)getDocumentURI(...)setFilter(...)setupMapping(...)isElement(...)isAttribute(...)/** Return the node identity from a node handle. */getNodeIdent(...)/** Return the node handle from a node identity. */getNodeHandle(...)getResultTreeFrag(...)getNSType(...)getUnparsedEntityURI(...)getElementsWithIDs(...)/** The code in some of the following interfaces are copied from SAXAdapter. * *//** Implementation of the SerializationHandler interfaces * */getNamespaceURI(...)// Create and initialize the wrapped SAXImpl objectmaybeEmitStartElement(...)setEscaping(...)prepareNewDOM(...)int colonposBasisLibrary.STRAY_ATTRIBUTE_ERRstartPrefixMapping(...)comment(...)processingInstruction(...)/** Implementation of the DTM interfaces * */getAxisTraverser(...)getFirstAttribute(...)getFirstNamespaceNode(...)getPreviousSibling(...)getNextAttribute(...)getNextNamespaceNode(...)getOwnerDocument(...)getDocumentRoot(...)getStringValueChunkCount(...)getStringValueChunk(...)getLocalNameFromExpandedNameID(...)getNamespaceFromExpandedNameID(...)getLevel(...)getDocumentBaseURI(...)setDocumentBaseURI(...)getDocumentSystemIdentifier(...)getDocumentEncoding(...)getDocumentStandalone(...)getDocumentVersion(...)getDocumentAllDeclarationsProcessed(...)getDocumentTypeDeclarationSystemIdentifier(...)getDocumentTypeDeclarationPublicIdentifier(...)getElementById(...)supportsPreStripping(...)isCharacterElementContentWhitespace(...)isDocumentAllDeclarationsProcessed(...)isAttributeSpecified(...)dispatchCharactersEvents(...)dispatchToEvents(...)needsTwoThreads(...)getContentHandler(...)getLexicalHandler(...)getEntityResolver(...)getDTDHandler(...)getErrorHandler(...)getDeclHandler(...)appendTextChild(...)documentRegistration(...)documentRelease(...)// Flush pending Text nodes to SAXImpl// "prefix:localpart" or "localpart"import TransletisInfinite(...)formatNumbers(...)int rootmatchesFrom(...)matchesCount(...)new DefaultAnyNodeCounter(...)int ntype//See Errata E24//%HZ%:  Is this the best way of finding the root?  Is it better to check//%HZ%:  parent(next)?/* if (next == root) { ... */int _pos;int _mark;...[] _nodes;...[] EMPTY;_nodes.lengthnew ArrayNodeListIterator(...)...[] _bits;int _bitSize;int _intSize;int _mask;...[] _masks;// (These operations are inexpensive on CPUs but very expensive on JVMs.)// This table is used to prevent expensive shift operationsboolean DEBUG_ASSERTIONS;/** Constructor. Defines the initial size of the bit array (in bits). *//** Set the mask for this bit array. The upper 8 bits of this mask ... *//** See setMask() *//** Returns the size of this bit array (in bits). *//** Returns true if the given bit is set *//** Returns the next set bit from a given position */DTMAxisIterator.END/** This method returns the Nth bit that is set in the bit array. The ... */int _node;int _int;int _bit;/** Returns the integer array in which the bit array is contained */int _first;int _last;// The index where first set bit is/** Sets a given bit */// The _INTEGER INDEX_ where last set bit is/** Merge two bit arrays. This currently only works for nodes from ... */other._bitsother._lastother._firstother._intSize/** Resizes the bit array - try to avoid using this method!!! */int[] newBitsnew BitArray(...)/** Read the whole tree from a file (serialized) */// Return last node if position we're looking for is the same// Start from beginning of position we're looking for is before// the point where we left off the last time.// Scan through the bit array - skip integers that have no bits set// Any bits set?// Take other array's bits if we have node set// Only merge if other array has any bits set// Merge these bits into other array if other array is larger// Merge other bits into this array if this arrai is large/equal.import IntegerArray/** CachedNodeListIterator is used for select expressions in a ... */new IntegerArray(...)IntegerArray _nodes;int _numCachedNodes;int _index;boolean _isEnded;at(...)int nodeClonedNodeListIterator clonenew ClonedNodeListIterator(...)//_isRestartable = isRestartable;//_source.setRestartable(isRestartable);/** A ClonedNodeListIterator is returned by the cloneIterator() method ... */CachedNodeListIterator _source;import CollatorFactoryLocale DEFAULT_LOCALE;Collator DEFAULT_COLLATOR;/** Iterators of this kind use a CurrentNodeListFilter to filter a subset of ... */boolean _docOrder;/** A flag indicating if nodes are returned in document order. *//** The source for this iterator. */CurrentNodeListFilter _filter;/** A reference to a filter object. *//** An integer array to store nodes from source iterator. *//** Index in _nodes of the next node to filter. */int _currentNode;/** The current node in the stylesheet at the time of evaluation. */AbstractTranslet _translet;/** A reference to the translet. */CurrentNodeListIterator cloneclone._nodesint currentNodeint positiontest(...)computePositionOfLast(...)int currNodeint lastPositionint nodeIndex// note incrementDOMEnhancedForDTM _enhancedDOM;// Mutually exclusive casting of DOM interface to known implementationsDOM _dom;...[] _namesArray;...[] _urisArray;...[] _typesArray;...[] _namespaceArray;...[] _mapping;// Cached mappings...[] _reverse;...[] _NSmapping;...[] _NSreverse;int _multiDOMMask;getReverseMapping(...)getNamespaceMapping(...)getReverseNamespaceMapping(...)/** Returns singleton iterator containg the document root */DTMAxisIterator iteratorint[] reversegetReverse(...)getNSReverse(...)short[] mappinggetExpandedTypeID2(...)getNSMapping(...)/** Return a instance of a DOM class to be used as an RTF *//** Returns a SerializationHandler class wrapped in a SAX adapter. */getOutputDomBuilder(...)/** A wrapper class that adapts the ... */AbstractTranslet m_translet;StripFilter m_filter;Map<DTM,short[]> m_mappings;// The Map for DTM to mapping arrayDTM m_currentDTM;// Cache the DTM and mapping that are used last time...[] m_currentMapping;/** Construct an adapter connecting the <code>DTMWSFilter</code> interface ... */new HashMap<DTM,short[]>(...)/** Test whether whitespace-only text nodes are visible in the logical ... */DOM domDOMEnhancedForDTM mappableDOMint expTypegetNamesArray(...)getUrisArray(...)getTypesArray(...)mapping.lengthstripSpace(...)/* $Id: DOMWSFilter.java,v 1.2.4.1 2005/09/06 06:14:31 pvedula Exp $ */// %OPT% The mapping array does not have information about all the// exptypes. However it does contain enough information about all names// in the translet's namesArray. If the expType does not fall into the// range of the mapping array, it means that the expType is not for one// of the recognized names. In this case we can just set the type to -1.import DOMCacheimport URLConnectionimport PathsMap<String,CachedDocument> _references;...[] _URIs;int _count;int _current;SAXParser _parser;XSLTCDTMManager _dtmManager;int REFRESH_INTERVAL;DocumentCache$CachedDocument/* Inner class containing a DOMImpl object and DTD handler */long _firstReferenced;// Statistics datalong _lastReferenced;long _accessCount;long _lastModified;long _lastChecked;long _buildTime;DOMEnhancedForDTM _dom;// DOM and DTD handler references/** Constructor - load document and initialise statistics */long stamploadDocument(...)/** Loads the document and updates build-time (latency) statistics */long thisTime/** DocumentCache constructor */new HashMap<String,CachedDocument>(...)ParserConfigurationException eBasisLibrary.NAMESPACES_SUPPORT_ERR/** Returns the time-stamp for a document's last update */URLConnection connectionopenConnection(...)long timestampgetLastModified(...)File localfiletoFile(...)insertDocument(...)/** Returns a document either by finding it in the cache or ... */CachedDocument docTransformerException telookupDocument(...)new CachedDocument(...)setLastModified(...)long nowlong chkgetLastChecked(...)setLastChecked(...)long lastreplaceDocument(...)incAccessCount(...)/** Outputs the cache statistics */getLatency(...)getAccessCount(...)getLastReferenced(...)/* $Id: DocumentCache.java,v 1.2.4.1 2005/09/06 06:15:22 pvedula Exp $ */// Initialise statistics variables// The build time can be used for statistics for a better// priority algorithm (currently round robin).// ???// Check for a "file:" URI (courtesy of Brian Ewins)// get 0 for local URI// Brutal handling of all exceptions// Insert out URI in circular buffer// Remove oldest URI from reference map// Insert our URI in circular buffer// Try to get the document from the cache first// better error handling needed!!!// If the document is in the cache we must check if it is still valid// Has the modification time for this file been checked lately?// Reload document if it has been modified since last download// Get the references to the actual DOM and DTD handler// The dom reference may be null if the URL pointed to a// non-existing document// For statistics// Give the translet an early opportunity to extract any// information from the DOM object that it would like./** Removes duplicates and sorts a source iterator. The nodes from the ... *//** Reference to source iterator. *//** Array to cache all nodes from source. *//** Index in _nodes array to current node. */int _nodesSize;/** Cardinality of _nodes array. */int _lastNext;/** Last value returned by next(). */int _markedLastNext;/** Temporary variable to store _lastNext. *//** Set the start node for this iterator ... */boolean sourceIsKeyIndexDupFilterIterator clone// System.out.println("DFI source = " + source + " this = " + this);// Cache contents of id() or key() index right away. Necessary for// union expressions containing multiple calls to the same index, and// correct as well since start-node is irrelevant for id()/key() exrp.// KeyIndex iterators are always relative to the root node, so there// is never any point in re-reading the iterator (and we SHOULD NOT).// Nodes produced by KeyIndex are known to be in document order.// Take advantage of it.// Bugzilla 25924import DTDHandlerimport DeclHandlerimport LexicalHandlerimport DTMFilter/** Similar to a CurrentNodeListIterator except that the filter has a ... */DTMFilter _filter;/** Reference to a filter object that to be applied to each node. */boolean _isReverse;/** A flag indicating if position is reversed. */FilterIterator cloneacceptNode(...)DTMIterator.FILTER_ACCEPTDTMFilter.SHOW_ALL// System.out.println("FI souce = " + source + " this = " + this);/** Extends a StepIterator by adding the ability to filter nodes. It ... */Filter _filter;/** This iterator is a wrapper that always returns the position of ... */ForwardPositionIterator clone/** Stores mappings of key values or IDs to DTM nodes. ... */new HashMap<Integer,Map<>>(...)Map<String,IntegerArray> _index;/** A mapping between values and nodesets for the current document.  Used ... */int _currentDocumentNode;/** The document node currently being processed.  Used only while building ... */Map<Integer,Map<>> _rootToIndexMap;/** A mapping from a document node to the mapping between values and nodesets *//** The node set associated to the current value passed ... *//** The XSLTC DOM object if this KeyIndex is being used to implement the ... */int _markedPosition;/** Store position after call to setMark() *//** Adds a node to the node list for a given value. Nodes will ... */IntegerArray nodesnew HashMap<String,IntegerArray>(...)/** Merge the current value's nodeset set by lookupKey() with _nodes. ... */other._nodesmerge(...)/** This method must be called by the code generated by the id() function ... */StringTokenizer valueshasDOMSource(...)getDOMNodeById(...)/** Return an IntegerArray for the DOM Node which has the given id. ... */int identInteger rootMap<String,IntegerArray> index/** <p>This method must be called by the code generated by the key() function ... *//** <p>Callers should not call next() after it returns END.</p> ... *//** Given a context node and the argument to the XPath <code>id</code> ... */int rootHandleAxis.ROOT/** <p>Given a context node and the second argument to the XSLT ... *//** <p>Resets the iterator to the last start node.</p> ... *//** <p>Returns the number of elements in this iterator.</p> ... *//** <p>Returns the position of the current node in the set.</p> ... *//** <p>Remembers the current node for the next call to gotoMark().</p> ... *//** <p>Restores the current node remembered by setMark().</p> ... *//** <p>Set start to END should 'close' the iterator, ... *//** <p>Get start to END should 'close' the iterator, ... *//** <p>True if this iterator has a reversed axis.</p> ... *//** <p>Returns a deep copy of this iterator.</p> ... */KeyIndex othernew KeyIndex(...)other._indexother._rootToIndexMapDOM idomgetDOMImpl(...)/** Create a {@link KeyIndexIterator} that iterates over the nodes that ... */getKeyIndexIterator(...)stringF(...)new KeyIndexIterator(...)IntegerArray EMPTY_NODES;/** Used to represent an empty node set. */KeyIndex$KeyIndexIterator/** An iterator representing the result of a reference to either the ... *//** <p>A reference to the <code>key</code> function that only has one ... */DTMAxisIterator _keyValueIterator;/** <p>This field contains the iterator representing a node set key value ... */String _keyValue;/** <p>This field contains the iterator representing a non-node-set key ... */boolean _isKeyIterator;/** Indicates whether this object represents the result of a reference ... */KeyIndex$KeyIndexIterator$KeyIndexHeapNode/** Represents the DTM nodes retrieved for one key value or one string ... */MultiValuedNodeHeapIterator.HeapNode/** {@link IntegerArray} of DTM nodes retrieved for one key value. ... *//** Position in {@link #_nodes} array of next node to return from ... */int _markPosition;/** Marked position.  Used by {@link #setMark()} and ... *//** Create a heap node representing DTM nodes retrieved for one ... *//** Advance to the next node represented by this {@link HeapNode} ... *//** Creates a deep copy of this {@link HeapNode}.  The clone is not ... */KeyIndexHeapNode clonecloneHeapNode(...)clone._positionclone._markPosition/** Remembers the current node for the next call to ... *//** Restores the current node remembered by {@link #setMark()}. *//** Performs a comparison of the two heap nodes ... */heapNode._node/** <p>Sets context with respect to which this heap node is ... *//** Reset the heap node back to its beginning. *//** Constructor used when the argument to <code>key</code> or ... *//** Retrieve nodes for a particular key value or a particular id ... */IntegerArray result/** Set context node for the iterator.  This will cause the iterator ... *//** Get the next node in the iteration. ... */int nodeHandle/** Resets the iterator to the last start node. ... *//** Evaluate the reference to the <code>key</code> or <code>id</code> ... */lookupNodes(...)DTMAxisIterator keyValuesint retrievedKeyValueIdxboolean foundNodesint keyValueNodeString keyValueaddHeapNode(...)new KeyIndexHeapNode(...)/** Returns the number of nodes in this iterator. ... */getLast(...)/** Return the node at the given position. ... */getNodeByPosition(...)/* $Id: KeyIndex.java,v 1.6 2006/06/19 19:49:02 spericas Exp $ */// Because nodes are added in document order,// duplicates can be eliminated easily at this stage.// Clear _nodes array// Get the mapping table for the document containing the context node// Split argument to id function into XML whitespace separated tokens// If input was from W3C DOM, use DOM's getElementById to do// the look-up.// Did we find the context node in the set of nodes?// Didn't find the context node in the set of nodes returned by id// Check whether the context node is present in the set of nodes// returned by the key function// The particular key name identifies no nodes in this document// If a MultiDOM, ensure _enhancedDOM is correctly set// so that getElementById() works in lookupNodes below// Get mapping from key values/IDs to DTM nodes for this document// For id function, tokenize argument as whitespace separated// list of values and look up nodes identified by each ID.// Does the ID map to any node in the document?// If we found any nodes, merge them into the cumulative// result// For key function, map key value to nodes// If the arugment to the function is a node set, set the// context node on it.// If at most one key value or at most one string argument to id// resulted in nodes being returned, use the IntegerArray// stored at _nodes directly.  This relies on the fact that the// IntegerArray never includes duplicate nodes and is always stored// in document order.// All nodes retrieved are in the same document// Is the argument not a node set?// Look up nodes returned for the single string argument// For each node in the node set argument, get the string value// and look up the nodes returned by key or id for that string// value.  If at most one string value has nodes associated,// the nodes will be stored in _nodes; otherwise, the nodes// will be placed in a heap.// If nodes are stored in _nodes, take advantage of the fact that// there are no duplicates.  Otherwise, fall back to the base heap// implementaiton and hope it does a good job with this.// there are no duplicates and they are stored in document order.// Otherwise, fall back to the base heap implementation to do a// good job with this.import TemplatesImplimport DTMManagerimport EmptyIterator/** Interprets the arguments passed from the document() function (see ... */String baseURIint arg2FirstNodeisAbsoluteURI(...)getAbsoluteURIFromRelative(...)document(...)String errnew TransletException(...)TemplatesImpl templatesgetTemplates(...)DOM sdomgetStylesheetDOM(...)String originalUriMultiDOM multiplexergetDocumentMask(...)DOMCache cachegetDOMCache(...)DOM newdomDOMAdapter domAdaptermakeDOMAdapter(...)DOM newDomgetDOMAdapter(...)new SingletonIterator(...)nextMask(...)retrieveDocument(...)getAllowedProtocols(...)DOMEnhancedForDTM enhancedDOMsetStylesheetDOM(...)addDOMAdapter(...)buildKeys(...)UnionIterator unionnew UnionIterator(...)addIterator(...)/** Create a DTMAxisIterator for the newdom. This is currently only ... */DTMManager dtmManagermigrateTo(...)//  the second argument node-set is empty//System.err.println("arg2FirstNode name: "//                   + dom.getNodeName(arg2FirstNode )+"["//                   +Integer.toHexString(arg2FirstNode )+"]");// %OPT% Optimization to cache the stylesheet DOM.// The stylesheet DOM is built once and cached// in the Templates object.// If the cached dom exists, we need to migrate it// to the new DTMManager and create a DTMAxisIterator// for the document.// Prepend URI base to URI (from context)// Return an empty iterator if the URI is clearly invalid// (to prevent some unncessary MalformedURL exceptions).// Check if this DOM has already been added to the multiplexer// Check if we can get the DOM from a DOMCache// Parse the input document and construct DOM object// Trust the DTMManager to pick the right parser and// set up the DOM correctly.// Cache the stylesheet DOM in the Templates object// Wrap the DOM object in a DOM adapter and add to multiplexer// Create index for any key elements// Return a singleton iterator containing the root node//document(node-set) if true;  document(node-set,node-set) if false// Need to migrate the cached DTM to the new DTMManager/** This is a special kind of iterator that takes a source iterator and a ... *//** A reference to a source iterator. */int _match;/** The node to match. */MatchingIterator clone// iterator is not a clone// Calculate the position of the node in the setimport DTMAxisIterNodeListimport SuballocatedIntVector...[] _adapters;DOMAdapter _main;DTMManager _dtmManager;Map<String,Integer> _documents;MultiDOM$AxisIterator// constitutive data// implementation mechanismint _dtmId;int domDTMManager.IDENT_DTM_NODE_BITSAxisIterator clonenew AxisIterator(...)clone._dtmIdMultiDOM$NodeValueIterator/** ************************************************************ ... */// end of AxisIteratorboolean _op;int _returnType;NodeValueIterator cloneDOMAdapter adapternew DOM[]getManager(...)int domNoint dtmSizeSuballocatedIntVector dtmIdsDTMDefaultBase dtmdbgetDTMIDs(...)SimpleResultTreeImpl simpleRTFDOMAdapter[] newArraynew DOMAdapter[]int domPosAdaptiveResultTreeImpl adaptiveRTFDOM nestedDomgetNestedDOM(...)DOMAdapter newAdapternew DOMAdapter(...)getNamespaceArray(...)Integer domIdx/** Returns singleton iterator containing the document root */getDTMId(...)new NodeValueIterator(...)int dom1int dom2new DTMAxisIterNodeList(...)DOM.NULL/** Returns a DOMBuilder class wrapped in a SAX adapter. */// %HZ% Does this method make any sense here???SuballocatedIntVector idsint idsSizeisMatchingAdapterEntry(...)_adapters.length// Get a new source first time and when mask changes// %HZ% %REVISIT% Is this the right thing to do here?  In the old// %HZ% %REVISIT% version, the main document did not get added through// %HZ% %REVISIT% a call to addDOMAdapter, which meant it couldn't be// %HZ% %REVISIT% found by a call to getDocumentMask.  The problem is// %HZ% %REVISIT% TransformerHandler is typically constructed with a// %HZ% %REVISIT% system ID equal to the stylesheet's URI; with SAX// %HZ% %REVISIT% input, it ends up giving that URI to the document.// %HZ% %REVISIT% Then, any references to document('') are resolved// %HZ% %REVISIT% using the stylesheet's URI.// %HZ% %REVISIT% MultiDOM.getDocumentMask is called to verify that// %HZ% %REVISIT% a document associated with that URI has not been// %HZ% %REVISIT% encountered, and that method ends up returning the// %HZ% %REVISIT% mask of the main document, when what we really what// %HZ% %REVISIT% is to read the stylesheet itself!// This method only has a function in DOM adapters// Add the DOM adapter to the array of DOMs// Store reference to document (URI) in the Map// If the dom is an AdaptiveResultTreeImpl, we need to create a// DOMAdapter around its nested dom object (if it is non-null) and// add the DOMAdapter to the list.// main source document @ 0// TODO: gather nodes from all DOMs ?/* Method addDOMAdapter overwrites for AdaptiveResultTreeImpl ... *//** <p><code>MultiValuedNodeHeapIterator</code> takes a set of multi-valued ... */new HeapNode[]/** An abstract representation of a set of nodes that will be retrieved in ... *//** wrapper for NodeIterators to support iterator ... */int _node, ...;boolean _isStartSet;HeapNode cloneclone._nodeclone._markedNode/** Remembers the current node for the next call to {@link #gotoMark()}. *//** Sets context with respect to which this heap node is evaluated. ... *//** Reset the heap node back to its beginning. ... */int InitSize;// end of HeapNodeint _heapSize;...[] _heap;int _returnedLast;// next; used to prune duplicates// Last node returned by this MultiValuedNodeHeapIterator to the caller ofint _cachedReturnedLast;// cached returned last for use in gotoMarkint _cachedHeapSize;// cached heap size for use in gotoMarkHeapNode[] heapCopy_heap.lengthMultiValuedNodeHeapIterator cloneclone._heapHeapNode[] newArrayint smallest...[...]._nodeHeapNode tempstep(...)heapify(...)...[...]._isStartSet/* Build a heap in document order. put the smallest node on the top. ... */isLessThan(...)/* $Id: UnionIterator.java 337874 2004-02-16 23:06:53Z minchau $ */// iterator _heap[0] is done// Swap first and last (iterator must be restartable)// duplicate// value consumed// fallthrough if not returned above// to get the first node// build heap// rebuild heap after call last() function. fix for bug 20913DTMAxisIterator _precSiblings;IntegerArray ancestorsint nAncestorsint[] countersint ancestornew DefaultMultipleNodeCounter(...)// Gather all ancestors that do not match from pattern// include self// Create an array of counters// Increment array of counters according to semantics// Count the node itselfDOM _document;DTMAxisIterator _iterator;Translet _translet;String _format;String _lang;String _letterValue;String _groupSep;int _groupSize;boolean _separFirst;boolean _separLast;Vector<> _separToks;Vector<> _formatToks;int _nSepars;int _nFormats;...[] Thousands;...[] Hundreds;...[] Tens;...[] Ones;StringBuilder _tempBuffer;boolean _hasFrom;/** Indicates if this instance of xsl:number has a from pattern. *//** Set the start node for this counter. The same <tt>NodeCounter</tt> ... *//** If the user specified a value attribute, use this instead of ... *//** Sets formatting fields before calling formatNumbers(). */parseStringToAnInt(...)setTokens(...)/** Effectively does the same thing as Integer.parseInt(String s) except ... */boolean negativeint radixint multminint digit// format == null assumed hereboolean isFirst/** Sets formatting fields to their default values. */setFormatting(...)/** Returns the position of <tt>node</tt> according to the level and ... */getCounter(...)/** Returns true if <tt>node</tt> matches the count pattern. By ... *//** Returns true if <tt>node</tt> matches the from pattern. By default, ... *//** Format a single value according to the format parameters. *//** Format a sequence of values according to the format paramaters ... */int nValuesboolean isEmptyStringBuilder bufferformatValue(...)/** Format a single value based on the appropriate formatting token. ... */char zerogetNumericValue(...)StringBuilder tempromanValue(...)alphaValue(...)int rangechar last// Accumulating negatively avoids surprises near MAX_VALUE/* Only got "-" */// has already been set/* Tokenize the format string into alphanumeric and non-alphanumeric ... */// Format the output string using the values array and the fmt. tokens// Append separation token before first digit/letter/numeral// Append next digit/letter/numeral and separation token// Append separation token after last digit/letter/numeral// Special case for Greek alphabet// omega// General case: search for end of groupNodeIterator.END/** Cached computed value of last(). *//** Value of position() in this iterator. Incremented in ... */int _markedNode;/** Store node in call to setMark(). */int _startNode;/** Store node in call to setStartNode(). */boolean _includeSelf;/** Flag indicating if "self" should be returned. */boolean _isRestartable;/** Flag indicating if iterator can be restarted. *//** Setter for _isRestartable flag. *//** Initialize iterator using a node. If iterator is not ... *//** Reset this iterator using state from last call to ... */boolean temp/** Setter for _includeSelf flag. *//** Default implementation of getLast(). Stores current position ... *//** Returns the position() in this iterator. *//** Indicates if position in this iterator is computed in reverse ... *//** Clones and resets this iterator. Note that the cloned iterator is ... */NodeIteratorBase clone/** Utility method that increments position and returns its ... *//** Reset the position in this iterator. */// Must adjust _startNode if self is includedimport CollationKeyimport StringComparable/** Base class for sort records containing application specific sort keys */int COMPARE_STRING;int COMPARE_NUMERIC;int COMPARE_ASCENDING;int COMPARE_DESCENDING;/** A reference to a collator. May be updated by subclass if the stylesheet ... */Collator _collator;/** A reference to the first Collator ... */...[] _collators;Locale _locale;/** A locale field that might be set by an instance of a subclass. ... */CollatorFactory _collatorFactory;SortSettings _settings;// The position in the current iteratorint _scanned;// Number of nodes in the current iterator...[] _values;// Number of key levels extracted from DOM/** This constructor is run by a call to ClassLoader in the ... */// Contains Comparable  objects/** This method allows the caller to set the values that could not be passed ... */getSortOrders(...).lengthgetSortOrders(...)String colFactClassnameLocale[] localesgetLocales(...)Object candObjnew Collator[]getCollator(...)getCollators(...)/** Returns the node for this sort object */other._node/** Get the string or numeric value of a specific level key for this sort ... */getTranslet(...)String[] caseOrdergetCaseOrders(...)extractValueFromDOM(...)Comparable<> keygetComparator(...)Double.NEGATIVE_INFINITY/** Compare this sort element to another. The first level is checked first, ... */int[] sortOrderint[] compareTypesgetTypes(...)Double ournumericValue(...)Double theirComparable<> ourstringValue(...)Comparable<> their/** Returns the array of Collators used for text comparisons in this object. ... *//** Extract the sort value for a level of this key. */// -- W. Eliot Kimber (eliot@isogen.com)// If we can't read the propery, just use default collator// Get value from our array if possible// Get value from DOM if accessed for the first time// Get value from our vector if possible// Treat number as NaN if it cannot be parsed as a double// Compare the two nodes either as numeric or text values// Return inverse compare value if inverse sort order// Compare based on document order if all sort keys are equalimport LocaleUtilityint DESCENDING;int NUMBER;Class<> _class;SortSettings _sortSettings;/** Creates a NodeSortRecord producing object. The DOM specifies which tree ... */order.lengthint[] iOrderint[] iTypeString[] emptyStringArraylang.lengthnew Locale[]Collator[] collatorsgetAuxiliaryClass(...)NodeSortRecord.COMPARE_DESCENDINGNodeSortRecord.COMPARE_NUMERICint numSortKeyslangToLocale(...)new SortSettings(...)/** Create an instance of a sub-class of NodeSortRecord. The name of this ... */NodeSortRecord sortRecordnew InstantiationException(...)// This should return a Class definition if using TrAX// This code is only run when the native API is used// Old NodeSortRecordFactory constructor had no lang or case_order// arguments.  Provide default values in that case for binary// compatibility.// Set up array of zero-length strings as default values// of lang and case_order//NodeSortRecord subclasses are generated with a public empty constructor// refer to com.sun.org.apache.xalan.internal.xsltc.compiler.Sort::compileInit// ...[N]boolean _ready;NthIterator clone/* if (_ready && _position > 0) { ... */import SAX2DTM2import ToXMLSAXHandlerimport XMLStringFactoryimport DocumentTypeimport Entity/** SAXImpl is the core model for SAX input source. SAXImpl objects are ... */int _uriCount;// Namespace prefix-to-uri mapping stuff/* ------------------------------------------------------------------- *//* DOMBuilder fields BEGIN */...[] _xmlSpaceStack;// by xml:space="preserve" attributes and which nodes that are not.// Stack used to keep track of what whitespace text nodes are protected// private int       _prefixCount  = 0;int _idx;boolean _preserve;String XML_PREFIX;// private static final String XML_STRING = "xml:";String XMLSPACE_STRING;String PRESERVE_STRING;String XML_URI;// private static final String XMLNS_PREFIX = "xmlns";boolean _disableEscaping;int _textNodeToProcess;// empty String for null attribute values/* DOMBuilder fields END */DTMAxisIterator EMPTYITERATOR;// empty iterator to be returned when there are no childrenint _namesSize;// The number of expanded namesMap<Integer,Integer> _nsIndex;// Namespace related stuff// The initial size of the text bufferBitArray _dontEscape;// Tracks which textnodes are not escaped// private String _documentURI = null;// The URI to this documentDocument _document;// The owner Document when the input source is DOMSource.Map<Node,Integer> _node2Ids;// buildIdIndex flag is true.// This is only used when the input is a DOMSource and the// The Map for org.w3c.dom.Node to node id mapping.boolean _hasDOMSource;// True if the input source is a DOMSource.// The DTMManager// Support for access/navigation through org.w3c.dom API...[] _nodeLists;/** Define the origin of the document from which the tree was built */// private final static String XML_LANG_ATTRIBUTE = "http://www.w3.org/XML/1998/namespace:@lang";/** Returns the origin of the document from which the tree was built *//** Lookup a namespace URI from a prefix starting at node. This method ... */int anodeint nsnodeAncestorIterator ancestorsnew AncestorIterator(...)includeSelf(...)NamespaceIterator namespacesnew NamespaceIterator(...)BasisLibrary.NAMESPACE_PREFIX_ERR/** Returns 'true' if a specific node is an element (of any type) *//** Returns 'true' if a specific node is an attribute (of any type) *//** Returns the number of nodes in the tree (used for indexing) */getNumberOfNodes(...)/** Part of the DOM interface - no function here. *//** Returns true if node1 comes before node2 in document order *//** Create an org.w3c.dom.Node from a node in the tree */int nodeIDmakeNodeIdentity(...)new DTMNodeProxy(...)/** Create an org.w3c.dom.Node from a node in an iterator ... *//** Create an org.w3c.dom.NodeList from a node in the tree */new NodeList[]_nodeLists.length/** Create an org.w3c.dom.NodeList from a node iterator ... */SAXImpl$TypedNamespaceIterator/** Iterator that returns the namespace nodes as defined by the XPath data ... */String _nsPrefix;/** Constructor TypedChildrenIterator ... */SAXImpl$NodeValueIterator// end of TypedNamespaceIteratorclone._valueclone._op// end NodeValueIterator/** Encapsulates an iterator in an OrderedIterator to ensure node order */new DupFilterIterator(...)/** Returns singleton iterator containg the document root ... *//** Get mapping from DOM namespace types to external namespace types */int eTypegetIdForNamespace(...)/** Returns the namespace type of a specific node *//** Returns the internal type associated with an expanded QName *//* private int[] setupMapping(String[] names, String[] uris, int[] types, int nNames) { ... *//** Sets up a translet-to-dom type mapping table */getGeneralizedType(...)String lNameint lNameStartIdx/** Get mapping from DOM element/attribute types to external types */int namesLengthint exLengthshort[] resultgetMapping2(...)int genType/** Get mapping from external element/attribute types to DOM types */int[] result/** Get mapping from DOM element/attribute types to external types. ... */int[] generalizedTypesint resultLengthint nsLengthnamespaces.lengthint mappingLengthInteger type/** Get mapping from external namespace types to DOM namespace types *//** Construct a SAXImpl object using the default block size. *//** Construct a SAXImpl object using the given block size. */DOMSource domsrcnew HashMap<Node,Integer>(...)/** Migrate a DTM built with an old DTMManager to a new DTMManager. ... *//** Return the node identity for a given id String ... *//** Return true if the input source is DOMSource. *//** Call this when an xml:space attribute is encountered to ... *//* --------------------------------------------------------------------------- *//* DOMBuilder methods begin */boolean setting/** Call this from endElement() to revert strip/preserve setting ... *//** Find out whether or not to strip whitespace nodes. ... */getShouldStripWhitespace(...)/** Creates a text-node and checks if it is a whitespace node. */setBit(...)/** ************************************************************* *//* SAX Interface Starts Here */definePrefixAndUri(...)handleTextEscaping(...)/** Specialized interface used by DOM2SAX. This one has an extra Node ... *//** SAX2: Receive notification of the beginning of an element. */xmlSpaceDefine(...)xmlSpaceRevert(...)/** SAX2: Receive notification of a processing instruction. *//** SAX2: Receive notification of ignorable whitespace in element ... */ignorableWhitespace(...)/** SAX2: Begin the scope of a prefix-URI Namespace mapping. */Integer eType/** SAX2: Report an XML comment anywhere in the document. *//** Prints the whole tree to standard output *//* DOMBuilder methods end */int child/** Returns the name of a node (attribute or element). */int nodehshort type/** Returns the namespace URI to which a node belongs *//** Returns the attribute node of a given type (if any) for an element */int attr/** Returns the value of a given attribute type of a given element *//** This method is for testing/debugging only *//** Returns an iterator with all the children of a given node */new ChildrenIterator(...)/** Returns an iterator with all children of a specific type ... */new TypedChildrenIterator(...)/** This is a shortcut to the iterators that implement the ... */new ParentIterator(...)new AttributeIterator(...)new DescendantIterator(...)new FollowingIterator(...)new PrecedingIterator(...)new FollowingSiblingIterator(...)new PrecedingSiblingIterator(...)new RootIterator(...)BasisLibrary.AXIS_SUPPORT_ERR/** Similar to getAxisIterator, but this one returns an iterator ... */new TypedSingletonIterator(...)setNodeType(...)new TypedAncestorIterator(...)new TypedAttributeIterator(...)new TypedDescendantIterator(...)new TypedFollowingIterator(...)new TypedPrecedingIterator(...)new TypedFollowingSiblingIterator(...)new TypedPrecedingSiblingIterator(...)new TypedNamespaceIterator(...)new TypedRootIterator(...)BasisLibrary.TYPED_AXIS_SUPPORT_ERR/** Do not think that this returns an iterator for the namespace axis. ... */new NamespaceChildrenIterator(...)new NamespaceAttributeIterator(...)new NamespaceWildcardIterator(...)/** Iterator that handles node tests that test for a namespace, but have ... */int m_nsType;/** The namespace type index. */DTMAxisIterator m_baseIterator;/** A nested typed axis iterator that retrieves nodes of the principal ... *//** Constructor NamespaceWildcard ... *//** Returns a deep copy of this iterator.  The cloned iterator is not ... */DTMAxisIterator nestedCloneNamespaceWildcardIterator cloneclone.m_baseIteratorclone.m_nsType/** True if this iterator has a reversed axis. ... */SAXImpl$NamespaceChildrenIterator/** Iterator that returns children within a given namespace for a ... */int _nsType;/** The extended type ID being requested. *//** Constructor NamespaceChildrenIterator ... */_firstch(...)_nextsib(...)makeNodeHandle(...)SAXImpl$NamespaceAttributeIterator/** Iterator that returns attributes within a given namespace for a node. */// end of NamespaceChildrenIterator/** Constructor NamespaceAttributeIterator ... */int nextNode/** Returns an iterator with all descendants of a node that are of ... */// end of NamespaceAttributeIterator/** Returns the nth descendant of a node */new NthDescendantIterator(...)/** Copy the string value of a node directly to an output handler *//** Copy a node-set to an output handler *//** Copy the whole tree to an output handler *//** Performs a deep copy (ref. XSLs copy-of()) ... */_exptype2(...)_exptype2Type(...)boolean oldEscapeSettingboolean escapeBit_firstch2(...)_nextsib2(...)copyPI(...)getBit(...)copyTextNode(...)copyAttribute(...)namespaceAfterStartElement(...)copyElement(...)copyNS(...)copyAttributes(...)/** Copies a processing instruction node to an output handler *//** Performs a shallow copy (ref. XSLs copy()) */int exptypeString uri1/** Returns a node' defined language for a node (if any) */int parentint langAttr/** Returns an instance of the DOMBuilder inner class ... *//** Return a SerializationHandler for output handling. ... */new ToXMLSAXHandler(...)/** Return a instance of a DOM class to be used as an RTF ... */int dtmPosgetFirstFreeDTMID(...)SimpleResultTreeImpl rtfnew SimpleResultTreeImpl(...)addDTM(...)AdaptiveResultTreeImpl rtfnew AdaptiveResultTreeImpl(...)/** Return the attributes map. ... *//** The getUnparsedEntityURI function returns the URI of the unparsed ... */DocumentType doctypegetDoctype(...)NamedNodeMap entitiesgetEntities(...)Entity entityString notationNamegetNotationName(...)// Is there a prefix?// Local part of name is after colon.  lastIndexOf returns -1 if// there is no colon, so lNameStartIdx will be zero in that case.// Distinguish attribute and element names.  Attribute has @ before// local part of name.// Extract local name// Delegate the work to getMapping2 if the document is not fully built.// Some of the processing has to be different in this case.// primitive types map to themselves// actual mapping of caller requested names// caller's types map into appropriate dom types// When the document is not fully built, the searchOnly// flag should be set to false. That means we should add// the type if it is not already in the expanded name table.//generalizedTypes[i] = getGeneralizedType(names[i], false);// Initialize all entries to -1// Use a smaller size for the space stack if the blocksize is small/* From DOMBuilder */// If the input source is DOMSource, set the _document field and// create the node2Ids table.// Resize the _dontEscape BitArray if necessary.// Look for any xml:space attributes// Depending on the implementation of attributes, this// might be faster than looping through all attributes. ILENE// Revert to strip/preserve-space setting from before this element// Check if the URI already exists before pushing on stack// Get the node type and make sure that it is within limits// Most common case handled first// Create a nested iterator that will select nodes of// the principal node kind for the selected axis.// For "attribute::p:*", the principal node kind is// attribute// This covers "namespace::p:*".  It is syntactically// correct, though it doesn't make much sense.// In all other cases, the principal node kind is// element// Return only nodes that are in the selected namespace//%HZ%: Added reference to DTMDefaultBase.ROOTNODE back in, temporarily// Start element definition//if(isChild) => not to copy any namespaces  from parents// else copy all namespaces in scope// Copy element children// Close element definition// Shallow copy of attribute to output handler// Special handling for DOM inputimport DTMManagerDefaultimport EmptySerializerimport XMLStringDefault/** This class represents a light-weight DOM model for simple result tree fragment(RTF). ... */new DTMAxisIteratorBase(...) { ... }SimpleResultTreeImpl$1SimpleResultTreeImpl$SimpleIterator/** The SimpleIterator is designed to support the nodeset() extension function. It has ... */int DIRECTION_UP;int DIRECTION_DOWN;int _direction;// DOWN is for child and descendant. UP is for parent and ancestor.// The direction of traversal (default to DOWN).SimpleResultTreeImpl$SingletonIterator/** The SingletonIterator is used for the self axis. */// END of SimpleIteratorDTMAxisIterator EMPTY_ITERATOR;// END of SingletonIteratorint RTF_ROOT;// The root node id of the simple RTFint RTF_TEXT;// The Text node id of the simple RTF (simple RTF has only one Text node).int NUMBER_OF_NODES;// The number of nodes.// Constant for empty String// This is set at the endDocument() call.// The String value of the Text node....[] _textArray;// can have different escape settings.// The characters() interface can be called multiple times. Each character item// The array of Text items, which is built by the characters() call.// Number of character itemsint _documentID;// The document ID// A BitArray, each bit holding the escape setting for a character item.// The current escape setting// Create a SimpleResultTreeImpl from a DTMManager and a document ID.new SimpleIterator(...)SimpleIterator.DIRECTION_DOWN// The SimpleIterator is used for the child, descendant, parent and ancestor axes.// Return the axis iterator for a given axis.SimpleIterator.DIRECTION_UP// %REVISIT% Can this one ever get used?// %REVISIT% Can the makeNode() and makeNodeList() interfaces ever get used?/** We only need to override the endDocument, characters, and ... */_textArray.lengthString[] newTextArray/** The DTM interfaces are not used in this class. Implementing the DTM ... */new XMLStringDefault(...)/* $Id: SimpleResultTreeImpl.java,v 1.2.4.1 2005/09/06 10:09:25 pvedula Exp $ */// Increase the node ID for down traversal. Also match the node type// if the type is given.// Decrease the node ID for up traversal.// Increase the node ID by 1 if self is not included.// Set the String value when the document is built.// Resize the text array if necessary// If the escape setting is false, set the corresponding bit in// the _dontEscape BitArray.// The _dontEscape array is only created when needed.// Resize the _dontEscape array if necessary...[] EmptyArray;DTMAxisIterator _countSiblings;boolean matchesCountint fromnew DefaultSingleNodeCounter(...)// found target// no target found// Target found, but need to check if ancestor matches from// found from// Have we found ancestor matching from?// If no target found then pass the empty listboolean _isConstant;/** Override the value of <tt>_node</tt> only when this ... *//** Class for carrying settings that are to be used for a particular set ... *//** A reference to the translet object for the transformation. */...[] _sortOrders;/** The sort order (ascending or descending) for each level of ... */...[] _types;/** The type of comparison (text or number) for each level of ... */...[] _locales;/** The Locale for each level of <code>xsl:sort</code>, based on any lang ... *//** The Collator object in effect for each level of <code>xsl:sort</code> */...[] _caseOrders;/** Case ordering for each level of <code>xsl:sort</code>. *//** Create an instance of <code>SortSettings</code>. ... */int INIT_DATA_SIZE;NodeSortRecordFactory _factory;...[] _data;// index in _nodes of the next node to trynew NodeSortRecord[]makeNodeSortRecord(...)/** Clone a <code>SortingIterator</code> by cloning its source ... */SortingIterator cloneclone._factoryclone._dataclone._freeclone._current_data.lengthNodeSortRecord[] newArrayNodeSortRecord xNodeSortRecord t// gather all nodes from the source iterator// now sort the records// shared between clones/** A step iterator is used to evaluate expressions like "BOOK/TITLE". ... *//** A reference to the "outer" iterator. *//** A reference to the "inner" iterator. *//** Temp variable to store a marked position. */StepIterator cloneclone._iterator// System.out.println("SI source = " + source + " this = " + this);// System.out.println("SI iterator = " + iterator + " this = " + this);// must be restartable// Set start node for left-hand iterator...// ... and get start node for right-hand iterator from left-hand,// with special case for //* path - see ParentLocationPath// Special case for //* path - see ParentLocationPath// Try to get another node from the right-hand iterator// If not, get the next starting point from left-hand iterator...// ...and pass it on to the right-hand iterator//_pos = _position;//_position = _pos;/** UnionIterator takes a set of NodeIterators and produces ... */DTMAxisIterator iterator;this.iteratorLookAheadIterator cloneclone.iteratorLookAheadIterator comparand// end of LookAheadIteratornew LookAheadIterator(...)import XMLEventReaderimport XMLStreamReaderimport StAXSourceimport DTMExceptionimport XMLErrorResourcesimport XMLMessagesimport DOM2SAXimport StAXEvent2SAXimport StAXStream2SAXimport SAXNotRecognizedException/** The default implementation for the DTMManager. */boolean DUMPTREE;/** Set this to true if you want a dump of the DTM after creation *//** Set this to true if you want basic diagnostics *//** Constructor DTMManagerDefault *//** Obtain a new instance of a <code>DTMManager</code>. ... */new XSLTCDTMManager(...)/** Creates a new instance of the XSLTC DTM Manager service. ... *//** Get an instance of a DTM, loaded with the content from the ... */int documentIDStAXSource staxSourceStAXEvent2SAX staxevent2saxStAXStream2SAX staxStream2SAXSAXImpl dtmgetXMLEventReader(...)XMLEventReader xmlEventReadernew StAXEvent2SAX(...)getXMLStreamReader(...)XMLStreamReader xmlStreamReadernew StAXStream2SAX(...)new SAXImpl(...)DTMDefaultBase.DEFAULT_BLOCKSIZEnew WrappedRuntimeException(...)DOM2SAX dom2saxnew DOM2SAX(...)boolean isSAXSourceboolean isStreamSourceInputSource xmlSourceString urlOfSourcesourceToInputSource(...)getBuilder(...)releaseXMLReader(...)dumpDTM(...)new DTMException(...)createXMLMessage(...)XMLErrorResources.ER_NOT_SUPPORTED// Make sure the user didn't lie// %REVIEW% Is there a better way to send a warning?// Create the basic SAX2DTM.// Go ahead and add the DTM to the lookup table.  This needs to be// done before any parsing occurs. Note offset 0, since we've just// created a new DTM.// Then the user will construct it themselves.// It should have been handled by a derived class or the caller// made a mistake.import DOMAdapterimport KeyIndeximport DecimalFormatimport DecimalFormatSymbolsimport DOMImplementationnew StringValueHandler(...)// appear as fields (with the same type, only public) in Output.javaboolean _isStandalone;//see OutputPropertiesFactory.ORACLE_IS_STANDALONEVector<> _cdata;int _indentamount;int FIRST_TRANSLET_VERSION;int VER_SPLIT_NAMES_ARRAY;int CURRENT_TRANSLET_VERSION;int transletVersion;// this default value).// before the notion of a translet version was introduced, it will get// version; if it doesn't override the value (because it was compiled// AbstractTranslet may override this value to a more recent translet// Initialize Translet version field to base value.  A class that extends...[] namesArray;// DOM/translet handshaking - the arrays are set by the compiled translet...[] urisArray;...[] typesArray;...[] namespaceArray;Templates _templates;// The Templates object that is used to create this Translet instance// Boolean flag to indicate whether this translet has id functions.StringValueHandler stringValueHandler;// TODO - these should only be instanciated when needed// Use one empty string instead of constantly instanciating String("");String ID_INDEX_NAME;// This is the name of the index used for ID attributes/** protocols allowed for external references set by the stylesheet processing instruction, Document() function, Import and Include element. *//** ********************************************************************** ... */namesArray.lengthnamespaceArray.lengthtotalMemory(...)/** Wrap the initial input DOM in a dom adapter. This adapter is wrapped in ... */setRootForKeys(...)int pbase, ...;// to denote the current parameter frame.// Parameter's stack: <tt>pbase</tt> and <tt>pframe</tt> are usedArrayList<> paramsStack;/** Push a new parameter frame. *//** Pop the topmost parameter frame. */int oldpbase/** Add a new global parameter if not already in the current frame. ... *//** Add a new global or local parameter if not already in the current frame. ... */param._isDefault/** Clears the parameter stack. *//** Get the value of a parameter from the current frame or ... */MessageHandler _msgHandler;// used, such as a dialog box for applets, etc.// The deault message handler dumps a string stdout, but anything can be// Holds the translet's message handler - used for <xsl:message>./** Set the translet's message handler - must implement MessageHandler *//** Pass a message to the message handler - used by Message class. */displayMessage(...)Map<String,DecimalFormat> _formatSymbols;// Contains decimal number formatting symbols used by FormatNumberCall/** Adds a DecimalFormat object to the _formatSymbols map. ... */DecimalFormat dfnew DecimalFormat(...)new HashMap<String,DecimalFormat>(...)setDecimalFormatSymbols(...)/** Retrieves a named DecimalFormat object from the _formatSymbols map. *//** Give the translet an opportunity to perform a prepass on the document ... */setIndexSize(...)buildIDIndex(...)/** Leverages the Key Class to implement the XSLT id() function. ... */buildKeyIndex(...)Map<String,Integer> elementsByIDboolean hasIDValuesEntry<String,Integer> entryMap<>.Entry<String,Integer>setKeyIndexDom(...)/** After constructing the translet object, this method must be called to ... */int arraySizeString[] newURIsArrayString[] newNamesArrayint[] newTypesArrayBasisLibrary.UNKNOWN_TRANSLET_VERSION_ERRMap<String,KeyIndex> _keyIndexes;// Container for all indexes for xsl:key elementsKeyIndex _emptyKeyIndex;int _indexSize;int _currentRootForKeys;/** This method is used to pass the largest DOM size to the translet. ... *//** Creates a KeyIndex object of the desired size - don't want to resize!!! *//** Adds a value to a key/id index ... */KeyIndex indexbuildKeyIndexHelper(...)/** Create an empty KeyIndex in the DOM case ... */setDom(...)/** Return KeyIndex for the buildKeyIndex methods. Note the difference from the ... */new HashMap<String,KeyIndex>(...)/** Returns the index for a given key (or id). ... *//** This method builds key indexes - it is overridden in the compiled ... */getKeyIndex(...)DOMCache _domCache;// Hold the DOM cache (if any) used with this translet/** Sets the DOM cache used for additional documents loaded using the ... *//** Returns the DOM cache used for this translet. Used by the LoadDocument ... */TransletOutputHandlerFactory factoryString dirStrSerializationHandler handlersetOutputStream(...)new BufferedOutputStream(...)transferOutputSettings(...)openOutputHandler(...)/** Main transform() method - this is overridden by the compiled translet *//** Calls transform() with a given output handler *//** Used by some compiled code as a shortcut for passing strings to the ... *//** Add's a name of an element whose text contents should be output as CDATA */int lastColon/** Transfer the output settings to the output post-processor */setStandalone(...)setOmitXMLDeclaration(...)setCdataSectionElements(...)setIndent(...)setIndentAmount(...)setDoctype(...)setIsStandalone(...)setMediaType(...)Map<String,Class<?>> _auxClasses;new HashMap<String,Class<?>>(...)// GTM added (see pg 110)/** Return the state of the services mechanism feature. *//** Set the state of the services mechanism feature. */DOMImplementation _domImplementation;DocumentBuilderFactory dbfgetDOMFactory(...)getDOMImplementation(...)createDocument(...)/* /* ... */// Local parameters need to be re-evaluated for each iteration// Only overwrite if current value is the default value and// the new value is _NOT_ the default value.// Add new parameter to parameter stack// Instanciate map for formatting symbols if needed// The name cannot be null - use empty string instead// Construct a DecimalFormat object containing the symbols we got// If the input source is DOMSource, the KeyIndex table is not// built at this time. It will be built later by the lookupId()// and containsId() methods of the KeyIndex class.// Given a Map of DTM nodes indexed by ID attribute values,// loop through the table copying information to a KeyIndex// for the mapping from ID attribute value to DTM node// If the version of the translet had just one namesArray, split// it into multiple fields.// Distinguish attribute and element names.  Attribute has// @ before local part of name.// Was translet compiled using a more recent version of the XSLTC// compiler than is known by the AbstractTranslet class?  If, so// and we've made it this far (which is doubtful), we should give up.// Return an empty key index iterator if none are defined// Look up the requested key index// Return an empty key index iterator if the requested index not found// what can you do?//final int length = string.length();int _element;import AbsoluteIteratorimport ArrayNodeListIteratorimport MultiDOMimport SingletonIteratorimport StepIteratorimport NamespaceMappingsimport FieldPositionimport NumberFormatimport Attr/** Standard XSLT functions. All standard functions expect the current node ... */new ThreadLocal<StringBuilder>(...) { ... }BasisLibrary$1new ThreadLocal<StringBuffer>(...) { ... }BasisLibrary$2NumberFormat fsetMaximumFractionDigits(...)setMinimumFractionDigits(...)setMinimumIntegerDigits(...)setGroupingUsed(...)new DecimalFormatSymbols(...)new FieldPosition(...)new ThreadLocal<AtomicInteger>(...) { ... }BasisLibrary$4String resourceThreadLocal<StringBuilder> threadLocalStringBuilder;/** Re-use a single instance of StringBuffer (per thread) in the basis library. ... */ThreadLocal<StringBuffer> threadLocalStringBuffer;/** ThreadLocal for StringBuffer used *//** Standard function count(node-set) *//** Standard function position() ... *//** XSLT Standard function sum(node-set). ... *//** XSLT Standard function string() *//** XSLT Standard function string(value) */(...).nodeDouble d/** XSLT Standard function number() */stringToReal(...)/** XSLT Standard function number(value) */DTMAxisIterator iter/** XSLT Standard function round() */floor(...)/** XSLT Standard function boolean() */double temp/** XSLT Standard function substring(). Must take a double because of ... */int strlengetStringLength(...)int istartint ilengthint isum/** XSLT Standard function substring-after(). *//** XSLT Standard function substring-before(). *//** XSLT Standard function translate(). */int tolint fromlint valuel/** XSLT Standard function normalize-space(). */normalize_spaceF(...)/** XSLT Standard function normalize-space(string). */isWhiteSpace(...)/** XSLT Standard function generate-id(). *//** utility function for calls to local-name(). *//** External functions that cannot be resolved are replaced with a call ... *//** Utility function to throw a runtime error on the use of an extension ... *//** Utility function to throw a runtime error for an unsupported element. ... *//** XSLT Standard function namespace-uri(node-set). */namespace_uriF(...)/** XSLT Standard function system-property(name) *//** XSLT Standard function namespace-uri(). *//** Implements the object-type() extension function. ... *//** Implements the nodeset() extension function. *///-- Begin utility functionsnumberF(...)/** Utility function: node-set/node-set compare. */int lnodeString lvalueint rnodecompareStrings(...)/** Utility function: node-set/number compare. *//** Utility function: node-set/string comparison. */boolean hasSimpleArgshasSimpleType(...)booleanF(...)Object tempswapOp(...)String sleftcompare(...)/** Utility function: used to test context node's language */String nodeLang/** Utility function: used in StringType to convert a string to a real. *//** Utility function: used in StringType to convert a string to an int. */int DOUBLE_FRACTION_DIGITS;double lowerBounds;double upperBounds;DecimalFormat defaultFormatter, ...;String defaultPattern;/** Utility function: used in RealType to convert a real to a string. ... *//** Utility function: used in RealType to convert a real to an integer */FieldPosition _fieldPosition;/** Utility function: used to format/adjust  a double to a string. The ... */applyLocalizedPattern(...)/** Utility function: used to convert references to node-sets. If the ... *//** Utility function: used to convert reference to org.w3c.dom.NodeList. */referenceToNodeSet(...)/** Utility function: used to convert reference to org.w3c.dom.Node. *//** Utility function: used to convert reference to long. *//** Utility function: used to convert reference to double. *//** Utility function: used to convert reference to boolean. *//** Utility function: used to convert reference to String. *//** Utility function used to convert a w3c Node into an internal DOM iterator. */Node inNodenew NodeList(...) { ... }BasisLibrary$3nodeList2Iterator(...)/** In a perfect world, this would be the implementation for ... */int[] dtmHandlesint handlegetDTMHandleFromNode(...)/** Utility function used to convert a w3c NodeList into a internal ... */int[] proxyNodesDTMAxisIterator childIterDTMAxisIterator attrIterElement midDTMNodeProxy proxyDTM nodeDTMboolean isOurDOMAbstractTranslet atNode.TEXT_NODENode.CDATA_SECTION_NODENode.COMMENT_NODENode.ENTITY_REFERENCE_NODENode.PROCESSING_INSTRUCTION_NODEimportNode(...)getDocumentElement(...)Node.ATTRIBUTE_NODEsetAttributeNodeNS(...)MultiDOM multiDOMDTMAxisIterator iter1DTMAxisIterator iter2new AbsoluteIterator(...)new StepIterator(...)DTMAxisIterator iter3new InternalRuntimeError(...)dtmHandles.length/** Utility function used to convert references to DOMs. *//** Utility function: used with nth position filters to convert a sequence ... */...[] _characterArray;/** Utility function: used in xsl:copy. */_characterArray.length/** Utility function to check if xsl:attribute has a valid qname ... */int firstOccurint lastOccurString newPrefixString oriPrefixConstants.XMLNS_PREFIX/** Utility function to check if a name is a valid ncname ... *//** Utility function to check if a name is a valid qname ... *//** Utility function for the implementation of xsl:element. */NamespaceMappings nmgetNamespaceMappings(...)flushPending(...)generatePrefix(...)/** This function is used in the execution of xsl:element *//** These functions are used in the execution of xsl:element to generate ... */ThreadLocal<AtomicInteger> threadLocalPrefixIndex;String RUN_TIME_INTERNAL_ERR;String RUN_TIME_COPY_ERR;String EXTERNAL_FUNC_ERR;String EQUALITY_EXPR_ERR;String INVALID_ARGUMENT_ERR;String FORMAT_NUMBER_ERR;String ITERATOR_CLONE_ERR;String AXIS_SUPPORT_ERR;String TYPED_AXIS_SUPPORT_ERR;String STRAY_NAMESPACE_ERR;String NAMESPACE_PREFIX_ERR;String DOM_ADAPTER_INIT_ERR;String PARSER_DTD_SUPPORT_ERR;String NAMESPACES_SUPPORT_ERR;String CANT_RESOLVE_RELATIVE_URI_ERR;String UNKNOWN_TRANSLET_VERSION_ERR;String UNALLOWED_EXTENSION_FUNCTION_ERR;String UNALLOWED_EXTENSION_ELEMENT_ERR;ResourceBundle m_bundle;/** Print a run-time error message. *//** Utility method to allow setting parameters of the form ... *//** Utility method to calculate string-length as a number of code points, ... */codePointCount(...)/* $Id: BasisLibrary.java,v 1.6 2006/06/20 21:51:58 spericas Exp $ */// When the first argument is a DOM we want the whole// DOM and not just a single node - that would not make sense.//return ((DOM)obj).getStringValueX(node);// Only generate ID if node exists// Otherwise return an empty string//final DOMAdapter adapter = (DOMAdapter) obj;// String value must be the same if both nodes are the same//iterator.reset();// Assume we're comparing document order here//left.reset();// If node-boolean comparison -> convert node to boolean// compare them as strings// swap operands and operator// language for context node (if any)// compare context node's language agains test language// Set max fraction digits so that truncation does not occur. Setting// the max to Integer.MAX_VALUE may cause problems with some JDK's.// This formatter is used to convert numbers according to the XPath// 1.0 syntax which ignores locales (http://www.w3.org/TR/xpath#NT-Number)// Remove leading zeros.//Convert -0.0 to +0.0 other values remains the same// Use the XPath formatter to ignore locales// bugzilla fix 12813// Convert var/param -> node// Convert var/param -> node-set// handles Integer and Double// Create a dummy NodeList which only contains the given node to make// use of the nodeList2Iterator() interface.// First pass: build w3c DOM for all nodes not proxied from our DOM.// Notice: this looses some (esp. parent) context for these nodes,// so some way to wrap the original nodes inside a DTMAxisIterator// might be preferable in the long run.// allow for change in list length, just in case.// invalid node handle, so definitely not our doc// Use one dummy element as container for each node of the// list. That way, it is easier to detect resp. avoid// funny things which change the number of nodes,// e.g. auto-concatenation of text nodes.// The mid element also serves as a container for// attributes, avoiding problems with conflicting// attributes or node order.// Better play it safe for all types we aren't sure we know// how to deal with.// w3cDOM -> DTM -> DOMImpl// Create DOMAdapter and register with MultiDOM// Second pass: find DTM handles for every node in the list.// Should not happen, as first run should have got all these// For now, play it self and perform extra checks://((DOM)obj).copy(((com.sun.org.apache.xml.internal.dtm.ref.DTMDefaultBase)((DOMAdapter)obj).getDOMImpl()).getDocument(), handler);// or call stringF()// even though the orignal prefix is ignored, it should still get checked for valid NCName// prefix must be a valid NCName// local name must be a valid NCName and must not be XMLNS// Get prefix from qname// Handle case when prefix is not known at compile time// not sure if this line of code ever works// need to flush or else can't get namespacemappings// Need to generate a prefix?//-- End utility functions/** This class defines constants used by both the compiler and the ... */int ANY;int PROCESSING_INSTRUCTION;/* XSLTC run-time error messages. ... */BasisLibrary.RUN_TIME_INTERNAL_ERRBasisLibrary.RUN_TIME_COPY_ERRBasisLibrary.DATA_CONVERSION_ERRBasisLibrary.EXTERNAL_FUNC_ERRBasisLibrary.EQUALITY_EXPR_ERRBasisLibrary.INVALID_ARGUMENT_ERRBasisLibrary.FORMAT_NUMBER_ERRBasisLibrary.STRAY_NAMESPACE_ERRBasisLibrary.DOM_ADAPTER_INIT_ERRBasisLibrary.PARSER_DTD_SUPPORT_ERRBasisLibrary.CANT_RESOLVE_RELATIVE_URI_ERRBasisLibrary.UNSUPPORTED_XSL_ERRBasisLibrary.UNSUPPORTED_EXT_ERRBasisLibrary.INVALID_QNAME_ERRBasisLibrary.INVALID_NCNAME_ERRBasisLibrary.UNALLOWED_EXTENSION_FUNCTION_ERRBasisLibrary.UNALLOWED_EXTENSION_ELEMENT_ERR/* Note to translators:  the substitution text in the following message ... *//* Note to translators:  <xsl:copy> is a keyword that should not be ... *//* Note to translators:  This message is displayed if the function named ... *//* Note to translators:  This message is displayed if two values are ... *//* Note to translators:  The substitution text for {0} will be a data ... *//* Note to translators:  There is way of specifying a format for a ... *//* Note to translators:  The following represents an internal error ... *//* Note to translators:  As with the preceding message, a namespace ... *//* Note to translators:  The following represents an internal error. ... *//* Note to translators:  The following message indicates that the XML ... *//* Note to translators:  The substitution text is the URI that was in ... *//* Note to translators:  This error message is produced if the translet ... *//* Note to translators:  An attribute whose effective value is required ... *//** Class to express failed assertions and similar for the xsltc runtime. ... *//** This class is used as "wrapper" for dom nodes. Wrappers are needed when ... */...[] swapOpArray;//  Swap operator array// EQ// NE// GT// LT// GE// LEObject _value;boolean _isDefault;StringBuilder _buffer;String _str;boolean m_escaping;int _nestedLevel;// aware that that method might be called.// Override the setEscaping method just to indicate that this class isboolean oldEscaping/** The value of a PI must not contain the substring "?>". Should ... */StringBuilder valueOfPIStringBuffer _buffer;import XMLEventWriterimport XMLEventConsumerimport XMLStreamWriterimport SAX2DOMimport SAX2StAXEventWriterimport SAX2StAXStreamWriterimport ToHTMLSAXHandlerimport ToTextSAXHandlerimport ToTextStreamimport ToUnknownStreamimport ToXMLStreamint SAX;int DOM;int STAX;OutputStream _ostream;Writer _writer;Node _node;Node _nextSibling;XMLEventWriter _xmlStAXEventWriter;XMLStreamWriter _xmlStAXStreamWriter;int _indentNumber;ContentHandler _handler;LexicalHandler _lexHandler;new TransletOutputHandlerFactory(...)getDOM(...)getEventWriter(...)getStreamWriter(...)SerializationHandler resultnew ToUnknownStream(...)new ToXMLStream(...)new ToHTMLStream(...)new ToTextStream(...)setWriter(...)new SAX2DOM(...)new SAX2StAXEventWriter(...)new SAX2StAXStreamWriter(...)new ToHTMLSAXHandler(...)new ToTextSAXHandler(...)// again falls through - Padmaja Vedula// default caseimport BufferedWriterString osNameint KB;/** Initializes a WriterOutputBuffer by creating an instance of a ... */new BufferedWriter(...)// Set a larger buffer size for Solarisimport SAXImplimport ErrorHandlernew HashMap<String,Stack<>>(...)Node _dom;ContentHandler _sax;LexicalHandler _lex;SAXImpl _saxImpl;Map<String,Stack<>> _nsPrefixes;/** Begin the scope of namespace prefix. Forward the event to the ... */boolean pushedStack<> uriStackString lastUri/* End the scope of a name prefix by popping it from the stack and ... */endPrefixMapping(...)/** If the DOM was created using a DOM 1.0 API, the local name may be ... */boolean isIncompleteNode.DOCUMENT_NODE/** Traverse the DOM and generate SAX events for a handler. A ... */Node firstString cdataNode nextVector<> pushedPrefixesAttributesImpl attrsNamedNodeMap mapint nPushedPrefixesString dataNode.DOCUMENT_FRAGMENT_NODENode.DOCUMENT_TYPE_NODENode.ENTITY_NODENode.NOTATION_NODEstartCDATA(...)endCDATA(...)setDocumentLocator(...)String qnameAttrString uriAttrString localNameAttr/** This class is only used internally so this method should never ... */// Debugging/* $Id: DOM2SAX.java,v 1.2.4.1 2005/09/06 11:52:46 pvedula Exp $ */// handled by ELEMENT_NODE// These node types are ignored!!!// in the case where there is no lex handler, we still// want the text of the cdate to make its way through.// should be handled!!!// Process all namespace declarations// Ignore everything but NS declarations here// Process all other attributes// Ignore NS declarations here// Uri may be implicitly declared// If no prefix for this attr, we need to create// one because we cannot use the default ns// Add attribute to list// Now process the element itself// Generate SAX event to start element// Traverse all child nodes of the element (if any)// Generate SAX event to close element// Generate endPrefixMapping() for all pushed prefixesimport Locator2/** A reference to the DOM to be traversed. *//** A reference to the output handler receiving the events. */String xmlVersion;String xmlEncoding;/** Traverse the DOM and generate TO events for a handler. Notice that ... */new NamespaceMappings(...)setDocumentInfo(...)generateNextPrefix(...)getXmlStandalone(...)setXMLVersion(...)getXmlVersion(...)getXmlEncoding(...)// Empty// Process all namespace attributes first// Is this a namespace declaration?// Process all non-namespace attributes next// Is this a regular attribute?// Fix for bug 26319// For attributes not given an prefix explictly// but having a namespace uri we need// to explicitly generate the prefix// Now element namespace and children// If an element foo is created using// createElementNS(null,locName)// then the  element should be serialized// <foo xmlns=" "/>String _cdata_section_elements;String _doctype_public;String _indent;String _media_type;String _omit_xml_declaration;Properties propertiesimport Commentimport ProcessingInstructionNode _root;Stack<> _nodeStk;Vector<> _namespaceDecls;Node _lastSibling;boolean needToSetDocumentInfo;StringBuilder _textBuffer;//Replace StringBuffer with StringBuilder now that we no long support jdk1.4Node _nextSiblingCache;DocumentBuilderFactory _factory;/** JAXP document builder factory. Create a single instance and use ... */boolean _internal;Node lastsetXmlVersion(...)getXMLVersion(...)Element tmpint nattrsappendTextNode(...)int nDeclssetAttributeNS(...)String attQNameString attURIgetURI(...)setIdAttribute(...)setIdAttributeNS(...)/** adds processing instruction node to DOM. */ProcessingInstruction picreateProcessingInstruction(...)this.locator/** Lexical Handler method to create comment node in DOM tree. */Comment commentcreateComment(...)// Lexical Handler methods- not implementedSAX2DOM.class// Ignore text nodes of length 0// No text nodes can be children of root (DOM006 exception)//try to set document version// Add namespace declarations first// Add attributes to element/* final int nattrs = attrs.getLength(); ... */// checking if Namespace processing is being done// Append this new node onto current stack node// If the SAX2DOM is created with a non-null next sibling node,// insert the result nodes before the next sibling under the root.// Push this node onto stack//default implementation is thread safeimport Locationimport XMLReporterimport XMLStreamExceptionimport SAXParseExceptionimport DefaultHandlerboolean isCDATA;StringBuffer CDATABuffer;Vector<> namespaces;Locator docLocator;XMLReporter reporter;this.reporterthis.docLocatornew SAXLocation(...)/** Used to report a {@link SAXException}to the {@link XMLReporter} ... */report(...)getCurrentLocation(...)XMLStreamException e1/** Parses an XML qualified name, and places the resulting prefix and local ... */SAX2StAXBaseWriter$SAXLocation/** {@Link Location}implementation used to expose details from a SAX ... */int lineNumber;int columnNumber;String publicId;String systemId;import XMLEventFactoryimport javax.xml.stream.events.*XMLEventWriter writer;XMLEventFactory eventFactory;List<> namespaceStack;boolean needToCallStartDocument;this.writerthis.eventFactorycreateStartDocument(...)getEncoding(...)XMLStreamException ecreateEndDocument(...)Collection<>[] eventsnew Collection<>[]writeStartDocument(...)createStartEvents(...)String[] qnameparseQName(...)createStartElement(...)Collection<> nsListIterator<> nsItercreateEndElement(...)createCharacters(...)createCData(...)Map<> nsMapList<> attrsNamespace nscreateNamespace(...)String attrPrefixString attrLocalString attrURICollections.EMPTY_LIST// Encoding and version info will be available only after startElement// is called for first time. So, defer START_DOCUMENT event of StAX till// that point of time.// clear the namespaces// set document location// create attribute and namespace events// parse name// get namespaces// Drat. We were trying to postpone this until the first element so that we could get// the locator, but we can't output a comment before the start document, so we're just// going to have to do without the locator if it hasn't been set yet.// the locator, but we can't output a PI before the start document, so we're just// create namespaces// create attributes// namespace declaration disguised as an attribute. If the// namespace has already been declared, skip it, otherwise// write it as an namespaceXMLStreamWriter writer;writeEndDocument(...)writeStartElement(...)setDefaultNamespace(...)setPrefix(...)writeNamespace(...)writeEndElement(...)writeComment(...)writeCharacters(...)writeCData(...)writeProcessingInstruction(...)//Do not call writeStartElement with prefix and namespaceURI, as it writes out//namespace declaration.//writer.writeStartElement(qname[0], qname[1], uri);// No need to write namespaces, as they are written as part of attributes./* if (namespaces != null) { ... */// write attributes// namespace declaration disguised as an attribute.import TemplatesHandlerimport XMLFilter/** Implementation of a transformer factory that uses an XSLTC ... */String CLASS_NAME;/** <p>Name of class as a constant to use for debugging.</p> */SAXTransformerFactory _xsltcFactory;SAXTransformerFactory _xalanFactory;SAXTransformerFactory _currFactory;ErrorListener _errorlistener;URIResolver _uriresolver;boolean featureSecureProcessing;/** <p>State of secure processing feature.</p> *//** implementation of the SmartTransformerFactory. This factory ... */new TransformerFactoryImpl(...)String xalanMessageClass<> xalanFactClasscreateXSLTCTransformerFactory(...)createXalanTransformerFactory(...)/** <p>Set a feature for this <code>SmartTransformerFactory</code> and <code>Transformer</code>s ... */new TransformerConfigurationException(...)/** javax.xml.transform.sax.TransformerFactory implementation. ... */String[] featuresDOMSource.FEATUREDOMResult.FEATURESAXSource.FEATURESAXResult.FEATUREStreamSource.FEATUREStreamResult.FEATUREfeatures.length/** Create a Transformer object that copies the input document to the ... *//** Create a Transformer object that from the input stylesheet ... *//** Create a Templates object that from the input stylesheet ... *//** Get a TemplatesHandler object that can process SAX ContentHandler ... */newTemplatesHandler(...)/** Get a TransformerHandler object that can process SAX ContentHandler ... *//** Create an XMLFilter that uses the given source as the ... */Templates templatesnewXMLFilter(...)/* Create an XMLFilter that uses the given source as the ... */new TrAXFilter(...)TransformerConfigurationException e1ErrorListener errorListenergetErrorListener(...)fatalError(...)TransformerException e2/* $Id: SmartTransformerFactoryImpl.java,v 1.2.4.1 2005/09/14 09:57:13 pvedula Exp $ */// try to create instance of Xalan factory...// GTM: NB: 'debug' should change to something more unique...// feature name cannot be null// secure processing?// all done processing feature// unknown feature// All supported features should be listed here// Inefficient, but it really does not matter in a function like thisimport QNameimport XMLStreamConstantsimport Charactersimport EndElementimport Namespaceimport StartElementimport XMLEventimport StartDocumentXMLEventReader staxEventReader;// StAX event source//private static final String XMLNS_PREFIX = "xmlns";//private final static String EMPTYSTRING = "";//private Node _dom = null;String encoding;bridge(...)//Main Work Starts Here./* @see StAXReaderToContentHandler#bridge() *//* public void parse() throws IOException, SAXException { ... */boolean startedAtDocumentXMLEvent eventisStartDocument(...)isStartElement(...)getEventType(...)XMLStreamConstants.START_DOCUMENTencodingSet(...)getCharacterEncodingScheme(...)nextEvent(...)handleStartDocument(...)XMLStreamConstants.START_ELEMENTXMLStreamConstants.CHARACTERShandleCharacters(...)asCharacters(...)XMLStreamConstants.PROCESSING_INSTRUCTIONhandlePI(...)XMLStreamConstants.COMMENThandleComment(...)XMLStreamConstants.DTDhandleDTD(...)XMLStreamConstants.SPACEhandleSpace(...)handleStartElement(...)asStartElement(...)XMLStreamConstants.END_ELEMENThandleEndElement(...)asEndElement(...)XMLStreamConstants.ENTITY_REFERENCEhandleEntityReference(...)XMLStreamConstants.ATTRIBUTEhandleAttribute(...)XMLStreamConstants.NAMESPACEhandleNamespace(...)XMLStreamConstants.CDATAhandleCDATA(...)XMLStreamConstants.ENTITY_DECLARATIONhandleEntityDecl(...)XMLStreamConstants.NOTATION_DECLARATIONhandleNotationDecl(...)XMLStreamConstants.END_DOCUMENThandleEndDocument(...)new XMLStreamException(...)new Locator2(...) { ... }StAXEvent2SAX$1QName qNameIterator<Namespace> igetNamespaces(...)String rawnameAttributes saxAttrs/** Get the attributes associated with the given START_ELEMENT StAXevent. ... */Iterator<Attribute> iAttribute staxAttrString qNamegetDTDType(...)// remembers the nest level of elements to know when we are done.// that gets the one we peeked at// that really gets the next one// Handle the prolog: http://www.w3.org/TR/REC-xml/#NT-prolog// Process the (document) element// These are all of the events listed in the javadoc for// XMLEvent.// The spec only really describes 11 of them.// Handle the Misc (http://www.w3.org/TR/REC-xml/#NT-Misc) that can follow the document element//construct prefix:localName from qName// fire endElement// end namespace bindings// true for default namespace// start namespace bindings// fire startElement// in SAX, namespace declarations are not part of attributes by default.// (there's a property to control that, but as far as we are concerned// we don't use it.) So don't add xmlns:* to attributes.// gather non-namespace attrs// no-op ???// namespace events don't normally occur outside of a startElement// or endElement// attribute events don't normally occur outside of a startElement// it seems like we need to pass this info along, but how?// this event is listed in the javadoc, but not in the spec.XMLStreamReader staxStreamReader;// StAX Stream sourceint eventnextTag(...)StAXStream2SAX$1getPITarget(...)getPIData(...)getTextLength(...)getTextCharacters(...)int nsCountgetNamespaceCount(...)getNamespacePrefix(...)Attributes attrs/** Get the attributes associated with the given START_ELEMENT or ATTRIBUTE ... */int eventTypegetAttributeCount(...)getAttributeNamespace(...)getAttributeLocalName(...)getAttributePrefix(...)getAttributeType(...)/* Copyright (c) 2005, 2015, Oracle and/or its affiliates. All rights reserved. ... */// skip over START_DOCUMENT// If not a START_ELEMENT (e.g., a DTD), skip to next tag// An error if a START_ELEMENT isn't found now// workaround for bugid 5046319 - switch over to commented section// below when it is fixed.//        int start = 0;//        int len;//        do {//            len = staxStreamReader.getTextCharacters(start, buf, 0, buf.length);//            start += len;//            try {//                _sax.characters(buf, 0, len);//            } catch (SAXException e) {//                throw new XMLStreamException(e);//        } while (len == buf.length);import CompilerExceptionimport SourceLoader/** Implementation of a JAXP1.1 TemplatesHandler ... *//** System ID for this stylesheet. *//** Number of spaces to add for output indentation. */URIResolver _uriResolver;/** This URIResolver is passed to all Transformers. */TransformerFactoryImpl _tfactory;/** A reference to the transformer factory that this templates ... *//** A reference to XSLTC's parser object. */TemplatesImpl _templates;/** The created Templates object. *//** Default constructor */getJdkXmlFeatures(...)setSecureProcessing(...)TransformerFactoryImpl.ENABLE_INLINING/** Implements javax.xml.transform.sax.TemplatesHandler.getSystemId() ... *//** Implements javax.xml.transform.sax.TemplatesHandler.setSystemId() ... *//** Store URIResolver needed for Transformers. *//** Implements javax.xml.transform.sax.TemplatesHandler.getTemplates() ... *//** This method implements XSLTC's SourceLoader interface. It is used to ... */getInputSource(...)/** Re-initialize parser and forward SAX2 event. */// -- ContentHandler --------------------------------------------------XSLTC.BYTEARRAY_OUTPUT/** Just forward SAX2 event to parser object. */String transletNamebyte[][] bytecodesnew TemplatesImpl(...)StringBuilder errorMessageArrayList<ErrorMsg> errorsskippedEntity(...)/** Set internal system Id and forward SAX2 event to parser object. *//* Copyright (c) 2007, 2017, Oracle and/or its affiliates. All rights reserved. */// Instantiate XSLTC and get reference to parser object// A _uriResolver must be set if this method is called// Falls through// calls _parser.init()// create the templates// Get java-legal class name from XSLTC module// Set a document loader (for xsl:include/import) if defined// Set it as top-level in the XSLTC object// Create AST under the Stylesheet element// Check that the transformation went well before returning// Set URIResolver on templates objectimport ObjectStreamFieldnew ThreadLocal<>(...)Properties.classString DESERIALIZE_TRANSLET;String ABSTRACT_TRANSLET;/** Name of the superclass of all translets. This is needed to ... *//** Name of the main class or default name if unknown. */...[] _bytecodes;/** Contains the actual class definition for the translet class and ... */...[] _class;/** Contains the translet class definition(s). These are created when ... */int _transletIndex;/** The index of the main translet class in the arrays _class[] and ... *//** Contains the list of auxiliary class definitions. *//** Output properties of this translet. *//** This URIResolver is passed to all Transformers. ... */ThreadLocal<> _sdom;/** Cache the DTM for the stylesheet in a thread local variable, ... *//** A flag to determine whether the system-default parser may be overridden */...[] serialPersistentFields;/** @serialField ... */TemplatesImpl$TransletClassLoaderMap<String,Class<>> _loadedExternalExtensionFunctions;Class<?> ret/** Access to final protected superclass member from outer class. */defineClass(...)/** Create an XSLTC template object from the bytecodes. ... *//** Create an XSLTC template object from the translet class definition(s). */overrideDefaultParser(...)/** Need for de-serialization, see readObject(). *//** Overrides the default readObject implementation since we decided ... */GetField gf/** This is to fix bugzilla bug 22438 ... */PutField pfputFields(...)writeFields(...)/** The TransformerFactory must pass us the translet bytecodes using this ... *//** Returns the translet bytecodes stored in this template ... */defineTransletClasses(...)/** Returns the index of the main class in array of bytecodes *//** The TransformerFactory should call this method to set the translet name *//** Returns the name of the main translet class stored in this template *//** Defines the translet class and auxiliary classes. ... */TransletClassLoader loaderTemplatesImpl$1new TransletClassLoader(...)getExternalExtensionsMap(...)int classCount_bytecodes.lengthClassFormatError eLinkageError e/** This method generates an instance of the translet class that is ... */setTemplates(...)setOverrideDefaultParser(...)setAllowedProtocols(...)setAuxiliaryClasses(...)/** Implements JAXP's Templates.newTransformer() ... */TransformerImpl transformernew TransformerImpl(...)getTransletInstance(...)/** Implements JAXP's Templates.getOutputProperties(). We need to ... *//** Return the thread local copy of the stylesheet DOM. *//** Set the thread local copy of the stylesheet DOM. *//* $Id: TemplatesImpl.java,v 1.8 2007/03/26 20:12:27 spericas Exp $ */// The _loadedExternalExtensionFunctions will be empty when the// SecurityManager is not set and the FSP is turned off// We have to read serialized fields first.//throw with the same message as when Hashtable was used for compatibility.// Write serialized fields// Check if this is the main class// The translet needs to keep a reference to all its auxiliary// class to prevent the GC from collecting themimport XMLReaderManagerimport XMLFilterImpl/** skeleton extension of XMLFilterImpl for now. ... */TransformerImpl _transformer;TransformerHandlerImpl _transformerHandler;new TransformerHandlerImpl(...)XMLReader parentXMLReader managedReadercreateParent(...)//org.xml.sax.helpers.XMLReaderFactory// make this XMLReader the parent of this filter// call parse on the parentimport XMLSecurityPropertyManagerimport Propertyimport StopParseExceptionimport StylesheetPIHandlerimport FilenameFilterimport StAXResult/** Implementation of a JAXP TransformerFactory for Translets. ... */String TRANSLET_NAME;// Public constants for attributes supported by the XSLTC TransformerFactory.String DESTINATION_DIRECTORY;String PACKAGE_NAME;String JAR_NAME;String GENERATE_TRANSLET;String AUTO_TRANSLET;String USE_CLASSPATH;String DEBUG;String ENABLE_INLINING;String INDENT_NUMBER;ErrorListener _errorListener;/** This error listener is used only for this factory and is not passed to ... *//** This URIResolver is passed to all created Templates and Transformers */String DEFAULT_TRANSLET_NAME;/** As Gregor Samsa awoke one morning from uneasy dreams he found himself ... */String _transletName;/** The class name of the translet */String _destinationDirectory;/** The destination directory for the translet *//** The package name prefix for all generated translet classes *//** The jar file name which the translet classes are packaged into */Map<Source,PIParamWrapper> _piParams;/** This Map is used to store parameters for locating ... *//** The above Map stores objects of this class. */String _media;String _title;String _charset;/** Set to <code>true</code> when debugging is enabled. */boolean _enableInlining;/** Set to <code>true</code> when templates are inlined. */boolean _generateTranslet;/** Set to <code>true</code> when we want to generate ... */boolean _autoTranslet;/** If this is set to <code>true</code>, we attempt to use translet classes ... */boolean _useClasspath;/** If this is set to <code>true</code>, we attempt to load the translet ... *//** Number of indent spaces when indentation is turned on. */boolean _isNotSecureProcessing;boolean _isSecureMode;/** <p>State of secure mode.</p> *//** Indicates whether 3rd party parser may be used to override the system-default ... */XMLSecurityPropertyManager _xmlSecurityPropertyMgr;Map<String,Class<>> _xsltcExtensionFunctions;// type checking// It will be populated by user-specified extension functions during the// Unmodifiable view of external extension function from xslt compiler/** javax.xml.transform.sax.TransformerFactory implementation. */new XMLSecurityPropertyManager(...)new XMLSecurityManager(...)String propertyValuegetLimitAsString(...)XMLSecurityManager.State.APIPROPERTYXMLSecurityManager.StateXMLSecurityPropertyManager.State.APIPROPERTYXMLSecurityPropertyManager.State/** <p>Set a feature for this <code>TransformerFactory</code> and <code>Transformer</code>s ... */XalanConstants.IS_JDK8_OR_ABOVEXalanConstants.EXTERNAL_ACCESS_DEFAULT_FSPJdkXmlFeatures.State.FSPJdkXmlFeatures.StateXalanConstants.ORACLE_FEATURE_SERVICE_MECHANISMJdkXmlFeatures.State.APIPROPERTYJdkXmlUtils.OVERRIDE_PARSERJdkXmlFeatures.ORACLE_FEATURE_SERVICE_MECHANISMStAXSource.FEATUREStAXResult.FEATURESAXTransformerFactory.FEATURESAXTransformerFactory.FEATURE_XMLFILTERString baseIdInputSource isourceStylesheetPIHandler _stylesheetPIHandlernew StylesheetPIHandler(...)setBaseId(...)StopParseException eTransformerImpl result/** Pass warning messages from the compiler to the error listener */isWarningError(...)/** Pass error messages from the compiler to the error listener */int outputTypegetTransletBaseName(...)resetTransientAttributes(...)String transletClassNamegetBytecodesFromJar(...)getBytecodesFromClasses(...)getExternalExtensionFunctions(...)PIParamWrapper pp._mediap._titlep._charsetString xslNamegetStylesheetFileName(...)File xslFileString xslDirXSLTC.BYTEARRAY_AND_JAR_OUTPUTXSLTC.BYTEARRAY_AND_FILE_OUTPUTpassWarningsToListener(...)ArrayList<ErrorMsg> errsTransformerConfigurationException excpassErrorsToListener(...)/** javax.xml.transform.sax.SAXTransformerFactory implementation. ... */TemplatesHandlerImpl handlernew TemplatesHandlerImpl(...)TransformerImpl internal/** Receive notification of a recoverable error. ... */Throwable wrappedgetMessageAndLocation(...)/** Receive notification of a non-recoverable error. ... *//** Receive notification of a warning. ... *//** Reset the per-session attributes to their default values *//** Load the translet classes from local .class files and return ... */String transletPathFile transletFileVector<> bytecodesint fileLengthString transletParentDirFile transletParentFileString transletAuxPrefixFile[] auxfileslistFiles(...)TransformerFactoryImpl$1long xslTimestamplong transletTimestampFileInputStream inputreadFromInputStream(...)auxfiles.lengthFile auxfileint auxlengthFileInputStream auxinput/** Load the translet classes from the jar file and return the bytecode. ... */String jarPathZipFile jarFileString transletFullNameEnumeration<> entriesString entryName/** Read a given number of bytes from the InputStream into a byte array. ... *//** Return the base class name of the translet. ... */String transletBaseName/** Return the local file name from the systemId of the Source object ... */getFile(...)/** Returns a new instance of the XSLTC DTM Manager service. *///Parser's security manager//Unmodifiable hash map with loaded external extension functions// Return value for attribute 'translet-name'/** Check to see if the property is managed by the security manager * */// Throw an exception for all other attributes// Set the default translet name (ie. class name), which will be used// for translets that cannot be given a name from their system-id.// set external access restriction when FSP is explicitly set// for compatibility, in secure mode, useServicesMechanism is determined by the constructor// Inefficient, but array is small/** Check to see if the property is managed by the JdkXmlFeatures * */// Feature not supported/** Fix for bugzilla bug 24187 */// startElement encountered so do not parse further// Pass messages to listener, one by one// Workaround for the TCK failure ErrorListener.errorTests.error001.// If the _useClasspath attribute is true, try to load the translet from// the CLASSPATH and create a template object using the loaded// translet.// If _autoTranslet is true, we will try to load the bytecodes// from the translet classes without compiling the stylesheet.// Reset the per-session attributes to their default values// after each newTemplates() call.// Create and initialize a stylesheet compiler// Pass parameters to the Parser to make sure it locates the correct// <?xml-stylesheet ...?> PI in an XML input document// Get the parameters for this Source object// Pass them on to the compiler (which will pass then to the parser)// Set the attributes for translet generation// Set the translet name// Compile the stylesheet// Output to the jar file if the jar file name is set.// Pass compiler warnings to the error listener// Pass compiler errors to the error listener// As required by TCK 1.2, send a fatalError to the// error listener because compilation of the stylesheet// failed and no further processing will be possible.// well, we tried.// should catch it when the resolver explicitly throws the exception// Find the base name of the translet// Construct the path name for the translet class file// Return null if the translet class file does not exist.// Compare the timestamps of the translet and the xsl file.// If the translet is older than the xsl file, return null// so that the xsl file is used for the transformation and// the translet is regenerated.// Load the translet into a bytecode array.// Find the parent directory of the translet.// Find all the auxiliary files which have a name pattern of "transletClass$nnn.class".// Load the auxiliary class files and add them to the bytecode array.// Convert the Vector of byte[] to byte[][].// Construct the path for the jar file// Return null if the jar file does not exist.// Compare the timestamps of the jar file and the xsl file. Return null// if the xsl file is newer than the jar file.// Create a ZipFile object for the jar file// Iterate through all entries in the jar file to find the// translet and auxiliary classes.import Result/** Implementation of a JAXP1.1 TransformerHandler ... */DTDHandler _dtdHandler;DeclHandler _declHandler;Result _result;boolean _done;boolean _isIdentity;/** A flag indicating whether this transformer handler implements the ... */// Set in endDocument()/** Cosntructor - pass in reference to a TransformerImpl object */new DefaultHandler(...)/** Implements javax.xml.transform.sax.TransformerHandler.getSystemId() ... *//** Implements javax.xml.transform.sax.TransformerHandler.setSystemId() ... *//** Implements javax.xml.transform.sax.TransformerHandler.getTransformer() ... *//** Implements javax.xml.transform.sax.TransformerHandler.setResult() ... */SerializationHandler outputHandlergetOutputHandler(...)transferOutputProperties(...)setDOM(...)/** Implements org.xml.sax.ContentHandler.characters() ... *//** Implements org.xml.sax.ContentHandler.startDocument() ... */boolean hasIdCallDTMWSFilter wsFiltergetTransformerFactory(...)/** Implements org.xml.sax.ContentHandler.endDocument() ... */setNode(...)getTransletOutputHandlerFactory(...)/** Implements org.xml.sax.ContentHandler.startElement() ... *//** Implements org.xml.sax.ContentHandler.endElement() ... *//** Implements org.xml.sax.ContentHandler.processingInstruction() ... *//** Implements org.xml.sax.ext.LexicalHandler.startCDATA() *//** Implements org.xml.sax.ext.LexicalHandler.endCDATA() *//** Implements org.xml.sax.ext.LexicalHandler.comment() ... *//** Implements org.xml.sax.ContentHandler.ignorableWhitespace() ... *//** Implements org.xml.sax.ContentHandler.setDocumentLocator() ... *//** Implements org.xml.sax.ContentHandler.skippedEntity() ... *//** Implements org.xml.sax.ContentHandler.startPrefixMapping() ... *//** Implements org.xml.sax.ContentHandler.endPrefixMapping() ... *//** Implements org.xml.sax.ext.LexicalHandler.startDTD() */startDTD(...)/** Implements org.xml.sax.ext.LexicalHandler.endDTD() */endDTD(...)/** Implements org.xml.sax.ext.LexicalHandler.startEntity() */startEntity(...)/** Implements org.xml.sax.ext.LexicalHandler.endEntity() */endEntity(...)/** Implements org.xml.sax.DTDHandler.unparsedEntityDecl() */unparsedEntityDecl(...)/** Implements org.xml.sax.DTDHandler.notationDecl() */notationDecl(...)/** Implements org.xml.sax.ext.DeclHandler.attributeDecl() */attributeDecl(...)/** Implements org.xml.sax.ext.DeclHandler.elementDecl() */elementDecl(...)/** Implements org.xml.sax.ext.DeclHandler.externalEntityDecl() */externalEntityDecl(...)internalEntityDecl(...)/** Implementation of the reset() method */// Save the reference to the transformer// Set initial handler to the empty handler// Get a reference to the translet wrapped inside the transformer//"result should not be null");// Connect this object with output system directly// Run the transformation now, if not already done// What the hell are we supposed to do with this???// Make sure setResult() was called before the first SAX event// Create an internal DOM (not W3C) and get SAX2 input handler// Construct the DTM using the SAX events that come through// Set document URI// Proxy call// Signal to the DOMBuilder that the document is complete// Run the transformation now if we have a reference to a Result object// Signal that the internal DOM is built (see 'setResult()').// Set this DOM as the transformer's DOMimport OutputPropertiesFactoryimport URIimport UnknownServiceExceptionString LEXICAL_HANDLER_PROPERTY;String NAMESPACE_PREFIXES_FEATURE;/** Namespace prefixes feature for {@link XMLReader}. *//** A reference to the translet or null if the identity transform. *//** The output method of this transformation. *//** The output encoding of this transformation. */String _sourceSystemId;/** The systemId set in input source. *//** An error listener for runtime errors. *//** A reference to a URI resolver for calls to document(). */Properties _properties, ...;/** Output properties of this transformer instance. */TransletOutputHandlerFactory _tohFactory;/** A reference to an output handler factory. *//** A reference to a internal DOM representation of the input. *//** Number of indent spaces to add when indentation is on. *//** A reference to the output stream, if we create one in our code. *//** A reference to the XSLTCDTMManager which is used to build the DOM/DTM ... */XMLReaderManager _readerManager;/** A reference to an object that creates and caches XMLReader objects. *//** A flag indicating whether this transformer implements the identity ... *///private boolean _isIncremental = false;/** A flag indicating whether we use incremental building of the DTM. *//** Indicates whether 3rd party parser may be used to override the system-default */XMLSecurityManager _securityManager;Map<String,Object> _parameters;/** A map to store parameters for the identity transform. These ... */TransformerImpl$MessageHandler/** This class wraps an ErrorListener into a MessageHandler in order to ... */createOutputProperties(...)/** Returns the translet wrapped inside this Transformer or ... *//** Implements JAXP's Transformer.transform() ... */SerializationHandler toHandlersetDOMCache(...)getXMLEventWriter(...)getXMLStreamWriter(...)/** Create an output handler for the transformation output based on ... */setIndentNumber(...)SAXResult targetContentHandler handlergetHandler(...)LexicalHandler lexicalHandlersetHandler(...)setLexicalHandler(...)TransletOutputHandlerFactory.SAXsetXMLEventWriter(...)setXMLStreamWriter(...)TransletOutputHandlerFactory.STAXsetNextSibling(...)TransletOutputHandlerFactory.DOMStreamResult targetOutputStream ostreamURI urinew URI(...)UnknownServiceException e/** Set the internal DOM that will be used for the next transformation *//** Builds an internal DOM from a TrAX Source object */postErrorToListener(...)/** Returns the {@link com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl} ... *//** Returns the {@link com.sun.org.apache.xalan.internal.xsltc.runtime.output.TransletOutputHandlerFactory} ... */StreamSource streamInputStream streamInputReader streamReadergetReader(...)SAXSource saxboolean userReadernew DOM2TO(...)/** Internal transformation method - uses the internal APIs of XSLTC */DocumentBuilderFactory builderFDocumentBuilder builderString systemIDtransformIdentity(...)/** Implements JAXP's Transformer.getErrorListener() ... *//** Implements JAXP's Transformer.setErrorListener() ... */setMessageHandler(...)new MessageHandler(...)/** Inform TrAX error listener of an error *//** Inform TrAX error listener of a warning *//** Implements JAXP's Transformer.getOutputProperties(). ... *//** Implements JAXP's Transformer.getOutputProperty(). ... */validOutputProperty(...)/** Implements JAXP's Transformer.setOutputProperties(). ... */Enumeration<> namesisDefaultProperty(...)/** Implements JAXP's Transformer.setOutputProperty(). ... *//** Internal method to pass any properties to the translet prior to ... */translet._doctypePublictranslet._doctypeSystemtranslet._mediaTypetranslet._standalonetranslet._versiontranslet._omitHeadertranslet._indentOutputPropertiesFactory.S_BUILTIN_OLD_EXTENSIONS_UNIVERSALtranslet._indentamountOutputPropertiesFactory.S_BUILTIN_EXTENSIONS_UNIVERSALStringTokenizer etranslet._cdataaddCdataElement(...)OutputPropertiesFactory.ORACLE_IS_STANDALONEtranslet._isStandalone/** This method is used to pass any properties to the output handler ... */String doctypePublicString doctypeSystemVector<> uriAndLocalNamesint lastcolon/** Internal method to create the initial set of properties. There ... */Properties basesetDefaults(...)_translet._encoding_translet._method/** Internal method to get the default properties from the ... */Properties method_propsgetDefaultMethodProperties(...)/** Verifies if a given output property name is a property defined in ... *//** Checks if a given output property is default (2nd layer only) *//** Implements JAXP's Transformer.setParameter() ... *//** Implements JAXP's Transformer.clearParameters() ... */clearParameters(...)/** Implements JAXP's Transformer.getParameter() ... *//** Implements JAXP's Transformer.getURIResolver() ... *//** Implements JAXP's Transformer.setURIResolver() ... *//** This class should only be used as a DOMCache for the translet if the ... */Source resolvedSourceStreamSource streamSource/** This method resets  the Transformer to its original configuration ... *//* $Id: TransformerImpl.java,v 1.10 2007/06/13 01:57:09 joehw Exp $ */// _properties.put(OutputKeys.METHOD, "xml");//_isIncremental = tfactory._incremental;// Pass output properties to the translet// Pass output properties to handler if identity//result = new StAXResult(_tohFactory.getXMLStreamWriter());// Get output method using get() to ignore defaults// Get encoding using getProperty() to use defaults// Set indentation number in the factory// Return the content handler for this Result object// Result object could be SAXResult, DOMResult, or StreamResult/** Fix for bug 24414 ... */// Get StreamResult// StreamResult may have been created with a java.io.File,// java.io.Writer, java.io.OutputStream or just a String// systemId.// try to get a Writer from Result object// or try to get an OutputStream from Result object// or try to get just a systemId string from Result object// System Id may be in one of several forms, (1) a uri// that starts with 'file:', (2) uri that starts with 'http:'// or (3) just a filename on the local system.// if StreamResult(File) or setSystemID(File) was used,// the systemId will be URI encoded as a result of File.toURI(),// it must be decoded for use by URL// decoded String//decoded String// if host (URI authority) then file:// + host + path// else just path (may be absolute or relative)// URI exception which means nothing can be done so OK to ignore// system id is just a filename// If we cannot write to the location specified by the SystemId// If we cannot create the file specified by the SystemId// use only once, so reset to 'null'// Give the translet the opportunity to make a prepass of// the document, in case it can extract useful information early// Get systemId from source// Hook up reader and output handler// Create input source from source// Start pushing SAX events// Create a reader if not set by user/* According to JAXP1.2, new SAXSource()/StreamSource() ... */// Copy system ID from original, empty Source to new// If we create an output stream for the Result, we need to close it after the transformation.// Register a message handler to report xsl:messages// ignored - transformation cannot be continued// Ignore lower layer properties// Return right now if no properties are set// Get a list of all the defined properties// Note the use of get() instead of getProperty()// Ignore default properties// Pass property value to translet - override previous setting// clear previous setting// look for the last colon, as the String may be// something like "http://abc.com:local"// no colon at all, lets hope this is the// local name itself then// add the uri/localName as a pair, in that order// Call setDoctype() if needed// Copy propeties set in stylesheet to base// Update defaults based on output method// Argument to document function was: document('');/* Fix for bug 24188 ... */String property;/** Creates a SAX2 InputSource object from a TrAX Source object */boolean overrideDefaultParserJdkXmlUtils.NAMESPACES_FEATUREJdkXmlUtils.NAMESPACE_PREFIXES_FEATUREsetXMLReader(...)SAXNotRecognizedException snreSAXNotSupportedException snseDocument dom/* $Id: Util.java,v 1.2.4.1 2005/09/14 09:37:34 pvedula Exp $ */// Try to get InputSource from SAXSource input// Pass the SAX parser to the compiler// compatibility for legacy applications// handle  DOMSource// Try to get SAX InputSource from DOM Source.// handle StAXSource// get sax InputSource from StAXSource// Try to get InputStream or Reader from StreamSource// Clear old XML reader// Create InputSource from Reader or InputStream in SourceSource _source;ThreadLocal<> _dom;/** Create a new XSLTC-specific source from a system ID *//** Create a new XSLTC-specific source from a JAXP Source *//** Implements javax.xml.transform.Source.setSystemId() ... *//** Implements javax.xml.transform.Source.getSystemId() ... *//** Internal interface which returns a DOM for a given DTMManager and translet. */SAXImpl idomDOMWSFilter wsfilterint InitialSize;...[] _array;IntegerArray cloneclone._arraygrowArray(...)/** Adds new int at the end if not already present. *//** Merge two sorted arrays and eliminate duplicates. ... */other._freeint[] newArrayother._array// already in array// System.out.println("IntegerArray.merge() begin newSize = " + newSize);// Merge the two arrays// Copy the rest if of different lengths// Update reference to this array// System.out.println("IntegerArray.merge() end");/** Constructor AbortException *//* Copyright (c) 2016, Oracle and/or its affiliates. All rights reserved. ... */import TypeInfoimport DOMException/** Attribute represents an XML-style attribute of an ... *//** Serialization version. */String DTD_URI;/** DTD namespace. * *//** This can either be a String or the first child node. *//** Attribute name. */Object type;// REVISIT: we are losing the type information in DOM during serialization/** Type information */TextImpl textNode;/** Attribute has no public constructor. Please use the factory ... */isSpecified(...)hasStringValue(...)// for AttrNSImpl// CoreDocumentImpl does all the work.// called after the Attr has been detached for one thing.// Note: This only deals with part of the pb. It is expected to be// Support for DOM Level 3 renameNode method.needsSyncData(...)synchronizeData(...)// create a real text node as child if we don't have one yetTextImpl textownerDocument(...)isFirstChild(...)text.previousSiblingtext.ownerNodeisOwned(...)/** NON-DOM ... */needsSyncChildren(...)synchronizeChildren(...)setOwnerDocument(...)ChildNode childchild.nextSibling/** NON-DOM: set the type of this attribute to be ID type. ... */isIdAttribute(...)/** DOM Level 3: isId */// Node methodsAttrImpl clonecloneNode(...)clone.value/** A short integer indicating what type of node this is. The named ... *//** Returns the attribute name *//** Implicit in the rerouting of getNodeValue to getValue is the ... *//** Method getSchemaTypeInfo. ... *//** In Attribute objects, NodeValue is considered a synonym for ... *//** In Attributes, NodeName is considered a synonym for the ... */// Attr methods/** The DOM doesn't clearly define what setValue(null) means. I've taken it ... */// getName():StringCoreDocumentImpl ownerDocumentElement ownerElementgetOwnerElement(...)String oldvalueownerDocument.errorCheckingformatMessage(...)DOMMessageFormatter.DOM_DOMAINnew DOMException(...)DOMException.NO_MODIFICATION_ALLOWED_ERRgetMutationEvents(...)textNode.datatextNode.previousSiblingtextNode.ownerNodeinternalRemoveChild(...)ChildNode firstChildfirstChild.previousSiblingfirstChild.ownerNoderemoveIdentifier(...)internalInsertBefore(...)modifiedAttrValue(...)changed(...)putIdentifier(...)/** The "string value" of an Attribute is its text representation, ... */// setValue(String)ChildNode nodefirstChild.nextSiblingStringBuffer valuegetEntityRefValue(...)node.nextSibling/** The "specified" flag is true if and only if this attribute's ... */// getValue():String/** Returns the element node that this attribute is associated with, ... */// Attr2 methods// getSpecified():booleanNode kidisNormalized(...)appendData(...)removeChild(...)/** NON-DOM, for use by parser */// Public methods// normalize()/** NON-DOM: used by the parser ... */// setSpecified(boolean)/** NON-DOM method for debugging convenience */// Object methods/** Test whether this node has any children. Convenience shorthand ... *//** Obtain a NodeList enumerating all children of this node. If there ... *//** The first child of this Node, or null if none. */// getChildNodes():NodeListmakeChildNode(...)/** The last child of this Node, or null if none. */// getFirstChild():Node// getLastChild():Node(...).previousSibling/** Move one or more node(s) to our list of children. Note that this ... *//** NON-DOM INTERNAL: Within DOM actions,we sometimes need to be able ... */// insertBefore(Node,Node):Nodeboolean errorCheckingChildNode newInternalNode oldparentparentNode(...)ChildNode refInternalisKidOK(...)DOMException.HIERARCHY_REQUEST_ERRboolean treeSafeDOMException.WRONG_DOCUMENT_ERRDOMException.NOT_FOUND_ERRNodeImpl ainsertingNode(...)newInternal.ownerNodenewInternal.previousSiblingChildNode lastChildlastChild.nextSiblingnewInternal.nextSiblingChildNode prevrefInternal.previousSiblingprev.nextSiblinginsertedNode(...)checkNormalizationAfterInsert(...)/** Remove a child from this Node. The removed child's subtree ... */// internalInsertBefore(Node,Node,int):Node// removeChild(Node) :NodeChildNode oldInternalChildNode oldPreviousSiblingpreviousSibling(...)removingNode(...)oldInternal.nextSiblingoldInternal.previousSiblingChildNode nextnext.previousSiblingoldInternal.ownerNoderemovedNode(...)checkNormalizationAfterRemove(...)/** Make newChild occupy the location that oldChild used to ... */// internalRemoveChild(Node,int):NodereplacingNode(...)replacedNode(...)/** NodeList method: Count the immediate children of this node ... */// NodeList methods/** NodeList method: Return the Nth immediate child of this node, or ... */// getLength():int/** DOM Level 3 WD- Experimental. ... */// DOM3// item(int):NodeisEqualNode(...)/** Introduced in DOM Level 3. <p> ... *//** Override default behavior so that if deep is true, children are also ... */ChildNode mykidmykid.nextSibling/** Override this method in subclass to hook in efficient ... */// setReadOnly(boolean,boolean)/** Checks the normalized state of this node after inserting a child. ... */insertedChild.nextSibling/** Checks the normalized of this node after removing a child. ... */// checkNormalizationAfterInsert(ChildNode)previousSibling.nextSibling/** Serialize object. */// Serialization methods// checkNormalizationAfterRemove(ChildNode)/** Deserialize object. */// writeObject(ObjectOutputStream)/** False for default attributes. */// REVISIT: should an attribute that is not in the tree return// isID true?// take care of case where there are kids// Need to break the association w/ original kids// Cloning an Attribute always clones its children,// since they represent its value, no matter whether this// is a deep clone or not// Can no longer just discard the kids; they may have// event listeners waiting for them to disconnect.// create an actual text node as our child so// that we can use it in the event// simply discard children if any// remove ref from first child to last child// then remove ref to current value// Create and add the new one, generating only non-aggregate events// (There are no listeners on the new Text, but there may be// capture/bubble listeners on the Attr.// Note that aggregate events are NOT dispatched here,// since we need to combine the remove and insert.// if there are any event handlers create a real node// notify document// directly store the string// if we have an owner, ownerNode is our ownerElement, otherwise it's// our ownerDocument and we don't have an ownerElement// No need to normalize if already normalized or// if value is kept as a String.// If kid is a text node, we need to check for one of two// conditions://   1) There is an adjacent text node//   2) There is no adjacent text node, but kid is//      an empty text node.// If an adjacent text node, merge it with kid// Don't advance; there might be another.// If kid is empty, remove it// JKESS: KNOWN ISSUE HERE// last child is stored as the previous sibling of first child// store lastChild as previous sibling of first child// Tail-call; optimizer should be able to do good things with.// SLOW BUT SAFE: We could insert the whole subtree without// juggling so many next/previous pointers. (Wipe out the// parent's child-list, patch the parent pointers, set the// ends of the list.) But we know some subclasses have special-// case behavior they add to insertBefore(), so we don't risk it.// This approch also takes fewer bytecodes.// NOTE: If one of the children is not a legal child of this// node, throw HIERARCHY_REQUEST_ERR before _any_ of the children// have been transferred. (Alternative behaviors would be to// reparent up to the first failure point or reparent all those// which are acceptable to the target node, neither of which is// as robust. PR-DOM-0818 isn't entirely clear on which it// recommends?????// No need to check kids for right-document; if they weren't,// they wouldn't be kids of that DocFrag.// Prescan// stupid case that must be handled as a no-op triggering events...// refChild must be a child of this node (or null)// Prevent cycles in the tree// newChild cannot be ancestor of this Node,// and actually cannot be this// make sure we have a node and not a string// Convert to internal type, to avoid repeated casting// Attach up// Attach before and after// Note: firstChild.previousSibling == lastChild!!// this our first and only child// firstchild = newInternal;// this is an append// this is an insert// at the head of the list// firstChild = newInternal;// somewhere in the middle// Tail-call, should be optimizable// we don't have any child per say so it can't be one of them!// Patch linked list around oldChild// Note: lastChild == firstChild.previousSibling// oldInternal == firstChild// removing first child// next line is: firstChild = oldInternal.nextSibling// removing last child// removing some other child in the middle// Save previous sibling for normalization checking.// Remove oldInternal's references to tree// If Mutation Events are being generated, this operation might// throw aggregate events twice when modifying an Attr -- once// on insertion and once on removal. DOM Level 2 does not specify// this as either desirable or undesirable, but hints that// aggregations should be issued only once per user request.// Recursively set kids// By default just change the flag to avoid calling this method again// See if insertion caused this node to be unnormalized.// If an adjacent sibling of the new child is a text node,// flag this node as unnormalized.// If the new child is not normalized,// then this node is inherently not normalized.// See if removal caused this node to be unnormalized.// If the adjacent siblings of the removed child were both text nodes,// synchronize chilren// write object// perform default deseralization// hardset synchildren - so we don't try to sync -// it does not make any sense to try to synchildren when we just// deserialize object.// readObject(ObjectInputStream)// class AttrImplimport XSSimpleTypeDeclimport NamespaceContextimport XSSimpleTypeDefinition/** AttrNSImpl inherits from AttrImpl and adds namespace support. ... */String xmlnsURI;String xmlURI;String namespaceURI;/** DOM2: Namespace URI. */String localName;/** DOM2: localName. *//* Default constructor *//** DOM2: Constructor for Namespace implementation. */int colon1int colon2this.namespaceURIcheckNamespaceWF(...)checkQName(...)NamespaceContext.XMLNS_URIDOMException.NAMESPACE_ERRcheckDOMNSErr(...)// when local name is knownthis.localName// for DeferredAttrImpl/** NON-DOM: resets this node and sets specified values for the node ... */super.textNodesuper.flagssuper.namesuper.value/** Introduced in DOM Level 2. <p> ... */// DOM2: Namespace methodsownerDocument(...).errorCheckingisXMLName(...)isXML11Version(...)DOMException.INVALID_CHARACTER_ERRisDOMDerivedFrom(...)// DOM Level 3: namespace URI is never empty string.// there is no prefix// REVIST: This code could/should be done at a lower-level, such that// the namespaceURI is set properly upon creation. However, there still// seems to be some DOM spec interpretation grey-area.// update node name with new qualifiedName/** AttributeMap inherits from NamedNodeMapImpl and extends it to deal with the ... *//** Constructs a named node map. */cloneContent(...)hasDefaults(...)/** Adds an attribute using its nodeName attribute. ... */boolean errCheckAttrImpl argnfindNamePoint(...)AttrImpl previousDOMException.INUSE_ATTRIBUTE_ERRargn.ownerNodeprevious.ownerNodesetAttrNode(...)/** Adds an attribute using its namespaceURI and localName. ... */// setNamedItem(Node):Node/** Removes an attribute specified by name. ... */// setNamedItemNS(Node):NodeinternalRemoveNamedItem(...)/** Same as removeNamedItem except that it simply returns null if the ... *//** NON-DOM: Remove the node object ... *//** Internal removeNamedItem method allowing to specify whether an exception ... */// internalRemoveNamedItem(String,boolean):NodeNamedNodeMapImpl defaultsgetDefaultAttributes(...)Node dNodeImpl clone(...).namespaceURIclone.ownerNodeattr.ownerNoderemovedAttrNode(...)internalRemoveNamedItemNS(...)/** Internal removeNamedItemNS method allowing to specify whether an ... */AttrImpl nString nodeNamen.ownerNode/** Cloning a NamedNodeMap is a DEEP OPERATION; it always clones ... */// internalRemoveNamedItemNS(String,String,boolean):NodeAttributeMap newmapnew AttributeMap(...)/** Override parent's method to set the ownerNode correctly */// cloneMap():AttributeMapList<> srcnodessrcmap.nodesNodeImpl n/** Move specified attributes from the given map to this one */// cloneContent():AttributeMapint nsizeAttrImpl attrsetNamedItem(...)setNamedItemNS(...)/** Get this AttributeMap in sync with the given "defaults" map. ... */// moveSpecifiedAttributes(AttributeMap):voidint dsizedefaults.nodesAttrImpl d// reconcileDefaults()// initialize map with the defaults// replacing an Attribute with itself does nothing// set owner// make sure it won't be mistaken with defaults in case it's reused// Insert point (may be end of list)// If the new attribute is not normalized,// the owning element is inherently not normalized.// If we can't find by namespaceURI, localName, then we find by// nodeName so we know where to insert.//      changed(true);// If there's a default, add it instead// we must rely on the name to find a default attribute// ("test:attr"), but while copying it from the DOCTYPE// we should not loose namespace URI that was assigned// to the attribute in the instance document.//        changed(true);// remove reference to owner// make sure it won't be mistaken with defaults in case it's// reused// update id table if needed// remove any existing default// add the new defaults// class AttributeMapimport CDATASection/** XML provides the CDATA markup to allow a region of text in which ... *//** Factory constructor for creating a CDATA section. *//** Returns the node name. */// class CDATASectionImpl/** CharacterData is an abstract Node that can carry character data as its ... */CharacterDataImpl$1String data;NodeList singletonNodeList;/** Empty child nodes. *//** Factory constructor. *//** Returns an empty node list. *//* returns the content of this node *//** Convenience wrapper for calling setNodeValueInternal when ... */setNodeValueInternal(...)/** This function added so that we can distinguish whether ... */modifyingCharacterData(...)modifiedCharacterData(...)/** Sets the content, possibly firing related events, ... */replacedText(...)/** Retrieve character data currently stored in this node. ... */// CharacterData methods/** Report number of characters currently stored in this node's ... *//** Concatenate additional characters onto the end of the data ... *//** Remove a range of characters from the node's value. Throws a ... */// appendData(String)internalDeleteData(...)/** NON-DOM INTERNAL: Within DOM actions, we sometimes need to be able ... */// deleteData(int,int)int tailLengthDOMException.INDEX_SIZE_ERRdeletedText(...)/** Insert additional characters into the data stored in this node, ... */// internalDeleteData(int,int,boolean)internalInsertData(...)// insertData(int,int)insertedText(...)/** Replace a series of characters at the specified (zero-based) ... */// internalInsertData(int,String,boolean)replacingData(...)replacedCharacterData(...)/** Store character data into this node. ... */// replaceData(int,int,String)/** Substring is more than a convenience function. In some ... */int tailIndex// revisit: may want to set the value in ownerDocument.// Default behavior, overridden in some subclasses// keep old value for document notification// The read-only check is done by deleteData()// ***** This could be more efficient w/r/t Mutation Events,// specifically by aggregating DOMAttrModified and// DOMSubtreeModified. But mutation events are// underspecified; I don't feel compelled// to deal with it right now.//notify document// substringData(int,int):String// class CharacterDataImpl/** ChildNode inherits from NodeImpl and adds the capability of being a child by ... */StringBuffer fBufferStr;ChildNode previousSibling;/** Previous sibling. */ChildNode nextSibling;/** Next sibling. *//** No public constructor; only subclasses of Node should be ... *//** Constructor for serialization. */// <init>(CoreDocumentImpl)/** Returns a duplicate of a given node. You can consider this a ... */ChildNode newnodenewnode.previousSiblingnewnode.nextSibling/** Returns the parent node of this node */// cloneNode(boolean):Node/* same as above but returns internal type *//** The next child of this node's parent, or null if none *//** The previous child of this node's parent, or null if none */// if we have an owner, ownerNode is our parent, otherwise it's// our ownerDocument and we don't have a parent// if we are the firstChild, previousSibling actually refers to our// parent's lastChild, but we hide that// class ChildNodeimport CharacterData/** Represents an XML (or HTML) comment. ... */// class CommentImplimport RevalidationHandlerimport DOMParserImplimport DTDConfigurationimport XIncludeAwareParserConfigurationimport XMLCharimport XMLGrammarDescriptionimport DOMSerializerImplimport LSParserimport DOMImplementationLSimport LSInputimport LSOutputimport LSSerializer/** The DOMImplementation class is description of a particular ... */new RevalidationHandler[]new CoreDOMImplementationImpl(...)// validators pool...[] validators;...[] dtdValidators;int freeValidatorIndex;int freeDTDValidatorIndex;int docAndDoctypeCounter;// compareDocumentPosition// doctypes without owners, on an demand basis.   Used for// Document and doctype counter.  Used to assign order to documents andCoreDOMImplementationImpl singleton;/** Dom implementation singleton. */// static/** NON-DOM: Obtain and return the single shared object *//** Test if the DOM implementation supports a specific "feature" -- ... */// DOMImplementation methodsboolean anyVersionClass<> xpathClass// hasFeature(String,String):booleannew DocumentTypeImpl(...)isNCNameStart(...)isNCName(...)CoreDocumentImpl docnew CoreDocumentImpl(...)Element e/** DOM Level 3 WD - Experimental. */hasFeature(...)/** DOM Level 3 LS CR - Experimental. ... */// DOM L3 LSDOMImplementationLS.MODE_SYNCHRONOUSDOMException.NOT_SUPPORTED_ERRnew DOMParserImpl(...)new DTDConfiguration(...)new XIncludeAwareParserConfiguration(...)new DOMSerializerImpl(...)new DOMInputImpl(...)/** NON-DOM: retrieve validator. */XMLGrammarDescription.XML_SCHEMARevalidationHandler valXMLGrammarDescription.XML_DTD/** NON-DOM: release validator */validators.lengthRevalidationHandler[] newarraydtdValidators.length/** NON-DOM:  increment document/doctype counter *//* DOM Level 3 LS CR - Experimental. ... */new DOMOutputImpl(...)/* Copyright 1999-2005 The Apache Software Foundation. ... */// check if Xalan implementation is around and if yes report true for supporting// XPath API// if a plus sign "+" is prepended to any feature name, implementations// are considered in which the specified feature may not be directly// castable DOMImplementation.getFeature(feature, version). Without a// plus, only features whose interfaces are directly castable are considered.// Check if the DOM XPath implementation implements// the interface org.w3c.dom.XPathEvaluator// REVISIT: this might allow creation of invalid name for DOCTYPE//          xmlns prefix.//          also there is no way for a user to turn off error checking.// it is an error for NCName to have more than one ':'// check if it is valid QName [Namespace in XML production 6]// Namespace in XML production [6]// check that prefix is NCName// check local part// REVISIT: add qname parameter to the message// create default parser configuration validating against XMLSchemas// REVISIT: implement retrieving DTD validator// create new validator - we should not attempt// to restrict the number of validation handlers being// requested// return first available validator// REVISIT: implement support for DTD validators as well// resize size of the validators// class DOMImplementationImplimport DOMConfigurationimport EntityReferenceimport Notationimport UserDataHandler/** The Document interface represents the entire HTML or XML document. ... */DocumentTypeImpl.classElementImpl.classNodeListCache.classHashtable<>.class/** TODO:: 1. Change XML11Char method names similar to XMLChar. That will ... */DocumentTypeImpl docType;/** Document type. */// document informationElementImpl docElement;/** Document element. */NodeListCache fFreeNLCache;/** NodeListCache free list *//** Experimental DOM Level 3 feature: Document encoding */String actualEncoding;/** Experimental DOM Level 3 feature: Document actualEncoding *//** Experimental DOM Level 3 feature: Document version */boolean standalone;/** Experimental DOM Level 3 feature: Document standalone */String fDocumentURI;/** Experimental DOM Level 3 feature: documentURI */Map<Node,Map<String,UserDataRecord>> nodeUserData;/** Table for user data attached to this document nodes. *///Revisit :: change to a better data structure.Map<String,Node> identifiers;/** Identifiers. */DOMNormalizer domNormalizer;// DOM Level 3: normalizeDocumentDOMConfigurationImpl fConfiguration;Object fXPathEvaluator;// support of XPath API...[] kidOK;/** Table for quick check of child insertion. */int changes;/** Number of alterations made to this document since its creation. ... */boolean allowGrammarAccess;/** Allow grammar access. */// experimentalboolean errorChecking;/** Bypass error checking. */boolean ancestorChecking;/** Ancestor checking */boolean xmlVersionChanged;//this field helps us to optimize when normalizingDocument.//Did version change at any point when the document was created ?int documentNumber;// positive integer values.  Documents are assigned numbers on demand.// Document number.   Documents are ordered across the implementation using/** The following are required for compareDocumentPosition */int nodeCounter;// assigned numbers on demand.// document.  Node number values are negative integers.  Nodes are// Node counter and table.  Used to assign numbers to nodes for thisMap<Node,Integer> nodeTable;boolean xml11Version;/** NON-DOM: Actually creating a Document is outside the DOM's spec, ... */String systemPropConstants.SUN_DOM_PROPERTY_PREFIXConstants.SUN_DOM_ANCESTOR_CHECCK/** For DOM2 support. ... *//** For DOM2 support. */DocumentTypeImpl doctypeImpldoctypeImpl.ownerDocument// the DOM Level 2 spec says it must be null, so make it appear so// even though ownerDocument refers to this in this implementation/** Returns the node type. *//** Deep-clone a document, including fixing ownerDoc for the cloned ... */CoreDocumentImpl newdoccallUserDataHandlers(...)UserDataHandler.NODE_CLONED/** internal method to share code with subclass */Map<Node,String> reversedIdentifiersnew HashMap<Node,String>(...)String elementIdChildNode kidkid.nextSiblingnewdoc.allowGrammarAccessnewdoc.errorChecking/** Since a Document may contain at most one top-level Element child, ... */// cloneNode(CoreDocumentImpl,boolean):void(...).ownerDocument/** Since insertBefore caches the docElement (and, currently, docType), ... *//** Since we cache the docElement (and, currently, docType), ... */// removeChild(Node):NodereplaceChild(...)/* Get Node text content ... */// replaceChild(Node,Node):Node/* Set Node text content ... */Constructor<> xpathClassConstrDocument.class/** Factory method; creates an Attribute having this Document as its ... */// factory methods// Document methodsnew AttrImpl(...)/** Factory method; creates a CDATASection having this Document as ... */// createAttribute(String):Attrnew CDATASectionImpl(...)/** Factory method; creates a Comment having this Document as its ... */new CommentImpl(...)/** Factory method; creates a DocumentFragment having this Document ... */new DocumentFragmentImpl(...)/** Factory method; creates an Element having this Document ... */new ElementImpl(...)/** Factory method; creates an EntityReference having this Document ... */// createElement(String):Elementnew EntityReferenceImpl(...)/** Factory method; creates a ProcessingInstruction having this Document ... */// createEntityReference(String):EntityReferencenew ProcessingInstructionImpl(...)/** Factory method; creates a Text node having this Document as its ... */// createProcessingInstruction(String,String):ProcessingInstructionnew TextImpl(...)/** For XML, this provides access to the Document Type Definition. ... */// other document methods/** Convenience method, allowing direct access to the child node ... *//** Return a <em>live</em> collection of all descendent Elements (not just ... */new DeepNodeListImpl(...)/** Retrieve information describing the abilities of this particular ... *//** Sets whether the DOM implementation performs error checking ... *//* DOM Level 3 WD - Experimental. *//** Returns true if the DOM implementation performs error checking. *//** DOM Level 3 CR - Experimental. (Was getActualEncoding) ... *//** DOM Internal ... */setXmlEncoding(...)/** DOM Level 3 WD - Experimental. ... *//** DOM Level 3 CR - Experimental. ... */setXmlStandalone(...)ElementImpl elrename(...)UserDataHandler.NODE_RENAMEDElementNSImpl nelnew ElementNSImpl(...)Map<String,UserDataRecord> dataremoveUserDataTable(...)Node parentNode nextSibcopyEventListeners(...)moveSpecifiedAttributes(...)setUserDataTable(...)renamedElement(...)AttrImpl atElement elremoveAttributeNode(...)setAttributeNode(...)AttrNSImpl natnew AttrNSImpl(...)renamedAttrNode(...)/** DOM Level 3 WD - Experimental ... */isNormalizeDocRequired(...)new DOMNormalizer(...)new DOMConfigurationImpl(...)normalizeDocument(...)/** DOM Level 3 CR - Experimental ... *//** Returns the absolute base URI of this node or null if the implementation ... */MalformedURIException eURI.MalformedURIExceptionDOMImplementationLS domImplLSLSSerializer xmlWritercreateLSSerializer(...)writeToString(...)/** Sets whether the DOM implementation generates mutation events upon ... *//** Returns true if the DOM implementation generates mutation events. *//** NON-DOM Factory method; creates a DocumentType having this Document as ... */// non-DOM factory methods/** NON-DOM Factory method; creates an Entity having this Document as its ... */// createDocumentType(String):DocumentTypenew EntityImpl(...)/** NON-DOM Factory method; creates a Notation having this Document as its ... */// createEntity(String):Entitynew NotationImpl(...)/** NON-DOM Factory method: creates an element definition. Element ... */// createNotation(String):Notationnew ElementDefinitionImpl(...)/** NON-DOM: Get the number associated with this document. Used to order ... */// other non-DOM methods// createElementDefinition(String):ElementDefinitionImplCoreDOMImplementationImpl cdassignDocumentNumber(...)/** NON-DOM: Get a number associated with a node created with respect to this ... *//** Copies a node from another document to this document. The new nodes are ... *//** Overloaded implementation of DOM's importNode method. This method ... */// importNode(Node,boolean):NodeNode newnodeMap<String,UserDataRecord> userDatagetUserDataRecord(...)Element newElementboolean domLevel20getImplementation(...)NamedNodeMap sourceAttrsAttr attrgetSpecified(...)Attr newAttrcreateAttributeNS(...)AttrImpl newattrcreateCDATASection(...)createEntityReference(...)Entity srcentityEntityImpl newentitycreateEntity(...)setPublicId(...)setNotationName(...)DocumentType srcdoctypeDocumentTypeImpl newdoctypecreateDocumentType(...)NamedNodeMap smapNamedNodeMap tmapgetNotations(...)Notation srcnotationNotationImpl newnotationcreateNotation(...)UserDataHandler.NODE_IMPORTEDNode srckid// importNode(Node,boolean,boolean,Map):NodeDOMImplementation thisImplDOMImplementation otherImplundeferChildren(...)Node entityNodeNode childClonereconcileDefaultAttributes(...)UserDataHandler.NODE_ADOPTED/** Traverses the DOM Tree and expands deferred nodes and their ... */Node topNamedNodeMap attributesNode nextNode/** Introduced in DOM Level 2 ... */// identifier maintenencegetIdentifier(...)/** Remove all identifiers from the ID table *//** Registers an identifier name with a specified element node. ... *//** Returns a previously registered element with the specified ... */// putIdentifier(String,Element)/** Removes a previously registered element with the specified ... */// getIdentifier(String):Element// removeIdentifier(String)/** NON-DOM: a factory method used by the Xerces DOM parser ... *//** Clone. */newdoc.docTypenewdoc.docElement/** Check the string against XML's definition of acceptable names for ... */// Public static methodsisValidName(...)isXML11ValidName(...)/** Checks if the given qualified name is legal with respect ... */// isXMLName(String):booleanboolean validNCNameisValidNCName(...)/** Uses the kidOK lookup table to check whether the proposed ... *//** Denotes that this node has changed. *//** Returns the number of changes to this node. *//** Returns a NodeListCache for the given node. *///  NodeListCache poolNodeListCache cnew NodeListCache(...)fFreeNLCache.nextc.fChildc.fChildIndexc.fLengthc.fOwnerc.fOwner.fNodeListCache/** Puts the given NodeListCache in the free list. ... *//** Associate an object to a key on this node. The object can later be ... */Map<String,UserDataRecord> tUserDataRecord rr.fDatanew UserDataRecord(...)new HashMap<Node,Map<String,UserDataRecord>>(...)new HashMap<String,UserDataRecord>(...)/** Retrieves the object associated to a key on a this node. The object ... *//** Remove user data table for the given node. ... *//** Set user data table for the given node. ... *//** Call user data handlers when a node is deleted (finalized) ... */r.fHandler/* public void finalize() { ... */// -SG// 2. It affects the performance greatly in multi-thread environment.//    functionality is not implemented.// 1. It seems that finalizers are not guaranteed to be called, so the// Temporarily comment out this method, because/** Call user data handlers to let them know the nodes they are related to ... */NamespaceContext.XML_URI/** We could have more xml versions in future , but for now we could ... *///version of the document is changed.//we should be checking the (elements, attribute, entity etc.) names only when/** NON-DOM: kept for backward compatibility ... */// Event related methods overidden in subclass/** A method to be called when some text was changed in a text node, ... */// Notification methods overidden in subclasses/** A method to be called when some text was deleted from a text node, ... *//** A method to be called when some text was inserted into a text node, ... *//** A method to be called when a character data node is about to be modified *//** A method to be called when a character data node has been modified *//** A method to be called when a node is about to be inserted in the tree. *//** A method to be called when a node has been inserted in the tree. *//** A method to be called when a node is about to be removed from the tree. *//** A method to be called when a node has been removed from the tree. *//** A method to be called when a node is about to be replaced in the tree. *//** A method to be called when a node has been replaced in the tree. *//** A method to be called when a character data node is about to be replaced *//** method to be called when a character data node has been replaced. *//** A method to be called when an attribute value has been modified *//** A method to be called when an attribute node has been set *//** A method to be called when an attribute node has been removed *//** A method to be called when an attribute node has been renamed *//** A method to be called when an element has been renamed *//** @serialData ... */Hashtable<Node,Hashtable<String,UserDataRecord>> nudHashtable<String,Node> idsnew Hashtable<String,Node>(...)Hashtable<Node,Integer> ntnew Hashtable<Node,Integer>(...)new Hashtable<Node,Hashtable<String,UserDataRecord>>(...)Entry<Node,Map<String,UserDataRecord>> eMap<>.Entry<Node,Map<String,UserDataRecord>>new Hashtable<String,UserDataRecord>(...)Entry<Node,Hashtable<String,UserDataRecord>> eMap<>.Entry<Node,Hashtable<String,UserDataRecord>>/* Copyright (c) 2009, 2015, Oracle and/or its affiliates. All rights reserved. *///by default 1.0// Static initialization// clone the children by importing them// Build a reverse mapping from element to identifier.// Copy children into new document.// Only one such child permitted// Adopt orphan doctypes// If insert succeeded, cache the kid appropriately// If remove succeeded, un-cache the kid appropriately// no-op// plus, only features whose interfaces are directly castable are// considered.// If an XPathEvaluator was created previously// return it otherwise create a new one.// Currently implemented as a singleton, since it's hardcoded// information anyway.//we need to change the flag value only --// when the version set is different than already set.//change the normalization value back to false//NOT_SUPPORTED_ERR: Raised if the vesion is set to a value that is not supported by//this document//we dont support any other XML version// fire user data NODE_RENAMED event// we need to create a new object// register event listeners on new node// remove user data from old node// remove old node from parent if any// move children to new node// move specified attributes to new node// attach user data to new node// and fire user data NODE_RENAMED event// insert new node where old one was// fire ElementNameChanged event// dettach attr from element// reattach attr to element// fire AttributeNameChanged event// No need to normalize if already normalized.//set the XMLversion changed value to false -- once we have finished//doing normalization// attribute value is always empty string// REVISIT: what should happen in this case?// does nothing by default - overidden in subclass// does nothing by default - overriden in subclass// Check if the node is already in the hash// If so, retrieve the node number// If not, assign a number to the node// Node numbers are negative, from -1 to -n// Sigh. This doesn't work; too many nodes have private data that// would have to be manually tweaked. May be able to add local// shortcuts to each nodetype. Consider ?????// if(source instanceof NodeImpl &&//  !(source instanceof DocumentImpl))//  // Can't clone DocumentImpl since it invokes us...//  newnode=(NodeImpl)source.cloneNode(false);//  newnode.ownerDocument=this;// Create element according to namespace support/qualification.// Copy element's attributes, if any.// NOTE: this methods is used for both importingNode// and cloning the document node. In case of the// clonning default attributes should be copied.// But for importNode defaults should be ignored.// Attach attribute according to namespace// support/qualification.// Register element identifier.// Does element have an associated identifier?// if source is an AttrImpl from this very same implementation// avoid creating the child nodes if possible// According to the DOM spec the kids carry the value.// However, there are non compliant implementations out// there that fail to do so. To avoid ending up with no// value at all, in this case we simply copy the text value// directly.// the subtree is created according to this doc by the method// above, so avoid carrying over original subtree// Kids carry additional value,// allow deep import temporarily// unless this is used as part of cloning a Document// forbid it for the sake of being compliant to the DOM spec// Values are on NamedNodeMaps// NOTE: At this time, the DOM definition of DocumentType// doesn't cover Elements and their Attributes. domimpl's// extentions in that area will not be preserved, even if// copying from domimpl to domimpl. We could special-case// that here. Arguably we should. Consider. ?????// No name, kids carry value// Kids carry additional value// No name, no value// Can't import document nodes// Unknown node type// If deep, replicate and attach the kids.// source node comes from a different DOMImplementation// Return null if the source is null// when the source node comes from a different implementation.// Adopting from a DefferedDOM to DOM// traverse the DOM and expand deffered nodes and then allow adoption// Adopting from a DOM into a DefferedDOM, this should be okay// Adopting between two dissimilar DOM's is not allowed// remove node from wherever it is//1. owner element attribute is set to null//2. specified flag is set to true//3. change ownership//entity, notation nodes are read only nodes.. so they can't be adopted.//runtime will fall through to NOTATION_NODE//document, documentype nodes can't be adopted.//runtime will fall through to DocumentTypeNode// discard its replacement value// change ownership// set its new replacement value if any// reconcile default attributes//DOM L3 Core CR//http://www.w3.org/TR/2003/CR-DOM-Level-3-Core-20031107/core.html#UserDataHandler-ADOPTED// check that the element is in the tree// check that both prefix and local part match NCName// revoke previous ownership// c.next = null; not necessary, except for confused people...// :camera , nikon:camera:minolta, camera:// REVISIT: Implement to optimize when normalization// is required// Convert Maps to Hashtables//e.getValue() will not be null since an entry is always put with a non-null value//userData is the original name. It has been changed to nodeUserData, refer to the corrsponding @serialField//convert Hashtables back to HashMaps// class CoreDocumentImplimport XMLEntityManagerimport XMLErrorReporterimport DTDDVFactoryimport XMLMessageFormatterimport ValidationManagerimport DOMEntityResolverWrapperimport DOMErrorHandlerWrapperimport MessageFormatterimport ParserConfigurationSettingsimport PropertyStateimport SymbolTableimport XMLDTDContentModelHandlerimport XMLDTDHandlerimport XMLDocumentHandlerimport XNIExceptionimport XMLGrammarPoolimport XMLComponentimport XMLComponentManagerimport XMLConfigurationExceptionimport XMLEntityResolverimport XMLErrorHandlerimport XMLInputSourceimport XMLParserConfigurationimport DOMErrorHandlerimport DOMStringListimport LSResourceResolver/** Xerces implementation of DOMConfiguration that maintains a table of recognized parameters. ... */new DOMErrorHandlerWrapper(...)Constants.SAX_FEATURE_PREFIXConstants.VALIDATION_FEATUREConstants.NAMESPACES_FEATUREConstants.XERCES_FEATURE_PREFIXConstants.SCHEMA_VALIDATION_FEATUREConstants.SCHEMA_FULL_CHECKINGConstants.DYNAMIC_VALIDATION_FEATUREConstants.SCHEMA_NORMALIZED_VALUEConstants.SCHEMA_AUGMENT_PSVIConstants.XERCES_PROPERTY_PREFIXConstants.DATATYPE_VALIDATOR_FACTORY_PROPERTYConstants.NAMESPACE_GROWTH_FEATUREConstants.TOLERATE_DUPLICATES_FEATUREConstants.ENTITY_MANAGER_PROPERTYConstants.ERROR_REPORTER_PROPERTYConstants.SAX_PROPERTY_PREFIXConstants.XML_STRING_PROPERTYConstants.SYMBOL_TABLE_PROPERTYConstants.XMLGRAMMAR_POOL_PROPERTYConstants.ERROR_HANDLER_PROPERTYConstants.ENTITY_RESOLVER_PROPERTYConstants.JAXP_PROPERTY_PREFIXConstants.SCHEMA_LANGUAGEConstants.SCHEMA_SOURCEConstants.VALIDATION_MANAGER_PROPERTYConstants.SCHEMA_DV_FACTORY_PROPERTYConstants.SECURITY_MANAGERConstants.XML_SECURITY_PROPERTY_MANAGERString XERCES_VALIDATION;/** Feature identifier: validation. */// feature identifiersString XERCES_NAMESPACES;/** Feature identifier: namespaces. */String SCHEMA;String SCHEMA_FULL_CHECKING;String DYNAMIC_VALIDATION;String NORMALIZE_DATA;String SEND_PSVI;/** sending psvi in the pipeline */String DTD_VALIDATOR_FACTORY_PROPERTY;String NAMESPACE_GROWTH;/** Feature identifier: namespace growth */String TOLERATE_DUPLICATES;String ENTITY_MANAGER;/** Property identifier: entity manager. */// property identifiersString ERROR_REPORTER;/** Property identifier: error reporter. */String XML_STRING;/** Property identifier: xml string. */String SYMBOL_TABLE;/** Property identifier: symbol table. */String GRAMMAR_POOL;/** Property id: Grammar pool */String ERROR_HANDLER;/** Property identifier: error handler. */String ENTITY_RESOLVER;/** Property identifier: entity resolver. */String JAXP_SCHEMA_LANGUAGE;/** Property identifier: JAXP schema language / DOM schema-type. */String JAXP_SCHEMA_SOURCE;/** Property identifier: JAXP schema source/ DOM schema-location. */String VALIDATION_MANAGER;String SCHEMA_DV_FACTORY;/** Property identifier: Schema DV Factory *//** Property identifier: Security manager. *//** Property identifier: Security property manager. */XMLDocumentHandler fDocumentHandler;short features;/** Normalization features */short NAMESPACES;short DTNORMALIZATION;short ENTITIES;short CDATA;short SPLITCDATA;short COMMENTS;short VALIDATE;short PSVI;short WELLFORMED;short NSDECL;short INFOSET_TRUE_PARAMS;short INFOSET_FALSE_PARAMS;short INFOSET_MASK;SymbolTable fSymbolTable;/** Symbol table. */ArrayList<> fComponents;/** Components. */ValidationManager fValidationManager;Locale fLocale;/** Locale. */XMLErrorReporter fErrorReporter;/** Error reporter */DOMErrorHandlerWrapper fErrorHandlerWrapper;DOMStringList fRecognizedParameters;// private data/** Default Constructor. *//** Constructs a parser configuration using the specified symbol table. ... */// <init>()/** Constructs a parser configuration using the specified symbol table ... */// <init>(SymbolTable)String[] recognizedFeaturesString[] recognizedPropertiesXMLEntityManager managernew XMLEntityManager(...)addRecognizedFeatures(...)JdkXmlUtils.OVERRIDE_PARSER_DEFAULTaddRecognizedProperties(...)new XMLErrorReporter(...)createValidationManager(...)getMessageFormatter(...)XMLMessageFormatter.XML_DOMAINXMLMessageFormatter xmftnew XMLMessageFormatter(...)putMessageFormatter(...)XMLMessageFormatter.XMLNS_DOMAINMessageFormatter xmftsetLocale(...)XNIException e/** Parse an XML document. ... */// XMLParserConfiguration methods/** Sets the document handler on the last component in the pipeline ... *//** Returns the registered document handler. */// setDocumentHandler(XMLDocumentHandler)/** Sets the DTD handler. ... */// getDocumentHandler():XMLDocumentHandler/** Returns the registered DTD handler. */// setDTDHandler(XMLDTDHandler)/** Sets the DTD content model handler. ... */// getDTDHandler():XMLDTDHandler/** Returns the registered DTD content model handler. */// setDTDContentModelHandler(XMLDTDContentModelHandler)/** Sets the resolver used to resolve external entities. The EntityResolver ... */// getDTDContentModelHandler():XMLDTDContentModelHandler/** Return the current entity resolver. ... */// setEntityResolver(XMLEntityResolver)/** Allow an application to register an error event handler. ... */// getEntityResolver():XMLEntityResolver/** Return the current error handler. ... */// setErrorHandler(XMLErrorHandler)/** Set the state of a feature. ... */// getErrorHandler():XMLErrorHandler/** setProperty ... */// setFeature(String,boolean)/** Set the locale to use for messages. ... */// setProperty(String,Object)/** Returns the locale. */// setLocale(Locale)// getLocale():Localeboolean stateConstants.DOM_COMMENTSConstants.DOM_DATATYPE_NORMALIZATIONConstants.DOM_NAMESPACESConstants.DOM_CDATA_SECTIONSConstants.DOM_ENTITIESConstants.DOM_SPLIT_CDATAConstants.DOM_VALIDATEConstants.DOM_WELLFORMEDConstants.DOM_NAMESPACE_DECLARATIONSConstants.DOM_INFOSETConstants.DOM_NORMALIZE_CHARACTERSConstants.DOM_CANONICAL_FORMConstants.DOM_VALIDATE_IF_SCHEMAConstants.DOM_CHECK_CHAR_NORMALIZATIONConstants.DOM_ELEMENT_CONTENT_WHITESPACEConstants.DOM_PSVIConstants.DOM_ERROR_HANDLERDOMException.TYPE_MISMATCH_ERRConstants.DOM_RESOURCE_RESOLVERnew DOMEntityResolverWrapper(...)XMLConfigurationException eConstants.DOM_SCHEMA_LOCATIONConstants.DOM_SCHEMA_TYPEConstants.NS_XMLSCHEMAConstants.NS_DTDXMLEntityResolver entityResolver//canSetParameternew DOMStringListImpl(...)/** reset all components before parsing *///getParameterNamesXMLComponent c/** Check a property. If the property is known and supported, this method ... */// reset()int suffixLengthPropertyState.NOT_SUPPORTEDcheckProperty(...)// checkProperty(String)getRecognizedFeatures(...)getRecognizedProperties(...)// addComponent(XMLComponent)new ValidationManager(...)// create table for features and properties// add default recognized features// set state for default features// add default recognized properties// set default values for normalization features// add message formatters// REVISIT: try to include XML Schema formatter.//          This is a hack to allow DTD configuration to be build.// set locale// REVISIT: What is the right thing to do? -Ac//no-op// save state if noone "objects"// store value if noone "objects"// REVISIT: Recognizes DOM L3 default features only.//          Does not yet recognize Xerces features.// Setting to false has no effect.// true is not supported// false is not supported// REVISIT: turning augmentation of PSVI is not support,// because in this case we won't be able to retrieve element// default value./* String msg = ... */// set properties// REVISIT: type mismatch// map DOM schema-location to JAXP schemaSource property// REVISIT: when add support to DTD validation// Added support for revalidation against DTDs// Xerces Symbol Table// REVISIT: check if this is a boolean parameter -- type mismatch should be thrown.//parameter is not recognized// REVISIT: datatype-normalization only takes effect if validation is on//if null, the returned value is true.//REVISIT: I dont like this --- even for unrecognized parameter it would//return 'true'. I think it should return false in that case.// Application will be surprised to find that setParameter throws not//recognized exception when canSetParameter returns 'true' Then what is the use//of having canSetParameter ??? - nb.//features whose parameter value can be set either 'true' or 'false'// or they accept any boolean value -- so we just need to check that// its a boolean value..//features whose parameter value can not be set to 'true'//features whose parameter value can not be set to 'false'// if name is not among the above listed above -- its not recognized. return false// REVISIT: should null value be supported?//as of now we are only supporting W3C XML Schema//false if the parameter is not recognized or the requested value is not supported.//Add DOM recognized parameters//REVISIT: Would have been nice to have a list of//recognized paramters.//Add recognized xerces features and properties// special cases// http://xml.org/sax/properties/xml-string// Value type: String// Access: read-only//   Get the literal string of characters associated with the//   current event.  If the parser recognises and supports this//   property but is not currently parsing text, it should return//   null (this is a good way to check for availability before the//   parse begins).// REVISIT - we should probably ask xml-dev for a precise// definition of what this is actually supposed to return, and// in exactly which circumstances.// check property// don't add a component more than once// register component's recognized features// register component's recognized properties// class XMLParserimport DOMErrorimport DOMLocatorimport XMLParseException//          we probably should not pass XMLParseException// REVISIT: the implementation of ErrorReporter./** <code>DOMErrorImpl</code> is an implementation that describes an error. ... */DOMError.SEVERITY_WARNINGnew DOMLocatorImpl(...)short fSeverity;String fMessage;DOMLocatorImpl fLocator;Exception fException;String fType;Object fRelatedData;/** Exctracts information from XMLParserException) */createDOMLocator(...)/** The severity of the error, either <code>SEVERITY_WARNING</code>, ... *//** An implementation specific string describing the error that occured. *//** The location of the error. */// method to get the DOMLocator ObjectgetCharacterOffset(...)getExpandedSystemId(...)/** The related platform dependent exception if any.exception is a reserved ... */// createDOMLocator()// assuming DOMLocator wants the *expanded*, not the literal, URI of the doc... - neilg// class DOMErrorImplnew DOMImplementationImpl(...)DOMImplementationImpl singleton;DocumentImpl docnew DocumentImpl(...)//if namespaceURI, qualifiedName and doctype are null, returned document is empty with//no document elementimport DOMImplementationList/** <p>This class implements the DOM Level 3 Core interface DOMImplementationList.</p> ... */Vector<> fImplementations;//A collection of DOMImplementations/** Construct an empty list of DOMImplementations *//** Returns the indexth item in the collection. ... *//** Returns the number of DOMImplementations in the list. ... */import DOMImplementationSourceimport DOMImplementationListImpl/** Supply one the right implementation, based upon requested features. Each ... *//** A method to request a DOM implementation. ... */DOMImplementation impltestImpl(...)/** A method to request a list of DOM implementations that support the ... */Vector<> implementationsnew DOMImplementationListImpl(...)String featureboolean isVersion// first check whether the CoreDOMImplementation would do// if not try the DOMImplementation// 2. we probably need only the default constructor.  -- el// DOMInputImpl extends XMLInputSource implements LSInput// 1. it should be possible to do the following/** This Class <code>DOMInputImpl</code> represents a single input source for an XML entity. ... */String fPublicId;String fSystemId;String fBaseSystemId;InputStream fByteStream;Reader fCharStream;String fData;String fEncoding;boolean fCertifiedText;/** Default Constructor, constructs an input source *//** Constructs an input source from just the public and system ... *//** Constructs an input source from a byte stream. ... */// DOMInputImpl(String,String,String)/** Constructs an input source from a character stream. ... */// DOMInputImpl(String,String,String,InputStream,String)/** Constructs an input source from a String. ... */// DOMInputImpl(String,String,String,Reader,String)/** An attribute of a language-binding dependent type that represents a ... */// DOMInputImpl(String,String,String,String,String)/** A string attribute that represents a sequence of 16 bit units (utf-16 ... *//** The character encoding, if known. The encoding must be a string ... *//** The public identifier for this input source. The public identifier is ... *//** The system identifier, a URI reference , for this input source. The ... *//** The base URI to be used (see section 5.1.4 in ) for resolving relative ... *//** If set to true, assume that the input is certified (see section 2.13 ... */// class DOMInputImpl/** <code>DOMLocatorImpl</code> is an implementaion that describes a location (e.g. ... */int fColumnNumber;/** The column number where the error occured, ... */int fLineNumber;/** The line number where the error occured, ... */Node fRelatedNode;/** related data node */String fUri;/** The URI where the error occured, ... */int fByteOffset;/** The byte offset into the input source this locator is pointing to or -1 ... */int fUtf16Offset;/** The UTF-16, as defined in [Unicode] and Amendment 1 of [ISO/IEC 10646], ... */// DOMLocatorImpl (int lineNumber, int columnNumber, String uri )// DOMLocatorImpl (int lineNumber, int columnNumber, int utf16Offset, String uri )// DOMLocatorImpl (int lineNumber, int columnNumber, int offset, Node errorNode, String uri )/** The line number where the error occured, or -1 if there is no line ... *//** The column number where the error occured, or -1 if there is no column ... *//** The URI where the error occured, or null if there is no URI available. */// class DOMLocatorImpl/** Used to format DOM error messages, using the system locale. ... */String DOM_DOMAIN;String XML_DOMAIN;String SERIALIZER_DOMAIN;ResourceBundle domResourceBundle;ResourceBundle xmlResourceBundle;ResourceBundle serResourceBundle;Locale locale;/** Formats a message with the specified arguments using the given ... */ResourceBundle resourceBundlearguments.length/** Initialize Message Formatter. *//** setLocale to be used by the formatter. ... */// format message// error// no messageimport AbortExceptionimport DTDGrammarimport XMLDTDDescriptionimport XMLDTDValidatorimport XSSimpleTypeimport SimpleLocatorimport XMLGrammarPreparserimport AugmentationsImplimport NamespaceSupportimport XMLGrammarPoolImplimport XMLSymbolsimport Augmentationsimport XMLAttributesimport XMLLocatorimport XMLResourceIdentifierimport XMLDocumentSourceimport AttributePSVIimport ElementPSVIimport XSTypeDefinition/** This class adds implementation for normalizeDocument method. ... */new XMLAttributesProxy(...)new DOMErrorImpl(...)new NamespaceSupport(...)new XMLString(...)boolean DEBUG_ND;/** Debug normalize document */// constants/** Debug namespace fix up algorithm */boolean DEBUG_EVENTS;/** Debug document handler events */String PREFIX;/** prefix added by namespace fixup algorithm should follow a pattern "NS" + index */CoreDocumentImpl fDocument;XMLAttributesProxy fAttrProxy;QName fQName;RevalidationHandler fValidationHandler;/** Validation handler represents validator instance. *//** symbol table */DOMErrorHandler fErrorHandler;/** error handler. may be null. */DOMErrorImpl fError;/** Cached {@link DOMError} impl. ... */boolean fNamespaceValidation;// Validation against namespace aware grammarboolean fPSVI;// Update PSVI information in the treeNamespaceContext fNamespaceContext;/** The namespace context of this document: stores namespaces in scope */NamespaceContext fLocalNSBinder;/** Stores all namespace bindings on the current element */ArrayList<> fAttributeList;/** list of attributes *//** DOM Locator -  for namespace fixup algorithm */Node fCurrentNode;/** for setting the PSVI */QName fAttrQName;XMLString fNormalizedValue;// attribute value normalizationXMLDTDValidator fDTDValidator;//DTD validatorboolean allWhitespace;//Check if element content is all "ignorable whitespace"/** Normalizes document. ... */DOMConfigurationImpl.SYMBOL_TABLEdeclarePrefix(...)XMLSymbols.EMPTY_STRINGfConfiguration.featuresDOMConfigurationImpl.VALIDATEString schemaLangDOMConfigurationImpl.JAXP_SCHEMA_LANGUAGEgetValidator(...)CoreDOMImplementationImpl.singletonDOMConfigurationImpl.SCHEMADOMConfigurationImpl.SCHEMA_FULL_CHECKINGDOMConfigurationImpl.PSVIDOMConfigurationImpl.XERCES_VALIDATIONclearIdentifiers(...)setDocumentHandler(...)new SimpleLocator(...)fDocument.encodingfDocument.fDocumentURInormalizeNode(...)releaseValidator(...)AbortException e/** This method acts as if the document was going through a save ... */boolean wellformedfLocator.fRelatedNodeDocumentTypeImpl docTypecreateGrammarPool(...)doctypeDecl(...)ElementImpl elemAttributeMap attributesfDocument.errorCheckingisXMLVersionChanged(...)DOMConfigurationImpl.WELLFORMEDisValidQName(...)reportDOMError(...)DOMError.SEVERITY_ERRORpushContext(...)DOMConfigurationImpl.NAMESPACESnamespaceFixUp(...)DOMConfigurationImpl.NSDECLAttr attgetItem(...)XMLSymbols.PREFIX_XMLNSnormalize(...)isAttrValueWF(...)updateQName(...)fConfiguration.fErrorHandlerWrapper.fCurrentNodefConfiguration.fErrorHandlerWrapperpopContext(...)DOMConfigurationImpl.COMMENTSNode prevSiblingNode nextSiblinginsertData(...)String commentdataisCommentWF(...)DOMConfigurationImpl.ENTITIESexpandEntityRef(...)DOMConfigurationImpl.CDATAcharacterData(...)DOMConfigurationImpl.SPLITCDATAisXMLCharWF(...)Node firstSplitNodeNode newChildisCDataWF(...)short nextTypesetIgnorableWhitespace(...)ProcessingInstruction pinode//normalizeNodeXMLGrammarPoolImpl poolnew XMLGrammarPoolImpl(...)XMLGrammarPreparser preParsernew XMLGrammarPreparser(...)String internalSubsetgetInternalSubset(...)XMLInputSource isnew XMLInputSource(...)registerPreparser(...)setCharacterStream(...)DTDGrammar gpreparseGrammar(...)setRootName(...)getGrammarDescription(...)// check attribute names if the version of the document changed.// remove default attributes// normalize attribute values// fix namespacesDOMMessageFormatter.XML_DOMAINString localpartaddSymbol(...)addNamespaceDecl(...)DOMError.SEVERITY_FATAL_ERRORcloneMap(...)String declaredURIString declaredPrefix/** Adds a namespace attribute or replaces the value of existing namespace ... *//** Check if CDATA section is well-formed ... */// Methods for well-formness checkingchar[] dataarrayint datalengthdataarray.lengthisXML11Invalid(...)isHighSurrogate(...)isLowSurrogate(...)isSupplemental(...)supplemental(...)isInvalid(...)/** NON-DOM: check for valid XML characters as per the XML version ... */// isCDataWFchar ch2/** NON-DOM: check if value of the comment is well-formed ... */// isXMLCharWF/** NON-DOM: check if attribute value is well-formed ... */// isCommentWFDocument ownerEntity entDocumentType docTypegetNamedItemNS(...)/** Reports a DOM error to the user handler. ... */error.fMessageerror.fSeverityerror.fLocatorerror.fTypeerror.fRelatedDatalocator.fRelatedNodenew AbortException(...)qname.prefixqname.localpartqname.rawnameqname.uri/* REVISIT: remove this method if DOM does not change spec. ... */boolean normalizedfNormalizedValue.ch.lengthfNormalizedValue.chfNormalizedValue.lengthAttributeMap fAttributes;ElementImpl fElement;Vector<> fAugmentations;new AugmentationsImpl(...)/** This method adds default declarations ... */getXercesAttribute(...)setXercesAttributeNode(...)setSpecified(...)boolean specified/** Sets the augmentations of the attribute at the specified index. ... *//** The start of the document. ... */// XMLDocumentHandler methods/** Notifies of the presence of an XMLDecl line in the document. If ... *//** Notifies of the presence of the DOCTYPE line in the document. ... *//** A comment. ... *//** A processing instruction. Processing instructions consist of a ... *//** The start of an element. ... */Element currentElementint attrCountAttributePSVI attrPSVIgetAugmentations(...)Constants.ATTRIBUTE_PSVIgetAttributeNodeNS(...)fAttrQName.urifAttrQName.localpartXSTypeDefinition declgetMemberTypeDefinition(...)boolean idisIDType(...)getTypeDefinition(...)setIdAttributeNode(...)setPSVI(...)DOMConfigurationImpl.DTNORMALIZATIONgetSchemaNormalizedValue(...)/** An empty element. ... *//** This method notifies the start of a general entity. ... *//** Notifies of the presence of a TextDecl line in an entity. If present, ... *//** This method notifies the end of a general entity. ... *//** Character content. ... *//** Ignorable whitespace. For this method to be called, the document ... *//** The end of an element. ... */ElementPSVI elementPSVIConstants.ELEMENT_PSVIElementImpl elementNodeString normalizedValuesetTextContent(...)getTextContent(...)/** The start of a CDATA section. ... *//** The end of a CDATA section. ... *//** The end of the document. ... *//** Sets the document source. *//** Returns the document source. */// intialize and reset DOMNormalizer component// reset namespace context// report fatal error on DOM Level 1 nodes// check if we need to fill in PSVI// reset ID table// reset schema validator// don't advance// release resources// otherwise re-throw.//REVISIT: well-formness encoding info//do the name check only when version of the document was changed &//application has set the value of well-formed features to true// push namespace context// fix namespaces and remove default attributes//removeDefault(attr, attributes);// REVISIT: possible solutions to discard default content are://         either we pass some flag to XML Schema validator//         or rely on the PSVI information.// updates global qname// set error node in the dom error wrapper// so if error occurs we can report an error node// call re-validation handler// normalize children// normalized subtree// pop namespace context// remove the comment node//if comment node need not be removed// check comments for invalid xml chracter as per the version// of the document//end-else if comment node is not to be removed.// The list of children #text -> &ent;// and entity has a first child as a text// we should not advance// Don't advance// REVISIT: traverse entity reference and send appropriate calls to the validator// (no normalization should be performed for the children).// convert CDATA to TEXT nodes//don't advance// send characters call for CDATA// issue warning// check well-formedness// If node is a text node, we need to check for one of two//   2) There is no adjacent text node, but node is// If an adjacent text node, merge it with this node// We don't need to check well-formness here since we are not yet// done with this node.// Don't advance;// validator.characters() call and well-formness// Don't send characters or check well-formness in the following cases:// 1. entities is false, next child is entity reference: expand tree first// 2. comments is false, and next child is comment// 3. cdata is false, and next child is cdata//do the well-formed valid PI target name , data check when application has set the value of well-formed feature to true//1.check PI target name//2. check PI data//processing isntruction data may have certain characters//which may not be valid XML character//end case Node.PROCESSING_INSTRUCTION_NODE//end of switch// ------------------------------------// pick up local namespace declarations// <xsl:stylesheet xmlns:xsl="http://xslt">//   <!-- add the following via DOM//          body is bound to http://xslt//    -->//   <xsl:body xmlns:xsl="http://bound"/>// Record all valid local declarations//checkQName does checking based on the version of the document// namespace attribute// "namespace-declarations" == false; Discard all namespace declaration attributes// Check for invalid namespace declaration://A null value for locale is passed to formatMessage,//which means that the default locale will be used// XML 1.0 Attribute value normalization// value = normalizeAttributeValue(value, attr);//xmlns:prefix// REVISIT: issue error on invalid declarations//          xmlns:foo = ""//removeDefault (attr, attributes);// (localpart == fXmlnsSymbol && prefix == fEmptySymbol)  -- xmlns// empty prefix is always bound ("" or some string)// end-else: valid declaration// end-if: namespace attribute// ---------------------------------------------------------// Fix up namespaces for element: per DOM L3// Need to consider the following cases:// case 1: <xsl:stylesheet xmlns:xsl="http://xsl">// We create another element body bound to the "http://xsl" namespace// as well as namespace attribute rebounding xsl to another namespace.// <xsl:body xmlns:xsl="http://another">// Need to make sure that the new namespace decl value is changed to// "http://xsl"// check if prefix/namespace is correct for current element// "namespace-declarations" == false? Discard all namespace declaration attributes// no namespace declaration == no namespace URI, semantics are to keep prefix// Element has a namespace// The xmlns:prefix=namespace or xmlns="default" was declared at parent.// The binder always stores mapping of empty prefix to "".// the prefix is either undeclared// or// conflict: the prefix is bound to another URI// Element has no namespace//  Error: DOM Level 1 node!// uri=null and no colon (DOM L2 node)// undeclare default namespace declaration (before that element// bound to non-zero length uir), but adding xmlns="" decl// -----------------------------------------// Fix up namespaces for attributes: per DOM L3// check if prefix/namespace is correct the attributes// clone content of the attributes// normalize attribute value// make sure that value is never null.// attribute has namespace !=null/* String localpart = */// ---------------------------------------// skip namespace declarations// REVISIT: can we assume that "uri" is from some symbol// table, and compare by reference? -SG//---------------------------------------// check if value of the attribute is namespace well-formed/* if (removeDefault(attr, attributes)) { ... *///value = normalizeAttributeValue(value, attr);// reset id-attributes// find if for this prefix a URI was already declared// attribute has no prefix (default namespace decl does not apply to attributes)// OR// attribute prefix is not declared// conflict: attribute has a prefix that conficlicts with a binding//           already active in scope// Find if any prefix for attributes namespace URI is available// in the scope// use the prefix that was found (declared previously for this URI// the current prefix is not null and it has no in scope declaration// use this prefix// find a prefix following the pattern "NS" +index (starting at 1)// make sure this prefix is not declared in the current scope.// add declaration for the new prefix// change prefix for this attribute// attribute uri == null// It is an error if document has DOM L1 nodes.// uri=null and no colon// no fix up is needed: default namespace decl does not// removeDefault(attr, attributes);// end loop for attributes// version of the document is XML 1.1// we need to check all chracters as per production rules of XML11// check if this is a supplemental character// CDEndInContent// version of the document is XML 1.0// we need to check all chracters as per production rules of XML 1.0// Note:  The key InvalidCharInCDSect from XMLMessages.properties// is being used to obtain the message and DOM error type// "wf-invalid-character" is used.  Also per DOM it is error but// as per XML spec. it is fatal error// end-else fDocument.isXMLVersion()//we need to check all characters as per production rules of XML11// we need to check all characters as per production rules of XML 1.0// invalid: '--' in comment//check each child node of the attribute's value//If the attribute's child is an entity refernce//search for the entity in the docType//of the attribute's ownerDocument//If the entity was not found issue a fatal error// Text node// REVISIT: the symbols are added too often: start/endElement//          and in the namespaceFixup. Should reduce number of calls to symbol table.// specified attributes should already have a normalized form// since those were added by validator// ensure capacity// skip following xA// REVISIT: this implementation does not store any value in augmentations//          and basically not keeping augs in parallel to attributes map//          untill all attributes are added (default attributes)// add defaults to the tree// the default attribute was removed by a user and needed to// be added back// REVISIT: the following should also update ID table// default attribute is in the tree// we don't need to do anything since prefix was already fixed// at the namespace fixup time and value must be same value, otherwise// attribute will be treated as specified and we will never reach// this method.// REVISIT: implement//return fAttributes.item(index).ge);// REVISIT: is this desired behaviour?// The values are updated in the case datatype-normalization is turned on// in this case we need to make sure that specified attributes stay specified//REVISIT: instead we should be using augmentations:// to set/retrieve Id attributes// datatype-normalization// NOTE: The specified value MUST be set after we set//       the node value because that turns the "specified"//       flag to "true" which may overwrite a "false"//       value from the attribute list.// include element default content (if one is available)// NOTE: this is a hack: it is possible that DOM had an empty element// and validator sent default value using characters(), which we don't// implement. Thus, here we attempt to add the default value.// default content could be provided// DOMNormalizer class/** This class represents an output destination for data. ... */Writer fCharStream;OutputStream fByteStream;/** Default Constructor *//** An attribute of a language and binding dependent type that represents a ... *//** Depending on the language binding in use, this attribute may not be ... *//** The system identifier, a URI reference [IETF RFC 2396], for this output ... *///DOMOutputImpl/** DOM Level 3 ... */Vector<> fStrings;//A collection of DOMString values/** Construct an empty list of DOMStringListImpl *//** DOM Internal: ... *//* Copyright 2001, 2002,2004 The Apache Software Foundation. ... */import XSImplementationImpl/** Allows to retrieve <code>XSImplementation</code>, DOM Level 3 Core and LS implementations ... */DOMImplementationList listgetDOMImplementationList(...)// if not try the PSVIDOMImplementation// if not try the XSImplementation//Add core DOMImplementations/** This class implements the DOM's NodeList behavior for ... */NodeImpl rootNode;String tagName;// Where the search started// Or "*" to mean all-tags-acceptableVector<> nodes;String nsName;boolean enableNS;this.rootNodethis.tagName/** Constructor for Namespace support. */this.nsName/** Returns the length of the node list. *//** Returns the node at the specified index. */Node thisNodechanges(...)nextMatchingElementAfter(...)/** Iterative tree-walker. When you have a Parent link, there's often no ... */// Protected methods (might be overridden by an extending DOM)getTagName(...)// Preload all matching elements. (Stops when we run out of subtree!)// Tree changed. Do it all from scratch!// In the cache// Not yet seen// Pick up where we left off (Which may be the beginning)// Add nodes up to the one we're looking for// Either what we want, or null (not avail.)// Look down to first child.// Look right to sibling (but not from root!)// Look up and right (but not past root!)// Stop when we return to starting point// Have we found an Element with the right tagName?// ("*" matches anything.)// DOM2: Namespace logic.// Otherwise continue walking the tree// Fell out of tree-walk; no more instances found// nextMatchingElementAfter(int):Node// class DeepNodeListImplint fNodeIndex;/** Node index. *//** This is the deferred constructor. Only the fNodeIndex is given here. ... *//** Returns the node index. */// DeferredNode methods// <init>(DeferredDocumentImpl,int)/** Synchronizes the data (name and value) for fast nodes. */DeferredDocumentImpl ownerDocumentint extragetNodeExtra(...)int extraNode/** Synchronizes the node's children with the internal structure. ... */// synchronizeData()/* WARNING: because java doesn't support multi-inheritance some code is ... */// no need to sync in the future// fluff data// synchronizeChildren()// class DeferredAttrImpl/** DeferredAttrNSImpl is to AttrNSImpl, what DeferredAttrImpl is to ... */getNodeURI(...)// extract prefix and local part from QName/** This is the deferred constructor. Only the fNodeIndex is given here. All other data, ... */getNodeValueString(...)// class DeferredCDATASectionImpl// class DeferredCommentImpl/** <p>This DOMImplementation class is description of a particular ... */new DeferredDOMImplementationImpl(...)DeferredDOMImplementationImpl singleton;boolean DEBUG_PRINT_REF_COUNTS;/** To include code for printing the ref count tables. */// debuggingboolean DEBUG_PRINT_TABLES;/** To include code for printing the internal tables. */boolean DEBUG_IDS;/** To debug identifiers set to true and recompile. */int CHUNK_SHIFT;/** Chunk shift. */// protectedint CHUNK_SIZE;/** Chunk size. */// 2^8 = 256int CHUNK_MASK;/** Chunk mask. */int INITIAL_CHUNK_COUNT;/** Initial chunk size. */int fNodeCount;/** Node count. */// depending on the node type.// To maximize memory consumption the actual semantic of these fields vary// lazy-eval information// 32...[] fNodeType;/** Node types. */...[] fNodeName;/** Node names. */...[] fNodeValue;/** Node values. */...[] fNodeParent;/** Node parents. */...[] fNodeLastChild;/** Node first children. */...[] fNodePrevSib;/** Node prev siblings. */...[] fNodeURI;/** Node namespace URI. */...[] fNodeExtra;/** Extra data. */int fIdCount;/** Identifier count. */...[] fIdName;/** Identifier name indexes. */...[] fIdElement;/** Identifier element indexes. */boolean fNamespacesEnabled;// interpret the int representing the qname.// Implementation Note: The deferred element and attribute must know how to/** DOM2: For namespace support in the deferred case. */StringBuilder fBufferStr;ArrayList<> fStrChunks;/** Experimental constructor. */// <init>(boolean)// <init>(boolean,boolean)/** Returns the cached parser.getNamespaces() value. *//** Creates a document node in the table. */// internal factory methodscreateNode(...)/** Creates a doctype. */setChunkValue(...)// createDeferredDocumentType(String,String,String):intint extraDataIndexint echunkint eindexsetChunkIndex(...)/** Creates a notation in the table. *//** Creates an entity in the table. */// createDeferredNotation(String,String,String):intint extraDataIndex2int echunk2int eindex2// createDeferredEntity(String,String,String,String):int// DOM Level 3: setting encoding and versionint eNodeIndex// DOM Level 3: sets element TypeInfoint elementChunkint elementIndex/** Creates an entity reference node in the table. *//** Creates an element node with a URI in the table and type information. ... */// createDeferredEntityReference(String):intint elementNodeIndex/** Creates an element node in the table. ... */// createDeferredElement(String,String,Object):intcreateDeferredElement(...)/** Creates an element node with a URI in the table. *//** This method is used by the DOMParser to create attributes. ... */// createDeferredElement(String,String):intint attrNodeIndexcreateDeferredAttribute(...)int attrChunkint attrIndexint lastAttrNodeIndexgetChunkIndex(...)getChunkValue(...)DeferredNode.TYPE_NODE/** Creates an attribute in the table. *//** Creates an attribute with a URI in the table. */NodeImpl.ATTRIBUTE_NODE/** Creates an element definition in the table. */// createDeferredAttribute(String,String,String,boolean):intNodeImpl.ELEMENT_DEFINITION_NODE/** Creates a text node in the table. */// createDeferredElementDefinition(String):int/** Creates a CDATA section node in the table. */// createDeferredTextNode(String,boolean):int/** Creates a processing instruction node in the table. */// createDeferredCDATASection(String):int/** Creates a comment node in the table. */// createDeferredProcessingInstruction(String,String):int/** Creates a clone of the specified node. */// createDeferredComment(String):intint nchunkint nindexint cloneIndexint cchunkint cindexint extraIndexint prevIndexint clonedChildIndexgetRealPrevSibling(...)/** Appends a child to the specified parent in the table. */// cloneNode(int,boolean):intint pchunkint pindexint olast/** Adds an attribute node to the specified element. */// appendChild(int,int)int achunkint aindexint oldAttrIndexint nextIndexint oachunkint oaindexString oldAttrNameint attrTextIndexclearChunkIndex(...)int atchunkint atindexclearChunkValue(...)// setAttributeNode(int,int):int/** Sets type of attribute *//** Inserts a child before the specified node in the table. */int rchunkint previousIndex/** Sets the last child of the parentIndex to childIndex. */// insertBefore(int,int,int):int/** Returns the parent node of the given node. ... */// setAsLastChild(int,int)/** Returns the last child of the given node. */// getParentNode(int):int/** Returns the last child of the given node. ... *//** Returns the prev sibling of the given node. ... */// getLastChild(int,boolean):intgetPrevSibling(...)/** Returns the <i>real</i> prev sibling of the given node, ... */// getPrevSibling(int,boolean):int/** Returns the <i>real</i> prev sibling of the given node. ... *//** Returns the index of the element definition in the table ... */// getReadPrevSibling(int,boolean):intint docTypeIndex/** Instantiates the requested node object. */// lookupElementDefinition(String):intDeferredNode nodenew DeferredAttrNSImpl(...)new DeferredAttrImpl(...)new DeferredCDATASectionImpl(...)new DeferredCommentImpl(...)new DeferredDocumentTypeImpl(...)new DeferredElementNSImpl(...)new DeferredElementImpl(...)int idIndexputIdentifier0(...)new DeferredEntityImpl(...)new DeferredEntityReferenceImpl(...)new DeferredNotationImpl(...)new DeferredProcessingInstructionImpl(...)new DeferredTextImpl(...)new DeferredElementDefinitionImpl(...)/** Returns the name of the given node. */// createNodeObject(int):Node/** Returns the name of the given node. ... */// getNodeNameString(int):String/** Returns the real value of the given node. */// getNodeName(int,boolean):String/** Returns the real value of the given node. ... */// getNodeValueString(int):Stringint prevSibint chunkCount/** Returns the value of the given node. */// getNodeValueString(int,boolean):String/** Clears the type info that is stored in the fNodeValue array ... */RefCount cc.fCount/** Returns the value of the given node. ... *//** Returns the extra info of the given node. ... */// getNodeValue(int,boolean):String/** Returns the type of the given node. */// getNodeExtra(int,boolean):int/** Returns the type of the given node. ... *//** Returns the attribute value of the given name. */// getNodeType(int):int/** Returns the URI of the given node. *//** Returns the URI of the given node. ... *//** Registers an identifier name with a specified element node. */// identifier maintenance// getNodeURI(int,int):StringfIdName.lengthString[] idNameint[] idElementidName.length/** Prints out the tables. */// DEBUG// putIdentifier(String,int)fNodeType.lengthDocumentImpl.ELEMENT_DEFINITION_NODE// print()/** Synchronizes the node's data. */IntVector pathnew IntVector(...)String idNameNode placegetNodeIndex(...)boolean origChildNode firstChildNode lastgetNodeObject(...)first.previousSiblingnode.ownerNodesetMutationEvents(...)a.valueChildNode firstNodeChildNode lastNodefirstNode.previousSibling// synchronizeChildren(AttrImpl,int):voidp.firstChild/** Ensures that the internal tables are large enough. */// utility methods// synchronizeChildren(ParentNode,int):voidint newsizeint[][] newArrayObject[][] newStrArraycreateChunk(...)/** Creates a node of the specified type. */// ensureCapacity(int,int)/** Performs a binary search for a target value in an array of ... */// createNode(short):intint middle...[] INIT_ARRAY;// Private methods// binarySearch(int[],int,int,int):int/** Creates the specified chunk in the given array of chunks. */DeferredDocumentImpl$RefCountint fCount;new RefCount(...)/** Sets the specified value in the given of data at the chunk and index. ... */int[] dataChunkint ovalueObject[] dataChunkString ovalue/** Returns the specified value in the given data at the chunk and index. *//** Clears the specified value in the given data at the chunk and index. ... *//** This version of putIdentifier is needed to avoid fluffing ... *//** Prints the ID array. */// putIdentifier0(String,Element)DeferredDocumentImpl$IntVector/** A simple integer vector. */// Classes// print(int[],int,int,int,int)/** Data. *//** Size. *//** Returns the length of this vector. *//** Returns the element at the specified index. *//** Appends an element to the end of the vector. *//** Clears the vector. *//** Makes sure that there is enough storage. */int[] newdata// create node// save name, public id, system id// return node index// create extra data node to store internal subset// create extra data node// save name, public id, system id, and notation name// in extra data node set baseURI value// set other values in the extra chunk// notation// version  L3// encoding L3// baseURI// get first extra data chunk// get second extra data chunk// create attribute// set attribute's parent to element// get element's last attribute// add link from new attribute to last attribute// add link from element to new last attribute// store type information// use extra to store ignorableWhitespace info// clone immediate node// clone and attach children// return cloned node index// append parent index// set previous sibling of new child// update parent's last child// see if this attribute is already here// remove old attribute// patch links// remove connections to siblings// add new attribute// find doctype// find element definition// is there anything to do?// get node type// create new node// Standard DOM node types// NOTE: Document fragments can never be "fast".//       The parser will never ask to create a document//       fragment during the parse. Document fragments//       are used by the application *after* the parse.// case Node.DOCUMENT_FRAGMENT_NODE: { break; }// this node is never "fast"// save the doctype node// check to see if this element needs to be// registered for its ID attributes// register ID// continue if there are more IDs for// this element// non-standard DOM node types// switch node type// store and return// append data that is stored in fNodeValue// REVISIT: for text nodes it works differently than for CDATA//          nodes.// go in reverse order: find last child, then// its previous sibling, etc// add to the buffer in the correct order.// find if any other data stored in children// initialize arrays// resize arrays// store identifier// separator// ref count// This assumes that the document is small// fluff up enough nodes to fill identifiers hash// REVISIT: There has to be a more efficient way of//          doing this. But keep in mind that the//          tree can have been altered and re-ordered//          before all of the element nodes with ID//          attributes have been registered. For now//          this is reasonable and safe. -Ac// ignore if it's already been registered// find path from this element to the root// Traverse path (backwards), fluffing the elements// along the way. When this loop finishes, "place"// will contain the reference to the element node// we're interested in. -Ac// register the element// see if there are more IDs on this element// if identifiers/* when we have elements with IDs this method is being recursively ... */// we don't want to generate any event for this so turn them off// create children and link them as siblings// save doctype and document type// set mutation events flag back to its original value// create children and link them as siblings or simply store the value// as a String if all we have is one piece of text// firstChild = firstNode// create buffers// resize the tables// Done - there's sufficient capacity// create new chunks// ensure tables are large enough// initialize node// return node index number// look for target value// is this the one we're looking for?// is this point higher or lower?// while// not found// Re-create chunk if it was deleted.// type information// create Map// save ID and its associated element// ensureCapacity(int)// class IntVector// class DeferredDocumentImpl/** This class represents a Document Type <em>declaraction</em> in ... */this.ownerDocument/** Synchronizes the entities, notations, and elements. */DeferredNode lastnew NamedNodeMapImpl(...)(...).allowGrammarAccess// public and system ids// no need to synchronize again// create new node maps// fill node maps// internal, external, and unparsed entities// notations// element definitions// elements// NOTE: Should never get here! -Ac// set entities and notations read_only per DOM spec// class DeferredDocumentTypeImpl/** NON-DOM CLASS: Describe one of the Elements (and its associated ... *//** Synchronizes the default attribute values. */// attributes are now synced// create attributes node map// Default attributes dangle as children of the element// definition "node" in the internal fast table.// class DeferredElementDefinitionImpl/** Elements represent most of the "markup" and structure of the ... *//** This is the deferred constructor. Only the fNodeIndex is given here. All ... */// <init>(DocumentImpl,int)ownerDocument.mutationEventssetupDefaultAttributes(...)NodeImpl attr// class DeferredElementImpl/** DeferredElementNSImpl is to ElementNSImpl, what DeferredElementImpl is to ... */boolean seenSchemaDefault// extract local part from QName// Take special care of schema defaulted attributes. Calling the// non-namespace aware setAttributeNode() method could overwrite// another attribute with the same local name./** Entity nodes hold the reference data for an XML Entity -- either ... *//** Synchronize the entity data. This is special because of the way ... */int extraIndex2/** Synchronize the children. */// no need to sychronize again// get the node data// get the entity data// encoding and version DOM L3// baseURI, actualEncoding DOM L3// class DeferredEntityImpl/** EntityReference models the XML &entityname; syntax, when used for ... */// get children// class DeferredEntityReferenceImpl/** An interface for deferred node object. ... */short TYPE_NODE;// interface DeferredNode/** Notations are how the Document Type Description (DTD) records hints ... *//** Synchronizes the data. This is special because of the way ... */// class DeferredNotationImpl/** Processing Instructions (PIs) permit documents to carry ... *//** Synchronizes the data. */// class DeferredProcessingInstructionImpl/** Text nodes hold the non-markup, non-Entity content of ... *//** Synchronizes the underlying data. */isIgnorableWhitespace(...)// no need for future synchronizations// get initial text value// NOTE: We used to normalize adjacent text node values here.//       This code has moved to the DeferredDocumentImpl//       getNodeValueString() method. -Ac// ignorable whitespace// class DeferredTextImpl/** DocumentFragment is a "lightweight" or "minimal" Document ... *//** Override default behavior to call normalize() on this Node's ... */// class DocumentFragmentImplimport EventImplimport MutationEventImplimport DocumentEventimport EventExceptionimport MutationEventimport DocumentRangeimport Rangeimport DocumentTraversalimport NodeFilterimport TreeWalkerVector<>.classList<NodeIterator> iterators;// REVISIT: Should this be transient? -Ac/** Iterators */List<Range> ranges;/** Ranges */Map<NodeImpl,List<LEntry>> eventListeners;/** Table for event listeners registered to this document nodes. */boolean mutationEvents;/** Bypass mutation events firing. */DocumentImpl newdocnewdoc.mutationEvents/** NON-DOM extension: ... */// DocumentTraversal methodscreateNodeIterator(...)/** Create and return a NodeIterator. The NodeIterator is ... */NodeIterator iteratornew NodeIteratorImpl(...)new ArrayList<NodeIterator>(...)createTreeWalker(...)/** Create and return a TreeWalker. ... */new TreeWalkerImpl(...)/** This is not called by the developer client. The ... */// Not DOM Level 2. Support DocumentTraversal methods.// DocumentRange methodsRange rangenew RangeImpl(...)new ArrayList<Range>(...)/** Not a client function. Called by Range.detach(), ... */receiveReplacedText(...)receiveDeletedText(...)receiveInsertedText(...)/** A method to be called when a text node has been split, ... */receiveSplitData(...)/** Introduced in DOM Level 2. Optional. <p> ... */// DocumentEvent methodsnew EventImpl(...)new MutationEventImpl(...)/** Sets whether the DOM implementation generates mutation events ... *//** Store event listener registered on a given node ... */new HashMap<NodeImpl,List<LEntry>>(...)/** Retreive event listener registered on a given node */DocumentImpl$LEntry/* NON-DOM INTERNAL: Class LEntry is just a struct used to represent ... */// EventTarget support (public and internal)EventListener listener;boolean useCapture;/** NON-DOM INTERNAL: Constructor for Listener list Entry ... */this.useCapture/** Introduced in DOM Level 2. <p> Register an event listener with this ... */// LEntryList<LEntry> nodeListenersgetEventListeners(...)LCount lcremoveEventListener(...)new ArrayList<LEntry>(...)setEventListeners(...)new LEntry(...)lc.captureslc.totallc.bubbles/** Introduced in DOM Level 2. <p> Deregister an event listener previously ... */// addEventListener(NodeImpl,String,EventListener,boolean) :voidLEntry lele.useCapturele.listenerle.type// removeEventListener(NodeImpl,String,EventListener,boolean) :voidEventImpl evtList<Node> pvNode pevt.initializedevt.typenew EventException(...)EventException.UNSPECIFIED_EVENT_TYPE_ERRevt.preventDefaultevt.targetevt.stopPropagationevt.eventPhaseEvent.CAPTURING_PHASENodeImpl nnevt.currentTargetList<LEntry> nlint nlsizeEvent.AT_TARGETevt.bubblesint pvsizeEvent.BUBBLING_PHASElc.defaultsevt.cancelable/** NON-DOM INTERNAL: DOMNodeInsertedIntoDocument and ...RemovedFrom... ... */// dispatchEvent(NodeImpl,Event) :booleanNamedNodeMap adispatchingEventToSubtree(...)/** Dispatches event to the target node's descendents recursively ... */// dispatchEventToSubtree(NodeImpl,Node,Event) :voidDocumentImpl$EnclosingAttr/** NON-DOM INTERNAL: Return object for getEnclosingAttr. Carries ... */AttrImpl node;String oldvalue;EnclosingAttr savedEnclosingAttr;/** NON-DOM INTERNAL: Convenience wrapper for calling ... */dispatchAggregateEvents(...)ea.nodeea.oldvalueMutationEvent.MODIFICATION/** NON-DOM INTERNAL: Generate the "aggregated" post-mutation events ... */// dispatchAggregateEvents(NodeImpl,EnclosingAttr) :voidNodeImpl ownerMutationEventImpl.DOM_SUBTREE_MODIFIEDMutationEventImpl.DOM_ATTR_MODIFIEDMutationEventImpl meinitMutationEvent(...)MutationEvent me/** NON-DOM INTERNAL: Pre-mutation context check, in ... */// dispatchAggregateEvents(NodeImpl, AttrImpl,String) :voidNodeImpl eventAncestorEnclosingAttr retvalnew EnclosingAttr(...)retval.noderetval.oldvalue// saveEnclosingAttr(NodeImpl) :voidsaveEnclosingAttr(...)MutationEventImpl.DOM_CHARACTER_DATA_MODIFIED/** A method to be called when a character data node has been replaced */MutationEventImpl.DOM_NODE_INSERTEDMutationEventImpl.DOM_NODE_INSERTED_INTO_DOCUMENTsavedEnclosingAttr.nodeNodeImpl pdispatchEventToSubtree(...)insertedNodeFromDOM(...)removeNode(...)MutationEventImpl.DOM_NODE_REMOVEDMutationEventImpl.DOM_NODE_REMOVED_FROM_DOCUMENT/** A method to be called when character data is about to be replaced in the tree. */MutationEvent.ADDITIONMutationEvent.REMOVALVector<NodeIterator> itnew Vector<NodeIterator>(...)Vector<Range> rnew Vector<Range>(...)Hashtable<NodeImpl,Vector<LEntry>> elnew Hashtable<NodeImpl,Vector<LEntry>>(...)Entry<NodeImpl,List<LEntry>> eMap<>.Entry<NodeImpl,List<LEntry>>new Vector<LEntry>(...)Entry<NodeImpl,Vector<LEntry>> eMap<>.Entry<NodeImpl,Vector<LEntry>>// notify ranges// stop firing events when there isn't any listener// turn mutation events on// We can't dispatch to blank type-name, and of course we need// a listener to dispatch to// Each listener may be registered only once per type per phase.// Simplest way to code that is to zap the previous entry, if any.// Record active listener// If this couldn't be a valid listener registration, ignore request// Note that addListener has previously ensured that// each listener may be registered only once per type per phase.// count-down is OK for deletions!// Storage management: Discard empty listener lists// Remove active listener// Found it; no need to loop farther.// Can't use anyone else's implementation, since there's no public// API for setting the event's processing-state fields.// VALIDATE -- must have been initialized at least once, must have// a non-null non-blank name.// If nobody is listening for this event, discard immediately// INITIALIZE THE EVENT'S DISPATCH STATUS// (Note that Event objects are reusable in our implementation;// that doesn't seem to be explicitly guaranteed in the DOM, but// I believe it is the intent.)// Capture pre-event parentage chain, not including target;// use pre-event-dispatch ancestors even if event handlers mutate// document and change the target's context.// Note that this is parents ONLY; events do not// cross the Attr/Element "blood/brain barrier".// DOMAttrModified. which looks like an exception,// is issued to the Element rather than the Attr// and causes a _second_ DOMSubtreeModified in the Element's// tree.// CAPTURING_PHASE:// Ancestors are scanned, root to target, for// Capturing listeners.// Someone set the flag. Phase ends.// Handle all capturing listeners on this node// call listeners in the order in which they got registered// All exceptions are ignored.// Both AT_TARGET and BUBBLE use non-capturing listeners.// AT_TARGET PHASE: Event is dispatched to NON-CAPTURING listeners// on the target node. Note that capturing listeners on the target// node are _not_ invoked, even during the capture phase.// BUBBLING_PHASE: Ancestors are scanned, target to root, for// non-capturing listeners. If the event's preventBubbling flag// has been set before processing of a node commences, we// instead immediately advance to the default phase.// Note that not all events bubble.// Handle all bubbling listeners on this node// call listeners in the order in which they got// registered// DEFAULT PHASE: Some DOMs have default behaviors bound to specific// nodes. If this DOM does, and if the event's preventDefault flag has// not been set, we now return to the target node and process its// default handler for this event, if any.// No specific phase value defined, since this is DOM-internal// evt.eventPhase = Event.DEFAULT_PHASE;// evt.currentTarget = node;// DO_DEFAULT_OPERATION// ***** Recursive implementation. This is excessively expensive,// and should be replaced in conjunction with optimization// mentioned above.// We have to send DOMAttrModified.// DOMSubtreeModified gets sent to the lowest common root of a// set of changes.// "This event is dispatched after all other events caused by the// mutation have been fired."// If we're within an Attr, DStM gets sent to the Attr// and to its owningElement. Otherwise we dispatch it// locally.// MUTATION PREPROCESSING AND PRE-EVENTS:// If we're within the scope of an Attr and DOMAttrModified// was requested, we need to preserve its previous value for// that event.// Any other parent means we're not in an Attr// MUTATION POST-EVENTS:// Subroutine: Transmit DOMAttrModified and DOMSubtreeModified,// if required. (Common to most kinds of mutation)// End mutation postprocessing//now that we have finished replacing data, we need to perform the same actions//that are required after a character data node has been modified//send the value of false for replace parameter so that mutation//events if appropriate will be initiated// "Local" events (non-aggregated)// New child is told it was inserted, and where// If within the Document, tell the subtree it's been added// to the Doc.// Might have been orphan Attr// Last non-null ancestor// In this context, ancestry includes// walking back from Attr to Element// Subroutine: Transmit DOMAttrModified and DOMSubtreeModified// (Common to most kinds of mutation)// notify the range of insertions// notify iterators// mutation events// Child is told that it is about to be removed// If within Document, child's subtree is informed that it's// losing that status// End mutation preprocessing// We can't use the standard dispatchAggregate, since it assumes// that the Attr is still attached to an owner. This code is// similar but dispatches to the previous owner, "element".// If we have to send DOMAttrModified (determined earlier),// do so.// We can hand off to process DOMSubtreeModified, though.// Note that only the Element needs to be informed; the// Attr's subtree has not been changed by this operation.// REVISIT: To be implemented!!!// Convert Maps to Hashtables, Lists to Vectors//convert Hashtables back to HashMaps and Vectors to Lists// class DocumentImplNamedNodeMapImpl.class/** Document type name. */NamedNodeMapImpl entities;/** Entities. */NamedNodeMapImpl notations;/** Notations. */NamedNodeMapImpl elements;/** Elements. */// NON-DOMString publicID;// DOM2: support public ID.String systemID;// DOM2: support system ID.String internalSubset;// DOM2: support internal subset.int doctypeNumber;// a number, on demand, for ordering purposes for compareDocumentPosition// Doctype number.   Doc types which have no owner may be assignedMap<String,UserDataRecord> userData;/** Factory method for creating a document type node. */// <init>(CoreDocumentImpl,String)this.publicIDthis.systemID// DOM2: methods./** NON-DOM. <p> ... */this.internalSubset/** Returns the document type name *//** Clones the node. */DocumentTypeImpl newnodenewnode.entitiesnewnode.notationsnewnode.elementsDocumentTypeImpl argDocTypeNamedNodeMapImpl argEntitiesargDocType.entitiesNamedNodeMapImpl argNotationsargDocType.notationsNode entNode1Node entNode2Node noteNode1Node noteNode2//end isEqualNodegetNodeNumber(...)assignDocTypeNumber(...)/** Name of this document type. If we loaded from a DTD, this should ... */// DocumentType methods/** Access the collection of general Entities, both external and ... *//** Access the collection of Notations defined in the DTD.  A ... *//** NON-DOM: Subclassed to flip the entities' and notations' readonly switch ... *//** NON-DOM: Access the collection of ElementDefinitions. ... */UserDataRecord udrudr.fDataHashtable<String,UserDataRecord> ud// NamedNodeMaps must be cloned explicitly, to avoid sharing them.//test if the following string attributes are equal: publicId,//systemId, internalSubset.//test if NamedNodeMaps entities and notations are equal// If the doctype has a document owner, get the node number// relative to the owner doc// The doctype is disconnected and not associated with any document.// Assign the doctype a number relative to the implementation.// set read-only property// Convert the HashMap to Hashtable//convert the Hashtable back to HashMap// class DocumentTypeImpl/** Element definition name. */NamedNodeMapImpl attributes;/** Default attributes. *//** Returns the element definition name *//** Replicate this object. */ElementDefinitionImpl newnodenewnode.attributes/** Query the attributes defined on this Element. ... */// NamedNodeMap must be explicitly replicated to avoid sharing// getAttributes():NamedNodeMap// class ElementDefinitionImpl/** Element name. */AttributeMap attributes;/** Attributes. */// for ElementNSImpl// does all the work.// Note: This only deals with part of the pb. CoreDocumentImpl/** Returns the element name *//** Retrieve all the Attributes as a set. Note that this API is inherited ... *//** Return a duplicate copy of this Element. Note that its children ... */ElementImpl newnodegetBaseURI(...)this.ownerNodeAttr attrNodeString parentBaseURIMalformedURIException ex//getBaseURI/** Look up a single Attribute by name. Returns the Attribute's ... */// Element methods/** Look up a single Attribute by name. Returns the Attribute Node, ... */// getAttribute(String):String/** Returns a NodeList of all descendent nodes (children, ... */// getAttributeNode(String):Attr/** Returns the name of the Element. Note that Element.nodeName() is ... *//** In "normal form" (as read from a source file), there will never be two ... *//** Remove the named attribute from this Element. If the removed ... */safeRemoveNamedItem(...)/** Remove the specified attribute/value pair. If the removed ... */// removeAttribute(String)removeItem(...)/** Add a new name/value pair, or replace the value of the existing ... */// removeAttributeNode(Attr):Attr/** Add a new attribute/value pair, or replace the value of the ... */// setAttribute(String,String)// setAttributeNode(Attr):Attr// getAttributeNS(String,String):StringString origNodeName(...).nameString newName// setAttributeNS(String,String,String)safeRemoveNamedItemNS(...)/** Retrieves an Attr node by local name and namespace URI. ... */// removeAttributeNS(String,String)// getAttributeNodeNS(String,String):Attr/** NON-DOM: sets attribute node for this element */// setAttributeNodeNS(Attr):Attr/** NON-DOM: get inded of an attribute */getNamedItemIndex(...)/** Introduced in DOM Level 2. */boolean hasAttrsNamedNodeMap map1NamedNodeMap map2Node n1Node n2/** DOM Level 3: register the given attribute node as an ID attribute */Attr at/** NON-DOM: Subclassed to flip the attributes' readonly switch as well. ... */// @param el The element from which to take the attributes// support for DOM Level 3 renameNode methodel.attributes/** Setup the default attributes. *//** Reconcile default attributes. */reconcileDefaults(...)/** Get the default attributes. */DocumentTypeImpl doctypeElementDefinitionImpl eldef/* Copyright 1999-2002,2004 The Apache Software Foundation. ... */// synchronizeData will initialize attributes// Replicate NamedNodeMap rather than sharing it.// Absolute base URI is computed according to// XML Base (http://www.w3.org/TR/xmlbase/#granularity)// 1. The base URI specified by an xml:base attribute on the element,// if one exists// This may be a relative URI.// Make any parentURI into a URI object to use with the URI(URI, String) constructor// This should never happen: parent should have checked the URI and returned null if invalid.// 2.the base URI of the element's parent element within the// document or external entity, if one exists// 3. the base URI of the document entity or external entity// containing the element// ownerNode serves as a parent or as document//base URI of parent element is not null//return valid absolute base URI// Otherwise it might be an Element, which is handled recursively// We must also normalize all of the attributes// changed() will have occurred when the removeChild() was done,// so does not have to be reissued.// This will throw INUSE if necessary// REVISIT: this is not efficient, we are creating twice the same//          strings for prefix and localName.// Note: we can't just change the name of the attribute. Names have to be in sorted// order in the attributes vector because a binary search is used to locate them.// If the new name has a different prefix, the list may become unsorted.// Maybe it would be better to resort the list, but the simplest// fix seems to be to remove the old attribute and re-insert it.// -- Norman.Walsh@Sun.COM, 2 Feb 2007// This case may happen if user calls://      elem.setAttribute("name", "value");//      elem.setAttributeNS(null, "name", "value");// This case is not defined by the DOM spec, we choose// to create a new attribute in this case and remove an old one from the tree// note this might cause events to be propagated or user data to be lost// DOM Level 1 Node//if namespace uri is empty string, set it to 'null'// getDefaultAttributes()// class ElementImplimport XSComplexTypeDecl/** ElementNSImpl inherits from ElementImpl and adds namespace support. ... */XSTypeDefinition type;/** DOM3: type information */// for DeferredElementImpl//DOM2: Namespace methods.String parentElementBaseURINodeImpl parentOrOwner/** NON-DOM: setting type used by the DOM parser ... *///convert the empty string to 'null'//NAMESPACE_ERR://1. if the qualified name is 'null' it is malformed.//2. or if the qualifiedName is null and the namespaceURI is different from null,// We dont need to check for namespaceURI != null, if qualified name is null throw DOMException.//there is a prefix//1. if the qualifiedName has a prefix and the namespaceURI is null,//2. or if the qualifiedName has a prefix that is "xml" and the namespaceURI//is different from " http://www.w3.org/XML/1998/namespace"// remove children first// set owner document// Absolute base URI is computed according to XML Base (http://www.w3.org/TR/xmlbase/#granularity)// 1.  the base URI specified by an xml:base attribute on the element, if one exists// Start from the base URI of the parent, or if this node has no parent, the owner node.// Make any parentURI into a URI object to use with the URI(URI, String) constructor.//2.the base URI of the element's parent element within the document or external entity,//if one exists//3. the base URI of the document entity or external entity containing the element/** Entity name. *//** Public identifier. *//** System identifier. *//** Encoding */String inputEncoding;/** Input Encoding *//** Version */String notationName;/** Notation name. */String baseURI;/** base uri *//** Returns the entity name *//** Sets the node value. ... *//** The namespace prefix of this node ... *//** Clone node. *//** The public identifier associated with the entity. If not specified, ... */// Entity methods/** The system identifier associated with the entity. If not specified, ... */// getPublicId():String/** DOM Level 3 WD - experimental ... */// getSystemId():String// getVersion():String/** Unparsed entities -- which contain non-XML data -- have a ... *//** DOM Level 2: The public identifier associated with the entity. If not specified, ... */// getNotationName():String// setPublicId(String)/** An attribute specifying the encoding used for this entity at the tiome ... */// setEncoding (String)/** NON-DOM, used to set the input encoding. */this.inputEncoding/** DOM Level 2: The system identifier associated with the entity. If not ... */// setVersion (String)/** DOM Level 2: Unparsed entities -- which contain non-XML data -- have a ... */// setSystemId(String)// setNotationName(String)/** NON-DOM: set base uri */// class EntityImpl/** Name of Entity referenced *//** Base URI *///protected boolean fEnableSynchronize = false;/** Enable synchronize. *///protected int entityChanges = -1;/** Entity changes. *//** Returns the name of the entity referenced */EntityReferenceImpl erEntityImpl entDef/** NON-DOM: compute string representation of the entity reference. ... */next.nextSibling/** EntityReference's children are a reflection of those defined in the ... */Node defkidNode newkid/** NON-DOM: sets the node and its children value. ... */// invalid to have other types of nodes in attr value// No Entity by this name, stop here.// If entity's definition exists, clone its kids/** Enable the synchronize method which may do cloning. This method is enabled ... */// The Xerces parser invokes callbacks for startEnityReference// the parsed value of the entity EACH TIME, so it is actually// easier to create the nodes through the callbacks rather than// clone the Entity.// class EntityReferenceImpl/** @xerces.internal *//** Internal class LCount is used to track the number of ... */new ConcurrentHashMap<String,LCount>(...)Map<String,LCount> lCounts;int captures, ...;new LCount(...)// class LCount/** NamedNodeMaps represent collections of Nodes that can be accessed ... */short flags;short READONLY;short CHANGED;short HASDEFAULTS;List<> nodes;/** Nodes. */NodeImpl ownerNode;// the node this map belongs to/** Report how many nodes are currently stored in this NamedNodeMap. ... */// NamedNodeMap methods/** Retrieve an item from the map by 0-based index. ... *//** Retrieve a node by name. ... */// getNamedItem(String):Node/** Adds a node using its nodeName attribute. ... */// getNamedItemNS(String,String):NodeNodeImpl previous/** Adds a node using its namespaceURI and localName. ... *//** Removes a node specified by name. ... */// removeNamedItem(String):NodeNamedNodeMapImpl newmap/** Internal subroutine to allow read-only Nodes to make their contained ... */// Package methods// cloneMap():NamedNodeMapImpl/** Internal subroutine returns this NodeNameMap's (shallow) readOnly value. */// getReadOnly()/** Subroutine: Locate the named item, or the point at which said item ... */int test/** This findNamePoint is for DOM Level 2 Namespaces. */// findNamePoint(String):intString aNamespaceURIString aLocalName// return false// compare 2 nodes in the map.  If a precedes b, return true, otherwise/** NON-DOM: Remove attribute at specified index *//** NON-DOM: copy content of this map into the specified ArrayList ... *//** NON-DOM remove all elements from this map */List<> oldNodesthis.nodes/* Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved. */// Binary search// Name found// not-found has to be encoded.// This is a linear search through the same nodes ArrayList.// The ArrayList is sorted on the DOM Level 1 nodename.// The DOM Level 2 NS keys are namespaceURI and Localname,// so we must linear search thru it.// In addition, to get this to work with nodes without any namespace// (namespaceURI and localNames are both null) we then use the nodeName// as a secondary key.// cast to Vector is required// If the write fails for some reason ensure// that we restore the original object.// class NamedNodeMapImplimport EventTarget/** NodeImpl provides the basic structure of a DOM tree. It is never used ... */short TREE_POSITION_PRECEDING;/** The node precedes the reference node. */// Taken from DOM L3 Node interface.// TreePosition Constants.short TREE_POSITION_FOLLOWING;/** The node follows the reference node. */short TREE_POSITION_ANCESTOR;/** The node is an ancestor of the reference node. */short TREE_POSITION_DESCENDANT;/** The node is a descendant of the reference node. */short TREE_POSITION_EQUIVALENT;/** The two nodes have an equivalent position. This is the case of two ... */short TREE_POSITION_SAME_NODE;/** The two nodes are the same. Two nodes that are the same have an ... */short TREE_POSITION_DISCONNECTED;/** The two nodes are disconnected, they do not have any common ancestor. ... */short DOCUMENT_POSITION_DISCONNECTED;// DocumentPositionshort DOCUMENT_POSITION_PRECEDING;short DOCUMENT_POSITION_FOLLOWING;short DOCUMENT_POSITION_CONTAINS;short DOCUMENT_POSITION_IS_CONTAINED;short DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC;short ELEMENT_DEFINITION_NODE;/** Element definition node type. */// public// links// data// typically the parent but not always!short SYNCDATA;short SYNCCHILDREN;short OWNED;short FIRSTCHILD;short SPECIFIED;short IGNORABLEWS;short HASSTRING;short NORMALIZED;short ID;/** the name of this node. *//** Returns the node value. ... *//** Adds a child node to the end of the list of children for this node. ... */NodeImpl newnodenewnode.ownerNode/** Find the Document that this Node belongs to (the document in ... *//** same as above but returns internal type and this one is not overridden ... *//** Returns the node number */int nodeNumberCoreDocumentImpl cd/** Obtain the DOM-tree parent of this node, or null if it is not ... *//** Return the collection of attributes associated with this node, ... *//** Returns whether this node (if it is an element) has any attributes. ... *//** The first child of this Node, or null if none. ... *//** Puts all <code>Text</code> nodes in the full depth of the sub-tree ... */// DOM2: methods, getters, setters// EventTarget supportaddEventListener(...)/** The absolute base URI of this node or <code>null</code> if undefined. ... */// Public DOM Level 3 methods/** Compares a node with this node with regard to their position in the ... */short thisTypeshort otherTypeNode thisAncestorNode otherAncestorint thisDepthint otherDepthNode otherNodeint thisAncestorTypeint otherAncestorTypeNode thisNodePNode otherNodePNode currentDocument thisOwnerDocDocument otherOwnerDocint otherDocNumint thisDocNumDocumentType containerprecedes(...)int thisAncestorNumint otherAncestorNum/** This attribute returns the text content of this node and its ... */// internal method taking a StringBuffer in parameterString content/** Returns whether this node is the same node as the given one. ... *//** DOM Level 3: Experimental ... */NodeImpl ancestorgetElementAncestor(...)isDefaultNamespace(...)/** DOM Level 3 - Experimental: ... */lookupNamespacePrefix(...)lookupNamespaceURI(...)String foundNamespace/** Tests whether two nodes are equal. ... */ParentNode.UserDataRecord/** NON-DOM: PR-DOM-Level-1-19980818 mentions readonly nodes in conjunction ... *//** NON-DOM: Returns true if this node is read-only. This is a ... *//** NON-DOM: As an alternative to subclassing the DOM, this implementation ... */// getReadOnly():boolean/** NON-DOM: ... *//** For non-child nodes, the node which "points" to this node. ... *//* Flags setters and getters */// inconsistent name to avoid clash with public method on TextImpl/** NON-DOM method for debugging convenience. */// as long as we do not have any owner, ownerNode is our ownerDocument// overridden in some subclasses// Default behavior is to do nothing, overridden in some subclasses// if we get here we have an error in our program we may as well// be vocal about it, so that people can take appropriate action.// By default we make all clones readwrite,// this is overriden in readonly subclasses// if we have an owner simply forward the request// otherwise ownerNode is our ownerDocument// if we have an owner we rely on it to have it right// overriden by ChildNode// default behavior, overriden in ChildNode// overridden in ElementImpl/* by default we do not have any children, ... */// simply forward to Document// Questions of clarification for this method - to be answered by the// DOM WG.   Current assumptions listed - LM// 1. How do ENTITY nodes compare?//    Current assumption: TREE_POSITION_DISCONNECTED, as ENTITY nodes//    aren't really 'in the tree'// 2. How do NOTATION nodes compare?//    Current assumption: TREE_POSITION_DISCONNECTED, as NOTATION nodes// 3. Are TREE_POSITION_ANCESTOR and TREE_POSITION_DESCENDANT//    only relevant for nodes that are "part of the document tree"?//     <outer>//         <inner  myattr="true"/>//     </outer>//    Is the element node "outer" considered an ancestor of "myattr"?//    Current assumption: No.// 4. How do children of ATTRIBUTE nodes compare (with eachother, or//    with children of other attribute nodes with the same element)//    Current assumption: Children of ATTRIBUTE nodes are treated as if//    they they are the attribute node itself, unless the 2 nodes//    are both children of the same attribute.// 5. How does an ENTITY_REFERENCE node compare with it's children?//    Given the DOM, it should precede its children as an ancestor.//    Given "document order",  does it represent the same position?//    Current assumption: An ENTITY_REFERENCE node is an ancestor of its//    children.// 6. How do children of a DocumentFragment compare?//    Current assumption: If both nodes are part of the same document//    fragment, there are compared as if they were part of a document.// If the nodes are the same...// If either node is of type ENTITY or NOTATION, compare as disconnected// Find the ancestor of each node, and the distance each node is from// its ancestor.// During this traversal, look for ancestor/descendent relationships// between the 2 nodes in question.// We do this now, so that we get this info correct for attribute nodes// and their children.// The other node is an ancestor of this one.// The other node is a descendent of the reference node.// if the ancestor is an attribute, get owning element.// we are now interested in the owner to determine position.// Before proceeding, we should check if both ancestor nodes turned// out to be attributes for the same element// Now, find the ancestor of the owning element, if the original// ancestor was an attribute// Note:  the following 2 loops are quite close to the ones above.// May want to common them up.  LM.// The other node is an ancestor of the owning element// The other node is a descendent of the reference// node's element// thisAncestor and otherAncestor must be the same at this point,// otherwise, we are not in the same tree or document fragment// Go up the parent chain of the deeper node, until we find a node// with the same depth as the shallower node// Check if the node we have reached is in fact "otherNode". This can// happen in the case of attributes.  In this case, otherNode// "precedes" this.// Check if the node we have reached is in fact "thisNode".  This can// "follows" this.// We now have nodes at the same depth in the tree.  Find a common// ancestor.// At this point, thisNode and otherNode are direct children of// the common ancestor.// See whether thisNode or otherNode is the leftmost// REVISIT:  shouldn't get here.   Should probably throw an// If the nodes are the same, no flags should be set// check if other is from a different implementation// other comes from a different implementation// get the respective Document owners.// If from different documents, we know they are disconnected.// and have an implementation dependent order// Special casing for ENTITY, NOTATION, DOCTYPE and ATTRIBUTES// LM:  should rewrite this.// the nodes are of different types// the nodes are of the same type.  Find order.// Now, find the ancestor of the element// otherwise, the original nodes are disconnected// overriden in some subclasses// we do not use any wrapper so the answer is obvious// REVISIT: When Namespaces 1.1 comes out this may not be true// Prefix can't be bound to null namespace// to flip out children// looking for default namespace// non default namespace// at this point we are dealing with DOM Level 2 nodes only// REVISIT: if no prefix is available is it null or empty string, or//          could be both?// DOM Level 2 nodes// in theory nodeName can't be null but better be careful// who knows what other implementations may be doing?...// we don't have any alternate node, either this node does the job// or we don't have anything that does// we do not actually store this information on every node, we only// have a global indicator on the Document. Doing otherwise cost us too// much for little gain.// See if flag should propagate to parent.// synchronize data// class NodeImpl/** DefaultNodeIterator implements a NodeIterator, which iterates a ... */NodeFilter.SHOW_ALLDocumentImpl fDocument;/** The DocumentImpl which created this iterator, so it can be detached. */Node fRoot;/** The root. */int fWhatToShow;/** The whatToShow mask. */NodeFilter fNodeFilter;/** The NodeFilter reference. */boolean fDetach;/** If detach is called, the fDetach flag is true, otherwise flase. *//** The last Node returned. */// can be placed on a Node which would not pass filters.// Note also, if removing a Node, the fCurrentNode// (eg fForward = true) or previousNode() (eg fForward = false).// (usually akin to whether the node was returned via nextNode())// direction is whether the pointer is in front or behind this node.// and the// two nodes. The fCurrentNode is actually the last node returned,// the desired behaviour of the current pointer being _between_// Note: The current node and direction are sufficient to implement// Iterator state - current node and direction.boolean fForward;/** The direction of the iterator on the fCurrentNode. ... */boolean fEntityReferenceExpansion;/** When TRUE, the children of entites references are returned in the iterator. *//** Public constructor *//** Return the whatToShow value */// setters for these values and alter them while iterating!// and filter values at each call, and therefore one _could_ add// Implementation Note: Note that the iterator looks at whatToShow/** Return the filter *//** Return whether children entity references are included in the iterator. *//** Return the next Node in the Iterator. The node is the next node in ... */boolean acceptedDOMException.INVALID_STATE_ERR/** Return the previous Node in the Iterator. The node is the next node in ... */Node previousNodepreviousNode(...)/** The node is accepted if it passes the whatToShow and the filter. */NodeFilter.FILTER_ACCEPT/** Return node, if matches or any parent if matches. *//** The method nextNode(Node, boolean) returns the next node ... */Node result/** The method previousNode(Node) returns the previous node ... *//** Fix-up the iterator on a remove. Called by DOM or otherwise, ... */Node deletedmatchNodeOrParent(...)removeNodeIterator(...)// if root is null there is no next node.// the next node has not been accepted.// if last direction is not forward, repeat node.//System.out.println("nextNode():!fForward:"+fCurrentNode.getNodeName());// else get the next node via depth-first//REVIST: should direction be set forward before null check?// nothing in the list. return null.// does node pass the filters and whatToShow?// if so, then the node is the current node.// while (!accepted) {// no nodes, or no accepted nodes.// if the root is null, or the current node is null, return null.//repeat last node.// get previous node in backwards depth first order.// we are going backwards// if the new previous node is null, we're at head or past the root,// so return null.// check if node passes filters and whatToShow.// if accepted, update the current node, and return it.// there are no nodes?// Additions and removals in the underlying data structure may occur// before any iterations, and in this case the reference_node is null.// check if the removed node is an _ancestor_ of the// reference node// only check children if we visit children.//if hasChildren, return 1st child.//if Root has no kids// if hasSibling, return sibling// return parent's 1st sibling.// while (parent != null && parent != fRoot) {// end of list, return null// if we're at the root, return null.// get sibling//if 1st sibling, return parent// if sibling has children, keep getting last child of child.// Implementation note: Fix-up means setting the current node properly// after a remove.// if (!fForward)// normal case: there _are_ nodes following this in the iterator.// the last node in the iterator is to be removed,// so we set the current node to be the previous one./** This class is used, via a pool managed on CoreDocumentImpl, in ParentNode to ... */int fLength;/** Cached node list length. */int fChildIndex;/** Last requested node index. */ChildNode fChild;/** Last requested node. */ParentNode fOwner;/** Owner of this cache */NodeListCache next;/** Pointer to the next object on the list, ... *//** Returns the notation name *//** The Public Identifier for this Notation. If no public identifier ... */// Notation methods/** The System Identifier for this Notation. If no system identifier ... *//** NON-DOM: The Public Identifier for this Notation. If no public ... *//** NON-DOM: The System Identifier for this Notation. If no system ... */// class NotationImplimport com.sun.org.apache.xerces.internal.xs.*/** Attribute namespace implementation; stores PSVI attribute items. ... */XSConstants.UNAVAILABLE_DTAttributePSVI.VALIDATION_NONEAttributePSVI.VALIDITY_NOTKNOWN/** Construct an attribute node. */XSAttributeDeclaration fDeclaration;/** attribute declaration */XSTypeDefinition fTypeDecl;/** type of attribute, simpleType */boolean fSpecified;/** If this attribute was explicitly given a ... */String fNormalizedValue;/** schema normalized value property */Object fActualValue;/** schema actual value */short fActualValueType;/** schema actual value type */ShortList fItemValueTypes;/** actual value types if the value is a list */XSSimpleTypeDefinition fMemberType;/** member type definition against which attribute was validated */short fValidationAttempted;/** validation attempted: none, partial, full */short fValidity;/** validity: valid, invalid, unknown */StringList fErrorCodes;/** error codes */String fValidationContext;/** validation context: could be QName or XPath expression *//** [schema default] ... */// AttributePSVI methodsgetConstraintValue(...)/** [schema normalized value] ... *//** [schema specified] ... *//** Determines the extent to which the document has been validated ... *//** Determine the validity of the node with respect ... *//** A list of error codes generated from validation attempts. ... */// This is the only information we can provide in a pipeline./** An item isomorphic to the type definition used to validate this element. ... *//** If and only if that type definition is a simple type definition ... *//** An item isomorphic to the attribute declaration used to validate ... *//** Copy PSVI properties from another psvi item. ... */this.fDeclarationgetAttributeDeclaration(...)this.fValidationContextgetValidationContext(...)this.fValiditygetValidity(...)this.fValidationAttemptedgetValidationAttempted(...)this.fErrorCodesgetErrorCodes(...)this.fNormalizedValuethis.fActualValuegetActualNormalizedValue(...)this.fActualValueTypegetActualNormalizedValueType(...)this.fItemValueTypesgetItemValueTypes(...)this.fTypeDeclthis.fMemberTypethis.fSpecifiedgetIsSchemaSpecified(...)/* (non-Javadoc) ... */// we support object serialization of grammars -- mrglavas// REVISIT: Forbid serialization of PSVI DOM until/* Copyright 2002-2004 The Apache Software Foundation. ... */new PSVIDOMImplementationImpl(...)PSVIDOMImplementationImpl singleton;new PSVIDocumentImpl(...)/** Our own document implementation, which knows how to create an element ... *//** Create a document. */PSVIDocumentImpl newdoc/** Create an element with PSVI information */new PSVIElementNSImpl(...)/** Create an attribute with PSVI information */new PSVIAttrNSImpl(...)/** The configuration used when <code>Document.normalizeDocument</code> is ... */getDomConfig(...)// class PSVIDocumentImpl/** Element namespace implementation; stores PSVI element items. ... */ElementPSVI.VALIDATION_NONEElementPSVI.VALIDITY_NOTKNOWN/** Construct an element node. */XSElementDeclaration fDeclaration;/** element declaration *//** type of element, could be xsi:type */boolean fNil;/** true if clause 3.2 of Element Locally Valid (Element) (3.3.4) ... *//** false if the element value was provided by the schema; true otherwise. */XSNotationDeclaration fNotation;/** http://www.w3.org/TR/xmlschema-1/#e-notation *//** member type definition against which element was validated */XSModel fSchemaInformation;/** the schema information property */// ElementPSVI methods/** [nil] ... *//** [notation] ... *//** An item isomorphic to the element declaration used to validate ... *//** [schema information] ... */getElementDeclaration(...)this.fNotationgetNotation(...)this.fSchemaInformationgetSchemaInformation(...)this.fNilgetNil(...)/** ParentNode inherits from ChildNode and adds the capability of having child ... */CoreDocumentImpl ownerDocument;/** Owner document. */ChildNode firstChild;/** First child. */NodeListCache fNodeListCache;/** NodeList cache */// transients/** No public constructor; only subclasses of ParentNode should be ... */ParentNode newnodenewnode.ownerDocumentnewnode.firstChildnewnode.fNodeListCacheownerDocument.ancestorCheckingfNodeListCache.fLengthfNodeListCache.fChildIndexfNodeListCache.fChild// internalInsertBefore(Node,Node,boolean):Node// internalRemoveChild(Node,boolean):NodehasTextContent(...)// internal method returning whether to take the given node's text content/** Count the immediate children of this node.  Use to implement ... */getNodeListCache(...)ChildNode nn.nextSibling// nodeListGetLength():intnodeListGetLength(...)/** Return the Nth immediate child of this node, or null if the index is ... */boolean firstAccessfreeNodeListCache(...)// nodeListItem(int):NodenodeListItem(...)/** Create a NodeList to access children that is use by subclass elements ... */ParentNode$1// getChildNodesUnoptimized():NodeListNode child1Node child2// checkNormalizationAfterRemove(Node)ParentNode$UserDataRecord/* a class to store some user data along with its handler */Object fData;UserDataHandler fHandler;// invalidate cache for children NodeList// Then, if deep, clone the kids too./* setting the owner document of self, after it's children makes the ... */// update cached length if we have any// if we happen to insert just before the cached node, update// the cache to the new node to match the cached index// otherwise just invalidate the cache// if the removed node is the cached node// move the cache to its (soon former) previous sibling// get rid of any existing children// create a Text node to hold the given content// get rid of trivial cases// otherwise request a cache object// is the cached length invalid ?// start from the cached node if we have one// get rid of trivial case// short way// long way// release cache if reaching last child or first child// we can keep using the cache until it is actually reused// fNodeListCache will be nulled by the pool (document) if that// happens.// fNodeListCache = null;// otherwise update it// there are many ways to do this test, and there isn't any way// better than another. Performance may vary greatly depending on// the implementations involved. This one should work fine for us.// hardset synchildren - so we don't try to sync - it does not make any// sense to try to synchildren when we just deserialize object.// class ParentNodeString target;/** Returns the target *//** A PI's "target" states what processor channel the PI's data ... */// ProcessingInstruction methods/** A PI's data content tells the processor what we actually want it ... */// getTarget():String/** Change the data content of this PI. ... */// getData():String// setData(String)// Hand off to setNodeValue for code-reuse reasons (mutation// events, readonly protection, synchronizing, etc.)// class ProcessingInstructionImplimport RangeException/** The RangeImpl class implements the org.w3c.dom.range.Range interface. ... */Node fStartContainer;Node fEndContainer;int fStartOffset;int fEndOffset;boolean fIsCollapsed;Node fInsertNode;Node fDeleteNode;Node fSplitNode;boolean fInsertedFromRange;// Was the Node inserted from the Range or the Document/** The constructor. Clients must use DocumentRange.createRange(), ... */Vector<> startVVector<> endVint eisLegalContainer(...)new RangeExceptionImpl(...)RangeException.INVALID_NODE_TYPE_ERRgetCommonAncestorContainer(...)collapse(...)hasLegalRootContainer(...)isLegalContainedNode(...)Node endPointANode endPointBint offsetAint offsetBint depthDiffgetStartContainer(...)getEndContainer(...)Node pANode pBtraverseContents(...)Node cloneCurrentint currentChildrensignalSplitData(...)Node realStartNode realEndDocumentFragment fragextractContents(...)RangeException.BAD_BOUNDARYPOINTS_ERRselectNode(...)createRange(...)Node stopNoderemoveRange(...)/** Signal other Ranges to update their start/end ... */// Mutation functionssplitData(...)/** Fix up this Range if another Range has split a Text Node ... *//** This function inserts text into a Node and invokes ... */deleteData(...)/** This function is called from DOM. ... *//** This function is called from the DOM. ... */Node fRemoveChild;/** This function is called within Range ... *//** This function must be called by the DOM _BEFORE_ ... */isAncestorOf(...)int EXTRACT_CONTENTS;//REVIST: use boolean, since there are only 2 now...// parameters for traverseContents(int)// Utility functions.int CLONE_CONTENTS;int DELETE_CONTENTS;/** This is the master routine invoked to visit the nodes ... */int endContainerDepthint startContainerDepthtraverseSameContainer(...)traverseCommonStartContainer(...)traverseCommonEndContainer(...)Node spNode eptraverseCommonAncestors(...)/** Visits the nodes selected by this range when we know ... */getSelectedNode(...)String subNode siblingNode xferNodetraverseFullySelected(...)traverseRightBoundary(...)int endIdxsetEndBefore(...)traverseLeftBoundary(...)int startIdxsetStartAfter(...)Node commonParentint startOffsetint endOffset/** Traverses the "right boundary" of this range and ... */boolean isFullySelectedNode clonedParenttraverseNode(...)Node clonedGrandParentNode clonedChild/** Traverses the "left boundary" of this range and ... *//** Utility method for traversing a single node. ... */traverseTextNode(...)traversePartiallySelected(...)/** Utility method for traversing a single node when ... *//** Utility method for traversing a text node that we know ... */String txtValueString newNodeValueString oldNodeValueNode newNode/** Given a node, calculate what the Range's root container ... *//** Returns true IFF the given node can serve as a container ... *//** Finds the root container for the given node and determines ... */Node rootContainergetRootContainer(...)/** Returns true IFF the given node can be contained by ... *//** is a an ancestor of b ? *//** what is the index of the child in the parent *//** Utility method to retrieve a child node by index.  This method ... */// If one boundary-point of a Range is set to have a root container// other// than the current one for the Range, the Range should be collapsed to// the new position.// The start position of a Range should never be after the end position.// REVIST: what to do if it IS null?// WRONG_DOCUMENT_ERR: Raised if the two Ranges are not in the same Document or DocumentFragment.// The DOM Spec outlines four cases that need to be tested// to compare two range boundary points://   case 1: same container//   case 2: Child C of container A is ancestor of B//   case 3: Child C of container B is ancestor of A//   case 4: preorder traversal of context tree.// case 1: same container// case 2: Child C of container A is ancestor of B// This can be quickly tested by walking the parent chain of B// case 3: Child C of container B is ancestor of A// This can be quickly tested by walking the parent chain of A// case 4: preorder traversal of context tree.// Instead of literally walking the context tree in pre-order,// we use relative node depth walking which is usually faster//throw exception?//boolean MULTIPLE_MODE = false;//holds number of kids before insertion// split text node: results is 3 nodes..//update ranges after the insertion//endContainer is the new Node created//endContainer was not a text Node.//endOffset + = number_of_children_added// signal other Ranges to update their start/end containers/offsets// ! TEXT_NODE//need to remember number of kids//update fEndOffset. ex:<body><p/></body>. Range(start;end): body,0; body,1// insert <h1>: <body></h1><p/></body>. Range(start;end): body,0; body,2//update fEndOffset if not 0//fEndContainer!=fStartContainer//fStartContainer is not a TextNode//find a first node within a range, specified by fStartOffset//look into all kids of the Range// Offsets are adjusted in Range.insertNode//startContainer or endContainer or both is/are the ancestor(s) of the Node to be deleted// REVIST: Throw exception?//Check for a detached range./* Traversal is accomplished by first determining the ... */// case 2: Child C of start container is ancestor of end container// This can be quickly tested by walking the parent chain of// end container// case 4: There is a common ancestor container.  Find the// ancestor siblings that are children of that container.// ascend the ancestor hierarchy until we have a common parent.// If selection is empty, just return the fragment// Text node needs special case handling// get the substring// set the original text node to its new value// Nothing is partially selected, so collapse to start point// Copy nodes between the start/end offsets.// Collapse to just before the endAncestor, which// is partially selected.// Because we already traversed it....// should never occur// TBD: This should be a HIERARCHY_REQUEST_ERR// If the node contains text, ensure that the// offset of the range is <= to the length of the text// Since the node is not text, ensure that the offset// is valid with respect to the number of child nodes// This case is an important convenience for// traverseRightBoundary()// Private Data members/** NON-DOM: resets node and sets specified values for the current node ... */super.data/** NON-DOM: Set whether this Text is ignorable whitespace. *//** DOM L3 Core CR - Experimental ... */// setIgnorableWhitespace(boolean)internalIsIgnorableWhitespace(...)getWholeTextBackward(...)getWholeTextForward(...)/** internal method taking a StringBuffer in parameter and inserts the ... *//** Concatenates the text of all logically-adjacent text nodes to the ... */boolean inEntRef/** Concatenates the text of all logically-adjacent text nodes to the left of ... */insertTextContent(...)/** Replaces the text of the current node and all logically-adjacent text ... */Text currentNodeNode prevcanModifyPrev(...)canModifyNext(...)Text newNodesetData(...)hasTextOnlyChildren(...)/** If any EntityReference to be removed has descendants that are not ... */boolean textLastChildNode lastChildshort lTypeboolean textFirstChildNode firstChild/** Check if an EntityReference node has Text Only child nodes ... *//** NON-DOM: Returns whether this Text is ignorable whitespace. *//** Break a text node into two sibling nodes. (Note that if the current node ... */// Text methods// isIgnorableWhitespace():booleanText newTextNode parentNode/** NON-DOM (used by DOMParser): Reset data for the node. */// splitText(int):Text/** NON-DOM (used by DOMParser: Sets data to empty string. ... */String olddata// REVISIT: is this implemenation correct?//concatenate text of logically adjacent text nodes to the left of this node in the tree//clear buffer//concatenate text of logically adjacent text nodes to the right of this node in the tree// boolean to indicate whether node is a child of an entity reference// if the parent node is an entity reference node, must// check nodes to the right of the parent entity reference node for logically adjacent// text nodes// check nodes to the left of the parent entity reference node for logically adjacent//if the content is null// check if node in the tree//replace the text node//check logically-adjacent text nodes//If the logically-adjacent next node can be removed//remove it. A logically adjacent node can be removed if//it is a Text or CDATASection node or an EntityReference with//Text and CDATA only children.//If the previous sibling was entityreference//check if its content is replaceable//if the entity reference has no children//return false//The replacement text of the entity reference should//be either only text,cadatsections or replaceable entity//reference nodes or the last child should be neither of these//If the EntityReference child contains//only text, or non-text or ends with a//non-text node.//If the last child was replaceable and others are not//Text or CDataSection or replaceable EntityRef nodes//return false.//If the previous sibling was text or cdatasection move to next//If the previous sibling was anything but text or//cdatasection or an entity reference, stop search and//return true//If the first child was replaceable text and next//children are not, then return false//If the next sibling was anything but text or// split text into two separate nodes// insert new text node// class TextImpl/** This class implements the TreeWalker interface. ... *//** The current Node. *//** The root Node. */// implementation will still work.// setters could be created for these data values and the// (fWhatToShow, fNodeFilter, fCurrentNode, fRoot) such that// Implementation Note: No state is kept except the data above/** Return the NodeFilter *//** Return the current Node. *//** Return the parent Node from the current node, ... *//** Return the first child Node from the current node, ... *//** Return the last child Node from the current node, ... *//** Return the previous sibling Node from the current node, ... *//** Return the next sibling Node from the current node, ... *//** Return the previous Node from the current node, ... *//** Return the next Node from the current node, ... *//** Internal function. ... */int acceptint parentAcceptNodeFilter.FILTER_SKIPNode fChild// getNextSibling(Node node) {// getPreviousSibling(Node node) {Node lChild// get the lastChild of result.// if there is a lastChild which passes filters return it.// otherwise return the previous sibling.// otherwise return null.// end , return null//if (accept == NodeFilter.SKIP_NODE) // and REJECT too.//if (accept == NodeFilter.REJECT_NODE)// What to show has failed. See above excerpt from spec.// Equivalent to FILTER_SKIP./** EventImpl is an implementation of the basic "generic" DOM Level 2 Event ... */EventTarget target;EventTarget currentTarget;short eventPhase;boolean initialized, ...;boolean stopPropagation, ...;/** The DOM doesn't deal with constructors, so instead we have an ... *//** Causes exit from in-progress event dispatch before the next ... *//** Prevents any default processing built into the target node from ... */Node relatedNode;String prevValue, ...;short attrChange;// attribute be specified. Since it doesn't we have to give write access.// REVISIT: The DOM Level 2 PR has a bug: the init method should let thisString DOM_SUBTREE_MODIFIED;// NON-DOM CONSTANTS: Storage efficiency, avoid risk of typos.String DOM_NODE_INSERTED;String DOM_NODE_REMOVED;String DOM_NODE_REMOVED_FROM_DOCUMENT;String DOM_NODE_INSERTED_INTO_DOCUMENT;String DOM_ATTR_MODIFIED;String DOM_CHARACTER_DATA_MODIFIED;/** <code>attrChange</code> indicates the type of change which triggered ... *//** Initialize a mutation event, or overwrite the event's current ... */initEvent(...)Constants.SECURITY_MANAGER_PROPERTYnew ArrayEnumeration(...)String NS_XMLSCHEMA;// Schema Types:String NS_DTD;String SUN_SCHEMA_FEATURE_PREFIX;// Schema featuresString SUN_REPORT_IGNORED_ELEMENT_CONTENT_WHITESPACE;String ZEPHYR_PROPERTY_PREFIX;//stax propertiesString STAX_PROPERTIES;String STAX_ENTITY_RESOLVER_PROPERTY;String STAX_REPORT_CDATA_EVENT;String READER_IN_DEFINED_STATE;String ADD_NAMESPACE_DECL_AS_ATTRIBUTE;String ESCAPE_CHARACTERS;String REUSE_INSTANCE;String SUN_DOM_PROPERTY_PREFIX;//DOM propertiesString SUN_DOM_ANCESTOR_CHECCK;String IGNORE_EXTERNAL_DTD;/** If true, ignore DOCTYPE declaration as if it wasn't present at all. ... */String SAX_FEATURE_PREFIX;/** SAX feature prefix ("http://xml.org/sax/features/"). */// sax featuresString NAMESPACES_FEATURE;/** Namespace prefixes feature ("namespace-prefixes"). */String STRING_INTERNING_FEATURE;/** String interning feature ("string-interning"). */String VALIDATION_FEATURE;/** Validation feature ("validation"). */String EXTERNAL_GENERAL_ENTITIES_FEATURE;/** External general entities feature ("external-general-entities "). */String EXTERNAL_PARAMETER_ENTITIES_FEATURE;/** External parameter entities feature ("external-parameter-entities "). */String LEXICAL_HANDLER_PARAMETER_ENTITIES_FEATURE;/** Lexical handler parameter entities feature ("lexical-handler/parameter-entities"). */String IS_STANDALONE_FEATURE;/** Is standalone feature ("is-standalone"). */String RESOLVE_DTD_URIS_FEATURE;/** Resolve DTD URIs feature ("resolve-dtd-uris"). */String USE_ATTRIBUTES2_FEATURE;/** Use Attributes2 feature ("use-attributes2"). */String USE_LOCATOR2_FEATURE;/** Use Locator2 feature ("use-locator2"). */String USE_ENTITY_RESOLVER2_FEATURE;/** Use EntityResolver2 feature ("use-entity-resolver2"). */String UNICODE_NORMALIZATION_CHECKING_FEATURE;/** Unicode normalization checking feature ("unicode-normalization-checking"). */String XMLNS_URIS_FEATURE;/** xmlns URIs feature ("xmlns-uris"). */String XML_11_FEATURE;/** XML 1.1 feature ("xml-1.1"). */String ALLOW_DTD_EVENTS_AFTER_ENDDTD_FEATURE;/** Allow unparsed entity and notation declaration events to be sent after the end DTD event ("allow-dtd-events-after-endDTD") */String SAX_PROPERTY_PREFIX;/** SAX property prefix ("http://xml.org/sax/properties/"). */// sax propertiesString DECLARATION_HANDLER_PROPERTY;/** Declaration handler property ("declaration-handler"). *//** Lexical handler property ("lexical-handler"). */String DOM_NODE_PROPERTY;/** DOM node property ("dom-node"). */String XML_STRING_PROPERTY;/** XML string property ("xml-string"). */String FEATURE_SECURE_PROCESSING;String DOCUMENT_XML_VERSION_PROPERTY;/** Document XML version property ("document-xml-version"). */String JAXP_PROPERTY_PREFIX;/** JAXP property prefix ("http://java.sun.com/xml/jaxp/properties/"). */// JAXP propertiesString SCHEMA_SOURCE;/** JAXP schemaSource property: when used internally may include DTD sources (DOM) */String SCHEMA_LANGUAGE;/** JAXP schemaSource language: when used internally may include DTD namespace (DOM) */String JAXPAPI_PROPERTY_PREFIX;/** JAXP Standard property prefix ("http://javax.xml.XMLConstants/property/"). */String SP_ACCESS_EXTERNAL_SCHEMA;/** FEATURE_SECURE_PROCESSING (FSP) is true by default *//** JDK property to allow printing out information from the limit analyzer */String INCLUDE_COMMENTS_FEATURE;/** Comments feature ("include-comments"). */// DOM featuresString CREATE_CDATA_NODES_FEATURE;/** Create cdata nodes feature ("create-cdata-nodes"). */String LOAD_AS_INFOSET;/** Feature id: load as infoset. */String DOM_CANONICAL_FORM;// Constants: DOM Level 3 feature idsString DOM_CDATA_SECTIONS;String DOM_COMMENTS;String DOM_CHARSET_OVERRIDES_XML_ENCODING;// REVISIT: this feature seems to have no effect for XercesString DOM_DATATYPE_NORMALIZATION;String DOM_ENTITIES;String DOM_INFOSET;String DOM_NAMESPACES;String DOM_NAMESPACE_DECLARATIONS;String DOM_SUPPORTED_MEDIATYPES_ONLY;String DOM_VALIDATE_IF_SCHEMA;String DOM_VALIDATE;String DOM_ELEMENT_CONTENT_WHITESPACE;String DOM_DISCARD_DEFAULT_CONTENT;// DOM Level 3 features defined in Core:String DOM_NORMALIZE_CHARACTERS;String DOM_CHECK_CHAR_NORMALIZATION;String DOM_WELLFORMED;String DOM_SPLIT_CDATA;String DOM_FORMAT_PRETTY_PRINT;// Load and SaveString DOM_XMLDECL;String DOM_UNKNOWNCHARS;String DOM_CERTIFIED;String DOM_DISALLOW_DOCTYPE;String DOM_IGNORE_UNKNOWN_CHARACTER_DENORMALIZATIONS;String DOM_RESOURCE_RESOLVER;// DOM PropertiesString DOM_ERROR_HANDLER;String DOM_SCHEMA_TYPE;String DOM_SCHEMA_LOCATION;String DOM_ANCESTOR_CHECCK;String DOM_PSVI;// XSModelString XERCES_FEATURE_PREFIX;/** Xerces features prefix ("http://apache.org/xml/features/"). */// xerces featuresString SCHEMA_VALIDATION_FEATURE;/** Schema validation feature ("validation/schema"). */String SCHEMA_NORMALIZED_VALUE;/** Expose schema normalized values */String SCHEMA_ELEMENT_DEFAULT;/** Send schema default value via characters() *//** Schema full constraint checking ("validation/schema-full-checking"). */String SCHEMA_AUGMENT_PSVI;/** Augment Post-Schema-Validation-Infoset */String DYNAMIC_VALIDATION_FEATURE;/** Dynamic validation feature ("validation/dynamic"). */String WARN_ON_DUPLICATE_ATTDEF_FEATURE;/** Warn on duplicate attribute declaration feature ("validation/warn-on-duplicate-attdef"). */String WARN_ON_UNDECLARED_ELEMDEF_FEATURE;/** Warn on undeclared element feature ("validation/warn-on-undeclared-elemdef"). */String WARN_ON_DUPLICATE_ENTITYDEF_FEATURE;/** Warn on duplicate entity declaration feature ("warn-on-duplicate-entitydef"). */String ALLOW_JAVA_ENCODINGS_FEATURE;/** Allow Java encoding names feature ("allow-java-encodings"). */String DISALLOW_DOCTYPE_DECL_FEATURE;/** Disallow DOCTYPE declaration feature ("disallow-doctype-decl"). */String CONTINUE_AFTER_FATAL_ERROR_FEATURE;/** Continue after fatal error feature ("continue-after-fatal-error"). */String LOAD_DTD_GRAMMAR_FEATURE;/** Load dtd grammar when nonvalidating feature ("nonvalidating/load-dtd-grammar"). */String LOAD_EXTERNAL_DTD_FEATURE;/** Load external dtd when nonvalidating feature ("nonvalidating/load-external-dtd"). */String DEFER_NODE_EXPANSION_FEATURE;/** Defer node expansion feature ("dom/defer-node-expansion"). */String CREATE_ENTITY_REF_NODES_FEATURE;/** Create entity reference nodes feature ("dom/create-entity-ref-nodes"). */String INCLUDE_IGNORABLE_WHITESPACE;/** Include ignorable whitespace feature ("dom/include-ignorable-whitespace"). */String DEFAULT_ATTRIBUTE_VALUES_FEATURE;/** Default attribute values feature ("validation/default-attribute-values"). */String VALIDATE_CONTENT_MODELS_FEATURE;/** Validate content models feature ("validation/validate-content-models"). */String VALIDATE_DATATYPES_FEATURE;/** Validate datatypes feature ("validation/validate-datatypes"). */String BALANCE_SYNTAX_TREES;/** Balance syntax trees feature ("validation/balance-syntax-trees"). */String NOTIFY_CHAR_REFS_FEATURE;/** Notify character references feature (scanner/notify-char-refs"). */String NOTIFY_BUILTIN_REFS_FEATURE;/** Notify built-in (&amp;amp;, etc.) references feature (scanner/notify-builtin-refs"). */String STANDARD_URI_CONFORMANT_FEATURE;/** Standard URI conformant feature ("standard-uri-conformant"). */String GENERATE_SYNTHETIC_ANNOTATIONS_FEATURE;/** Generate synthetic annotations feature ("generate-synthetic-annotations"). */String VALIDATE_ANNOTATIONS_FEATURE;/** Validate annotations feature ("validate-annotations"). */String HONOUR_ALL_SCHEMALOCATIONS_FEATURE;/** Honour all schemaLocations feature ("honour-all-schemaLocations"). */String NAMESPACE_GROWTH_FEATURE;/** Namespace growth feature ("namespace-growth"). */String TOLERATE_DUPLICATES_FEATURE;/** Tolerate duplicates feature ("internal/tolerate-duplicates"). */String XINCLUDE_FEATURE;/** XInclude processing feature ("xinclude"). */String XINCLUDE_FIXUP_BASE_URIS_FEATURE;/** XInclude fixup base URIs feature ("xinclude/fixup-base-uris"). */String XINCLUDE_FIXUP_LANGUAGE_FEATURE;/** XInclude fixup language feature ("xinclude/fixup-language"). */String USE_GRAMMAR_POOL_ONLY_FEATURE;/** Internal feature. When set to true the schema validator will only use ... */String PARSER_SETTINGS;/** Internal performance related feature: ... */String XINCLUDE_AWARE;/** Feature to make XML Processor XInclude Aware */String IGNORE_SCHEMA_LOCATION_HINTS;/** Ignore xsi:schemaLocation and xsi:noNamespaceSchemaLocation. */String CHANGE_IGNORABLE_CHARACTERS_INTO_IGNORABLE_WHITESPACES;/** When true, the schema processor will change characters events ... */String XERCES_PROPERTY_PREFIX;/** Xerces properties prefix ("http://apache.org/xml/properties/"). */// xerces propertiesString CURRENT_ELEMENT_NODE_PROPERTY;/** Current element node property ("dom/current-element-node"). */String DOCUMENT_CLASS_NAME_PROPERTY;/** Document class name property ("dom/document-class-name"). */String SYMBOL_TABLE_PROPERTY;/** Symbol table property ("internal/symbol-table"). */String ERROR_REPORTER_PROPERTY;/** Error reporter property ("internal/error-reporter"). */String ERROR_HANDLER_PROPERTY;/** Error handler property ("internal/error-handler"). */String XINCLUDE_HANDLER_PROPERTY;/** XInclude handler property ("internal/xinclude-handler"). */String XPOINTER_HANDLER_PROPERTY;/** XPointer handler property ("internal/xpointer-handler"). */String ENTITY_MANAGER_PROPERTY;/** Entity manager property ("internal/entity-manager"). *//** Input buffer size property ("input-buffer-size"). */String SECURITY_MANAGER_PROPERTY;/** Security manager property ("security-manager"). */String LOCALE_PROPERTY;/** Locale property ("locale"). *//** property identifier: security manager. */String ENTITY_RESOLVER_PROPERTY;String XMLGRAMMAR_POOL_PROPERTY;/** Grammar pool property ("internal/grammar-pool"). */String DATATYPE_VALIDATOR_FACTORY_PROPERTY;/** Datatype validator factory ("internal/datatype-validator-factory"). */String DOCUMENT_SCANNER_PROPERTY;/** Document scanner property ("internal/document-scanner"). */String DTD_SCANNER_PROPERTY;/** DTD scanner property ("internal/dtd-scanner"). */String DTD_PROCESSOR_PROPERTY;/** DTD processor property ("internal/dtd-processor"). */String VALIDATOR_PROPERTY;/** Validator property ("internal/validator"). */String DTD_VALIDATOR_PROPERTY;/** Validator property ("internal/validator/dtd"). */String SCHEMA_VALIDATOR_PROPERTY;/** Validator property ("internal/validator/schema"). */String SCHEMA_LOCATION;/** No namespace schema location property ("schema/external-schemaLocation"). */String SCHEMA_NONS_LOCATION;/** Schema location property ("schema/external-noNamespaceSchemaLocation"). */String NAMESPACE_BINDER_PROPERTY;/** Namespace binder property ("internal/namespace-binder"). */String NAMESPACE_CONTEXT_PROPERTY;/** Namespace context property ("internal/namespace-context"). */String VALIDATION_MANAGER_PROPERTY;/** Validation manager property ("internal/validation-manager"). */String XPOINTER_SCHEMA_PROPERTY;/** XPointer Schema property ("xpointer-schema"). */String SCHEMA_DV_FACTORY_PROPERTY;/** Schema element declaration for the root element in a document ("internal/validation/schema/dv-factory"). */String ELEMENT_PSVI;/** Element PSVI is stored in augmentations using string "ELEMENT_PSVI" */// general constantsString ATTRIBUTE_PSVI;/** Attribute PSVI is stored in augmentations using string "ATTRIBUTE_PSVI" */String ATTRIBUTE_DECLARED;/** Boolean indicating whether an attribute is declared in the DTD is stored ... */String TYPEINFO;/** {@link org.w3c.dom.TypeInfo} associated with current element/attribute ... */String ID_ATTRIBUTE;/** Whether an attribute is an id or not is stored in augmentations ... */String ENTITY_SKIPPED;/** Boolean indicating whether an entity referenced in the document has ... */// XML version constantsString CHAR_REF_PROBABLE_WS;/** Boolean indicating whether a character is a probable white space ... */String LAST_ENTITY;/** Boolean indicating if this entity is the last opened entity. ... */short XML_VERSION_ERROR;short XML_VERSION_1_0;short XML_VERSION_1_1;String ANONYMOUS_TYPE_NAMESPACE;// DOM related constantsboolean SCHEMA_1_1_SUPPORT;// Constant to enable Schema 1.1 supportshort SCHEMA_VERSION_1_0;short SCHEMA_VERSION_1_0_EXTENDED;...[] fgSAXFeatures;/** SAX features. */// private...[] fgSAXProperties;/** SAX properties. */...[] fgXercesFeatures;/** Xerces features. */...[] fgXercesProperties;/** Xerces properties. */Enumeration<> fgEmptyEnumeration;/** Empty enumeration. *//** This class cannot be instantiated. *//** Returns an enumeration of the SAX features. */// saxfgSAXFeatures.length/** Returns an enumeration of the SAX properties. */// getSAXFeatures():EnumerationfgSAXProperties.length/** Returns an enumeration of the Xerces features. */// xerces// getSAXProperties():EnumerationfgXercesFeatures.length/** Returns an enumeration of the Xerces properties. */// getXercesFeatures():EnumerationfgXercesProperties.length// getXercesProperties():EnumerationConstants$ArrayEnumeration/** An array enumeration. ... */...[] array;/** Array. *//** Index. *//** Constructs an array enumeration. */this.array/** Tests if this enumeration contains more elements. ... */// Enumeration methods// <init>(Object[])/** Returns the next element of this enumeration. ... */// hasMoreElement():boolean/** Prints all of the constants to standard output. */// MAIN// class ArrayEnumeration/** Prints a list of features/properties. */// main(String[])/* Copyright (c) 2003, 2016, Oracle and/or its affiliates. All rights reserved. *//* Copyright 2005 The Apache Software Foundation. ... *///DEFER_NODE_EXPANSION_FEATURE,//GRAMMAR_ACCESS_FEATURE,// nextElement():Object// print(String,String,Object[])/** <p>This interface extends <code>XMLEntityResolver</code> providing ... *//** <p>Locates an external subset for documents which do not explicitly ... */// ExternalSubsetResolver methods// interface ExternalSubsetResolverimport StaxEntityResolverWrapperimport XMLInputFactoryimport XMLOutputFactoryimport XMLResolver/** This class manages different properties related to Stax specification and its implementation. ... */String STAX_NOTATIONS;String STAX_ENTITIES;String STRING_INTERNING;HashMap<> supportedProps;XMLSecurityManager fSecurityManager;XMLSecurityPropertyManager fSecurityPropertyMgr;int CONTEXT_READER;int CONTEXT_WRITER;/** Creates a new instance of PropertyManager */initConfigurableReaderProperties(...)initWriterProps(...)/** Initialize this object with the properties taken from passed PropertyManager object. */HashMap<> properties/** Important point: ... */XMLInputFactory.IS_NAMESPACE_AWAREXMLInputFactory.IS_VALIDATINGXMLInputFactory.IS_REPLACING_ENTITY_REFERENCESXMLInputFactory.IS_SUPPORTING_EXTERNAL_ENTITIESXMLInputFactory.IS_COALESCINGXMLInputFactory.SUPPORT_DTDXMLInputFactory.REPORTERXMLInputFactory.RESOLVERXMLInputFactory.ALLOCATORConstants.STRING_INTERNING_FEATUREConstants.ALLOW_JAVA_ENCODINGS_FEATUREConstants.ADD_NAMESPACE_DECL_AS_ATTRIBUTEConstants.READER_IN_DEFINED_STATEConstants.REUSE_INSTANCEConstants.ZEPHYR_PROPERTY_PREFIXConstants.STAX_REPORT_CDATA_EVENTConstants.IGNORE_EXTERNAL_DTDConstants.WARN_ON_DUPLICATE_ATTDEF_FEATUREConstants.WARN_ON_DUPLICATE_ENTITYDEF_FEATUREConstants.WARN_ON_UNDECLARED_ELEMDEF_FEATUREXMLOutputFactory.IS_REPAIRING_NAMESPACESConstants.ESCAPE_CHARACTERS/** public void reset(){ ... */String equivalentPropertynew StaxEntityResolverWrapper(...)Constants.STAX_ENTITY_RESOLVER_PROPERTY//spec default values//zephyr (implementation) specific properties which can be set by the application.//interning is always done//recognizing java encoding names by default//in stax mode, namespace declarations are not added as attributes//default value of escaping characters is 'true'//add internal stax property/** It's possible for users to set a security manager through the interface. ... *///check if the property is managed by security manager//check if the property is managed by security property manager//fall back to the existing property manager//PropertyManagerimport XMLDocumentFilter/** DOM Revalidation handler adds additional functionality to XMLDocumentHandler ... */// interface DOMRevalidationHandler/** This class defines the version number of the parser. ... */String fVersion;/** Version string. ... */String fImmutableVersion;/* Print out the version information. ... *//** Prints out the version number to System.out. This is needed ... */// getVersion():  String/* The Apache Software License, Version 1.1 ... */// class Versionimport XMLStringBuffer/** This class is responsible for scanning the declarations found ... */new XMLStringBuffer(...)XMLStringBuffer fStringBuffer;/** String buffer. *//** Constructor for he use of non-XMLComponentManagers. *//** Scans public ID literal. ... */// This needs to be refactored!!!  - NG// multiple inheritance...// we need to override these methods in both places.  Ah for// NOTE:  this is a carbon copy of the code in XML11DocumentScannerImpl;// XMLScanner methods// XMLDTDScanner methodsint quotescanChar(...)boolean skipSpaceboolean dataokreportFatalError(...)fStringBuffer.lengthsetValues(...)isPubid(...)/** Normalize whitespace in an XMLString converting all whitespace ... */value.offsetvalue.chisSpace(...)/** Checks whether this string would be unchanged by normalization. ... */// XML understood by this scanner.// valid with respect to the version of// returns true if the given character is notisXML11Valid(...)// with respect to the version of XML understood by this scanner.// valid or may not be used outside a character reference// isInvalid(int):  booleanisXML11ValidLiteral(...)// a valid nameChar with respect to the version of// returns true if the given character is// isInvalidLiteral(int):  booleanisXML11Name(...)// a valid nameStartChar with respect to the version of// isValidNameChar(int):  booleanisXML11NameStart(...)// a valid NCName character with respect to the version of// isValidNameStartChar(int):  booleanisXML11NCName(...)// by this scanner.// with respect to the version of XML understood// a valid high surrogate for a nameStartChar// isValidNCName(int):  booleanisXML11NameHighSurrogate(...)// is allowed to appear in this context// documents may invoke 1.0 entities; thus either version decl (or none!)// note that, according to 4.3.4 of the XML 1.1 spec, XML 1.1// isValidNameStartHighSurrogate(int):  boolean// versions of XML with respect to the version of// returns the error message key for unsupported// versionSupported(String):  boolean// skip leading whitespace// REVISIT:  it could really only be \n or 0x20; all else is normalized, no?  - neilg// take the first whitespace as a space and skip the others// if we finished on a space let's trim it// getVersionNotSupportedKey: String// class XML11DTDScannerImpl/** This class is responsible for scanning XML document structure ... */XMLStringBuffer fStringBuffer2;XMLStringBuffer fStringBuffer3;/** Scans element content. ... */// XMLDocumentFragmentImpl methods// overridden methodsscanContent(...)fTempString.lengthskipChar(...)/** Scans an attribute value and normalizes whitespace converting all ... */// scanContent():intpeekChar(...)int entityDepthscanLiteral(...)int cquoteNameType.ATTRIBUTEisUnchangedByNormalization(...)normalizeWhitespace(...)NameType.REFERENCEscanCharReferenceValue(...)String entityNamescanName(...)resolveCharacter(...)checkEntityLimit(...)fEntityScanner.fCurrentEntity.namefEntityScanner.fCurrentEntityisExternalEntity(...)isDeclaredEntity(...)XMLErrorReporter.SEVERITY_ERRORscanSurrogates(...)isInvalidLiteral(...)// this needs to be refactored!!!  - NG// we need to override these methods in both places.// NOTE:  this is a carbon copy of the code in XML11DTDScannerImpl;// scanAttributeValue()// happens when there is the character reference &#13;// but scanContent doesn't do entity expansions...// is this *really* necessary???  - NG/* if (fDocumentHandler != null && content.length > 0) { ... */// remember where we are in case we get an endEntity before we// could flush the buffer out - this happens when we're parsing an// entity which ends with a ]// We work on a single character basis to handle cases such as:// ']]]>' which we might otherwise miss./* if (fDocumentHandler != null && fStringBuffer.length != 0) { ... */// quote/** Both the non-normalized and normalized attribute values are equal. * *///WFC & VC: Entity Declared// note that none of these characters should ever get through// XML11EntityScanner.  Not sure why// this check was originally necessary.  - NG// REVISIT:  none of these except \n and 0x20 should make it past the entity scanner// class XML11DocumentScannerImplimport NameTypeimport Limit/** Implements the entity scanner methods in ... *//** Returns the next character on the input. ... */// XMLEntityScanner methodsfCurrentEntity.chfCurrentEntity.positionfCurrentEntity.count// peekChar():intboolean externalfCurrentEntity.lineNumberfCurrentEntity.columnNumberinvokeListeners(...)int cc/** Returns a string matching the NMTOKEN production appearing immediately ... */// scanChar():intString symbolfCurrentEntity.ch.lengthfCurrentEntity.startPosition/** Returns a string matching the Name production appearing immediately ... */// scanNmtoken():StringcheckBeforeLoad(...)checkLimit(...)Limit.MAX_NAME_LIMIT/** Returns a string matching the NCName production appearing immediately ... */// scanName():StringisXML11NCNameStart(...)/** Scans a qualified name from the input, setting the fields of the ... */// scanNCName():StringXMLScanner.NameTypeboolean sawIncompleteSurrogatePairint startLocalXMLErrorReporter.SEVERITY_FATAL_ERROR/** Scans a range of parsed character data, setting the fields of the ... */// scanQName(QName):booleanint newlinesboolean countedfCurrentEntity.baseCharOffsetisXML11Content(...)isXML11InternalEntityContent(...)/** Scans a range of attribute value data, setting the fields of the ... */// scanContent(XMLString):intfCurrentEntity.literal/** Scans a range of character data up to the specicied delimiter, ... */// scanLiteral(int,XMLString):intint delimLenchar charAt0boolean bNextEntityNameType.COMMENTint delimOffset/** Skips a character appearing immediately on the input. ... */// scanData(String,XMLString)int ccc/** Skips space characters appearing immediately on the input. ... */// skipChar(int):booleanisXML11Space(...)boolean entityChanged/** Skips the specified string appearing immediately on the input. ... */// skipSpaces():booleanint beforeSkip// load more characters, if needed// peek at character// return peeked character// scan character// return character that was scanned// scan nmtoken// bad luck we have to resize our buffer// return nmtoken// scan name// return name// scan qualified name//check prefix before further read//check the result: prefix//check the result: localpart// normalize newlines/** * NEWLINE NORMALIZATION ** */// inner loop, scanning for content// In internal entities control characters are allowed to appear unescaped.// return next character// REVISIT: Does this need to be updated to fix the//          #x0D ^#x0A newline normalization problem? -Ac// scan literal value// NOTE: We don't want to accidentally signal the//       end of the literal if we're expanding an//       entity appearing in the literal. -Ac// something must be wrong with the input:  e.g., file ends  an unterminated comment// iterate over buffer looking for delimiter// looks like we just hit the delimiter// In external entities control characters cannot appear// as literals so do not skip over them.// Control characters are allowed to appear as literals// in internal entities.// return true if string was skipped// skip character// handle newlines// character was not skipped//we are doing this check only in skipSpace() because it is called by//fMiscDispatcher and we want the parser to exit gracefully when document//is well-formed.//it is possible that end of document is reached and//fCurrentEntity becomes null//nothing was read so entity changed  'false' should be returned.// skip spaces// External --  Match: S + 0x85 + 0x2028, and perform end of line normalization// the load change the position to be 1,// need to restore it when entity not changed//If this is a general entity, spaces within a start element should be counted// Internal -- Match: S (only)// no spaces were found// skip string// REVISIT: Can a string to be skipped cross an//          entity boundary? -Ac// skipString(String):boolean// class XML11EntityScannerimport XMLDTDValidatorFilterimport XMLAttributesImpl/** The scanner acts as the source for the document ... */boolean fBindNamespaces;/** If is true, the dtd validator is no longer in the pipeline ... */boolean fPerformValidation;/** If validating parser, make sure we report an error in the ... */XMLDTDValidatorFilter fDTDValidator;/** DTD validator */boolean fSawSpace;/** Saw spaces after element name or between attributes. ... *//** The scanner is responsible for removing DTD validator ... *//** Scans a start element. This method will handle the binding of ... */fElementQName.rawnamescanQName(...)NameType.ELEMENTSTARTpushElement(...)removeAllAttributes(...)boolean sawSpaceskipSpaces(...)isValidNameStartChar(...)isValidNameStartHighSurrogate(...)scanAttribute(...)isNoLimit(...)fElementQName.prefixfElementQName.urifCurrentElement.urifCurrentElement.prefixString aprefixfAttributeQName.prefixfAttributeQName.urifAttributeQName.rawnamesetURI(...)checkDuplicatesNS(...)name.uriname.localpartname.rawnamefCurrentElement.rawnameemptyElement(...)popElement(...)/** Scans the name of an element in a start or empty tag. ... */// scanStartElement():boolean/** Scans the remainder of a start or empty tag after the element name. ... */// scanStartElementName()/** Scans an attribute. ... */// scanStartElementAfterName()boolean isVCfAttributeQName.localpartboolean isNSDeclNameType.ATTRIBUTENAMEaddAttributeNS(...)XMLSymbols.fCDATASymbolint oldLenscanAttributeValue(...)this.fTempStringsetNonNormalizedValue(...)getStateLiteral(...)XMLSecurityManager.Limit.MAX_NAME_LIMITXMLSymbols.PREFIX_XML/** Scans an end element. ... */// scanAttribute(XMLAttributes)QName endElementNameskipString(...)endElementName.rawnameNameType.ELEMENTEND// scanEndElement():int/** Creates a content Driver. */new NS11ContentDriver(...)/** return the next state on the input ... */// createContentDriver():DriverXMLEvent.END_ELEMENTXML11NSDocumentScannerImpl$NS11ContentDriver/** Driver to handle content scanning. *//** Scan for root element hook. This method is a hook for ... */scanStartElementName(...)resolveExternalSubsetAndRead(...)reconfigurePipeline(...)scanStartElementAfterName(...)setScannerState(...)setDriver(...)scanStartElement(...)/** Re-configures pipeline by removing the DTD validator ... */// scanRootElementHook():booleanhasGrammar(...)XMLDocumentSource sourcegetDocumentSource(...)XMLDocumentHandler handlergetDocumentHandler(...)setDocumentSource(...)// Note: namespace processing is on by default// REVISIT - [Q] Why do we need this local variable? -- mrglavas// push element stack// spaces// end tag?// Second chance. Check if this character is a high// surrogate of a valid name start character.// REVISIT: is it required? forbit xmlns prefix for element// bind the element// assign uri to the element// make sure that object in the element stack is updated as well// making sure that the object in the element stack is updated too.// bind attributes (xmlns are already bound bellow)// REVISIT: try removing the first "if" and see if it is faster.//decrease the markup depth..// check that this element was opened in the same entity/* if (fBindNamespaces) { ... *///pop the element off the stack..// Must skip spaces here because the DTD scanner// would consume them at the end of the external subset./** Determine whether this is a namespace declaration that will be subject ... */// record namespace declarations if any.// get the internalized value of this attribute// 1. "xmlns" can't be bound to any namespace// 2. the namespace for "xmlns" can't be bound to any prefix// 3. "xml" can't be bound to any other namespace than it's own// 4. the namespace for "xml" can't be bound to any other prefix// Declare prefix in context. Removing the association between a prefix and a// namespace name is permitted in XML 1.1, so if the uri value is the empty string,// the prefix is being unbound. -- mrglavas// bind namespace attribute to a namespace// attempt to bind attribute// pop context// Take advantage of the fact that next string _should_ be "fElementQName.rawName",//In scanners most of the time is consumed on checks done for XML characters, we can// optimize on it and avoid the checks done for endElement,//we will also avoid symbol table lookup - neeraj.bajaj@sun.com// this should work both for namespace processing true or false...//REVISIT: if the string is not the same as expected.. we need to do better error handling..//We can skip this for now... In any case if the string doesn't match -- document is not well formed.// end//we have increased the depth for two markup "<" characters//since namespace context should still be valid when the parser is at the end element state therefore//we pop the context only when next() has been called after the end element state was encountered. - nb.// re-configure pipeline// reconfigurePipeline()/** This class performs namespace binding on the startElement and endElement ... */// this is disallowed by the version of XML namespaces in use.// returns true iff the given prefix is bound to "" *and*// prefixBoundToNullURI(String, String):  boolean// class XML11NamespaceBinderimport XMLEntityHandlerimport XMLLimitAnalyzerimport XMLDTDScannernew XMLAttributesImpl(...)new Boolean[]int SCANNER_STATE_END_OF_INPUT;/** Scanner state: end of input. */// scanner statesint SCANNER_STATE_TEXT_DECL;/** Scanner state: text declaration. */int SCANNER_STATE_MARKUP_DECL;/** Scanner state: markup declaration. */...[] RECOGNIZED_FEATURES;/** Recognized features. */// recognized features and properties...[] FEATURE_DEFAULTS;/** Feature defaults. */...[] RECOGNIZED_PROPERTIES;/** Recognized properties. */...[] PROPERTY_DEFAULTS;/** Property defaults. */boolean DEBUG_SCANNER_STATE;/** Debug scanner state. */XMLDTDHandler fDTDHandler;/** DTD handler. */// handlersXMLDTDContentModelHandler fDTDContentModelHandler;/** DTD content model handler. */int fScannerState;/** Scanner state. */boolean fStandalone;/** Standalone. */boolean fSeenExternalDTD;/** Seen external DTD. */boolean fSeenExternalPE;/** Seen external parameter entity. */boolean fStartDTDCalled;/** Start DTD called. */XMLAttributesImpl fAttributes;/** Default attribute */...[] fContentStack;/** Stack of content operators (either '|' or ',') in children ... */int fContentDepth;/** Size of content stack. */...[] fPEStack;/** Parameter entity stack to check well-formedness. */...[] fPEReport;/** Parameter entity stack to report start/end entity calls. */int fPEDepth;/** Number of opened parameter entities. */int fMarkUpDepth;/** Markup depth. */int fExtEntityDepth;/** Number of opened external entities. */int fIncludeSectDepth;/** Number of opened include sections. */...[] fStrings;/** Array of 3 strings. */// temporary variablesXMLString fString;/** String. */XMLString fLiteral;/** Literal text. */XMLString fLiteral2;...[] fEnumeration;/** Enumeration values. */int fEnumerationCount;/** Enumeration values count. */XMLStringBuffer fIgnoreConditionalBuffer;/** Ignore conditional section buffer. */DTDGrammar nvGrammarInfo;/** Object contains grammar information for a non-validaing parser. */boolean nonValidatingMode;/** Sets the input source. ... */setEntityHandler(...)startDTDEntity(...)// setInputSource(XMLInputSource)/** Scans the external subset of the document. ... */boolean textDeclscanTextDecl(...)scanDecls(...)/** Scans the internal subset of the document. ... */// scanDTDExternalSubset(boolean):booleangetEntityScanner(...)XMLSecurityManager.Limit.GENERAL_ENTITY_SIZE_LIMITXMLSecurityManager.Limit.TOTAL_ENTITY_SIZE_LIMIT/** Skip the DTD if javax.xml.stream.supportDTD is false. ... */// scanDTDInternalSubset(boolean,boolean,boolean):booleanscanData(...)fEntityScanner.fCurrentEntity.position/** reset ... */// XMLComponent methods// this is made for something like XMLDTDLoader--XMLComponentManager-free operation...// reset(XMLComponentManager)setPropertyManager(...)new DTDGrammar(...)/** Returns a list of feature identifiers that are recognized by ... *//** Returns a list of property identifiers that are recognized by ... */// getRecognizedFeatures():String[]/** Returns the default state for a feature, or null if this ... */// getRecognizedProperties():String[]RECOGNIZED_FEATURES.length/** Returns the default state for a property, or null if this ... */// getFeatureDefault(String):BooleanRECOGNIZED_PROPERTIES.length/** setDTDHandler ... */// XMLDTDSource methods// getPropertyDefault(String):Object/** getDTDHandler ... *//** setDTDContentModelHandler ... */// XMLDTDContentModelSource methods// getDTDHandler():  XMLDTDHandler/** getDTDContentModelHandler ... */// setDTDContentModelHandler/** This method notifies of the start of an entity. The DTD has the ... */// XMLEntityHandler methodsboolean dtdEntitystartExternalSubset(...)pushPEStack(...)startParameterEntity(...)/** This method notifies the end of an entity. The DTD has the pseudo-name ... */// startEntity(String,XMLResourceIdentifier,String)boolean reportEntityint startMarkUpDepthpopPEStack(...)peekReportEntity(...)fEntityManager.fCurrentEntity.namefEntityManager.fCurrentEntityendParameterEntity(...)endExternalSubset(...)Constants.LAST_ENTITY/** Sets the scanner state. ... */// helper methods// endEntity(String)getScannerStateName(...)/** Returns the scanner state name. */// setScannerState(int)// getScannerStateName(int):String/** start a parameter entity dealing with the textdecl if there is any ... */String pName/** Dispatch an XML "event". ... */isValidNameChar(...)fStringBuffer.chfStringBuffer.offsetscanPIData(...)String encodingscanXMLDeclOrTextDecl(...)textDecl(...)fEntityManager.fCurrentEntity.mayReadChunks/** Scans a processing data. This is needed to handle the situation ... */// scanTextDecl(boolean):boolean/** Scans a comment. ... */// scanPIData(String)scanComment(...)/** Scans an element declaration ... */// scanComment()String contentModelskipSeparator(...)scanningInternalSubset(...)startContentModel(...)any(...)startGroup(...)scanMixed(...)scanChildren(...)endContentModel(...)/** scan Mixed content model ... */// scanElementDecl()pcdata(...)separator(...)XMLDTDContentModelHandler.SEPARATOR_CHOICENameType.ENTITYelement(...)endGroup(...)occurrence(...)XMLDTDContentModelHandler.OCCURS_ZERO_OR_MORE/** scan children content model ... */int currentOppushContentStack(...)short ocXMLDTDContentModelHandler.OCCURS_ZERO_OR_ONEXMLDTDContentModelHandler.OCCURS_ONE_OR_MOREXMLDTDContentModelHandler.SEPARATOR_SEQUENCEpopContentStack(...)/** Scans an attlist declaration ... */String elNamestartAttlist(...)endAttlist(...)scanAttType(...)String defaultTypescanAttDefaultDecl(...)String[] enumr/** Scans an attribute type definition ... */// scanAttlistDecl()ensureEnumerationSize(...)scanNmtoken(...)/** Scans an attribute default declaration ... */// scanAttType():String/** Scans an entity declaration ... */// ScanAttDefaultDeclboolean isPEDeclboolean sawPERefString publicIdString notationString peNamestartPE(...)scanExternalID(...)NameType.NOTATIONscanEntityValue(...)fLiteral.chfLiteral.offsetfLiteral.lengthfLiteral2.chfLiteral2.offsetfLiteral2.lengthString baseSystemIdgetBaseSystemId(...)addUnparsedEntity(...)addExternalEntity(...)expandSystemId(...)addInternalEntity(...)/** Scans an entity value. ... */// scanEntityDecl()XMLString literalXMLString literal2int countCharfEntityManager.fLimitAnalyzerString eNamefString.lengthXMLSecurityManager.Limit.PARAMETER_ENTITY_SIZE_LIMIT/** Scans a notation declaration ... */// scanEntityValue(XMLString,XMLString):void/** Scans a conditional section. If it's a section to ignore the whole ... */// scanNotationDecl()startConditional(...)XMLDTDHandler.CONDITIONAL_INCLUDEint initialDepthXMLDTDHandler.CONDITIONAL_IGNOREfIgnoreConditionalBuffer.chfIgnoreConditionalBuffer.lengthignoredCharacters(...)endConditional(...)// scanConditionalSect()boolean againscanPI(...)scanElementDecl(...)scanAttlistDecl(...)scanEntityDecl(...)scanNotationDecl(...)scanConditionalSect(...)/** Skip separator. This is typically just whitespace but it can also be one ... *//* Element Children Content Stack */fContentStack.lengthint[] newStack/* Parameter Entity Stack */fPEStack.lengthint[] newIntStackboolean[] newBooleanStack/** pop the stack *//** look at the top of the stack *//* Utility method */fEnumeration.lengthString[] newEnumfEntityManager.fSecurityManager/* Copyright (c) 2003, 2017, Oracle and/or its affiliates. All rights reserved. */// no system id was available// next state is markup decls regardless of whether there// is a TextDecl or not// keep dispatching "events"// return that there is more to scan// reset entity scanner//xxx:stax getText() is supposed to return only DTD internal subset//shouldn't we record position here before we go ahead ??//System.out.println("state"+fScannerState);// set starting state for internal subset// we're done, set starting state for external subset// we're done scanning DTD.//Revisit : Create new grammar until we implement GrammarPool.// if there is no data after the doctype// Handle end of PE// check well-formedness of the enity// throw fatalError if this entity was incomplete and// was a freestanding decl// Proper nesting of parameter entities is a Validity Constraint// and must not be enforced when validation is off// end DTD//XML (Document Entity) is the last opened entity, however//if for some reason DTD Scanner receives this callback//there is something wrong (probably invalid XML), throw exception.//or//For standalone DTD loader, it might be the last opened entity//and if this is the last opened entity and fMarkUpDepth != 0 or//fIncludeSectDepth != 0 or fExtEntityDepth != 0 throw Exception//System.out.println();// if we actually got a new entity and it's external// parse text decl if there is any// scan XMLDecl// NOTE: special case where document starts with a PI//       whose name starts with "xml" (e.g. "xmlfoo")// standard Text declaration// pseudo-attribute values//Venu REVISIT//      super.scanPIData(target, data);// element name// content model// Mixed content model// children content// The following check must be done in a single call (as opposed to one// for ')' and then one for '*') to guarantee that callbacks are// properly nested. We do not want to trigger endEntity too early in// case we cross the boundary of an entity between the two characters.// we are done// push current op on stack and reset it// restore previous op// The following checks must be done in a single call (as// opposed to one for ')' and then one for '?', '*', and '+')// to guarantee that callbacks are properly nested. We do not// want to trigger endEntity too early in case we cross the// boundary of an entity between the two characters.// no occurrence specified// no space, is it the end yet?// yes, stop here// definitions// type// default decl// REVISIT: Should we do anything with the non-normalized//          default attribute value? -Ac// yes--according to bug 5073.  - neilg// Determine whether the default value to be passed should be null.// REVISIT: should probably check whether fLiteral.ch is null instead. LM./* Watchout: the order here is important: when a string happens to ... */// open paren// Enumeration//                       "OPEN_PAREN_REQUIRED_BEFORE_ENUMERATION_IN_ATTRDECL",// AttValue// <!ENTITY x "x">// <!ENTITY % x "x">// <!ENTITY %%x; "x"> is legal// <!ENTITY[^ ]...> or <!ENTITY[^ %]...>// <!ENTITY% ...>// external id// NDATA// check whether there was space before NDATA// internal entity// since we need it's value anyway, let's snag it so it doesn't get corrupted// if a new load takes place before we store the entity values// skip possible trailing space// register entity and make callback//Venu Revisit : why false has been removed in expandSYstem// store at which depth of entities we start// REVISIT: [Q] Why do we skip spaces here? -Ac// REVISIT: This will make returning the non-//          normalized value harder. -Ac// if it's not the delimiting quote or if it is but from a// different entity than the one this literal started from,// simply append the character to our buffer// notation name//Venu Revisit wby false has been removed.//fResourceIdentifier.setValues(publicId, systemId, baseSystemId, XMLEntityManager.expandSystemId(systemId, baseSystemId, false));// just stop there and go back to the main loop// These tests are split so that we handle cases like// '<<![' and '<!<![' which we might otherwise miss.// The same thing goes for ']<![' and '<]]>', etc./* empty loop body *///System.out.println("scanDecls"+fScannerState);// we're done with this decl// end of conditional section?// decreaseMarkupDepth();// this is the end of the internal subset, let's stop here// simply skip// report end/start calls// reset state related data// set starting state//new SymbolTable());// class XMLDTDScannerImplimport XMLAttributesIteratorImplimport XMLDocumentScannerimport XMLBufferListenerimport XMLEntityStorageimport DTDGrammarUtil/** This class is responsible for scanning the structure and content ... */new ElementStack(...)new ElementStack2(...)createContentDriver(...)new XMLAttributesIteratorImpl(...)Constants.NOTIFY_BUILTIN_REFS_FEATUREConstants.STANDARD_URI_CONFORMANT_FEATUREConstants.EXTERNAL_ACCESS_DEFAULTint fElementAttributeLimit, ...;ExternalSubsetResolver fExternalSubsetResolver;/** External subset resolver. * */int SCANNER_STATE_START_OF_MARKUP;/** Scanner state: start of markup. *///XXX this should be divided into more states.int SCANNER_STATE_CONTENT;/** Scanner state: content. */int SCANNER_STATE_PI;/** Scanner state: processing instruction. */int SCANNER_STATE_DOCTYPE;/** Scanner state: DOCTYPE. */int SCANNER_STATE_XML_DECL;/** Scanner state: XML Declaration */int SCANNER_STATE_ROOT_ELEMENT;/** Scanner state: root element. */int SCANNER_STATE_COMMENT;/** Scanner state: comment. */int SCANNER_STATE_REFERENCE;/** Scanner state: reference. */int SCANNER_STATE_ATTRIBUTE;// <book type="hard"> reading attribute name 'type'int SCANNER_STATE_ATTRIBUTE_VALUE;// <book type="hard"> //reading attribute value.//protected static final int SCANNER_STATE_TRAILING_MISC = 32;/** Scanner state: trailing misc. USED BY DOCUMENT_SCANNER_IMPL */int SCANNER_STATE_TERMINATED;/** Scanner state: terminated. */int SCANNER_STATE_CDATA;/** Scanner state: CDATA section. *//** Scanner state: Text declaration. */int SCANNER_STATE_CHARACTER_DATA;int SCANNER_STATE_START_ELEMENT_TAG;//<book type="hard">foo</book>int SCANNER_STATE_END_ELEMENT_TAG;//<book type="hard">foo</book> reading </book>int SCANNER_STATE_CHAR_REFERENCE;int SCANNER_STATE_BUILT_IN_REFS;String NOTIFY_BUILTIN_REFS;/** Feature identifier: notify built-in refereces. */String STANDARD_URI_CONFORMANT;/** Feature identifier: standard uri conformant *//** access external dtd: file protocol ... */...[] cdata;...[] xmlDecl;// private static final char [] endTag = {'<','/'};boolean DEBUG_DISPATCHER;/** Debug driver. */boolean DEBUG_START_END_ELEMENT;/** Debug content driver scanning. */boolean DEBUG_NEXT;/** Debug driver next */boolean DEBUG_COALESCE;/** Document handler. */// protected dataint fScannerLastState;XMLEntityStorage fEntityStore;/** Entity Storage */...[] fEntityStack;/** Entity stack. */int fMarkupDepth;boolean fEmptyElement;//is the element emptyboolean fReadingAttributes;//there is a callback//track if we are reading attributes, this is usefule whileboolean fInScanContent;/** SubScanner state: inside scanContent method. */boolean fLastSectionWasCData;boolean fLastSectionWasEntityReference;boolean fLastSectionWasCharacterData;boolean fHasExternalDTD;/** has external dtd */boolean fStandaloneSet;QName fCurrentElement;/** Current element. */// element informationElementStack fElementStack;/** Element stack. */ElementStack2 fElementStack2;String fPITarget;/** Document system identifier. ... */// other infoXMLString fPIData;//xxx do we need to create an extra XMLString object... look for using fTempString for collecting all the data valuesboolean fNotifyBuiltInRefs;/** Notify built-in references. */// featuresboolean fSupportDTD;//defaultValues.//STAX related propertiesboolean fReplaceEntityReferences;boolean fSupportExternalEntities;boolean fReportCdataEvent;boolean fIsCoalesce;String fDeclaredEncoding;boolean fDisallowDoctype;/** Xerces Feature: Disallow doctype declaration. */String fAccessExternalDTD;/** comma-delimited list of protocols that are allowed for the purpose ... */boolean fStrictURI;/** standard uri conformant (strict uri). ... */Driver fDriver;/** Active driver. */// driversDriver fContentDriver;/** Content driver. */QName fElementQName;/** Element QName. */QName fAttributeQName;/** Attribute QName. */XMLAttributesIteratorImpl fAttributes;/** CHANGED: Using XMLAttributesIteratorImpl instead of XMLAttributesImpl. This class ... */XMLString fTempString;XMLString fTempString2;/** Making the buffer accesible to derived class -- String buffer. */XMLStringBuffer fContentBuffer;/** Making the buffer accesible to derived class -- stores PI data *//** stores character data. */...[] fSingleChar;/** Single character array. */String fCurrentEntityName;boolean fScanToEnd;// New membersDTDGrammarUtil dtdGrammarUtil;boolean fAddDefaultAttr;boolean foundBuiltInRefs;short MAX_DEPTH_LIMIT;//skip element algorithmshort ELEMENT_ARRAY_LENGTH;short MAX_POINTER_AT_A_DEPTH;boolean DEBUG_SKIP_ALGORITHM;...[] fElementArray;//create a elemnet array of length equal to ELEMENT_ARRAY_LENGTHshort fLastPointerLocation;//pointer location where last element was skippedshort fElementPointer;...[] fPointerInfo;//2D array to store pointer infoString fElementRawname;boolean fShouldSkip;boolean fAdd;boolean fSkip;Augmentations fTempAugmentations;/** Reusable Augmentations. */// XMLDocumentScanner methods/** Scans a document. ... */checkNodeCount(...)// scanDocument(boolean):booleangetLastPoppedElement(...)/** Resets the component. The component can query the component manager ... */Object resolverXMLSecurityPropertyManager spmXMLSecurityPropertyManager.Property.ACCESS_EXTERNAL_DTDXMLSecurityPropertyManager.PropertyresetCommon(...)Boolean boBoolean cdataBoolean coalescegetEntityStore(...)getLimit(...)XMLSecurityManager.Limit.ELEMENT_ATTRIBUTE_LIMIT/** Sets the state of a feature. This method is called by the component ... *//** Sets the value of a property. This method is called by the component ... */String property/** setDocumentHandler ... */// XMLDocumentSource methods/** Returns the document handler */fEntityStack.lengthint[] entityarrayisEntityDeclInExternalSubset(...)startGeneralEntity(...)endGeneralEntity(...)/** / ... */new FragmentContentDriver(...)/** Scans an XML or text declaration. ... */// scanning methodsString standalonexmlDecl(...)isEncodingExternallySpecified(...)getCurrentEntity(...)// scanXMLDeclOrTextDecl(boolean)//XXX: why not this function behave as per the state of the parser?//xxx value returned by this function may not remain valid if another event is scanned.fElementStack.fDepthshort columnstorePointerForADepth(...)short pointergetElementPointer(...)resetPointer(...)//returns column information at which pointer was stored.short depthcanStore(...)//the following string from the buffer this makes sure//this function assumes that string passed is not null and skipsisName(...)skipFromTheBuffer(...)skipElement(...)//start of the column at which it should try searching// fAttributes will have the details of all the attributes.// fElementQName will have the details of element just read..reposition(...)fElementStack.fCountmatchElement(...)checkDepth(...)seekCloseOfStartTag(...)/** Looks for the close of start tag, i.e. if it finds '>' or '/>' ... *//** return the attribute iterator implementation *//* //REVISIT: one more case needs to be included: external PE and standalone is no ... *//** xxx there is one check of duplicate attribute that has been removed. ... *//** protected void scanAttribute(AttributeIteratorImpl attributes) ... */addDTDDefaultAttrs(...)/** return if standalone is set *//** return if the doucment is standalone *//** Scans an attribute name value pair. ... */int attIndexXMLString tmpStr//this function appends the data to the buffer.//It makes things easy if this functions takes XMLStringBuffer as parameter..//NOW: scanContent(XMLStringBuffer)//EARLIER: scanContent()//CHANGED:content.length/** Scans a CDATA section. ... */contentBuffer.length// scanCDATASection(XMLStringBuffer, boolean):boolean/** Scans a character reference. ... */Augmentations augsremoveAllItems(...)putItem(...)Constants.CHAR_REF_PROBABLE_WS/** Scans an entity reference. ... */// scanCharReference()boolean isEEisUnparsedEntity(...)handleCharacter(...)/** Check if the depth exceeds the maxElementDepth limit ... */// scanEntityReference()addValue(...)Limit.MAX_ELEMENT_DEPTH_LIMITisOverLimit(...)debugPrint(...)getTotalValue(...)/** Calls document handler with a single character resulting from ... */// handleCharacter(char)/** Sets the Driver. ... */getDriverName(...)/** Returns the driver name. */// getDriverName():StringString expandedSystemIdConstants.ACCESS_EXTERNAL_ALLQName qname;/** Symbol. */...[] fRawname;//raw name stored as charactersElement next;/** The next Element entry. *//** Constructs a new Element from the given QName and next Element ... */this.qnamethis.fRawname/** Element stack. ... */// class Elementnew QName[]...[] fQName;/** The stack data. */int fDepth;//Element depth//total number of elementsint fPosition;//current positionint fMark;//Mark refers to the positionint fLastDepth;fQName.lengthQName[] tmp/** Check if the element scanned during the start element ... */...[...].rawnameelement.rawname/** This function doesn't increase depth. The function in this function is ... */// pushElement(QName):QName/** Note that this function is considerably different than nextElement() ... *//** returns the current depth *//** Clears the stack without throwing away existing QName objects. *//** Element stack. This stack operates without synchronization, error ... */// class ElementStack...[] fElements;...[] fInt;fElements.length//XXX: THIS FUNCTION IS NOT USED/** Pushes an element on the stack. ... */QName[] array/** This function should be called only when element was skipped sucessfully. ... *//** Returns the next element on the stack. ... */// matchElement(QName):QName/** Pops an element off of the stack by setting the values of ... *//** Reposition the stack. fInt [] contains all the opened tags at particular depth. ... */// popElement(QName)/** This function is as a result of optimization done for endElement -- ... */// clear()/** Drives the parser to the next state/event on the input. Parser is guaranteed ... */XMLDocumentFragmentScannerImpl$FragmentContentDriver/** Driver to handle content scanning. This driver is capable of reading ... */// interface Driver/** decides the appropriate state of the parser */// Driver methodsscanForDoctypeHook(...)//startOfMarkup/** SCANNER_STATE_CONTENT and SCANNER_STATE_START_OF_MARKUP are two super states of the parser. ... *///startOfContentstartOfContent(...)startOfMarkup(...)//decideSubStateXMLEvent.CHARACTERSXMLEvent.START_DOCUMENTXMLEvent.START_ELEMENTisNameStart(...)isIgnorableWhiteSpace(...)XMLEvent.SPACEelementDepthIsZeroHook(...)scanEndElement(...)XMLEvent.COMMENTXMLEvent.PROCESSING_INSTRUCTIONscanCDATASection(...)XMLEvent.CDATAscanEntityReference(...)XMLEvent.ENTITY_REFERENCEscanRootElementHook(...)new XNIException(...)endOfFileHook(...)/** Scan for DOCTYPE hook. This method is a hook for subclasses ... *///       scanner can share the majority of code with this class.// NOTE: These hook methods are added so that the full document// hooks//next/** Element depth iz zero. This methos is a hook for subclasses ... */// scanForDoctypeHook():boolean// elementDepthIsZeroHook():boolean/** End of file hook. This method is a hook for subclasses to ... */// class FragmentContentDriverboolean fUsebuffer;/** this function gets an XMLString (which is used to store the attribute value) from the special pool ... */XMLString str/** Implements XMLBufferListener interface. */refresh(...)/** receives callbacks from {@link XMLEntityReader } when buffer ... */// fDocumentSystemId = fEntityManager.expandSystemId(inputSource.getSystemId());//System.out.println(" get Document Handler in NSDocumentHandler " + fDocumentHandler );//fDocumentHandler.startDocument(fEntityManager.getEntityScanner(),fEntityManager.getEntityScanner().getVersion(),fNamespaceContext,null);// not able to get//System.out.println(" in scann element");//fDocumentHandler.startElement(getElementQName(),fAttributes,null);//check if getCharacterData() is the right function to retrieve ignorableWhitespace information.//System.out.println("in the space");//fDocumentHandler.ignorableWhitespace(getCharacterData(), null);//entity reference callback are given in startEntity//all DTD related callbacks are handled in DTDScanner.//1. Stax doesn't define DTD states as it does for XML Document.//therefore we don't need to take care of anything here. So Just break;//xxx: check if CDATA values comes from getCharacterData() function//System.out.println(" in CDATA of the XMLNSDocumentScannerImpl");//do not give callback here.//this callback is given in scanEndElement function.//fDocumentHandler.endElement(getElementQName(),null);//System.out.println("here in before calling next");//System.out.println("here in after calling next");// other settings// fDocumentSystemId = null;//fAttributes.setNamespaces(fNamespaces);//attribute//xxx: external entities are supported in Xerces// it would be good to define feature for this case// setup Driver// JAXP 1.5 features and properties//fEntityManager.test();//fElementStack2.clear();//fReplaceEntityReferences = true;//fSupportExternalEntities = true;//if fIsCoalesce is set to true, set the value of fReplaceEntityReferences to true,//if fIsCoalesce is set to false, take the value of fReplaceEntityReferences as set by application//we dont need to do this -- nb.//setScannerState(SCANNER_STATE_CONTENT);//setDriver(fContentDriver);// initialize vars//skipping algorithm// Xerces properties//JAXP 1.5 properties//System.out.println(" In Set DOCUMENT HANDLER" + fDocumentHandler + " scanner =" + this);// keep track of this entity before fEntityDepth is increased// WFC:  entity declared in external subset in standalone doc/** we are not calling the handlers yet.. *//** // flush possible pending output buffer - see scanContent ... */// make sure markup is properly balanced// scan decl// set standalone///xxx see where its used.. this is not used anywhere. it may be useful for entity to store this information//but this information is only related with Document Entity.// set encoding on reader, only if encoding was not specified by the application explicitly//set the PI target and values//getTextCharacters can also be called for reading comments//storing element raw name in a linear list of array//storing elemnetPointer for particular element depth//store pointer information only when element depth is less MAX_DEPTH_LIMIT//identity comparison shouldn't take much time and we can rely on this//since its guaranteed to have same object id for same string.//reset the things and return.//Stores element pointer locations at particular depth , only 4 pointer locations//are stored at particular depth for now.//else//pointer was not stored because we reached the limit//colum = 0 , means first element at particular depth//column = 1, means second element at particular depth//        calle should make sure that it doesn't call for value outside allowed co-ordinates//If the start element was completely skipped we should encounter either ' '(space),//or '/' (in case of empty element)  or '>'//if this character is still valid element name -- this means string can't match//Look at the next element stored in the array list.. we might just get a match.//reset it back to zero... we haven't got the correct subset yet.//xxx: we can put some logic here as from what column it should start looking//for now we always start at 0//fallback to tolerant algorithm, it would look for differnt element stored at different//depth and get us the pointer location.//when skipping is true and no more elements should be added//get the stored element -- if everything goes right this should match the//token in the buffer//Be conservative -- if skipping fails -- stop.//if skipping fails reposition the stack or fallback to normal way of processing//we are still at the stage of adding elements//the elements were not matched or//fSkip is not set to true//get the next element from the stack//when the elements are being added , we need to check if we are set for skipping the elements//this sets the value of fAdd variable//xxx: We dont need another pointer, fCurrentElement, we can use fElementQName//We should not be popping out the context here in endELement becaause the namespace context is still//valid when parser is at the endElement state.//if (fNamespaces) {//  fNamespaceContext.popContext();//complete element and attributes are traversed in this function so we can send a callback//here.//<strong>we shouldn't be sending callback in scanDocument()</strong>//fTempString would store attribute value///fTempString2 would store attribute non-normalized value//this function doesn't use 'attIndex'. We are adding the attribute later//after we have figured out that current attribute is not namespace declaration//since scanAttributeValue doesn't use attIndex parameter therefore we//can safely add the attribute later..//if the attribute name already exists.. new value is replaced with old value//attributes count will be same if the current attribute  name already exists for this element name.//this means there are two duplicate attributes.//tmpString contains attribute value//we are passing null as the attribute value///xxx: nonNormalizedValue is not being set as it is not required by SAX & DOM//set the fTempString length to 0 before passing it on to scanContent//scanContent sets the correct co-ordinates as per the content read//xxx: We know the next chracter.. we should just skip it and add ']' directlry//fStringBuffer.clear();//fDocumentHandler.characters(content, null);//fDocumentHandler.startCDATA(null);//scanData will fill the contentBuffer/** We dont need all this code if we pass ']]>' as delimeter.. ... *///scan surrogates if any....//by this time we have also read surrogate contents if any...//fDocumentHandler.characters(contentBuffer, null);//fDocumentHandler.endCDATA(null);//end element is scanned in this function so we can send a callback//xxx: How do we deal with this - how to return charReferenceValues//now this is being commented because this is taken care in scanDocument()//fDocumentHandler.characters(fStringBuffer2, null);// handle built-in entities//1. if the entity is external and support to external entities is not required// 2. or entities should not be replaced//3. or if it is built in entity reference.// start general entity//SUPPORT_DTD=false && ReplaceEntityReferences should throw exception//we are starting the entity even if the entity was not declared//if that was the case it its taken care in XMLEntityManager.startEntity()//we immediately call the endEntity. Application gets to know if there was//any entity that was not declared.//set the scaner state to content.. parser will automatically revive itself at any point of time.//return true ;//fDocumentHandler.characters(fTempString, null);//System.out.print(fScannerState);//return the cached name/** int length = fElements.length; ... *///resize QNames//last depth is the depth when last elemnt was pushed//if last depth is greater than current depth//mark this position//decrease the depth by 1 as arrays are 0 based//we found the match and from next element skipping will start, add 1//Once we get match decrease the count -- this was increased by nextElement()//store the last depth//if number of elements becomes equal to the length of array -- stop the skipping//xxx: this is not correct, we are returning the last element//this wont make any difference since flag has been set to 'false'//when position reaches number of elements in the list..//set the position back to mark,  making it a circular linked list.//store the position of last opened tag at particular depth//fInt[++fDepth] = fPosition;//return fElements[fPosition++];//if(DEBUG_SKIP_ALGORITHM){//   System.out.println("Check if the element " + element.rawname + " matches");//  System.out.println("fLastDepth = " + fLastDepth);// System.out.println("fDepth = " + fDepth);//we found the match//store the position for the current depth//when we are adding the elements, when skipping//starts even then this should be tracked ie. when//calling getNext()//from next element skipping will start, add 1//sicne fInt[fDepth] contains pointer to the element array which are 0 based.//xxx: should we do "fCount == fInt.length"//reposition the stack -- it seems to be too complex document and there is no symmerty in structure//boundary checks are done in matchElement()//return the same object that was pushed -- this would avoid//setting the values for every end element.//STRONG: this object is read only -- this object reference shouldn't be stored.//element.setValues(fElements[--fDepth]);//XMLEvent.ENTITY_REFERENCE ); //SCANNER_STATE_REFERENCE//element content is there..//decide the actual sub state of the scanner.For more information refer to the javadoc of//decideSubState.//case: SCANNER_STATE_START_OF_MARKUP//decideSubState() ;//do some special handling if isCoalesce is set to true.//if the last section was character data//if we dont encounter any CDATA or ENITY REFERENCE and current state is also not SCANNER_STATE_CHARACTER_DATA//return the last scanned charactrer data.//if last section was CDATA or ENTITY REFERENCE//xxx: there might be another entity reference or CDATA after this//<foo>blah blah &amp;&lt;<![CDATA[[aa]]>blah blah</foo>//and current state is not SCANNER_STATE_CHARACTER_DATA//or SCANNER_STATE_CDATA or SCANNER_STATE_REFERENCE//this means there is nothing more to be coalesced.//return the CHARACTERS event.//xxx this function returns true when element is empty.. can be linked to end element event.//returns true if the element is empty//if the element is empty the next event is "end element"//set the next possible state//if last section was either entity reference or cdata or character data we should be using buffer//When coalesce is set to true and last state was REFERENCE or CDATA or CHARACTER_DATA, buffer should not be cleared.//clear the buffer//check if we have reached end of element//increase the mark up depth//check if its start of new element//there can be cdata ahead if coalesce is true we should call again//in case last section was either entity reference or cdata or character data -- we should be using buffer//xxx: we should be using only one buffer..// we need not to grow the buffer only when isCoalesce() is not true;//xxx what should be the behavior if entity reference is present in the content ?///xxx since this part is also characters, it should be merged...// special case: surrogates//xxx: scanContent also gives character callback.//we should not be iterating again if fIsCoalesce is not set to true//if (fDocumentHandler != null) {//  fDocumentHandler.characters(fContentBuffer, null);//if fIsCoalesce is true there might be more data so call fDriver.next()//set it back to false.//check the case when there is comment after single element document//<foo/> and some comment after this//It is last element of the document//if element depth is zero , it indicates the end of the document//the state shouldn't be set, because it is set by elementDepthIsZeroHook() function//xxx understand this point once again..//SCANNER_STATE_COMMENT://SCANNER_STATE_PI: {//clear the buffer first//xxx: which buffer should be passed. Ideally we shouldn't have//more than two buffers --//xxx: where should we add the switch for buffering.//SCANNER_STATE_CDATA: {//xxx: What if CDATA is the first event//<foo><![CDATA[hello<><>]]>append</foo>//we should not clear the buffer only when the last state was either SCANNER_STATE_REFERENCE or//SCANNER_STATE_CHARACTER_DATA or SCANNER_STATE_REFERENCE//if we dont need to coalesce clear the buffer//CDATA section is completely read in all the case.//1. if fIsCoalesce is set to true we set the variable fLastSectionWasCData to true//and just call fDispatche.next(). Since we have set the scanner state to//SCANNER_STATE_CONTENT (super state) parser will automatically recover and//behave appropriately. When isCoalesce is set to true we dont need to reportCDATA event//2. Check if application has set for reporting CDATA event//3. if the application has neither set the fIsCoalesce to true nor fReportCdataEvent//return the cdata event as characters.//there might be more data to coalesce.//we should not clear the buffer only when the last state was either CDATA or//fLastSectionWasEntityReference or fLastSectionWasCData are only//used when fIsCoalesce is set to true.//take care of character reference// this function also starts new entity//if there was built-in entity reference & coalesce is not true//return CHARACTERS//if there was a text declaration, call next() it will be taken care.// Skip the entity reference, we don't care//Wether it was character reference, entity reference or built-in entity//set the next possible state to SCANNER_STATE_CONTENT// scan text decl// NOTE: special case where entity starts with a PI// standard text declaration//xxx: this function gives callback// now that we've straightened out the readers, we can read in chunks://xxx: we don't return any state, so how do we get to know about TEXT declarations.//it seems we have to careful when to allow function issue a callback//and when to allow adapter issue a callback.//rest would be taken care by fTrailingMiscDriver set by scanRootElementHook//switch// premature end of file//while loop// NOTE: An end of file is only only an error if we were//       in the middle of scanning some markup. -Ac// endOfFileHook()//If you are reading attributes and you got a callback//cache available attributes.//since fTempString directly matches to the underlying main buffer//store the data into buffer//clear the XMLString so that data can't be added again.// class XMLDocumentFragmentScannerImplimport XMLResourceIdentifierImplimport StaxXMLInputSourcenew XMLDeclDriver(...)new PrologDriver(...)new TrailingMiscDriver(...)new XMLDTDDescription(...)Constants.DOCUMENT_SCANNER_PROPERTYConstants.LOAD_EXTERNAL_DTD_FEATUREConstants.DISALLOW_DOCTYPE_DECL_FEATUREConstants.DTD_SCANNER_PROPERTYConstants.NAMESPACE_CONTEXT_PROPERTY/** Scanner state: XML declaration. */int SCANNER_STATE_PROLOG;/** Scanner state: prolog. */int SCANNER_STATE_TRAILING_MISC;/** Scanner state: trailing misc. */int SCANNER_STATE_DTD_INTERNAL_DECLS;/** Scanner state: DTD internal declarations. */int SCANNER_STATE_DTD_EXTERNAL;/** Scanner state: open DTD external subset. */int SCANNER_STATE_DTD_EXTERNAL_DECLS;/** Scanner state: DTD external declarations. */int SCANNER_STATE_NO_SUCH_ELEMENT_EXCEPTION;/** Scanner state: NO MORE ELEMENTS. */String DOCUMENT_SCANNER;/** Property identifier document scanner: */String LOAD_EXTERNAL_DTD;/** Feature identifier: load external DTD. */String DTD_SCANNER;/** Property identifier: DTD scanner. */// property identifier:  ValidationManagerString NAMESPACE_CONTEXT;/** property identifier:  NamespaceContext */XMLDTDScanner fDTDScanner;/** DTD scanner. */// Data((Boolean)propertyManager.getProperty(XMLInputFactory.IS_NAMESPACE_AWARE)).booleanValue();//xxx: fValidationManager code needs to be added yet!/** Validation manager . */XMLStringBuffer fDTDDecl;boolean fReadingDTD;boolean fAddedListener;String fDoctypeName;/** Doctype name. */String fDoctypePublicId;/** Doctype declaration public identifier. */String fDoctypeSystemId;/** Doctype declaration system identifier. *//** Namespace support. */boolean fLoadExternalDTD;/** Load external DTD. */boolean fSeenDoctypeDecl;/** Seen doctype declaration. */boolean fScanEndElement;Driver fXMLDeclDriver;/** XML declaration driver. *///protected int fScannerLastState ;Driver fPrologDriver;/** Prolog driver. */Driver fDTDDriver;/** DTD driver. */Driver fTrailingMiscDriver;/** Trailing miscellaneous section driver. */int fStartPos;int fEndPos;boolean fSeenInternalSubset;XMLInputSource fExternalSubsetSource;/** External subset source. */XMLDTDDescription fDTDDescription;/** A DTD Description. */...[] DOCTYPE;...[] COMMENTSTRING;startDocumentEntity(...)/** return the state of the scanner */String[] featureIdsfeatureIds.lengthString[] combinedFeatureIdsString[] propertyIdspropertyIds.lengthString[] combinedPropertyIdsgetFeatureDefault(...)getPropertyDefault(...)registerListener(...)Constants.ENTITY_SKIPPED// startEntity(String,identifier,String)(...).ch//getNamespaceContext/** Creates a content driver. */// driver factory methodsnew ContentDriver(...)/** Scans a doctype declaration. */boolean internalSubsetNameType.DOCTYPEgetCurrentResourceIdentifier(...)getExternalSubset(...)/** Set the scanner state after scanning DTD */// scanDoctypeDecl():booleanXMLDocumentScannerImpl.this/** Driver to handle XMLDecl scanning. ... *//** Driver to handle prolog scanning. ... */// class XMLDeclDriver(...).positionscanDoctypeDecl(...)new DTDDriver(...)isCachedDTD(...)setInputSource(...)XMLEvent.DTD/** Driver to handle the internal and external DTD subsets. ... */// class PrologDrivernew DTDGrammarUtil(...)getGrammar(...)XMLResourceIdentifierImpl resourceIdentifiernew XMLResourceIdentifierImpl(...)new XML11DTDScannerImpl(...)new XMLDTDScannerImpl(...)setLimitAnalyzer(...)boolean moreToScanskipDTD(...)boolean completeDTDscanDTDInternalSubset(...)setEndDTDScanState(...)XMLInputSource xmlInputSourceStaxXMLInputSource staxInputSourceresolveEntityAsPerStax(...)hasResolver(...)getXMLInputSource(...)scanDTDExternalSubset(...)/** Driver to handle content scanning. ... */// class DTDDriverXMLInputSource src/** Driver to handle trailing miscellaneous section scanning. ... */// class ContentDriverXMLEvent.END_DOCUMENT// class TrailingMiscDriver//this starts a new entity and sets the current entity to the document entity.//fEntityScanner.registerListener((XMLBufferListener)componentManager.getProperty(DOCUMENT_SCANNER));// setup driver//register current document scanner as a listener for XMLEntityScanner// prepare to look for a TextDecl if external general entity// Don't do this if we're skipping the entity!/** comment this part.. LOCATOR problem.. *///if fMarkupDepth has reached 0.//and driver is fTrailingMiscDriver (which//handles end of document in normal case)//set the scanner state of SCANNER_STATE_TERMINATED//set the scanner set to SCANNER_STATE_TERMINATED//else we have reached the end of document prematurely//so throw EOFException.//this is taken care in wrapper which generates XNI callbacks, There are no next events//fDocumentHandler.endDocument(null);// root element name// Attempt to locate an external subset with an external subset resolver.// NOTE: I don't like calling the doctypeDecl callback until//       end of the *full* doctype line (including internal//       subset) is parsed correctly but SAX2 requires that//       it knows the root element name and public and system//       identifier for the startDTD call. -Ac// is there an internal subset?// next driver is prolog regardless of whether there// is an XMLDecl in this document//System.out.println("fEntityScanner = " + fEntityScanner);//this function should fill the data.. and set the fEvent object to this event.//REVISIT:where else we can set this value to 'true'//return PI event since PI was encountered// standard XML declaration//In both case return the START_DOCUMENT. ony difference is that first block will//cosume the XML declaration if any.//START_OF_THE_DOCUMENT//System.out.println("here in next");/** //this part is handled by FragmentContentHandler ... *///this function fills the data..//setScannerState(SCANNER_STATE_PROLOG);// scanDoctypeDecl() sends XNI doctypeDecl event that// in SAX is converted to startDTD() event.//allow parsing of entity decls to continue in order to stay well-formed//always return DTD event, the event however, will not contain any entities// handle external subset// This handles the case of a DOCTYPE that had neither an internal subset or an external subset.// Send endDTD() call if:// a) systemId is null or if an external subset resolver could not locate an external subset.// b) "load-external-dtd" and validation are false// c) DTD grammar is cached// in XNI this results in 3 events:  doctypeDecl, startDTD, endDTD// in SAX this results in 2 events: startDTD, endDTD/** if (complete) { ... *///xxx  what should be returned here.... ???// throw new XNIException("DTD Parsing is currently not supported");//xxx: remove this hack and align this with reusing DTD components//currently this routine will only be executed from Stax// REVISIT: Should there be a feature for//          the "complete" parameter?// end doctype declaration//simply reset the entity store without having to mess around//with the DTD Scanner code// scan external subset next unless we are ignoring DTDs/** fDTDDescription.setValues(fDoctypePublicId, fDoctypeSystemId, null, null); ... */// Check access permission. If the source is resolved by a resolver, the check is skipped.// skip entity decls// cleanup// dispatch(boolean):boolean//                fEntityScanner.markStartOfDTD();// in case continue-after-fatal-error set, should not do this...// call document handler// This inserts a doctypeDecl event into the stream though no// DOCTYPE existed in the instance document.// resolveExternalSubsetAndRead()//this could for cases like <foo/>//look at scanRootElementHook//we should have reached the end of the document in//most cases.//there can't be any element after SCANNER_STATE_TERMINATED or when the parser//has reached the end of document//xxx what to do when the scanner has reached the terminating state.// NOTE: This is the only place we're allowed to reach//       the real end of the document stream. Unless the//       end of file was reached prematurely.//System.out.println("EOFException thrown") ;// class XMLDocumentScannerImpl/** <p>This interface describes the properties of entities--their ... *//** Sets the name of the entity. ... *//** Returns the name of the entity. ... */// XMLEntityDescription/** The entity handler interface defines methods to report information ... */// interface XMLEntityHandlerimport ASCIIReaderimport UCSReaderimport UTF8Readerimport com.sun.org.apache.xerces.internal.util.*import com.sun.org.apache.xerces.internal.xni.parser.*import HttpURLConnectionimport URISyntaxException/** Will keep track of current entity. ... */new HashMap<String,Entity>(...)new Stack<Entity>(...)new CharacterBufferPool(...)Constants.EXTERNAL_GENERAL_ENTITIES_FEATUREConstants.EXTERNAL_PARAMETER_ENTITIES_FEATUREConstants.BUFFER_SIZE_PROPERTYConstants.PARSER_SETTINGSchar[] escChsescChs.length/** Default buffer size (2048). */int DEFAULT_XMLDECL_BUFFER_SIZE;/** Default buffer size before we've finished with the XMLDecl: */int DEFAULT_INTERNAL_BUFFER_SIZE;/** Default internal entity buffer size (1024). */String VALIDATION;String EXTERNAL_GENERAL_ENTITIES;/** Feature identifier: external general entities. */String EXTERNAL_PARAMETER_ENTITIES;/** Feature identifier: external parameter entities. */String ALLOW_JAVA_ENCODINGS;/** Feature identifier: allow Java encodings. */String WARN_ON_DUPLICATE_ENTITYDEF;/** Feature identifier: warn on duplicate EntityDef */String STAX_ENTITY_RESOLVER;String BUFFER_SIZE;/** property identifier: buffer size. *//** access external dtd: file protocol */String XMLEntity;String DTDEntity;boolean DEBUG_BUFFER;/** Debug printing of buffer. This debugging flag works best when you ... */boolean fWarnDuplicateEntityDef;/** warn on duplicate Entity declaration. ... */boolean DEBUG_ENTITIES;/** Debug some basic entities. */boolean DEBUG_ENCODINGS;/** Debug switching readers for encodings. */boolean DEBUG_RESOLVER;// should be diplayed trace resolving messagesboolean fValidation;/** Validation. This feature identifier is: ... */boolean fExternalGeneralEntities;/** External general entities. This feature identifier is: ... */boolean fExternalParameterEntities;/** External parameter entities. This feature identifier is: ... */boolean fAllowJavaEncodings;/** Allow Java encoding names. This feature identifier is: ... *//** Symbol table. This property identifier is: ... *//** Error reporter. This property identifier is: ... */XMLEntityResolver fEntityResolver;/** Entity resolver. This property identifier is: ... */StaxEntityResolverWrapper fStaxEntityResolver;/** Stax Entity Resolver. This property identifier is XMLInputFactory.ENTITY_RESOLVER */PropertyManager fPropertyManager;/** Property Manager. This is used from Stax *//** StAX properties *//** used to restrict external access *//** Validation manager. This property identifier is: ... */// settingsint fBufferSize;/** Buffer size. We get this value from a property. The default size ... *//** Security Manager */XMLLimitAnalyzer fLimitAnalyzer;int entityExpansionIndex;/** True if the document entity is standalone. This should really ... */boolean fInExternalSubset;// NOTE:  this *is not* the same as whether they're external entities!// are the entities being parsed in the external subset?XMLEntityHandler fEntityHandler;/** Entity handler. */XMLEntityScanner fEntityScanner;/** Current entity scanner */XMLEntityScanner fXML10EntityScanner;/** XML 1.0 entity scanner. */XMLEntityScanner fXML11EntityScanner;/** XML 1.1 entity scanner. */int fEntityExpansionCount;/** count of entities expanded: */Map<String,Entity> fEntities;// entitiesStack<Entity> fEntityStack;Entity.ScannedEntity fCurrentEntity;/** Current entity. */boolean fISCreatedByResolver;/** identify if the InputSource is created by a resolver */XMLEntityStorage fEntityStorage;// shared context...[] defaultEncoding;XMLResourceIdentifierImpl fResourceIdentifier;/** Resource identifer. */// temp varsAugmentations fEntityAugs;/** Augmentations for entities. */CharacterBufferPool fBufferPool;/** Pool of character buffers. *//** If this constructor is used to create the object, reset() should be invoked on this object */new XMLEntityStorage(...)setScannerVersion(...)Constants.XML_VERSION_1_0new XMLEntityScanner(...)/** Adds an internal entity declaration. ... */new InternalEntity(...)Entity.InternalEntityXMLErrorReporter.SEVERITY_WARNING/** Adds an external entity declaration. ... */// addInternalEntity(String,String)new ExternalEntity(...)Entity.ExternalEntitynew XMLEntityDescriptionImpl(...)fCurrentEntity.entityLocationScannedEntity externalEntityexternalEntity.entityLocation/** Adds an unparsed entity declaration. ... */// addExternalEntity(String,String,String,String)ExternalEntity entity/** get the entity storage object from entity manager */// addUnparsedEntity(String,String,String,String)/** return the entity responsible for reading the entity */setCurrentEntity(...)new XML11EntityScanner(...)/** This method uses the passed-in XMLInputSource to make ... */String literalSystemIdboolean encodingExternallySpecifiedBoolean isBigEndiangetCharacterStream(...)getByteStream(...)URL locationURLConnection connectboolean followRedirectsHttpURLConnection urlConnectionHTTPInputSource httpInputSourceIterator<Entry<String,String>> propItergetHTTPRequestProperties(...)setRequestProperty(...)getFollowHTTPRedirects(...)setInstanceFollowRedirects(...)String redirectgetURL(...)new RewindableInputStream(...)byte[] b4Object[] encodingDescgetEncodingName(...)int b0createReader(...)int[] b3int[] b4String utf16Encodingnew ScannedEntity(...)setEncodingExternallySpecified(...)/** Checks whether an entity given by name is external. ... *///setupCurrentEntity(String, XMLInputSource, boolean, boolean):  String/** Checks whether the declaration of an entity given by name is ... *//** Sets whether the document entity is standalone. ... *//** Returns true if the document entity is standalone. */// setStandalone(boolean)//isStandalone():booleanisUnparsed(...)// @return  a reference to the current fResourceIdentifier object// this doesn't returning meaningless or misleading data.// carefully manage the entity manager's behaviour, so that// this should only be used with caution by callers that// this simply returns the fResourceIdentifier object;/** Sets the entity handler. When an entity starts and ends, the ... *///this function returns StaxXMLInputSource// setEntityHandler(XMLEntityHandler)getLiteralSystemId(...)boolean needExpandXMLResourceIdentifierImpl riresolveEntity(...)new StaxXMLInputSource(...)hasXMLStreamOrXMLEventReader(...)/** Resolves the specified public and system identifiers. This ... */setBaseSystemId(...)setExpandedSystemId(...)/** Starts a named entity. ... */// resolveEntity(XMLResourceIdentifier):XMLInputSourcegetEntity(...)ExternalEntity externalEntityString extLitSysIdString extBaseSysIdboolean unparsedboolean parameterboolean generalEntity activeEntityactiveEntity.namefCurrentEntity.nameInternalEntity internalEntityinternalEntity.text/** Starts the document entity. The document entity has the "[xml]" ... */// startEntity(String,boolean)/** Starts the DTD entity. The DTD entity has the "[dtd]" ... *///xxx these methods are not required.// startDocumentEntity(XMLInputSource)// location of entity decls can be tracked// indicate start of external subset so that// startDTDEntity(XMLInputSource)/** Starts an entity. ... */setupCurrentEntity(...)/** Return the current entity being scanned. Current entity is SET using startEntity function. ... */// startEntity(String,XMLInputSource)/** Return the top level entity handled by this manager, or null ... *//** Close all opened InputStreams and Readers opened by this parser. */ScannedEntity entityboolean documentEntity// endEntity()new XMLLimitAnalyzer(...)boolean parser_settingsConstants.JDK_ENTITY_EXPANSION_LIMIT// implementing that interface for whatever reason.// a class acting as a component manager but not// reset general state.  Should not be called other than byInteger bufferSizesetBufferSize(...)setExternalBufferSize(...)this.fLimitAnalyzer/** Expands a system id and returns the system id as a URI, if ... */String gUserDir;// current value of the "user.dir" property// expandSystemId(String):StringURI gUserDirURI;// cached URI object for the current value of the escaped "user.dir" property stored as a URI...[] gNeedEscaping;// which ASCII characters need to be escaped...[] gAfterEscaping1;// the first hex character if a character needs to be escaped...[] gAfterEscaping2;// the second hex character if a character needs to be escaped...[] gHexChs;// which encoding to use. Leave them for now.// REVISIT: don't know how to escape non-ASCII characters, especially// need to be escaped too.// According to the URI spec, non-ASCII characters (whose value >= 128)// that was escaped before.// to change often, so in most cases, we only need to return the URI// this method looks heavy, but since the system property isn't expected// and '"'. It's a static method, so needs to be synchronized.// special ASCII characters: 0x00~0x1F, 0x7F, ' ', '<', '>', '#', '%'// To escape the "user.dir" system property, by using %HH to representString userDirchar separator/** Absolutizes a URI using the current value ... */absolutize(...)getUserDir(...)fixURI(...)URI base// expandSystemId(String,String):StringexpandSystemIdStrictOff(...)expandSystemIdStrictOff1(...)URISyntaxException ex/** Helper method for expandSystemId(String,String,boolean):String */// expandSystemId(String,String,boolean):StringURI systemURIURI baseURI/** Attempt to set whether redirects will be followed for an <code>HttpURLConnection</code>. ... */// expandSystemIdStrictOn(String,String):StringHttpURLConnection.classgetScheme(...)new MalformedURIException(...)// expandSystemIdStrictOff(String,String):StringisAbsolute(...)new URISyntaxException(...)/** Returns the IANA encoding name that is auto-detected from ... *//** Creates a reader capable of reading the given input stream in ... */// getEncodingName(byte[],int):Object[]String ENCODINGboolean validIANAisValidIANAEncoding(...)boolean validJavaisValidJavaEncoding(...)String javaEncodinggetIANA2JavaMapping(...)new UTF8Reader(...)new ASCIIReader(...)boolean isBEnew UCSReader(...)UCSReader.UCS4BEUCSReader.UCS4LEUCSReader.UCS2BEUCSReader.UCS2LE/** Return the public identifier for the current document event. ... */// createReader(InputStream,String, Boolean): Reader/** Return the expanded system identifier for the current document event. ... *//** Return the literal system identifier for the current document event. ... */// getExpandedSystemId():String/** Return the line number where the current document event ends. ... */// getLiteralSystemId():StringScannedEntity firstExternalEntityfirstExternalEntity.lineNumber/** Return the column number where the current document event ends. ... */// getLineNumber():intfirstExternalEntity.columnNumber/** Fixes a platform dependent filename to standard URI form. ... */// Protected static methods// getColumnNumber():intchar ch1char ch0/** Prints the contents of the buffer. */// Package visible methods// fixURI(String):StringXMLEntityManager$CharacterBuffer/** Buffer used in entity manager to reuse character arrays instead ... */...[] ch;/** character buffer */boolean isExternal;/** whether the buffer is for an external or internal scanned entity */this.isExternalXMLEntityManager$CharacterBufferPool/** Stores a number of character buffers and provides it to the entity ... */int DEFAULT_POOL_SIZE;...[] fInternalBufferPool;...[] fExternalBufferPool;int fExternalBufferSize;int fInternalBufferSize;int poolSize;int fInternalTop;int fExternalTop;this.poolSize/** Initializes buffer pool. * */new CharacterBuffer[]/** Retrieves buffer from pool. * */new CharacterBuffer(...)/** Returns buffer to pool. * */buffer.isExternalfExternalBufferPool.lengthfInternalBufferPool.length/** Sets the size of external buffers and dumps the old pool. * */XMLEntityManager$RewindableInputStream/** This class wraps the byte inputstreams we're presented with. ... */InputStream fInputStream;...[] fData;int fOffset;fData.lengthint bytesLeftint returnedValfCurrentEntity.mayReadChunksfCurrentEntity.xmlDeclChunkReadEntity.ScannedEntity.DEFAULT_XMLDECL_BUFFER_SIZE// end of RewindableInputStream class//for entity managers not created by parsers//pass a reference to current entity being scanned//fEntityStorage = new XMLEntityStorage(fCurrentEntity) ;// search for the first external entity on the stack// default to 1.0// get information// create reader// First chance checking strict URI// setup URLConnection if we have an HTTPInputSource// set request properties// set preference for redirection// REVISIT: If the URLConnection has external encoding// information, we should be reading it here. It's located// in the charset parameter of Content-Type. -- mrglavas// E43: Check if the URL was redirected, and then// update literal and expanded system IDs if needed.// wrap this stream in RewindableInputStream// perform auto-detect of encoding if necessary// read first four bytes and determine encoding// Special case UTF-8 files with BOM created by Microsoft// tools. It's more efficient to consume the BOM than make// the reader perform extra checks. -Ac// ignore first three bytes...// use specified encoding// If encoding is UTF-8, consume BOM if one is present.// First three bytes are not BOM, so reset.// If encoding is UTF-16, we still need to read the first four bytes// in order to discover the byte order.// UTF-16, big-endian// UTF-16, little-endian// UTF-16, big-endian, no BOM// UTF-16, little-endian, no BOM// If encoding is UCS-4, we still need to read the first four bytes// Ignore unusual octet order for now.// UCS-4, big endian (1234)// UCS-4, little endian (1234)// If encoding is UCS-2, we still need to read the first four bytes// UCS-2, big endian// UCS-2, little endian// read one character at a time so we don't jump too far// ahead, converting characters from the byte stream in// the wrong encoding//reader = new OneCharReader(reader);// We've seen a new Reader.// Push it on the stack so we can close it later.//fOwnReaders.add(reader);// push entity on stack// create entity/* if encoding is specified externally, 'encoding' information present ... */// if no base systemId given, assume that it's relative// to the systemId of the current scanned entity// Sometimes the system id is not (properly) expanded.// We need to expand the system id if:// a. the expanded one was null; or// b. the base system id was null, but becomes non-null from the current entity.// REVISIT:  why would the baseSystemId ever be null?  if we// didn't have to make this check we wouldn't have to reuse the// fXMLResourceIdentifier object...// give the entity resolver a chance//either of Stax or Xerces would be null//wrap this XMLInputSource to StaxInputSource// do default resolution//this works for both stax & Xerces, if staxInputSource is null, it means parser need to revert to default resolution// REVISIT: when systemId is null, I think we should return null.//          is this the right solution? -SG//if (systemId != null)//Waiting for the clarification from EG. - nb// REVISIT: what's the correct behavior if the user provided an entity// resolver (fEntityResolver != null), but resolveEntity doesn't return// an input source (xmlInputSource == null)?// do we do default resolution, or do we just return null? -SG// was entity declared?// should we skip external entities?// is entity recursive?// resolve external entity/** xxx:  Waiting from the EG ... *///let the not-LoadExternalDTD or not-SupportDTD process to handle the situation// wrap internal entity// start the entity//when entity expansion limit is set by the Application, we need to//check for the entity expansion limit set by the parser, if number of entity//expansions exceeds the entity expansion limit, parser will throw fatal error.// Note that this represents the nesting level of open entities.// is there anything better to do than reset the counter?// at least one can envision debugging applications where this might// be useful.../** this call actually does nothing, readers are closed in the endEntity method ... *///pop the entity from the stack/** need to close the reader first since the program can end ... *///close the reader//so this is the last opened entity, signal it to current fEntityHandler using Augmentation//check if it is a document entity//set popped entity as current entity//check if there are any entity left in the stack -- if there are//no entries EOF has been reached.// throw exception when it is the last entity but it is not a document entity// Zephyr feature ignore-external-dtd is the opposite of Xerces' load-external-dtd// JAXP 1.5 feature//reset fEntityStorage//reset XMLEntityReaderImpl// initialize state//fStandalone = false;// parser settings have not been changed//StAX Property//reset general state// reset scanner// should never happen//if(fEntityScanner!=null)//  fEntityScanner.reset(fSymbolTable, this,fErrorReporter);// initialize the above 3 arrays// get the user.dir property// return empty string if property value is empty string.// compute the new escaped value if the new property value doesn't// match the previous one// record the new value as the global property value// change C:/blah to /C:/blah// for each character in the path// if it's not an ASCII character, break here, and use UTF-8 encoding// record the fact that it's escaped// we saw some non-ascii character// get UTF-8 bytes for the remaining sub-string// for each byte// for non-ascii character: make it positive, then escape// change blah/blah to blah/blah/// check for bad parameters id// if id already expanded, return// continue on...// normalize id// normalize base// for xml schemas we might have baseURI with// a specified drive// expand id// let it go through// check if there is a system id before// trying to expand it.// system id has to be a valid URI// if it's already an absolute one, return it// if there isn't a base uri, use the working directory// otherwise, use the base uri// assume "base" is also a relative uri// absolutize the system id using the base// return the string rep of the new uri (an absolute one)// if any exception is thrown, it'll get thrown to the caller.// Assume the URIs are well-formed. If it turns out they're not, try fixing them up./** Xerces URI rejects unicode, try java.net.URI ... */// If it's already an absolute one, return it// If there isn't a base URI, use the working directory// absolutize the system identifier using the base URI// setInstanceFollowRedirects doesn't exist./** If the scheme's length is only one character, ... *///        systemURI.absolutize(baseURI);// UTF-16, with BOM// default to UTF-8 if we don't have enough bytes to make a// good determination of the encoding// UTF-8 with a BOM// other encodings// UCS-4, little endian (4321)// UCS-4, unusual octet order (2143)// REVISIT: What should this be?// UCS-4, unusual octect order (3412)// (or could turn out to be UCS-2...// EBCDIC// a la xerces1, return CP037 instead of EBCDIC here// normalize encoding name// try to use an optimized reader// sould never happen with this encoding...// check for valid name// NOTE: AndyH suggested that, on failure, we use ISO Latin 1//       because every byte is a valid ISO Latin 1 character.//       It may not translate correctly but if we failed on//       the encoding anyway, then we're expecting the content//       of the document to be bad. This will just prevent an//       invalid UTF-8 sequence to be detected. This is only//       important when continue-after-fatal-error is turned//       on. -Ac// try to use a Java reader// see comment above.// handle platform dependent strings// Windows fix// change "C:blah" to "/C:blah"// change "//blah" to "file://blah"// replace spaces in file names with %20.// Original comment from JDK5: the following algorithm might not be// very performant, but people who want to use invalid URI's have to// pay the price.// put characters before ' ' into the string builder// and %20 for the space// for the remamining part, also convert ' ' to "%20"./** //System.out.println("fCurrentEntitty = " + fCurrentEntity ); ... *//* In a manner of speaking, when this class isn't permitting more ... *///test();//System.out.println("TESTING: Added familytree to entityManager");//Usecase1//Usecase2// class XMLEntityManagerimport EncodingMapimport com.sun.org.apache.xerces.internal.xni.*import ScannedEntity/** Implements the entity scanner methods. ... */XMLEntityManager.DEFAULT_BUFFER_SIZEnew ArrayList<XMLBufferListener>(...)new EOFException(...) { ... }XMLEntityScanner$1XMLEntityManager fEntityManager;/** Security manager. *//** Limit analyzer. */ArrayList<XMLBufferListener> listeners;/** Listeners which should know when load is being called */...[] VALID_NAMES;boolean DEBUG_SKIP_STRING;EOFException END_OF_DOCUMENT_ENTITY;/** To signal the end of the document entity, this exception will be thrown. */...[] whiteSpaceLookup;int whiteSpaceLen;boolean whiteSpaceInfoNeeded;//for appending data.//Will be used only during internal subsets.boolean xmlVersionSetExplicitly;// so that XMLStreamReader.getVersion() can find that out.// Remember, that the XML version has explicitly been set,boolean detectingVersion;// indicates that the operation is for detecting XML version/** private constructor, this class can only be instantiated within this class. Instance of this class should ... */// set buffer size:/** Resets the components. *//** Returns the XML version of the current entity. This will normally be the ... */fCurrentEntity.xmlVersion/** Sets the XML version. This method is used by the ... */// getXMLVersion():String/** set the instance of current scanned entity. ... */// setXMLVersion(String)scannedEntity.name/** Returns the base system identifier of the currently scanned ... */// XMLEntityReader methods// getBaseSystemId():String///////////// Locator methods start.fCurrentEntity.fTotalCountTillLastLoad/** Returns the expanded system identifier. *//** Returns the literal system identifier. *//** Returns the public identifier. *//** the version of the current entity being scanned *////////////////// Locator methods finished.fCurrentEntity.version/** Returns the encoding of the current entity. ... */fCurrentEntity.encoding/** Sets the encoding of the scanner. This method is used by the ... */// getEncoding():StringfCurrentEntity.streamfCurrentEntity.reader/** Returns true if the current entity being scanned is external. */// setEncoding(String)// isExternal():booleanarrangeCapacity(...)//getChar()boolean vcfCurrentEntity.fBufferSize/** Checks whether the end of the entity buffer has been reached. If yes, ... */entity.countentity.positionint nameLengthentity.ch.lengthentity.chentity.fBufferSize/** If the current entity is an Entity reference, check the accumulated size ... */entity.isGELimit.GENERAL_ENTITY_SIZE_LIMIT/** If the current entity is an Entity reference, counts the total nodes in ... */Limit.ENTITY_REPLACEMENT_LIMIT/** Checks whether the value of the specified Limit exceeds its limit ... */entity.nameObject[] ekey(...)Limit.TOTAL_ENTITY_SIZE_LIMIT/** CHANGED: ... */isContent(...)storeWhiteSpace(...)/** Save whitespace information. Increase the whitespace buffer by 100 ... */whiteSpaceLookup.length/** Scans a range of character data up to the specified delimiter, ... */// scanData(String, XMLStringBuffer)int afterSkip/** Loads a chunk of text. ... */// Locator methodsfCurrentEntity.fLastCountXMLEntityManager.DEFAULT_XMLDECL_BUFFER_SIZE// load(int, boolean):boolean/** xxx not removing endEntity() so that i remember that we need to implement it. ... *//** Registers the listener object and provides callback. ... *//** Skips space characters appearing immediately on the input that would ... */// REVISIT: Buffer size passed to entity scanner// was not being kept in synch with the actual size// of the buffers in each scanned entity. If any// of the buffers were actually resized, it was possible// that the parser would throw an ArrayIndexOutOfBoundsException// for documents which contained names which are longer than// the current buffer size. Conceivably the buffer size passed// to entity scanner could be used to determine a minimum size// for resizing, if doubling its size is smaller than this// minimum. -- mrglavas//xerces properties//if the entity is closed, we should return -1//xxx at first place why such call should be there...// if the encoding is the same, don't change the reader and// re-use the original reader used by the OneCharReader// NOTE: Besides saving an object, this overcomes deficiencies//       in the UTF-16 reader supplied with the standard Java//       distribution (up to and including 1.3). The UTF-16//       decoder buffers 8K blocks even when only asked to read//       a single char! -Ac// UTF-16 is a bit of a special case.  If the encoding is UTF-16,// and we know the endian-ness, we shouldn't change readers.// If it's ISO-10646-UCS-(2|4), then we'll have to deduce// the endian-ness from the encoding we presently have.// wrap a new reader around the input stream, changing// the encoding//fCurrentEntity.stream.reset();//while (XMLChar.isName(fCurrentEntity.ch[fCurrentEntity.position])) {//XMLChar.isName(fCurrentEntity.ch[fCurrentEntity.position])) ;//making a check if if the specified character is a valid name start character//as defined by production [5] in the XML 1.0 specification.// Name ::= (Letter | '_' | ':') (NameChar)*//adding into symbol table.//XXX We are trying to add single character in SymbolTable??????// no qualified name found//check limit before loading more data//CHANGED: dont replace the value.. append to the buffer. This gives control to the callee//on buffering the data..//content.append(fCurrentEntity.ch, offset, length);/** * NEWLINE NORMALIZATION *** ... */// something must be wrong with the input:  e.g., file ends in an unterminated comment//boolean entityChanged = false;//check if the capacity is availble in the current buffer//count is no. of characters in the buffer   [x][m][l]//position is '0' based//System.out.println("fCurrent Entity " + fCurrentEntity);//load more characters -- this function shouldn't change the entity//load changes the position.. set it back to the point where we started.//after loading check again.//first make sure that required capacity is avaible//s.charAt() indexes are 0 to 'Length -1' based.//check from reverse//maintaing the count till last load// read characters// reset count and position// record the last count// end of this entity//notify the entity manager about the end of entity//return if the current entity becomes null// handle the trailing edges// default encoding//XMLEntityManager.print(fCurrentEntity);//  XMLEntityManager.print(fCurrentEntity);// skipDeclSpaces():boolean// class XMLEntityScannerimport ErrorHandlerProxy/** This class is a common element of all parser configurations and is ... */Constants.CONTINUE_AFTER_FATAL_ERROR_FEATUREshort SEVERITY_WARNING;/** Severity: warning. Warnings represent informational messages only ... */// severityshort SEVERITY_ERROR;/** Severity: error. Common causes of errors are document structure and/or ... */short SEVERITY_FATAL_ERROR;/** Severity: fatal error. Fatal errors are errors in the syntax of the ... */String CONTINUE_AFTER_FATAL_ERROR;/** Feature identifier: continue after fatal error. *//** The locale to be used to format error messages. */Map<String,MessageFormatter> fMessageFormatters;/** Mapping of Message formatters for domains. */XMLErrorHandler fErrorHandler;/** Error handler. */XMLLocator fLocator;/** Document locator. */boolean fContinueAfterFatalError;/** Continue after fatal error feature. */XMLErrorHandler fDefaultErrorHandler;/** Default error handler. This error handler is only used in the ... */ErrorHandler fSaxProxy;/** A SAX proxy to the error handler contained in this error reporter. *//** Constructs an error reporter with a locator. */new HashMap<String,MessageFormatter>(...)/** Sets the current locale. ... */// Methods/** Gets the current locale. ... *//** Sets the document locator. ... */// getLocale():  Locale/** Registers a message formatter for the specified domain. ... */// setDocumentLocator(XMLLocator)/** Returns the message formatter associated with the specified domain, ... */// putMessageFormatter(String,MessageFormatter)/** Removes the message formatter for the specified domain and ... */// getMessageFormatter(String):MessageFormatter/** Reports an error. The error message passed to the error handler ... */// removeMessageFormatter(String):MessageFormatter// reportError(String,String,Object[],short):String/** Reports an error at a specific location. ... */// reportError(String,String,Object[],short,Exception):String// reportError(XMLLocator,String,String,Object[],short):StringMessageFormatter messageFormatterXMLParseException parseExceptionnew XMLParseException(...)XMLErrorHandler errorHandlerint argCount// reportError(XMLLocator,String,String,Object[],short,Exception):String// return state of given feature or false if unsupported./** Get the internal XMLErrrorHandler. *//** Gets the internal XMLErrorHandler ... */new ErrorHandlerProxy(...) { ... }XMLErrorReporter$1// REVISIT: [Q] Should the locator be passed to the reportError//              method? Otherwise, there is no way for a parser//              component to store information about where an//              error occurred so as to report it later.//              An example would be to record the location of//              IDREFs so that, at the end of the document, if//              there is no associated ID declared, the error//              could report the location information of the//              reference. -Ac// NOTE: I added another reportError method that allows the//       caller to specify the location of the error being//       reported. -Ac// REVISIT: [Q] Should we do anything about invalid severity//              parameter? -Ac// format error message and create parse exception// get error handler// call error handler// Xerces features// http://apache.org/xml/features/continue-after-fatal-error//   Allows the parser to continue after a fatal error.//   Normally, a fatal error would stop the parse.// class XMLErrorReporter/** This class adds the functionality of namespace processing. ... */boolean fNotAddNSDeclAsAttribute;/** Default value of this feature is false, when in Stax mode this should be true */boolean fXmlnsDeclared;/** xmlns, default Namespace, declared *//** Resets the fields of this scanner. */tmpStr.chtmpStr.offsettmpStr.lengthboolean declaredcontainsPrefixInCurrentContext(...)new NSContentDriver(...)XMLNSDocumentScannerImpl$NSContentDriver// skipQElement(name);// There are two variables,fNamespaces and fBindNamespaces//StAX uses XMLNSDocumentScannerImpl so this distinction needs to be maintained// fLength = 0; //initialize structure// checkDuplicates(fAttributeQName, fAttributes);//if (fBindNamespaces) {// REVISIT: it seems that this function should not take attributes, and length//fTempString.toString();//check the length of URI//set it equal to XMLSymbols.PREFIX_XMLNS when namespace declaration// is of type xmlns = "..", in this case prefix = "" and localname = XMLSymbols.PREFIX_XMLNS//this special behavior is because of dependency on this behavior in DOM components// http://www.w3.org/TR/1999/REC-xml-names-19990114/#dt-prefix// We should only report an error if there is a prefix,// that is, the local part is not "xmlns". -SG// check for duplicate prefix bindings// declare prefix in context// check for duplicate xmlns declarations// by convention, prefix == "xmlns" | "xml"// error if duplicate declaration// xmlns declared//xerces internals (XSAttributeChecker) has dependency on namespace declaration returned//as part of XMLAttributes.//addition of namespace declaration to the attribute list is controlled by fNotAddNSDeclAsAttribute//feature. This is required in Stax where namespace declarations are not considered as attribute//add the attributes to the list of attributes//attributes.setNonNormalizedValue(attrIndex, fTempString2.toString());//removing  as we are not using non-normalized values . -Venu//fDTDValidator will be null in Stax mode// re-configure pipeline by removing DTDValidator// class XMLNSDocumentScannerImplString NAMESPACES;boolean fNamespaces;/** Namespaces. *//** Error reporter. */XMLDocumentSource fDocumentSource;boolean fOnlyPassPrefixMappingEvents;/** Only pass start and end prefix mapping events. *//** Namespace context. *//** Sets whether the namespace binder only passes the prefix mapping ... *//** Returns true if the namespace binder only passes the prefix mapping ... */// setOnlyPassPrefixMappingEvents(boolean)// getOnlyPassPrefixMappingEvents():boolean/** Sets the value of a property during parsing. ... *//** Sets the document handler to receive information about the document. *//** Sets the document source *//** Returns the document source */// setDocumentSource// getDocumentSource// startEntity(String,String,String,String,String)// textDecl(String,String)// startDocument(XMLLocator,String)// xmlDecl(String,String,String)// doctypeDecl(String,String,String)// comment(XMLString)/** Binds the namespaces. This method will handle calling the ... */// processingInstruction(String,XMLString)// startElement(QName,XMLAttributes)// emptyElement(QName,XMLAttributes)// characters(XMLString)// ignorableWhitespace(XMLString)// endElement(QName)// startCDATA()// endCDATA()// endDocument()/** Handles start element. */element.prefixprefixBoundToNullURI(...)element.uriString arawnameString auriString alocalpartString blocalpartString buri/** Handles end element. */// handleStartElement(QName,XMLAttributes,boolean)String eprefix// handleEndElement(QName,boolean)// add new namespace context// search for new namespace bindings// when it's of form xmlns="..." or xmlns:prefix="...",// it's a namespace declaration. but prefix:xmlns="..." isn't.// Since this is an error condition in XML 1.0,// and should be relatively uncommon in XML 1.1,// making this test into a method call to reuse code// should be acceptable.  - NG// bind the attributes// verify that duplicate attributes don't exist// Example: <foo xmlns:a='NS' xmlns:b='NS' a:attr='v1' b:attr='v2'/>// bind element// call handlers// class XMLNamespaceBinderimport Status/** This class is responsible for holding scanning methods common to ... *///import com.sun.org.apache.xerces.internal.impl.XMLErrorReporter;//import com.sun.xml.stream.XMLEntityManager;new ArrayList<XMLString>(...)new ArrayList<XMLStringBuffer>(...)Constants.NOTIFY_CHAR_REFS_FEATUREString NOTIFY_CHAR_REFS;/** Feature identifier: notify character references. */boolean DEBUG_ATTR_NORMALIZATION;/** Debug attribute normalization. */XMLScanner$NameType/** Type of names */new NameType(...)NameType ATTRIBUTE;NameType ATTRIBUTENAME;NameType COMMENT;NameType DOCTYPE;NameType ELEMENTSTART;NameType ELEMENTEND;NameType ENTITY;NameType NOTATION;NameType PI;NameType REFERENCE;boolean fNeedNonNormalizedValue;//we should have a feature when set to true computes this value//xxx: setting the default value as false, as we dont need to calculate this valueArrayList<XMLString> attributeValueCache;ArrayList<XMLStringBuffer> stringBufferCache;int fStringBufferIndex;boolean fAttributeCacheInitDone;int fAttributeCacheUsedCount;boolean fNotifyCharRefs;/** Character references notification. */boolean fParserSettings;/** Internal parser-settings feature *///protected XMLEntityManager fEntityManager = PropertyManager.getEntityManager();/** Entity manager. *//** xxx this should be available from EntityManager Entity storage */XMLEvent fEvent;/** event type *//** Entity scanner, this always works on last entity that was opened. */int fEntityDepth;/** Entity depth. */String fCharRefLiteral;/** Literal value of the last character reference scanned. */boolean fScanningAttribute;/** Scanning attribute. */boolean fReportEntity;/** Report entity boundary. */String fVersionSymbol;/** Symbol: "version". */// symbolsString fEncodingSymbol;/** Symbol: "encoding". */String fStandaloneSymbol;/** Symbol: "standalone". */String fAmpSymbol;/** Symbol: "amp". */String fLtSymbol;/** Symbol: "lt". */String fGtSymbol;/** Symbol: "gt". */String fQuotSymbol;/** Symbol: "quot". */String fAposSymbol;/** Symbol: "apos". *///       possibility.//       cause of the bug. By making these private, we avoid this//       modified the values, it would be difficult to track down the real//       of values by a subclass. If there were protected *and* the sub-// NOTE: These objects are private to help prevent accidental modification// temporary location for Resource identification information.int initialCacheCount;/* Sets the feature of the scanner. *//* Gets the state of the feature of the scanner. */new XMLConfigurationException(...)Status.NOT_RECOGNIZED// anybody calling this had better have set Symtoltable!// common scanning methodsint STATE_VERSIONint STATE_ENCODINGint STATE_STANDALONEint STATE_DONEboolean dataFoundForTargetScannedEntity currEntboolean currLiteralcurrEnt.literalscanPseudoAttribute(...)versionSupported(...)ScannedEntity topgetTopLevelEntity(...)top.versionConstants.XML_VERSION_1_1/** Scans a pseudo attribute. ... */scanPseudoAttributeName(...)/** Scans the name of a pseudo attribute. The only legal names ... */// scanPseudoAttribute(XMLString):String// as that for scanContent()//it makes things more easy if XMLStringBUffer is passed. Motivation for this change is same//NOW: scanPI(XMLStringBuffer)//EARLIER: scanPI()/** Scans a processing instruction. ... */// scanPseudoAttributeName()NameType.PI//be appended to that buffer//Now: Changed the signature of this function to pass XMLStringBuffer.. and data would//the supplied XMLString....//Earlier:This method uses the fStringBuffer and later buffer values are set to// scanPI(XMLStringBuffer)// scanPIData(String,XMLString)XMLStringBuffer stringBufferfEntityScanner.whiteSpaceLengetStringBuffer(...)/** Resolves character entity references. ... *//** Scans External ID and return the public and system IDs. ... */scanPubidLiteral(...)XMLString identisMarkup(...)int[] bufffEntityScanner.whiteSpaceLookupint buffLen/** This method notifies of the start of an entity. The document entity ... *//** This method notifies the end of an entity. The document entity has ... *//** Scans a character reference and append the corresponding chars to the ... */int initLenboolean hexboolean digitStringBuffer errorBuffStringBuffer3.lengthfStringBuffer3.chfStringBuffer3.offsethighSurrogate(...)lowSurrogate(...)String literalfEntityScanner.fCurrentEntity.isGE/** Scans surrogates and append them to the specified buffer. ... */// version Supported/** Convenience function used in all XML scanners. */// scanSurrogates():booleanXMLStringBuffer tmpObj/** Add the count of the content buffer and check if the accumulated ... *//** Add the count and check limit ... *///this step is extra because we have separated the storage of entity/* else if(propertyId.equals(Constants.STAX_PROPERTIES)){ ... */// DTD preparsing defaults://fEntityManager.reset();// scan pseudo-attributes// since pseudoattributes are *not* attributes,// their quotes don't need to be preserved in external parameter entities.// the XMLEntityScanner#scanLiteral method will continue to// emit -1 in such cases when it finds a quote; this is// fine for other methods that parse scanned entities,// but not for the scanning of pseudoattributes.  So,// temporarily, we must mark the current entity as not being "literal"// TODO: check encoding name; set encoding on//       entity scanner// restore original literal value// REVISIT: should we remove this error reporting?// If there is no data in the xml or text decl then we fail to report error// for version or encoding info above.// fill in return array// XMLEntityManager.print(fEntityManager.getCurrentEntity());// target// scan data// check target// we found the end, there is no data just return// if there is data there should be some space// since scanData appends the parsed data to the buffer passed// a while loop would append the whole of parsed data to the buffer(data:XMLStringBuffer)//until all of the data is buffered.//System.out.println( "XMLScanner#scanComment# In Scan Comment" );// text// REVISIT: handle invalid character, eof//System.out.println( "XMLScanner#scanComment#text.toString() == " + text.toString() );//System.out.println( "XMLScanner#scanComment#c == " + c );//Todo ::Move this check  to Attributes , do conversion//only if attribute is being accessed. -Venu/** entityNames (symbols) are interned. The equals method would do the same, ... */// looks like we don't have any system id// simply return the public id// store result in array// keep track of the entity depth// must reset entity scanner// scan hexadecimal value// scan decimal value// convert string to number// character reference must be a valid XML character// Conversion failed, let -1 value drop through.// If we end up here, the character reference was invalid.// append corresponding chars to the given buffer// character is supplemental, split it into surrogate chars// char refs notification code// convert surrogates to supplemental character// supplemental character must be a valid XML character// fill in the buffer// initialize scanner// class XMLScannerimport StreamFilterStreamFilter fStreamFilter;XMLStreamReader fStreamReader;int fCurrentEvent;boolean fEventAccepted;boolean fStreamAdvancedByHasNext;/** the very issue around a long discussion. but since we must pass the TCK, we have to allow ... *//** Creates a new instance of XMLStreamFilterImpl */this.fStreamFilterfindNextEvent(...)XMLStreamException xs/** @throws ... */findNextTag(...)/** @throws */getElementText(...)getTextStart(...)hasName(...)hasText(...)isCharacters(...)isEndElement(...)isStandalone(...)require(...)standaloneSet(...)//this is debatable to initiate at an acceptable event,//but it's neccessary in order to pass the TCK and yet avoid skipping element//although it seems that IllegalStateException should be thrown when next() is called//on a stream that has no more items, we have to assume END_DOCUMENT is always accepted//in order to pass the TCKimport NamespaceContextWrapperimport StaxErrorReporterimport XMLNotationDeclimport EntityDeclarationImplimport NotationDeclarationImpl/** This class implements javax.xml.stream.XMLStreamReader. It makes use of XML*Scanner classes to ... */new XMLNSDocumentScannerImpl(...)new NamespaceContextWrapper(...)new StaxErrorReporter(...)/** Property identifier: Error Reporter. *//** Property identifier: Symbol table. */XMLDocumentScannerImpl fScanner;/** Document scanner. */NamespaceContextWrapper fNamespaceContextWrapper;//as per the state of the parser.//make Global NamespaceContextWrapper object,  fScanner.getNamespaceContext() is dynamic object and ita value changesStaxErrorReporter fErrorReporter;/** Entity scanner, this alwasy works on last entity that was opened. */XMLInputSource fInputSource;/** Input Source *//** Store properties */int fEventType;/** current event type *//** debug flag */boolean fReuse;/** more to scan */boolean fReaderInDefinedState;String fDTDDecl;String versionStr;XMLInputSource inputSourceswitchToXML11Scanner(...)XNIException ex//setInputSource/** This function tells if this instances is available for reuse. ... */getEventTypeString(...)/** Resets this instance so that this instance is ready for reuse. *//** Frees any resources associated with this Reader. This method does not close the underlying input source. ... *//** Returns the character encoding declared on the xml declaration Returns null if none was declared ... *//** Return input encoding if known or null if unknown. ... *///getColumnNumber/** Returns the current value of the parse event as a string, this returns the string value of a CHARACTERS event, returns the value of a COMMENT, the replacement value for an ENTITY_REFERENCE, the string value of a CDATA section, the string value for a SPACE event, or the String value of the internal subset of the DTD. If an ENTITY_REFERENCE has been resolved, any character data will be reported as CHARACTERS events. ... *///getEncoding//getEventType//getLineNumbergetElementQName(...).localpartgetElementQName(...)getEntityName(...)//getLocalName()getElementQName(...).uri/** Get the data section of a processing instruction ... *///getNamespaceURI/** Get the target of a processing instruction ... *///getPIData//getPITargetgetElementQName(...).prefixXMLConstants.DEFAULT_NS_PREFIX//getPrefix()getCharacterData(...).chgetCharacterData(...).lengthgetCharacterData(...).offset/** Get the XML language version of the current document being parsed *///getValue()fEntityScanner.xmlVersionSetExplicitlygetAttributeIterator(...)/** this Funtion returns true if the current event has name *///hasName()isStandAlone(...)/** Returns true if the cursor points to a character data event that consists of all whitespace ... */fScanner.fScannerStatefScanner.SCANNER_STATE_DTD_EXTERNALBoolean isValidatingfScanner.SCANNER_STATE_PROLOGfScanner.fPrologDriver//next()int oldEntityDepthfScanner.fEntityDepthNamespaceContext oldNamespaceContextfScanner.fNamespaceContextnew XML11NSDocumentScannerImpl(...)XMLEvent.ATTRIBUTE/** Returns the count of attributes on this START_ELEMENT, ... *//** Returns the localName of the attribute at the provided ... *///getAttributeCountconvertXNIQNametoJavaxQName(...)getQualifiedName(...)//getAttributeName/** Returns the namespace of the attribute at the provided ... *//** Returns the prefix of this attribute at the ... *///getAttributeNamespace/** Returns the qname of the attribute at the provided index ... *///getAttributePrefix/** Returns the XML type of the attribute at the provided ... *///getAttributeQName/** Returns the value of the attribute at the ... *///getAttributeType//getAttributeValueXMLAttributesImpl attributesgetIndexByLocalName(...)/** Reads the content of a text-only element. Precondition: ... */StringBuffer content/** Return the current location of the processor. ... */new Location(...) { ... }XMLStreamReaderImpl$1String _publicId;int _offset;int _columnNumber;StringBuffer sbuffergetLocationURI(...)/** Returns a QName for the current START_ELEMENT or END_ELEMENT event ... *//** Returns a read only namespace context for the current ... *//** Returns the count of namespaces declared on this START_ELEMENT or END_ELEMENT, ... */XMLEvent.NAMESPACEgetDeclaredPrefixCount(...)/** Returns the prefix for the namespace declared at the ... */getDeclaredPrefixAt(...)/** Returns the uri for the namespace declared at the ... *//** Get the value of a feature/property from the underlying implementation ... */fPropertyManager.STAX_NOTATIONSgetNotationDecls(...)fPropertyManager.STAX_ENTITIESgetEntityDecls(...)/** Returns the current value of the parse event as a string, ... */XMLEntityStorage entityStoreEntity enfScanner.foundBuiltInRefs(...).entityLocation(...).textXMLStringBuffer tmpBuffergetDTDDecl(...)/** Test if the current event is of the given type and if the namespace and name match the current namespace and name of the current event. ... *///getText/** Gets the the text associated with a CHARACTERS, SPACE or CDATA event. ... */int copiedLengthint availabletarget.length/** Return true if the current event has text, false otherwise ... */pr(...)fScanner.fSeenDoctypeDecl/** Returns a boolean which indicates if this ... *//** Returns true if the cursor points to a character data event ... *//** Skips any insignificant events (COMMENT and PROCESSING_INSTRUCTION) ... *//** Checks if standalone was set in the document ... *//** Return the uri for the given prefix. ... *///xxx: this function is not being used.hasEntities(...)EntityDeclarationImpl declEnumeration<> enugetEntityKeys(...)getEntitySize(...)new EntityDeclarationImpl(...)setEntityName(...)setXMLResourceIdentifier(...)(...).notationsetEntityReplacementText(...)DTDGrammar grammarfScanner.fDTDScannerList<> notationsIterator<> itXMLNotationDecl ninew NotationDeclarationImpl(...)/* Copyright (c) 2005, 2017, Oracle and/or its affiliates. All rights reserved. ... *///publicId, systemid, baseSystemId, inputStream, enocding//pass the input source to document scanner impl.//xxx: Using buffered reader//once setInputSource() is called this instance is busy parsing the inputsource supplied//this instances is free for reuse if parser has reached END_DOCUMENT state or application has//called close()//XMLStreamReader should be in defined state//Issue 56 XNIException not caught//set Stax internal properties -- Note that these instances are being created in XMLReaderImpl.//1.SymbolTable//2.XMLMessageFormatter//3.XMLEntityManager//4. call reset()//1.//2.//3.//4.//when parsing begins, fReuse is set to false//fReuse is set to 'true' when application calls close()//reset entity manager//reset the scanner//REVISIT:this is too ugly -- we are getting XMLEntityManager and XMLEntityReader from//property manager, it should be only XMLEntityManager//default value for this property is true. However, this should be false when using XMLEventReader... Ugh..//because XMLEventReader should not have defined state.//xxx: Check what this function is intended to do.//reset();//xxx check whats the value of fCurrentElement//doesn't take care of Attribute as separte event//apply SAP's patch: the default version in the scanner was set to 1.0 because of DOM and SAX//so this patch is a workaround of the difference between StAX and DOM// SAPJVM: Return null if the XML version has not been declared (as specified in the JavaDoc).//the scanner returns -1 when it detects a broken stream//we can check in scanners if the scanner state is not set to//terminating, we still have more events.// if this error occured trying to resolve the external DTD subset// and IS_VALIDATING == false, then this is not an XML error// ignore the error, set scanner to known state// else real error//get the new scanner state to old scanner's previous state//xxx: recognize SAX properties namespace, namespace-prefix to get XML Namespace declarations//does length includes namespace declarations ?//State should be either START_ELEMENT or ATTRIBUTE// create new object at runtime..//sjsxp issue 70//namespaceContext is dynamic object.//REVISIT: check if it specifies all conditions mentioned in the javadoc//this requires creation of new string//fEventType == XMLEvent.ENTITY_REFERENCE//getTextStart() + sourceStart should not be greater than the lenght of number of characters//present//int presentDataLen = getTextLength() - (getTextStart()+sourceStart);//check that current state should be either START_ELEMENT or ATTRIBUTE//xxx: it requires if the standalone was set in the document ? This is different that if the document// is standalone//xxx: prefix definition ?//first add the string to symbol table.. since internally identity comparisons are done.//REVISIT: we were supplying hashmap ealier//XMLReaderImpl/** This class scans the version of the document to determine ... */...[] XML11_VERSION;String fXMLSymbol;// symbol:  [xml]:XMLString fVersionNum;...[] fExpectedVersionString;fExpectedVersionString.length/** Reset the reference to the appropriate scanner given the version of the ... *//** This methods scans the XML declaration to find out the version ... */XMLEntityScanner scannerscanner.detectingVersionint quoteCharint matchedskipDeclSpaces(...)fixupCurrentEntity(...)int versionPosXML11_VERSION.length// from offset 0, to the manager's fCurrentEntity.ch.// This method prepends "length" chars from the char array,ScannedEntity currentEntitycurrentEntity.ch.lengthcurrentEntity.countcurrentEntity.positioncurrentEntity.chchar[] tempChtempCh.lengthcurrentEntity.baseCharOffsetcurrentEntity.startPositioncurrentEntity.columnNumbercurrentEntity.lineNumber// Make sure the locator used by the error reporter is the current entity scanner.// Note: above we reset fEntityScanner in the entity manager, thus in startEntity// in each scanner fEntityScanner field must be reset to reflect the change.// Must use XML 1.0 scanner to handle whitespace correctly// in the XML declaration.// definitely not a well-formed 1.1 doc!// Check if the next character is '='. If it is then consume it.// REVISIT:  should we check whether this equals quoteChar?//resize array; this case is hard to imagine...// have to move sensitive stuff out of the way...// have to reintroduce some whitespace so this parses:// prepend contents...// class XMLVersionDetector/** <p>A DTD grammar that produces balanced syntax trees.</p> ... */boolean fMixed;/** Mixed. *//** Stack depth */...[] fOpStack;/** Children content model operation stack. */...[] fGroupIndexStack;/** Holder for choice/sequence/leaf groups at each depth. */...[] fGroupIndexStackSizes;/** Sizes of the allocated portions of each int[] in fGroupIndexStack. *//** The start of a content model. Depending on the type of the content ... */// BalancedDTDGrammar(SymbolTable,XMLDTDDescription)initializeContentModelStacks(...)/** A start of either a mixed or children content model. A mixed ... */// startContentModel(String)/** The appearance of "#PCDATA" within a group signifying a ... */// startGroup()/** A referenced element in a mixed or children content model. ... */// pcdata()addToCurrentGroup(...)addUniqueLeafNode(...)/** The separator between choices or sequences of a mixed or children ... */// element(String)XMLContentSpec.CONTENTSPECNODE_CHOICEXMLContentSpec.CONTENTSPECNODE_SEQ/** The occurrence count for a child in a children content model or ... */// separator(short)int currentIndexaddContentSpecNode(...)XMLContentSpec.CONTENTSPECNODE_ZERO_OR_ONEXMLContentSpec.CONTENTSPECNODE_ZERO_OR_MOREXMLContentSpec.CONTENTSPECNODE_ONE_OR_MORE/** The end of a group for mixed or children content models. ... */// occurrence(short)int groupaddContentSpecNodes(...)/** The end of the DTD. ... */// endGroup()/** Adds the content spec to the given element declaration. */// endDTD()int contentSpecsetContentSpecIndex(...)/** Creates a subtree from the leaf nodes at the current depth. *//** Initialize the stacks which temporarily hold content models. */// addContentSpecNodes(int,int)fOpStack.lengthshort[] newOpStackint[][] newGroupIndexStackint[] newGroupIndexStackLengths/** Add XMLContentSpec to the current group. ... */// initializeContentModelStacks()int[] currentGroupcurrentGroup.lengthint[] newGroup// addToCurrentGroup(int)// class BalancedDTDGrammarimport CMAnyimport CMBinOpimport CMLeafimport CMNodeimport CMUniOpimport ContentModelValidatorimport DFAContentModelimport MixedContentModelimport SimpleContentModelimport DatatypeValidatorimport EntityStateimport Grammarimport XMLDTDContentModelSourceimport XMLDTDSource/** A DTD grammar. This class implements the XNI handler interfaces ... */new QName[][]new ContentModelValidator[][]new String[][][]new DatatypeValidator[][]new XMLAttributeDecl(...)new XMLElementDecl(...)new XMLEntityDecl(...)new XMLSimpleType(...)new XMLContentSpec(...)new HashMap<String,XMLElementDecl>(...)int TOP_LEVEL_SCOPE;/** Top level scope (-1). *//** Chunk shift (8). *//** Chunk size (1 << CHUNK_SHIFT). *//** Chunk mask (CHUNK_SIZE - 1). *//** Initial chunk count (1 << (10 - CHUNK_SHIFT)). */short LIST_FLAG;/** List flag (0x80). */// 2^10 = 1kshort LIST_MASK;/** List mask (~LIST_FLAG). *//** Debug DTDGrammar. */XMLDTDSource fDTDSource;XMLDTDContentModelSource fDTDContentModelSource;int fCurrentElementIndex;/** Current element index. */int fCurrentAttributeIndex;/** Current attribute index. */boolean fReadingExternalDTD;/** fReadingExternalDTD */XMLDTDDescription fGrammarDescription;// The XMLDTDDescription with which this Grammar is associatedint fElementDeclCount;/** Number of element declarations. */// element declarations...[] fElementDeclName;/** Element declaration name. */...[] fElementDeclType;/** Element declaration type. ... */...[] fElementDeclContentSpecIndex;/** Element declaration content spec index. This index value is used ... */...[] fElementDeclContentModelValidator;/** Element declaration content model validator. This validator is ... */...[] fElementDeclFirstAttributeDeclIndex;/** First attribute declaration of an element declaration. */...[] fElementDeclLastAttributeDeclIndex;/** Last attribute declaration of an element declaration. */int fAttributeDeclCount;/** Number of attribute declarations. */// attribute declarations...[] fAttributeDeclName;/** Attribute declaration name. */boolean fIsImmutable;// is this grammar immutable?  (fully constructed and not changeable)...[] fAttributeDeclType;/** Attribute declaration type. ... */...[] fAttributeDeclEnumeration;/** Attribute declaration enumeration values. */...[] fAttributeDeclDefaultType;...[] fAttributeDeclDatatypeValidator;...[] fAttributeDeclDefaultValue;...[] fAttributeDeclNonNormalizedDefaultValue;...[] fAttributeDeclNextAttributeDeclIndex;int fContentSpecCount;// the index of the head node of the content spec tree.// each element with a content model will hold a pointer which is// here saves the content spec binary trees for element decls,// content specs...[] fContentSpecType;...[] fContentSpecValue;...[] fContentSpecOtherValue;int fEntityCount;...[] fEntityName;...[] fEntityValue;...[] fEntityPublicId;...[] fEntitySystemId;...[] fEntityBaseSystemId;...[] fEntityNotation;...[] fEntityIsPE;...[] fEntityInExternal;int fNotationCount;...[] fNotationName;...[] fNotationPublicId;...[] fNotationSystemId;...[] fNotationBaseSystemId;Map<String,Integer> fElementIndexMap;/** Element index mapping table. */// other informationMap<String,Integer> fEntityIndexMap;/** Entity index mapping table. */Map<String,Integer> fNotationIndexMap;/** Notation index mapping table. */// temp variables/** Temporary qualified name. */QName fQName2;XMLAttributeDecl fAttributeDecl;/** Temporary Attribute decl. */int fLeafCount;// for buildSyntaxTree methodint fEpsilonIndex;XMLElementDecl fElementDecl;/** Element declaration. */XMLEntityDecl fEntityDecl;/** Entity declaration. */XMLSimpleType fSimpleType;/** Simple type. */XMLContentSpec fContentSpec;/** Content spec node. */Map<String,XMLElementDecl> fElementDeclTab;/** table of XMLElementDecl */...[] fNodeIndexStack;/** Children content model index stack. */...[] fPrevNodeIndexStack;/** Children content model previous node index stack. */...[] fPEntityStack;...[] fElementDeclIsExternal;/** flag if the elementDecl is External. */// additional fields(columns) for the element Decl pool in the Grammar...[] fAttributeDeclIsExternal;/** flag if the AttributeDecl is External. */// additional fields(columns) for the attribute Decl pool in the Grammarint valueIndex;// for mixedElement methodint prevNodeIndex;int nodeIndex;// return the XMLDTDDescription object with which this is associated// Grammar methods/** Returns true if the specified element declaration is external. ... */// getGrammarDescription():  XMLGrammarDescription/** Returns true if the specified attribute declaration is external. ... */// getElementDeclIsExternal(int):booleanint attDefIndexgetFirstAttributeDeclIndex(...)getAttributeDecl(...)fAttributeDecl.name.rawnamefAttributeDecl.namegetNextAttributeDeclIndex(...)/** The start of the DTD. ... */// XMLDTDHandler methods// getAttributeDeclIndex (int,QName)// startDTD(XMLLocator)fPEntityStack.lengthboolean[] entityarray/** The start of the DTD external subset. ... */// startParameterEntity(String,XMLResourceIdentifier,String,Augmentations)// startExternalSubset(Augmentations)/** The end of the DTD external subset. ... */// endParameterEntity(String,Augmentations)/** An element declaration. ... */// endExternalSubset(Augmentations)XMLElementDecl tmpElementDeclXMLElementDecl elementDecltmpElementDecl.typegetElementDeclIndex(...)createElementDecl(...)elementDecl.nameelementDecl.contentModelValidatorelementDecl.scopeelementDecl.typeXMLElementDecl.TYPE_EMPTYXMLElementDecl.TYPE_ANYXMLElementDecl.TYPE_MIXEDXMLElementDecl.TYPE_CHILDRENthis.fElementDeclTabaddContentSpecToElement(...)fElementDecl.name.localpartfElementDecl.namefElementDecl.typesetElementDecl(...)ensureElementDeclCapacity(...)/** An attribute declaration. ... */// elementDecl(String,String)getAttributeDeclIndex(...)createAttributeDecl(...)fSimpleType.defaultTypeXMLSimpleType.DEFAULT_TYPE_FIXEDXMLSimpleType.DEFAULT_TYPE_IMPLIEDXMLSimpleType.DEFAULT_TYPE_REQUIREDfSimpleType.defaultValuefSimpleType.nonNormalizedDefaultValuefSimpleType.enumerationfSimpleType.typeXMLSimpleType.TYPE_CDATAXMLSimpleType.TYPE_IDXMLSimpleType.TYPE_IDREFfSimpleType.listXMLSimpleType.TYPE_ENTITYXMLSimpleType.TYPE_NMTOKENXMLSimpleType.TYPE_NOTATIONXMLSimpleType.TYPE_ENUMERATIONsetAttributeDecl(...)ensureAttributeDeclCapacity(...)/** An internal entity declaration. ... */// attributeDecl(String,String,String,String[],String,XMLString,XMLString, Augmentations)int entityIndexgetEntityDeclIndex(...)boolean isPEboolean inExternalXMLEntityDecl entityDeclcreateEntityDecl(...)setEntityDecl(...)/** An external entity declaration. ... */// internalEntityDecl(String,XMLString,XMLString)/** An unparsed entity declaration. ... */// externalEntityDecl(String, XMLResourceIdentifier, Augmentations)/** A notation declaration ... */// unparsedEntityDecl(String,StringXMLResourceIdentifier,Augmentations)XMLNotationDecl notationDeclnew XMLNotationDecl(...)int notationIndexgetNotationDeclIndex(...)createNotationDecl(...)setNotationDecl(...)// notationDecl(String,XMLResourceIdentifier,Augmentations)String currNameArrayList<> elementssetPossibleRoots(...)// sets the source of this handler// returns the source of this handler// setDTDSource(XMLDTDSource)// no-op methods// getDTDSource():  XMLDTDSource/** The start of an attribute list. ... *//** The end of an attribute list. ... *//** The start of a conditional section. ... *//** Characters within an IGNORE conditional section. ... *//** The end of a conditional section. ... */// set content model source// XMLDTDContentModelHandler methods// get content model sourceinitializeContentModelStack(...)XMLContentSpec.CONTENTSPECNODE_LEAF/** A content model of ANY. ... *//** A content model of EMPTY. ... *//** The end of a content model. ... *//** Returns true if this grammar is namespace aware. *//** Returns the symbol table. */// isNamespaceAware():boolean/** Returns the index of the first element declaration. This index ... */// getSymbolTable():SymbolTable/** Returns the next index of the element declaration following the ... */// getFirstElementDeclIndex():int/** getElementDeclIndex ... */// getNextElementDeclIndex(int):intInteger mapping/** Returns the element decl index. ... */// getElementDeclIndex(String):intelementDeclQName.rawname/** make separate function for getting contentSpecType of element. ... */// getElementDeclIndex(QName):int/** getElementDecl ... *///getContentSpecTypeelementDecl.simpleType.listelementDecl.simpleTypegetElementContentModelValidator(...)elementDecl.simpleType.datatypeValidatorelementDecl.simpleType.defaultTypeelementDecl.simpleType.defaultValue// getElementDecl(int,XMLElementDecl):boolean/** getFirstAttributeDeclIndex ... */// REVISIT: Make this getAttributeDeclCount/getAttributeDeclAt. -Ac/** getNextAttributeDeclIndex ... */// getFirstAttributeDeclIndex/** getAttributeDecl ... */// getNextAttributeDeclIndexshort attributeTypeboolean isListattributeDecl.nameattributeDecl.simpleType...[...].localpart/** Returns whether the given attribute is of type CDATA or not ... */// getAttributeDeclint elDeclIdxfAttributeDecl.simpleType.typefAttributeDecl.simpleType/** getEntityDeclIndex ... *//** getEntityDecl ... */// getEntityDeclIndex/** getNotationDeclIndex ... */// getEntityDecl/** getNotationDecl ... */// getNotationDeclIndex/** getContentSpec ... */// getNotationDeclcontentSpec.typecontentSpec.valuecontentSpec.otherValue/** Returns the index to the content spec for the given element ... *//** getContentSpecAsString ... */int contentSpecIndexXMLContentSpec contentSpecgetContentSpec(...)int parentContentSpecTypeint nextContentSpecappendContentSpec(...)XMLContentSpec.CONTENTSPECNODE_ANYXMLContentSpec.CONTENTSPECNODE_ANY_OTHERXMLContentSpec.CONTENTSPECNODE_ANY_LOCAL// getContentSpecAsString(int):Stringint elementDeclIndexgetElementDecl(...)elementDecl.name.rawnameint attributeDeclIndexprintAttribute(...)int pcdata/** getElementContentModelValidator ... */ContentModelValidator contentModelint contentTypeXMLElementDecl.TYPE_SIMPLEChildrenList childrennew ChildrenList(...)contentSpecTree(...)new MixedContentModel(...)children.qnamechildren.typecreateChildModel(...)// getElementContentModelValidator(int):ContentModelValidatorint elemChunkint elemIndexattributeDecl.simpleType.typeattributeDecl.simpleType.listattributeDecl.simpleType.enumerationattributeDecl.simpleType.defaultTypeattributeDecl.simpleType.datatypeValidatorattributeDecl.simpleType.defaultValueattributeDecl.simpleType.nonNormalizedDefaultValueensureContentSpecCapacity(...)ensureEntityDeclCapacity(...)entityDecl.nameentityDecl.valueentityDecl.publicIdentityDecl.systemIdentityDecl.baseSystemIdentityDecl.notationentityDecl.isPEentityDecl.inExternalensureNotationDeclCapacity(...)notationDecl.namenotationDecl.publicIdnotationDecl.systemIdnotationDecl.baseSystemId/** Create an XMLContentSpec for a single non-leaf ... */createContentSpec(...)setContentSpec(...)/** create an XMLContentSpec for a leaf ... */// addContentSpecNode(short,String):int/** Create an XMLContentSpec for a two child leaf ... */// addUniqueLeafNode(String):intint[] leftIntArrayint[] rightIntArray/** Initialize content model stack. */// addContentSpecNode(short,int,int):intshort[] newStack// initializeContentModelStack()int thisContentSpecint otherValue// appendContentSpec(XMLContentSpec.Provider,StringPool,XMLContentSpec,StringBuffer,boolean)XMLAttributeDecl attributeDeclattributeDecl.name.localpart/** When the element has a 'CHILDREN' model, this method is called to ... */// content models// printAttribute(int)CMNode cmnbuildSyntaxTree(...)new SimpleContentModel(...)XMLContentSpec contentSpecLeftXMLContentSpec contentSpecRightcontentSpecLeft.typecontentSpecRight.typecontentSpecLeft.valuecontentSpecLeft.otherValuecontentSpecRight.valuecontentSpecRight.otherValuenew DFAContentModel(...)// createChildModel(int):ContentModelValidatorCMNode nodeRetnew CMAny(...)new CMLeaf(...)int leftNodeint rightNodenew CMBinOp(...)new CMUniOp(...)/** Build a vector of valid QNames from Content Spec ... */children.qname.lengthQName[] newQNameint[] newType// contentSpecTree(int,XMLContentSpec,ChildrenList)fElementDeclName.lengthfElementDeclIsExternal.lengthfElementDeclType.lengthfElementDeclContentModelValidator.lengthfElementDeclContentSpecIndex.lengthfElementDeclFirstAttributeDeclIndex.lengthfElementDeclLastAttributeDeclIndex.lengthnew ContentModelValidator[]fAttributeDeclName.lengthfAttributeDeclIsExternal.lengthfAttributeDeclType.lengthfAttributeDeclEnumeration.lengthfAttributeDeclDefaultType.lengthfAttributeDeclDatatypeValidator.lengthfAttributeDeclDefaultValue.lengthfAttributeDeclNonNormalizedDefaultValue.lengthfAttributeDeclNextAttributeDeclIndex.lengthnew DatatypeValidator[]fEntityName.lengthfEntityValue.lengthfEntityPublicId.lengthfEntitySystemId.lengthfEntityBaseSystemId.lengthfEntityNotation.lengthfEntityIsPE.lengthfEntityInExternal.lengthfNotationName.lengthfNotationPublicId.lengthfNotationSystemId.lengthfNotationBaseSystemId.lengthfContentSpecType.lengthfContentSpecValue.lengthfContentSpecOtherValue.length// resize chunks// Private static methodsbyte[][] newarrayshort[][] newarrayint[][] newarrayDatatypeValidator[][] newarrayContentModelValidator[][] newarrayObject[][] newarrayQName[][] newarrayString[][] newarrayString[][][] newarray/** Children list for <code>contentSpecTree</code> method. ... *//** Length. */...[] qname;/** Left and right children names. *///       union data structure. -Ac//       written this way because Java doesn't have a native// NOTE: The following set of data is mutually exclusive. It is...[] type;/** Left and right children types. */// EntityState methods// class ChildrenList//Initialize stack// check if it is already defined// duplicate element, ignored.//create element decl//add(or set) this elementDecl to the local cache//set internal structure//if ElementDecl has already being created in the Grammar then remove from table,//this.fElementDeclTab.remove( (String) elementName );// then it is forward reference to a element decl, create the elementDecl first.//Get Grammar index to grammar array//return, when more than one definition is provided for the same attribute of given element type//only the first declaration is binding and later declarations are ignored// Create current Attribute Decl// REVISIT: Report error message. -Ac// REVISIT: The datatype should be stored with the attribute value//          and not special-cased in the XMLValidator. -Ac//fSimpleType.datatypeValidator = fDatatypeValidatorFactory.createDatatypeValidator(type, null, facets, fSimpleType.list);// make sure our description contains useful stuff...// we don't know what the root is; so use possibleRoots...//System.out.println("getElementDeclIndex("+elementDeclName+") -> "+mapping);/* Validators are null until we add that code */// lookup content spec node// build string// switch type// return string//                   ", "+ elementDecl.contentModelValidator.toString());// If we have one, just return that. Otherwise, gotta create one// Get the type of content this element has// And create the content model according to the spec type//  Just create a mixel content model object. This type of//  content model is optimized for mixed content validation.//  This method will create an optimal model for the complexity//  of the element's defined model. If its simple, it will create//  a SimpleContentModel object. If its a simple list, it will//  create a SimpleListContentModel object. If its complex, it//  will create a DFAContentModel object.// Add the new model to the content model for this element// create content spec node// set content spec node values// return index//  Get the content spec node for the element we are working on.//  This will tell us what kind of node it is, which tells us what//  kind of model we will try to create.// let fall through to build a DFAContentModel//  Check that the left value is not -1, since any content model//  with PCDATA should be MIXED, so we should not have gotten here.//  Its a single leaf, so its an 'a' type of content model, i.e.//  just one instance of one element. That one is definitely a//  simple content model.//  Lets see if both of the children are leafs. If so, then it//  it has to be a simple content model//  Its a simple choice or sequence, so we can do a simple//  content model for it.//  Its a repetition, so see if its one child is a leaf. If so//  its a repetition of a single element, so we can do a simple//  content model for that.//  It is, so we can create a simple content model here that//  will check for this repetition. We pass -1 for the unused//  right node.//  Its not a simple content model, so here we have to create a DFA//  for this element. So we create a DFAContentModel object. He//  encapsulates all of the work to create the DFA.//int leafCount = countLeaves(contentSpecIndex);// REVISIT: has to be fLeafCount because we convert x+ to x,x*, one more leaf// We will build a node at this level for the new tree//nodeRet = new CMAny(contentSpec.type, -1, fLeafCount++);//  If this node is a leaf, then its an easy one. We just add it//  to the tree.//  Create a new leaf node, and pass it the current leaf count,//  which is its DFA state position. Bump the leaf count after//  storing it. This makes the positions zero based since we//  store first and then increment.//  Its not a leaf, so we have to recurse its left and maybe right//  nodes. Save both values before we recurse and trash the node.//  Recurse on both children, and return a binary op node//  with the two created sub nodes as its children. The node//  type is the same type as the source.// And return our new node for this level// Handle any and leaf nodes// resize arrays, if needed// save values and return length//for unparsed entity notation!=null// class DTDGrammar/** This very simple class is the skeleton of what the DTDValidator could use ... */Map<XMLDTDDescription,DTDGrammar> fGrammars;/** Grammars associated with element root name. */// REVISIT:  make this class smarter and *way* more complete!DTDGrammar fActiveGrammar;// building) that is used in validation.// the unique grammar from fGrammars (or that we'reboolean fIsStandalone;// is the "active" grammar standalone?new HashMap<XMLDTDDescription,DTDGrammar>(...)/** Puts the specified grammar into the grammar pool and associate it to ... */XMLDTDDescription desc// retrieve a DTDGrammar given an XMLDTDDescription// putGrammar(DTDGrammar)// what the active grammar should be (no info about root)// at the time the validator discovers this we don't yet know// is the active grammar standalone?  This must live here because// set the "active" grammar:// class DTDGrammarBucketimport XML11DTDScannerImplimport XMLDTDScannerImpl/** This class extends XMLDTDProcessor by giving it ... */// constructors// init(SymbolTable)// init(SymbolTable, XMLGrammarPool)// init(SymbolTable, XMLGrammarPool, XMLErrorReporter, XMLEntityResolver)isXML11ValidNmtoken(...)// isValidNmtoken(String):  boolean// createDTDScanner(SymbolTable, XMLErrorReporter, XMLEntityManager) : XMLDTDScannerImpl// getScannerVersion() : short// class XML11DTDProcessor/** This allows the validator to correctlyhandle XML 1.1 ... */Constants.DTD_VALIDATOR_PROPERTY// will try and use...// grammarBucket as the corresponding DTDProcessor// overridden so that this class has access to the sameXMLDTDValidator currgetGrammarBucket(...)//reset(XMLComponentManager)getBuiltInDV(...)// now overwrite some entries in parent:// init()// class XML11DTDValidator/** The DTD validator. The validator implements a document ... *//** Bind namespaces */// startNamespaceScope(QName,XMLAttributes)// endNamespaceScope(QName,boolean)QName name;/** name */XMLSimpleType simpleType;/** simpleType */boolean optional;/** optional *//** setValues ... */this.simpleTypethis.optional/** clear */// setValues// clear// class XMLAttributeDecl/** ContentSpec really exists to aid the parser classes in implementing ... */short CONTENTSPECNODE_LEAF;/** Name or #PCDATA. Leaf nodes that represent parsed character ... */short CONTENTSPECNODE_ZERO_OR_ONE;/** Represents a zero or one occurence count, '?'. */short CONTENTSPECNODE_ZERO_OR_MORE;/** Represents a zero or more occurence count, '*'. */short CONTENTSPECNODE_ONE_OR_MORE;/** Represents a one or more occurence count, '+'. */short CONTENTSPECNODE_CHOICE;/** Represents choice, '|'. */short CONTENTSPECNODE_SEQ;/** Represents sequence, ','. */short CONTENTSPECNODE_ANY;/** Represents any namespace specified namespace. When the element ... */short CONTENTSPECNODE_ANY_OTHER;/** Represents any other namespace (XML Schema: ##other). ... */short CONTENTSPECNODE_ANY_LOCAL;/** Represents any local element (XML Schema: ##local). */short CONTENTSPECNODE_ANY_LAX;/** prcessContent is 'lax' * */short CONTENTSPECNODE_ANY_OTHER_LAX;short CONTENTSPECNODE_ANY_LOCAL_LAX;short CONTENTSPECNODE_ANY_SKIP;/** processContent is 'skip' * */short CONTENTSPECNODE_ANY_OTHER_SKIP;short CONTENTSPECNODE_ANY_LOCAL_SKIP;short type;/** The content spec node type. ... *//** The "left hand" value object of the content spec node. ... */Object otherValue;/** The "right hand" value of the content spec node. ... *//** Constructs a content spec with the specified values. *//** Constructs a content spec from the values in the specified content spec. *//** Constructs a content spec from the values specified by the given ... */XMLContentSpec.Provider/** Clears the values. *//** Sets the values. */this.otherValue/** Sets the values of the specified content spec. *//** Sets the values from the values specified by the given content spec ... *//** Returns a hash code for this node. *//** Returns true if the two objects are equal. *//** Provides a means for walking the structure built out of ... */// Interfaces/** Fills in the provided content spec structure with content spec ... */// XMLContentSpec.Provider methods// interface Provider// class XMLContentSpec/** All information specific to DTD grammars. ... */String fRootName;// if we know the root of this grammar, here's its name:// pieces of information needed to make this usable as a Grammar keyArrayList<> fPossibleRoots;// could serve; fPossibleRoots and fRootName cannot both be non-null// if we don't know the root name, this stores all elements that// Constructors:this.fRootNamethis.fPossibleRoots// init(XMLResourceIdentifier, String)// init(String, String, String, String, String)// XMLGrammarDescription methods// init(XMLInputSource)// getGrammarType():  String/** Set the root name * */// getRootName():  String/** Set possible roots * *//** Compares this grammar with the given grammar. Currently, we compare ... */XMLDTDDescription dtdDescgetGrammarType(...)dtdDesc.fRootNamedtdDesc.fPossibleRootsString rootdtdDesc.fExpandedSystemIddtdDesc.fPublicId/** Returns the hash code of this grammar ... */// assume it's a DTDDescription// if we got this far we've got a root match... try other two fields,// since so many different DTD's have roots in common:// give up; hope .equals can handle it:// class XMLDTDDescriptionimport XMLGrammarLoader/** The DTD loader. The loader knows how to build grammars from XMLInputSources. ... */Constants.BALANCE_SYNTAX_TREESConstants.LOCALE_PROPERTY/** Feature identifier: standard uri conformant feature. *//** Feature identifier: balance syntax trees. */...[] LOADER_RECOGNIZED_FEATURES;// recognized features:String LOCALE;/** Property identifier: locale. */...[] LOADER_RECOGNIZED_PROPERTIES;// enforcing strict uri?boolean fBalanceSyntaxTrees;/** Controls whether the DTD grammar produces balanced syntax trees. *//** Entity resolver . */XMLDTDScannerImpl fDTDScanner;// the scanner we use to actually read the DTD// the entity manager the scanner needs.// what's our Locale?/** Deny default construction; we need a SymtolTable! */createDTDScanner(...)setDTDContentModelHandler(...)// XMLGrammarLoader methods/** Returns the state of a property. ... */// getProperty(String):  Object/** Returns the state of a feature. ... *///getFeature(String):  boolean/** Return the Locale the XMLGrammarLoader is using. *//** Sets the error handler. ... *//** Returns the registered error handler. *//** Sets the entity resolver. ... */// getErrorHandler():  XMLErrorHandler/** Returns the registered entity resolver. *//** Returns a Grammar object by parsing the contents of the ... */// getEntityResolver():  XMLEntityResolverString eidnew BalancedDTDGrammar(...)new DTDGrammarBucket(...)setActiveGrammar(...)closeReaders(...)cacheGrammars(...)XMLDTDDescription.XML_DTDnew Grammar[]/** Parse a DTD internal and/or external subset and insert the content ... */// loadGrammar(XMLInputSource):  GrammarDTDGrammarBucket grammarBucketDTDGrammar activeGrammargetActiveGrammar(...)isImmutable(...)getScannerVersion(...)XMLInputSource source// reset all the components that we rely upon// loadGrammarWithContext(XMLDTDValidator, String, String, String, String, String)// Add XML message formatter if there isn't one.// no reason to use grammar bucket's "put" method--we// know which grammar it is, and we don't know the root name anyway...// actually start the parsing!// expected behaviour...// Close all streams opened by the parser.// process internal subset// To get the DTD scanner to end at the right place we have to fool// it into thinking that it reached the end of the internal subset// in a real document.// process external subset// class XMLDTDLoaderimport XMLDTDContentModelFilterimport XMLDTDFilter/** The DTD processor. The processor implements a DTD ... */String WARN_ON_DUPLICATE_ATTDEF;/** Feature identifier: warn on duplicate attdef */String WARN_ON_UNDECLARED_ELEMDEF;/** Feature identifier: warn on undeclared element referenced in content model. *//** Property identifier: grammar pool. */String DTD_VALIDATOR;/** Property identifier: validator . *//** Validation. */boolean fDTDValidation;/** Validation against only DTD */boolean fWarnDuplicateAttdef;/** warn on duplicate attribute definition, this feature works only when validation is true */boolean fWarnOnUndeclaredElemdef;/** warn on undeclared element referenced in content model, this feature only works when valiation is true */DTDGrammarBucket fGrammarBucket;/** Grammar bucket. */XMLDTDValidator fValidator;// the grammar with details like whether it's for a standalone document...// validator needs to hold the bucket so that it can initialize// the validator to which we look for our grammar bucket (theXMLGrammarPool fGrammarPool;// the grammar pool we'll try to add the grammar to:/** DTD source. *//** DTD content model source. */DTDGrammar fDTDGrammar;/** DTD Grammar. */// grammars/** Perform validation. */boolean fInDTDIgnore;/** True if in an ignore conditional section of the DTD. */// validation states// information regarding the current element/** Temporary entity declaration. */HashMap<> fNDataDeclNotations;/** Notation declaration hash. */String fDTDElementDeclName;/** DTD element declaration name. */ArrayList<> fMixedElementTypes;/** Mixed element type "hash". */ArrayList<> fDTDElementDecls;/** Element declarations in DTD. */HashMap<> fTableOfIDAttributeNames;/** ID attribute names. */// ATTLIST, and misc VCs// to check for duplicate ID or ANNOTATION attribute declare inHashMap<> fTableOfNOTATIONAttributeNames;/** NOTATION attribute names. */HashMap<> fNotationEnumVals;/** NOTATION enumeration values. *//* Resets the component. The component can query the component manager ... *//** Returns the DTD handler. ... *//** Gets the DTD content model handler. ... */// XMLDTDContentModelHandler and XMLDTDHandler methods// getDTDContentModelHandler():  XMLDTDContentModelHandler/** Check standalone entity reference. ... */int entIndexgetEntityDecl(...)tempEntityDecl.inExternal/** This method notifies of the start of a parameter entity. The parameter ... */getStandalone(...)checkStandaloneEntityRef(...)/** This method notifies the end of a parameter entity. Parameter entity ... */// startAttlist(String)normalizeDefaultAttrValue(...)boolean duplicateAttributeDefXMLSymbols.fIDSymboldefaultValue.lengthXMLSymbols.fIMPLIEDSymbolXMLSymbols.fREQUIREDSymbolString previousIDAttributeNameXMLSymbols.fNOTATIONSymbolenumeration.lengthString previousNOTATIONAttributeNameXMLSymbols.fENUMERATIONSymbolXMLSymbols.fFIXEDSymbolXMLSymbols.fNMTOKENSSymbolXMLSymbols.fENTITIESSymbolXMLSymbols.fIDREFSSymbolString nmtokenisValidNmtoken(...)XMLSymbols.fENTITYSymbolXMLSymbols.fIDREFSymbolXMLSymbols.fNMTOKENSymbol// attributeDecl(String,String,String,String[],String,XMLString, XMLString, Augmentations)// endAttlist()// externalEntityDecl(String,XMLResourceIdentifier, Augmentations)// unparsedEntityDecl(String,XMLResourceIdentifier,String,Augmentations)// notationDecl(String,XMLResourceIdentifier, Augmentations)// startConditional(short)// endConditional()Iterator<> entitiesIterator<> notationValsIterator<> elementsWithNotationsString entityString elementNamegetContentSpecType(...)checkDeclaredElements(...)// sets the XMLDTDSource of this handler// returns the XMLDTDSource of this handler// sets the XMLContentModelDTDSource of this handler// setDTDContentModelSource(XMLDTDContentModelSource)// getDTDContentModelSource():  XMLDTDContentModelSource// any()// empty()// childrenElement(String)/** Normalize the attribute value of a non CDATA default attribute ... */// endContentModel()/** Checks that all elements referenced in content models have ... */// isValidName(String):  booleangetFirstElementDeclIndex(...)getContentSpecIndex(...)getNextElementDeclIndex(...)/** Does a recursive (if necessary) check on the specified element's ... */getElementDeclName(...).rawnamegetElementDeclName(...)// initialize data// get needed components// we get our grammarBucket from the validator...// clear grammars// datatype validators// check VC: Standalone Document Declartion, entities references appear in the document.// the grammar bucket's DTDGrammar will now be the// one we want, whether we're constructing it or not.// if we're not constructing it, then we should not have a reference// to it!// ignored characters in DTD//check VC: Unique Element Declaration//more than one attribute definition is provided for the same attribute of a given element type.//this feature works only when validation is true.// a) VC: One ID per Element Type, If duplicate ID attribute// b) VC: ID attribute Default. if there is a declareared attribute//        default for ID it should be of type #IMPLIED or #REQUIRED//we should not report an error, when there is duplicate attribute definition for given element type//according to XML 1.0 spec, When more than one definition is provided for the same attribute of a given//element type, the first declaration is binding and later declaration are *ignored*. So processor should//ignore the second declarations, however an application would be warned of the duplicate attribute defintion// if http://apache.org/xml/features/validation/warn-on-duplicate-attdef feature is set to true,// one typical case where this could be a  problem, when any XML file// provide the ID type information through internal subset so that it is available to the parser which read//only internal subset. Now that attribute declaration(ID Type) can again be part of external parsed entity//referenced. At that time if parser doesn't make this distinction it will throw an error for VC One ID per//Element Type, which (second defintion) actually should be ignored. Application behavior may differ on the//basis of error or warning thrown. - nb.//rule a)//  VC: One Notation Per Element Type, should check if there is a//      duplicate NOTATION attribute// VC: Notation Attributes: all notation names in the//     (attribute) declaration must be declared.//ignore the second declarations, however an application would be warned of the duplicate attribute definition// if http://apache.org/xml/features/validation/warn-on-duplicate-attdef feature is set to true, Application behavior may differ on the basis of error or//warning thrown. - nb.// VC: No Duplicate Tokens// XML 1.0 SE Errata - E2// Only report the first uniqueness violation. There could be others,// but additional overhead would be incurred tracking unique tokens// that have already been encountered. -- mrglavas// VC: Attribute Default Legal//If the same entity is declared more than once, the first declaration//encountered is binding, SAX requires only effective(first) declaration//to be reported to the application//REVISIT: Does it make sense to pass duplicate Entity information across//the pipeline -- nb?//its a new entity and hasn't been declared.//store internal entity declaration in grammar//REVISIT: Does it make sense to pass duplicate entity information across//store external entity declaration in grammar// VC: Notation declared,  in the production of NDataDecl// VC: Unique Notation Name// set state// save grammar// VC : Notation Declared. for external entity declaration [Production 76].// VC: Notation Attributes://     all notation names in the (attribute) declaration must be declared.// VC: No Notation on Empty Element// An attribute of type NOTATION must not be declared on an element declared EMPTY.// should be safe to release these references// check whether each element referenced in a content model is declared// check VC: No duplicate Types, in a single mixed-content declaration// skip leading spaces// just skip it.// simply shift non space chars if needed// if we finished on a space trim it// set the new value length// It's not a leaf, so we have to recurse its left and maybe right// nodes. Save both values before we recurse and trash the node.//  Recurse on both children.// class XMLDTDProcessorimport InvalidDatatypeValueExceptionimport ValidationStatenew ValidationState(...)/** Symbol: "&lt;&lt;datatypes>>". *//** Feature identifier: dynamic validation. */String DATATYPE_VALIDATOR_FACTORY;/** Property identifier: datatype validator factory. */boolean DEBUG_ATTRIBUTES;/** Compile to true to debug attributes. */boolean DEBUG_ELEMENT_CHILDREN;/** Compile to true to debug element children. */// updated during resetValidationState fValidationState;// validation stateboolean fDynamicValidation;/** Dynamic validation. This state of this feature is only useful when ... */// the grammar poolXMLLocator fDocLocation;/* location of the document as passed in from startDocument call */DTDDVFactory fDatatypeValidatorFactory;/** Datatype validator factory. *//** True if seen DOCTYPE declaration. */String fSchemaType;/** Schema type: None, DTD, Schema *//** Current element name. */int fCurrentContentSpecType;/** Current content spec type. */QName fRootElement;/** The root element name. */boolean fInCDATASection;...[] fElementIndexStack;/** Element index stack. */// element stack...[] fContentSpecTypeStack;/** Content spec type stack. */...[] fElementQNamePartsStack;/** Element name stack. */...[] fElementChildren;/** Element children. This data structure is a growing stack that ... */// children list and offset stackint fElementChildrenLength;/** Element children count. */...[] fElementChildrenOffsetStack;/** Element children offset stack. This stack refers to offsets ... */int fElementDepth;/** Element depth. */boolean fSeenRootElement;/** True if seen the root element. */boolean fInElementContent;/** True if inside of element content. */XMLElementDecl fTempElementDecl;/** Temporary element declaration. */XMLAttributeDecl fTempAttDecl;/** Temporary atribute declaration. */QName fTempQName;StringBuffer fBuffer;/** Temporary string buffers. */DatatypeValidator fValID;/** Datatype validator: ID. */// attribute validators// symbols: generalDatatypeValidator fValIDRef;/** Datatype validator: IDREF. */DatatypeValidator fValIDRefs;/** Datatype validator: IDREFS. */DatatypeValidator fValENTITY;/** Datatype validator: ENTITY. */DatatypeValidator fValENTITIES;/** Datatype validator: ENTITIES. */DatatypeValidator fValNMTOKEN;/** Datatype validator: NMTOKEN. */DatatypeValidator fValNMTOKENS;/** Datatype validator: NMTOKENS. */DatatypeValidator fValNOTATION;/** Datatype validator: NOTATION. */fElementQNamePartsStack.length// getGrammarBucket():  DTDGrammarBucketresetIDTables(...)addValidationState(...)setUsingNamespaces(...)// getDocumentHandler():  XMLDocumentHandlerGrammar[] grammarsretrieveInitialGrammarSet(...)grammars.lengthputGrammar(...)XMLDTDDescription grammarDescretrieveGrammar(...)setCachedDTD(...)// doctypeDecl(String,String,String, Augmentations)boolean removedboolean callNextCharactersboolean allWhiteSpacetext.offsettext.lengthtext.chgetElementDeclIsExternal(...)charDataInContent(...)getContentSpecAsString(...)fTempElementDecl.type/** Add default attributes and validate. *///REVISIT:we can convert into functions.. adding default attribute values.. and one validating.int attlistIndexString attPrefixfTempAttDecl.name.prefixfTempAttDecl.nameString attLocalpartfTempAttDecl.name.localpartString attRawNamefTempAttDecl.name.rawnameString attTypegetAttributeTypeName(...)int attDefaultTypefTempAttDecl.simpleType.defaultTypefTempAttDecl.simpleTypeString attValueboolean requiredboolean cdataelementDecl.name.localpartfTempAttDecl.simpleType.defaultValuefTempAttDecl.simpleType.typeelementName.localpartint newAttrgetAttributeDeclIsExternal(...)fTempAttDecl.name.uriString attrRawNameboolean changedByNormalizationString oldValueString nonNormalizedValuegetNonNormalizedValue(...)getExternalEntityRefInAttrValue(...)elementName.rawnameConstants.ATTRIBUTE_DECLAREDnormalizeAttrValue(...)String defaultValuevalidateDTDattribute(...)/** Checks entities in attribute values for standalone VC. */// addDTDDefaultAttrsAndValidate(int,XMLAttrList)int valLengthint ampIndexint semicolonIndexfEntityDecl.inExternalfEntityDecl.value/** Validate attributes in DTD fashion. */// isExternalEntityRefInAttrValue(String):Stringboolean isAlistAttributeInvalidDatatypeValueException exgetArgs(...)String[] enumValsenumVals.lengthStringBuffer enumValueStringattributeDecl.name.rawname/** Returns true if invalid standalone attribute definition. */// validateDTDattribute(QName,String,XMLAttributeDecl)/** Normalize the attribute value of a non CDATA attributes collapsing ... */boolean leadingSpaceboolean spaceStartboolean readingNonSpaceint eatenchar[] attValueString newValueattValue.length/** Root element specified. */String root1fRootElement.rawnameString root2rootElement.rawname/** Check that the content of an element is valid. ... */// rootElementSpecified(QName)String elementTypeContentModelValidator cmElemfTempElementDecl.contentModelValidator/** Returns the content spec type for an element index. */// checkContent(int,int,QName[]):intint contentSpecType/** Character data in content. */fElementChildren.lengthQName[] newarray/** convert attribute type from ints to strings */// charDataInCount()attrDecl.simpleType.typeattrDecl.simpleTypeattrDecl.simpleType.listattrDecl.simpleType.enumeration.lengthattrDecl.simpleType.enumeration/** initialization */// getAttributeTypeName(XMLAttributeDecl):String/** ensure element stack capacity */QName[] newStackOfQueuethis.fElementQNamePartsStack/** Handle element ... */// ensureStackCapacitysetEntityState(...)setGrammarFound(...)rootElementSpecified(...)addDTDDefaultAttrsAndValidate(...)fElementChildrenOffsetStack.lengthint[] newarrayensureStackCapacity(...)startNamespaceScope(...)// handleStartElement(QName,XMLAttributes)/** Handle end element. */QName[] childrenint childrenOffsetint childrenLengthcheckContent(...)String messageKeyendNamespaceScope(...)checkIDRefID(...)// version of XML this validator supports.// returns whether a character is space according to the// isSpace(int):  boolean// get initial grammars// save standalone state// save root element state// find or create grammar:// give grammar pool a chance...// Do not bother checking the pool if no public or system identifier was provided.// Since so many different DTDs have roots in common, using only a root name as the// key may cause an unexpected grammar to be retrieved from the grammar pool. This scenario// would occur when an ExternalSubsetResolver has been queried and the// XMLInputSource returned contains an input stream but no external identifier.// This can never happen when the instance document specified a DOCTYPE. -- mrglavas// we'll have to create it...// we've found a cached one;so let's make sure not to read// any external subset!// REVISIT: [Q] Is there a more efficient way of doing this?//          Perhaps if the scanner told us so we don't have to//          look at the characters again. -Ac// call the ignoreableWhiteSpace callback// never call ignorableWhitespace if we are in cdata section// validate// For E15.2// fixes E15.1// Do validation if all of the following are true:// 1. The JAXP Schema Language property is not XML Schema//    REVISIT: since only DTD and Schema are supported at this time,//             such checking is sufficient. but if more schema types//             are introduced in the future, we'll need to change it//             to something like//             (fSchemaType == null || fSchemaType == NS_XML_DTD)// 2. One of the following is true (validation features)// 2.1 Dynamic validation is off, and validation is on// 2.2 Dynamic validation is on, and DOCTYPE was seen// 3 Xerces schema validation feature is off, or DOCTYPE was seen.// Check after all specified attrs are scanned// (1) report error for REQUIRED attrs that are missing (V_TAGc)// (2) add default attrs (FIXED and NOT_FIXED)// add namespace information// add attribute// get next att decl in the Grammar for this element// now iterate through the expanded attributes for// 1. if every attribute seen is declared in the DTD// 2. check if the VC: default_fixed holds// 3. validate every attribute.// check VC: Standalone Document Declaration, entities// references appear in the document.// REVISIT: this can be combined to a single check in// startEntity if we add one more argument in// startEnity, inAttrValue// found the match att decl,// REVISIT - cache the elem/attr tuple so that we only// give this error once for each unique occurrence// attribute is declared// fTempAttDecl should have the right value set now, so// the following is not needed// fGrammar.getAttributeDecl(attDefIndex,fTempAttDecl);// check VC: Standalone Document Declaration// for all attributes// NOTE: Save this information because invalidStandaloneAttDef//Caveat - Save this information because invalidStandaloneAttDef//changes fTempAttDef// REVISIT: This obviously needs to be fixed! -Ac/* if (fStandaloneReader == -1) { ... */// vars// now the tricky part/** * BUG #3512 *** ... */// check if the last appended character is a space.// Get the element name index from the element// Get out the content spec for this element//  Deal with the possible types of content. We try to optimized here//  by dealing specially with content models that don't require the//  full DFA treatment.//  If the child count is greater than zero, then this is//  an error right off the bat at index 0.//  This one is open game so we don't pass any judgement on it//  at all. Its assumed to fine since it can hold anything.// Get the content model for this element, faulting it in if needed/** ** ... */// this should never be reached in the case of DTD validation.// We succeeded//REVISIT: datatypeRegistry + initialization of datatype//         why do we cast to ListDatatypeValidator?// VC: Root Element Type// see if the root element's name matches the one in DoctypeDecl// REVISIT: Here are current assumptions about validation features//          given that XMLSchema validator is in the pipeline// http://xml.org/sax/features/validation = true// http://apache.org/xml/features/validation/schema = true// [1] XML instance document only has reference to a DTD//  Outcome: report validation errors only against dtd.// [2] XML instance document has only XML Schema grammars://  Outcome: report validation errors only against schemas (no errors produced from DTD validator)// [3] XML instance document has DTD and XML schemas:// [a] if schema language is not set outcome - validation errors reported against both grammars: DTD and schemas.// [b] if schema language is set to XML Schema - do not report validation errors// if dynamic validation is on//            validate only against grammar we've found (depending on settings//            for schema feature)// modify pipeline//  resolve the element//changed here.. new function for getContentSpecType//  0. insert default attributes//  1. normalize the attributes//  2. validate the attrivute list.// TO DO://changed here.. also pass element name,// set element content state// increment the element depth, add this element's// QName to its enclosing element 's children list// push current length onto stack// add this element to children// save current element information// decrease element depth// now pop this element off the top of the element stack// TO DO : fix this// Check after document is fully parsed// (1) check that there was an element with a matching id for every//   IDREF and IDREFS attr (V_IDREF0)// If Namespace enable then localName != rawName// NOTE: The binding of the element doesn't actually happen//       yet because the namespace binder does that. However,//       if it does it before this point, then the endPrefix-//       Mapping calls get made too soon! As long as the//       rawnames match, we know it'll have a good binding,//       so we can just use the current element. -Ac// class XMLDTDValidator/** Defines a DTD Validator filter to allow ... *//** Returns true if the validator has a DTD grammar ... *//** Return true if validator must validate the document ... */// interface XMLDTDValidatorFiltershort TYPE_ANY;/** TYPE_ANY */short TYPE_EMPTY;/** TYPE_EMPTY */short TYPE_MIXED;/** TYPE_MIXED */short TYPE_CHILDREN;/** TYPE_CHILDREN */short TYPE_SIMPLE;/** TYPE_SIMPLE */int scope;/** scope *//** type */ContentModelValidator contentModelValidator;/** contentModelValidator */this.scopethis.contentModelValidator// class XMLElementDecl/** publicId *//** systemId */String baseSystemId;/** baseSystemId */String notation;/** notation */boolean isPE;/** isPE */boolean inExternal;/** <strong>Note:</strong> flag of where the entity is defined, not whether it is a external entity *//** inExternal *//** Value. */this.publicIdthis.systemIdthis.baseSystemIdthis.notationthis.isPEthis.inExternal// setValues(String,String,String,String,String,boolean,boolean)// class XMLEntityDecl/** base systemId */// class XMLNotationDeclshort TYPE_CDATA;/** TYPE_CDATA */short TYPE_ENTITY;/** TYPE_ENTITY */short TYPE_ENUMERATION;/** TYPE_ENUMERATION */short TYPE_ID;/** TYPE_ID */short TYPE_IDREF;/** TYPE_IDREF */short TYPE_NMTOKEN;/** TYPE_NMTOKEN */short TYPE_NOTATION;/** TYPE_NOTATION */short TYPE_NAMED;/** TYPE_NAMED */short DEFAULT_TYPE_DEFAULT;/** DEFAULT_TYPE_DEFAULT */short DEFAULT_TYPE_FIXED;/** DEFAULT_TYPE_FIXED */short DEFAULT_TYPE_IMPLIED;/** DEFAULT_TYPE_IMPLIED */short DEFAULT_TYPE_REQUIRED;/** DEFAULT_TYPE_REQUIRED */...[] enumeration;/** enumeration */boolean list;/** list */short defaultType;/** defaultType *//** defaultValue */String nonNormalizedDefaultValue;/** non-normalized defaultValue */DatatypeValidator datatypeValidator;/** datatypeValidator */this.enumerationthis.enumeration.lengththis.defaultTypethis.nonNormalizedDefaultValuethis.datatypeValidator/** Set values. */// setValues(short,String,String[],boolean,short,String,String,DatatypeValidator)simpleType.typesimpleType.namesimpleType.enumerationsimpleType.enumeration.lengthsimpleType.listsimpleType.defaultTypesimpleType.defaultValuesimpleType.nonNormalizedDefaultValuesimpleType.datatypeValidator// setValues(XMLSimpleType)// REVISIT: Should this be a copy? -Ac// class XMLSimpleType/** Content model any node. ... */int fType;/** The any content model type. This value is one of the following: ... */String fURI;/** URI of the any content model. This value is set if the type is ... *//** Part of the algorithm to convert a regex directly to a DFA ... *//** Constructs a content model any. */// package// CMNode methodsStringBuilder strRetzeroBits(...)// Store the information// Leaf nodes are never nullable unless its an epsilon node// If we are an epsilon node, then the first pos is an empty set// Otherwise, its just the one bit of our position// If we are an epsilon node, then the last pos is an empty set// class CMAnyimport XMLContentSpec/** Content model Bin-Op node. ... *///  Constructors//  Package, final methods//  Package, inherited methodsisNullable(...)//  Protected, inherited methodssetTo(...)firstPos(...)lastPos(...)CMNode fLeftChild;//      side of this binary operation.//      These are the references to the two nodes that are on either//  fRightChild//  fLeftChild//  Private data membersCMNode fRightChild;// Insure that its one of the types we require// Store the nodes and init any data that needs it//  If its an alternation, then if either child is nullable then//  this node is nullable. If its a concatenation, then both of//  them have to be nullable.// Its the the union of the first positions of our children.//  If our left child is nullable, then its the union of our//  children's first positions. Else is our left child's first//  positions.//  If our right child is nullable, then its the union of our//  children's last positions. Else is our right child's last/** Content model leaf node. ... */QName fElement;/** This is the element that this leaf represents. *//** Constructs a content model leaf. */fElement.urifElement.localpart// Store the element index and position// class CMLeaf/** A content model node. ... */// made this public so it could be implemented and used outside this package -neilg.//  Package, abstract methods//  Package final methodsnew CMStateSet(...)calcFirstPos(...)calcLastPos(...)/** Allows the user to set arbitrary data on this content model ... *//** Allows the user to get arbitrary data set on this content ... *///  Protected, abstract methods//      being initialized.//      init to to -1 so it will cause an error if its used without//      state set members and they have to be sized to this size. We//      has to be stored redundantly, but we need to fault in the//      sets during the building of the DFA. Its unfortunate that it//      max number of NFA states that have to be traced in the state//      The maximum number of states that the NFA has, which means the//  fMaxStates//      node in the DFA.//      The set of NFA states that represent the final states of this//  fLastPos//      The set of NFA states that can be gotten to from from this//  fFollowPos//      The set of NFA states that represent the entry states of this//  fFirstPos//      This is one of the ContentSpecNode.NODE_XXX types.//      it is too expensive to use runtime typing to find this out.//      operation. Though we also do derived classes for these types,//      The type of node. This indicates whether its a leaf or an//  fTypeCMStateSet fFirstPos;CMStateSet fFollowPos;CMStateSet fLastPos;int fMaxStates;Object fUserData;// the XS content models from the schema package -neilg.// made this class public so it can be accessed by/** This class is a very simple bitset class. The DFA content model code needs ... *///  Public inherited methodsStringBuffer strRetRuntimeException exToCatchsetToAnd.fBits1setToAnd.fBits2setToAnd.fByteArrayint ofssetToCompare.fBitCountsetToCompare.fBits1setToCompare.fBits2setToCompare.fByteArraysetToOr.fBits1setToOr.fBits2setToOr.fByteArraysrcSet.fBitCountsrcSet.fBits1srcSet.fBits2srcSet.fByteArray// schema package - neilg.// had to make this method public so it could be accessed fromint fBitCount;//      Otherwise, the fByteArray member holds htem.//      When the bit count is < 64 (very common), these hold the bits.//  fBits2//  fBits1//      its value is meaningless.//      store the bits, and this indicates its size in bytes. Otherwise//      If the bit count is > 64, then we use the fByteArray member to//  fByteCount//      so its the max bit index plus one.//      The count of bits that the outside world wants to support,//  fBitCountint fByteCount;int fBits1;int fBits2;...[] fByteArray;/* Optimization(Jan, 2001) */isSameSet(...)// Store the required bit count and insure its legal//  See if we need to allocate the byte array or whether we can live//  within the 64 bit high performance scheme.// Init all the bits to zero//  We know this won't happen but we have to catch it to avoid it//  having to be in our 'throws' list.// Create the mask and byte values// And access the right bit and byte// They have to be the same size/** Content model Uni-Op node. ... */CMNode fChild;//      unary operation.//      This is the reference to the one child that we have for this//  fChild// Store the node and init any data that needs it//  For debugging purposes, make sure we got rid of all non '*'//  repetitions. Otherwise, '*' style nodes are always nullable.// Its just based on our child node's first pos// Its just based on our child node's last pos/** validate ... */// interface ContentModelValidatorString fEpsilonString;/** Epsilon string. */// special stringsString fEOCString;/** End-of-content string. */boolean DEBUG_VALIDATE_CONTENT;/** Set to true to debug content model validation. */...[] fElemMap;/** This is the map of unique input symbol elements to indices into ... *///private EquivClassComparator comparator = null;/* this is the EquivClassComparator object */...[] fElemMapType;/** This is a map of whether the element map contains information ... */int fElemMapSize;/** The element map size. *//** Boolean to distinguish Schema Mixed Content */int fEOCPos;/** The NFA position of the special EOC (end of content) node. This ... */...[] fFinalStateFlags;/** This is an array of booleans, one per state (there are ... */...[] fFollowList;/** The list of follow positions for each NFA position (i.e. for each ... */CMNode fHeadNode;/** This is the head node of our intermediate representation. It is ... *//** The count of leaf nodes. This is an important number that set some ... */...[] fLeafList;/** An array of non-epsilon leaf nodes, which is used during the DFA ... */...[] fLeafListType;/** Array mapping ANY types to the leaf list. */...[] fTransTable;/** This is the transition table that is the main by product of all ... *///private StringPool fStringPool = null;/** The string pool of our parser session. This is set during construction ... *///private ContentLeafNameTypeVector fLeafNameTypeVector = null;int fTransTableSize;/** The number of valid entries in the transition table, and in the other ... */boolean fEmptyContentIsValid;/** Flag that indicates that even though we have a "complicated" ... *//** Constructs a DFA content model. ... */buildDFA(...)/** Check that the specified content is valid according to this ... */// ContentModelValidator methodsint curStatefElemMap.length...[...].uriQName curElemcurElem.localpartcurElem.rawnamecurElem.uri/** Builds the internal DFA transition table from the given syntax tree. ... */CMLeaf nodeEOCint[] fLeafSorterint fSortCountint curArraySizeCMStateSet[] statesToDonew CMStateSet[]CMStateSet setTint unmarkedStateHashMap<> stateTablenew CMLeaf[]postTreeBuildInit(...)calcFollowList(...)int outIndexQName elementint inIndexint leafIndexQName leafleaf.rawnamemakeDefStateList(...)int[] transEntryCMStateSet newSetint sorterIndexInteger stateObjint stateIndexCMStateSet[] newToDoboolean[] newFinalFlagsint[][] newTransTabledumpTree(...)/** Calculates the follow list of the current node. ... */CMStateSet lastCMStateSet first/** Dumps the tree of the current node to standard output. ... *//** -1 is used to represent bad transitions in the transition table ... */int[] retArray/** Post tree build initialization. */setMaxStates(...)QName nodenode.localpart/** initializing static members * */// Store away our index and pools in members//fStringPool = stringPool;// this is for Schema Mixed Content//  Ok, so lets grind through the building of the DFA. This method//  handles the high level logic of the algorithm, but it uses a//  number of helper classes to do its thing.//  In order to avoid having hundreds of references to the error and//  string handlers around, this guy and all of his helper classes//  just throw a simple exception and we then pass it along.// A DFA content model must *always* have at least 1 child// so a failure is given if no children present.// Defect 782: This is an incorrect statement because a DFA// content model is also used for constructions such as://     (Optional*,NotRequired?)// where a perfectly valid content would be NO CHILDREN.// Therefore, if there are no children, we must check to// see if the CMNODE_EOC marker is a valid start state! -Ac// if child count == 0//  Lets loop through the children in the array and move our way//  through the states. Note that we use the fElemMap array to map//  an element index to a state index.// Get the current element index out// ignore mixed text// Look up this child in our element map//System.out.println("fElemMap["+elemIndex+"]: "+fElemMap[elemIndex]);// If we didn't find it, then obviously not valid//  Look up the next state for this input symbol when in the//  current state.// If its not a legal transition, then invalid//  We transitioned all the way through the input list. However, that//  does not mean that we ended in a final state. So check whether//  our ending state is a final state.//  The first step we need to take is to rewrite the content model//  using our CMNode objects, and in the process get rid of any//  repetition short cuts, converting them into '*' style repetitions//  or getting rid of repetitions altogether.//  The conversions done are://  x+ -> (x|x*)//  x? -> (x|epsilon)//  This is a relatively complex scenario. What is happening is that//  we create a top level binary node of which the special EOC value//  is set as the right side node. The the left side is set to the//  rewritten syntax tree. The source is the original content model//  info from the decl pool. The rewrite is done by buildSyntaxTree()//  which recurses the decl pool's content of the element and builds//  a new tree in the process.//  Note that, during this operation, we set each non-epsilon leaf//  node's DFA state position and count the number of such leafs, which//  is left in the fLeafCount member.//  The nodeTmp object is passed in just as a temp node to use during//  the recursion. Otherwise, we'd have to create a new node on every//  level of recursion, which would be piggy in Java (as is everything//  for that matter.)/* MODIFIED (Jan, 2001) ... *///  And handle specially the EOC node, which also must be numbered//  and counted as a non-epsilon leaf node. It could not be handled//  in the above tree build because it was created before all that//  started. We save the EOC position since its used during the DFA//  building loop.//  Ok, so now we have to iterate the new tree and do a little more//  work now that we know the leaf count. One thing we need to do is//  to calculate the first and last position sets of each node. This//  is cached away in each of the nodes.//  Along the way we also set the leaf count in each node as the//  maximum state count. They must know this in order to create their//  first/last pos sets.//  We also need to build an array of references to the non-epsilon//  leaf nodes. Since we iterate it in the same way as before, this//  will put them in the array according to their position values.//  And, moving onward... We now need to build the follow position//  sets for all the nodes. So we allocate an array of state sets,//  one for each leaf node (i.e. each DFA position.)//  And finally the big push... Now we build the DFA using all the//  states and the tree we've built up. First we set up the various//  data structures we are going to use while we do this.//  First of all we need an array of unique element names in our//  content model. For each transition table entry, we need a set of//  contiguous indices to represent the transitions for a particular//  input element. So we need to a zero based range of indexes that//  map to element types. This element map provides that mapping.// Get the current leaf's element index// See if the current leaf node's element index is in the list// If it was not in the list, then add it, if not the EOC node// set up the fLeafNameTypeVector object if there is one./** *** ... *///  Next lets create some arrays, some that that hold transient//  information during the DFA build and some that are permament.//  These are kind of sticky since we cannot know how big they will//  get, but we don't want to use any Java collections because of//  performance.//  Basically they will probably be about fLeafCount*2 on average,//  but can be as large as 2^(fLeafCount*2), worst case. So we start//  with fLeafCount*4 as a middle ground. This will be very unlikely//  to ever have to expand, though it if does, the overhead will be//  somewhat ugly.//  Ok we start with the initial set as the first pos set of the//  head node (which is the seq node that holds the content model//  and the EOC node.)//  Init our two state flags. Basically the unmarked state counter//  is always chasing the current state counter. When it catches up,//  that means we made a pass through that did not add any new states//  to the lists, at which time we are done. We could have used a//  expanding array of flags which we used to mark off states as we//  complete them, but this is easier though less readable maybe.//  Init the first transition table entry, and put the initial state//  into the states to do list, then bump the current state./* Optimization(Jan, 2001); This is faster for ... *///  Ok, almost done with the algorithm... We now enter the//  loop where we go until the states done counter catches up with//  the states to do counter.//  Get the first unmarked state out of the list of states to do.//  And get the associated transition table entry.// Mark this one final if it contains the EOC state// Bump up the unmarked state count, marking this state done// Loop through each possible input symbol in the element map//  Build up a set of states which is the union of all of//  the follow sets of DFA positions that are in the current//  state. If we gave away the new set last time through then//  create a new one. Otherwise, zero out the existing one.// If this leaf index (DFA position) is in the current set...//  If this leaf is the current input symbol, then we//  want to add its follow list to the set of states to//  transition to from the current state.//  If this new set is not empty, then see if its in the list//  of states to do. If not, then add it.//  Search the 'states to do' list to see if this new//  state set is already in there.// If we did not find it, then add it//  Put this new state into the states to do and init//  a new entry at the same index in the transition//  table.// We now have a new state to do so bump the count//  Null out the new set to indicate we adopted it.//  This will cause the creation of a new set on the//  next time around the loop.//  Now set this state in the transition table's entry//  for this element (using its index), with the DFA//  state we will move to from the current state when we//  see this input element.// Expand the arrays if we're full//  Yikes, we overflowed the initial array size, so//  we've got to expand all of these arrays. So adjust//  up the size by 50% and allocate new arrays.// Copy over all of the existing content// Store the new array size// Check to see if we can set the fEmptyContentIsValid flag.//  And now we can say bye bye to the temp representation since we've//  built the DFA.// Recurse as required// Recurse only//  Now handle our level. We use our left child's last pos//  set and our right child's first pos set, so go ahead and//  get them ahead of time.//  Now, for every position which is in our left child's last set//  add all of the states in our right child's first set to the//  follow set for that position.// Set the maximum states on this node// REVISIT: Don't waste these structures.//  Put this node in the leaf list at the current index if its//  a non-epsilon leaf.// class DFAContentModel/** MixedContentModel is a derivative of the abstract content model base ... *//** The count of possible children that we have to deal with. */...[] fChildren;/** The list of possible children that we have to accept. */...[] fChildrenType;/** The type of the children to support ANY. */boolean fOrdered;/** True if mixed content model is ordered. DTD mixed content models ... *//** Constructs a mixed content model. ... */QName curChildcurChild.localpartcurChild.rawname// Make our own copy now, which is exactly the right size// must match order// element must match// advance index// can appear in any order// Get the current child out of the source index// If its PCDATA, then we just accept that// And try to find it in our list// REVISIT: What about checking for multiple ANY matches?//          The content model ambiguity *could* be checked//          by the caller before constructing the mixed//          content model.// We did not find this one, so the validation failed// Everything seems to be in order, so return success// class MixedContentModel/** SimpleContentModel is a derivative of the abstract content model base ... */short CHOICE;/** CHOICE */short SEQUENCE;/** SEQUENCE */QName fFirstChild;/** The element decl pool indices of the first (and optional second) ... */QName fSecondChild;int fOperator;/** The operation that this object represents. Since this class only ... *//** Constructs a simple content model. ... */fFirstChild.rawnamefSecondChild.rawname//  Store away the children and operation. This is all we need to//  do the content model check.//  The operation is one of the ContentSpecNode.NODE_XXX values!//  According to the type of operation, we do the correct type of//  content check.// If there is not a child, then report an error at index 0// If the 0th child is not the right kind, report an error at 0// If more than one child, report an error at index 1//  If there is one child, make sure its the right type. If not,//  then its an error at index 0.//  If the child count is greater than one, then obviously//  bad, so report an error at index 1.//  If the child count is zero, that's fine. If its more than//  zero, then make sure that all children are of the element//  type that we stored. If not, report the index of the first//  failed one.//  If the child count is zero, that's an error so report//  an error at index 0.//  Otherwise we have to check them all to make sure that they//  are of the correct child type. If not, then report the index//  of the first one that is not.//  There must be one and only one child, so if the element count//  is zero, return an error at index 0.// If the zeroth element isn't one of our choices, error at 0// If there is more than one element, then an error at 1//  There must be two children and they must be the two values//  we stored, in the stored order.// We survived, so return success status// class SimpleContentModelimport DTDDVFactoryImplimport XML11DTDDVFactoryImpl/** The factory to create and return DTD types. The implementation should ... */String DEFAULT_FACTORY_CLASS;String XML11_DATATYPE_VALIDATOR_FACTORY;/** Get an instance of the default DTDDVFactory implementation. ... *//** Get an instance of DTDDVFactory implementation. ... */new DTDDVFactoryImpl(...)new XML11DTDDVFactoryImpl(...)new DVFactoryException(...)// can't create a new object of this class/** return a dtd type of the given name ... *//** get all built-in DVs, which are stored in a map keyed by the name ... *///fall back for compatibility/** A runtime exception that's thrown if an error happens when the application ... *//** Base class for datatype exceptions. For DTD types, the exception can be ... */// used to store error code and error substitution arguments/** Create a new datatype exception by providing an error code and a list ... *//** Return the error code ... *//** Return the list of error arguments ... *//** Overrides this method to get the formatted&localized error message. ... */import ValidationContext/** The interface that a DTD datatype must implement. The implementation of this ... *//** validate a given string against this DV ... *//** Datatype exception for invalid facet. This exception is only used by ... *//** Datatype exception for invalid values. ... */import SymbolHashimport XSObjectList/** Defines a factory API that enables applications to <p> ... *//** Get a default instance of SchemaDVFactory implementation. ... *//** Get an instance of SchemaDVFactory implementation. ... *///getInstance():  SchemaDVFactoryClassCastException e4/** Get a built-in simple type of the given name ... *//** get all built-in simple types, which are stored in a SymbolHash keyed by ... *//** Create a new simple type which is derived by restriction from another ... *//** Create a new simple type which is derived by list from another simple ... *//** Create a new simple type which is derived by union from a list of other ... */// if the class name is not specified, use the default oneimport ShortList/** Class to get the information back after content is validated. This info ... */String normalizedValue;/** The normalized value of a string value */Object actualValue;/** The actual value from a string value (QName, Boolean, etc.) ... */short actualValueType;/** The type of the actual value. It's one of the _DT constants ... */XSSimpleType memberType;/** If the type is a union type, then the member type which ... */...[] memberTypes;/** If ... */ShortList itemValueTypes;/** In the case the value is a list or a list of unions, this value ... *//** reset the state of this object */this.normalizedValuethis.actualValuethis.memberTypethis.memberTypes/** Return a string representation of the value. If there is an actual ... *//** ValidationContext has all the information required for the ... */// whether to validate against facets// whether to do extra id/idref/entity checking// whether we need to normalize the value that is passed!// are namespaces relevant in this context?// entity// id// idref// get symbol from symbol table// qname// Localeimport XSAnnotationimport XSObjectListImpl/** The class used to pass all facets to {@link XSSimpleType#applyFacets}. ... *//** value of length facet. */int minLength;/** value of minLength facet. */int maxLength;/** value of maxLength facet. */short whiteSpace;/** value of whiteSpace facet. */int totalDigits;/** value of totalDigits facet. */int fractionDigits;/** value of fractionDigits facet. */String pattern;/** string containing value of pattern facet, for multiple patterns values ... */Vector<> enumeration;/** Vector containing values of Enumeration facet, as String's. */Vector<> enumNSDecls;/** An array parallel to "Vector enumeration". It contains namespace context ... */String maxInclusive;/** value of maxInclusive facet. */String maxExclusive;/** value of maxExclusive facet. */String minInclusive;/** value of minInclusive facet. */String minExclusive;/** value of minExclusive facet. */XSAnnotation lengthAnnotation;XSAnnotation minLengthAnnotation;XSAnnotation maxLengthAnnotation;XSAnnotation whiteSpaceAnnotation;XSAnnotation totalDigitsAnnotation;XSAnnotation fractionDigitsAnnotation;XSObjectListImpl patternAnnotations;XSObjectList enumAnnotations;XSAnnotation maxInclusiveAnnotation;XSAnnotation maxExclusiveAnnotation;XSAnnotation minInclusiveAnnotation;XSAnnotation minExclusiveAnnotation;/** This interface <code>XSSimpleType</code> represents the simple type ... */short WS_PRESERVE;/** preserve the white spaces *//** constants defined for the values of 'whitespace' facet. ... */short WS_REPLACE;/** replace the white spaces */short WS_COLLAPSE;/** collapse the white spaces */short PRIMITIVE_STRING;/** "string" type *//** Constant defined for the primitive built-in simple tpyes. ... */short PRIMITIVE_BOOLEAN;/** "boolean" type */short PRIMITIVE_DECIMAL;/** "decimal" type */short PRIMITIVE_FLOAT;/** "float" type */short PRIMITIVE_DOUBLE;/** "double" type */short PRIMITIVE_DURATION;/** "duration" type */short PRIMITIVE_DATETIME;/** "dataTime" type */short PRIMITIVE_TIME;/** "time" type */short PRIMITIVE_DATE;/** "date" type */short PRIMITIVE_GYEARMONTH;/** "gYearMonth" type */short PRIMITIVE_GYEAR;/** "gYear" type */short PRIMITIVE_GMONTHDAY;/** "gMonthDay" type */short PRIMITIVE_GDAY;/** "gDay" type */short PRIMITIVE_GMONTH;/** "gMonth" type */short PRIMITIVE_HEXBINARY;/** "hexBinary" type */short PRIMITIVE_BASE64BINARY;/** "base64Binary" type */short PRIMITIVE_ANYURI;/** "anyURI" type */short PRIMITIVE_QNAME;/** "QName" type */short PRIMITIVE_PRECISIONDECIMAL;/** "precisionDecimal" type */short PRIMITIVE_NOTATION;/** "NOTATION" type *//** return an ID representing the built-in primitive base type. ... *//** validate a given string against this simple type. ... *//** validate a given string value, represented by content.toString(). ... *//** Validate an actual value against this simple type. ... *//** If this type is created from restriction, then some facets can be applied ... *//** Check whether two actual values are equal. ... *//** Check whether this type is or is derived from ID. ... *///public short compare(Object value1, Object value2);/** Check the order of the two actual values. (May not be supported by all ... *//** Return the whitespace corresponding to this datatype. ... *//** the factory to create/return built-in schema DVs and create user-defined DVs ... */Map<String,DatatypeValidator> builtInTypesnew HashMap<String,DatatypeValidator>(...)DatatypeValidator dvTempnew StringDatatypeValidator(...)new IDDatatypeValidator(...)new IDREFDatatypeValidator(...)new ListDatatypeValidator(...)new ENTITYDatatypeValidator(...)new NOTATIONDatatypeValidator(...)new NMTOKENDatatypeValidator(...)Map<String,DatatypeValidator> fBuiltInTypes;/** get all built-in DVs, which are stored in a Map keyed by the name ... */// DTDDVFactoryImplimport com.sun.org.apache.xerces.internal.impl.dv.*/** <P>ENTITYDatatypeValidator implements the ... */// construct an ENTITY datatype validator/** Checks that "content" string is valid ID value. ... */isEntityUnparsed(...)new InvalidDatatypeValueException(...)/** <P>IDDatatypeValidator - ID represents the ID attribute ... */// construct an ID datatype validatoruseNamespaces(...)isIdDeclared(...)addId(...)//Check if is valid key-[81] EncName ::= [A-Za-z] ([A-Za-z0-9._] | '-')*/** <P>IDREFDatatypeValidator - represents the IDREFS ... */// construct an IDREF datatype validator/** Checks that "content" string is valid IDREF value. ... */addIdRef(...)/** For list types: ENTITIES, IDREFS, NMTOKENS. ... */DatatypeValidator fItemValidator;// the type of items in the list// construct a list datatype validator/** Checks that "content" string is valid. ... */StringTokenizer parsedListint numberOfTokensthis.fItemValidator//Check each token in list against base type/** NMTOKEN datatype validator. ... */// construct a NMTOKEN datatype validator/** Checks that "content" string is valid NMTOKEN value. ... */// class NMTOKENDatatypeValidator/** NOTATIONValidator defines the interface that data type validators must obey. ... */// construct a NOTATION datatype validator/** Checks that "content" string is valid NOTATION value. ... *//** <P>StringValidator validates that XML content is a W3C string type.</P> ... */// construct a string datatype validator/** Checks that "content" string is valid string value. ... *//** the factory to create/return built-in XML 1.1 DVs and create user-defined DVs ... */Map<String,DatatypeValidator> xml11BuiltInTypesnew XML11IDREFDatatypeValidator(...)new XML11IDDatatypeValidator(...)new XML11NMTOKENDatatypeValidator(...)Map<String,DatatypeValidator> XML11BUILTINTYPES;// <clinit>HashMap<String,DatatypeValidator> toReturn//XML11DTDDVFactoryImpl/** NMTOKEN datatype validator for NMTokens from XML 1.1. ... */// class XML11NMTOKENDatatypeValidator/** This class provides encode/decode for RFC 2045 Base64 as ... */int BASELENGTH;int LOOKUPLENGTH;int TWENTYFOURBITGROUP;int EIGHTBIT;int SIXTEENBIT;int SIXBIT;int FOURBYTE;int SIGN;char PAD;boolean fDebug;...[] base64Alphabet;...[] lookUpBase64Alphabet;isData(...)isPad(...)/** Encodes hex octects into Base64 ... */int lengthDataBitsbinaryData.lengthint fewerThan24bitsint numberTripletsint numberQuartetchar[] encodedDatabyte kbyte lbyte b1byte b2byte b3int encodedIndexint dataIndexbyte val1byte val2byte val3/** Decodes Base64 data into octects ... */char[] base64DataremoveWhiteSpace(...)int numberQuadruplebyte[] decodedDatabyte b4char d1char d2char d3char d4/** remove WhiteSpace from MIME containing encoded Base64 data. ... */// form integral number of 6-bit groups// remove white spaces//should be divisible by four//if found "no data" just return null//Check if they are PAD characters//Two PAD e.g. 3c[Pad][Pad]//last 4 bits should be zero//One PAD  e.g. 3cQ[Pad]//last 2 bits should be zero//an error  like "3c[Pad]r", "3cdX", "3cXd", "3cXX" where X is non data//No PAD e.g 3cQl// count characters that's not whitespaceimport XSExceptionimport ByteList/** Implementation of <code>com.sun.org.apache.xerces.internal.xs.datatypes.ByteList</code>. ... */// actually data stored in a byte arrayString canonical;// canonical representation of the data/** The number of <code>byte</code>s in the list. The range of ... *//** Checks if the <code>byte</code> <code>item</code> is a ... *//** Returns the <code>index</code>th item in the collection. The index ... */new XSException(...)XSException.INDEX_SIZE_ERR/* List methods *//* Copyright 2004 The Apache Software Foundation. ... *//** format validation ... */...[] hexNumberTable;...[] lookUpHexAlphabet;/** Encode a byte array to hex string ... */int lengthDataint lengthEncode/** Decode hex string to a byte array ... */char[] binaryDataint lengthDecodebyte temp1byte temp2char tempCharimport DatatypeFactoryimport Durationimport XMLGregorianCalendarimport DatatypeFactoryImplimport XSDateTime/** This is the base class of all date/time datatype validators. ... */new DatatypeFactoryImpl(...)//debuggingint YEAR;//all date/time excluding duration//define constants to be used in assigning default values for//define shared variables for date/timeint MONTH;int DAY;DatatypeFactory datatypeFactory;XSSimpleTypeDecl.FACET_MINEXCLUSIVEXSSimpleTypeDecl.FACET_MAXEXCLUSIVEXSSimpleTypeDecl.FACET_MININCLUSIVEXSSimpleTypeDecl.FACET_MAXINCLUSIVEXSSimpleTypeDecl.FACET_ENUMERATIONXSSimpleTypeDecl.FACET_PATTERNXSSimpleTypeDecl.FACET_WHITESPACE// remembered timezones are now equal but not identical.// ie: two values representing the same "moment in time" but with different// distinguishes between identity and equality for date/time values//getAllowedFacets()DateTimeData v1DateTimeData v2v1.timezoneHrv2.timezoneHrv1.timezoneMinv2.timezoneMin// the parameters are in compiled form (from getActualValue)//isIdentical()compareDates(...)/** Compare algorithm described in dateDime (3.2.7). Duration datatype ... *///compare()short c1short c2DateTimeData tempDatenew DateTimeData(...)date1.utcdate2.utccompareOrder(...)cloneDate(...)tempDate.timezoneHrtempDate.timezoneMintempDate.utcdateToString(...)/** Given normalized values, determines order-relation between give date/time ... */date1.positiondate1.yeardate2.yeardate1.monthdate2.monthdate1.daydate2.daydate1.hourdate2.hourdate1.minutedate2.minutedate1.seconddate2.second/** Parses time hh:mm:ss.sss and time zone if any ... */int signfindUTCSign(...)data.hourdata.minutedata.secondparseSecond(...)/** Parses date CCYY-MM-DD ... */getYearMonth(...)date.day/** Parses date CCYY-MM ... */date.yearparseIntYear(...)date.month/** Shared code from Date and YearMonth datatypes. Finds if time zone sign is ... */isNextCharUTCSign(...)/** Parses time zone: 'Z' or {+,-} followed by hh:mm ... */data.utcint negatedata.timezoneHrdata.timezoneMindata.normalized/** Computes index of given char within StringBuffer ... *//** Validates given date/time object accoring to W3C PR Schema [D.1 ISO 8601 ... */Constants.SCHEMA_1_1_SUPPORTdata.yeardata.monthdata.daymaxDayInMonthFor(...)/** Return index of UTC char: 'Z', '+', '-' ... *//** Returns ... *//** Given start and end position, parses string value ... */getDigit(...)// parse Year differently to support negative value./** If timezone present - normalize dateTime [E Adding durations to ... */date.minutedate.timezoneMinint carryfQuotient(...)mod(...)date.hourdate.timezoneHrmodulo(...)date.utcdate.unNormYeardate.unNormMonthdate.unNormDaydate.unNormHourdate.unNormMinutedate.unNormSeconddate.second/** Resets object representation of date/time ... *//** Given {year,month} computes maximum number of days for given month ... */isLeapYear(...)// help function described in W3C PR Schema [E Adding durations to dateTimes]StringBuffer messageappend2(...)append3(...)String dint expint integerEnd//Private help functionstempDate.yearfinalValue.yeartempDate.monthfinalValue.monthtempDate.dayfinalValue.daytempDate.hourfinalValue.hourtempDate.minutefinalValue.minutetempDate.secondfinalValue.secondfinalValue.utcfinalValue.timezoneHrfinalValue.timezoneMinAbstractDateTimeDV$DateTimeData/** Represents date time data */int year, ...;double second;int timezoneHr, ...;String originalValue;boolean normalized;int unNormYear;int unNormMonth;int unNormDay;int unNormHour;int unNormMinute;double unNormSecond;// a date/time based data type.// used for comparisons - to decide the 'interesting' portions ofAbstractDateTimeDV type;// statically created XXXDV objects, so this won't cause any GC problem.// note that this is not the actual simple type, but one of the// a pointer to the type that was used go generate this datathis.originalValuethis.yearthis.monththis.daythis.hourthis.minutethis.utc// cache the result of the conversion...// The DateTimeData is unfortunately mutable - so we cannot// we return its hashcode.// hashcode. This means we need to convert the date to UTC before// If two DateTimeData are equals - then they should have the sameDateTimeData dtdt.normalizedthis.normalizeddt.canonicalthis.canonicaldt.positiondt.timezoneHrthis.timezoneHrdt.timezoneMinthis.timezoneMindt.unNormYearthis.unNormYeardt.unNormMonththis.unNormMonthdt.unNormDaythis.unNormDaydt.unNormHourthis.unNormHourdt.unNormMinutethis.unNormMinutedt.unNormSecondthis.unNormSecondgetXMLGregorianCalendar(...)getDuration(...)BigDecimal _valdata.unNormSecond// original timezones must be the same in addition to date/time values// being 'equal'//compare date1<=date1<=(date2 with time zone -14)//clones date1 value to global temporary storage: fTempDate//compare date1>=(date2 with time zone +14)//clones date1 value to global temporary storage: tempDate//compare (date1 with time zone -14)<=date2//compare (date1 with time zone +14)<=date2//get hours (hh)//get minutes (mm)//get seconds (ss)//find UTC sign if any//get seconds (ms)//parse UTC time zone (hh:mm)// REVISIT: date starts with preceding '-' sign//          do we have to do anything with it?//fStart points right after the MONTH//fStart points right after the date//parse hr//parse min//REVISIT: should we throw an exception for not valid dates//          or reporting an error message should be sufficient?/** XML Schema 1.1 - RQ-123: Allow year 0000 in date related types. *///validate days//validate hours//validate//REVISIT: more testing on this parsing needs to be done.// REVISIT: we have common code in addDuration() for durations//          should consider reorganizing it.//add minutes (from time zone)//add hours//REVISIT: should we take care about Julian calendar?//modulo(a, b) = a - fQuotient(a,b)*b//fQuotient(a, b) = the greatest integer less than or equal to a/b//modulo(a - low, high - low) + low//fQuotient(a - low, high - low)// Need to convert from scientific notation of the form// n.nnn...E-N (N >= 4) to a normal decimal value.// It's only possible if String.valueOf(double) is broken.// Remove trailing zeros.// Now append the digits to the end. Skip over the decimal point.// n.nnn...EN (N >= 7) to a normal decimal value.// Append trailing zeroes if necessary./** Represent the schema type "anyAtomicType" ... */// class AnyAtomicDV/** Represent the schema type "anySimpleType" ... */// anySimpleType doesn't allow any facet, not even whiteSpace// class AnySimpleDV/** Represent the schema type "anyURI" ... */URI BASE_URI;XSSimpleTypeDecl.FACET_MAXLENGTHXSSimpleTypeDecl.FACET_LENGTHXSSimpleTypeDecl.FACET_MINLENGTH// for some types (string and derived), they just return the string itself// before we return string we have to make sure it is correct URI as per spec.String encoded// and non-ASCII characters (whose value >= 128).// special ASCII characters: 0x00~0x1F, 0x7F, ' ', '<', '>', etc.// To encode special characters in anyURI, by using %HH to represent// check 3.2.17.c0 must: URI (rfc 2396/2723)// encode special characters using XLink 5.4 algorithm// Support for relative URLs// According to Java 1.1: URLs may also be specified with a// String and the URL object that it is related to.// REVISIT: do we need to return the new URI object?// for each character in the anyURI// If encoding happened, create a new string;// otherwise, return the orginal one.// class AnyURIDVimport Base64import ByteListImpl/** Represent the schema type "base64Binary" ... */byte[] decodednew XBase64(...)// length of a binary type is the number of bytes/** represent base64 data */byte[] odataodata.length// class Base64BinaryDVimport SchemaDVFactoryimport XSFacetsimport XSConstantsnew SymbolHash(...)createBuiltInTypes(...)String URI_SCHEMAFORSCHEMA;SymbolHash fBaseTypes;// there are 27 types. 53 is the closest prime number to 27*2=54./** get all built-in simple types, which are stored in a hashtable keyed by ... */makeClone(...)new XSSimpleTypeDecl(...)int typeNummemberTypes.lengthXSSimpleTypeDecl[] mtypesnew XSSimpleTypeDecl[]// create all built-in typesString ANYSIMPLETYPEString ANYURIString BASE64BINARYString BOOLEANString BYTEString DATEString DATETIMEString DAYString DECIMALString INTString INTEGERString LONGString NEGATIVEINTEGERString MONTHString MONTHDAYString NONNEGATIVEINTEGERString NONPOSITIVEINTEGERString POSITIVEINTEGERString SHORTString STRINGString TIMEString UNSIGNEDBYTEString UNSIGNEDINTString UNSIGNEDLONGString UNSIGNEDSHORTString YEARString YEARMONTHXSFacets facetsnew XSFacets(...)XSSimpleTypeDecl anySimpleTypeXSSimpleTypeDecl.fAnySimpleTypeXSSimpleTypeDecl stringDVXSSimpleTypeDecl.DV_STRINGXSSimpleType.ORDERED_FALSEXSConstants.STRING_DTXSSimpleTypeDecl decimalDVXSSimpleTypeDecl.DV_DECIMALXSSimpleType.ORDERED_TOTALXSConstants.DECIMAL_DTXSSimpleTypeDecl integerDVXSSimpleTypeDecl.DV_INTEGERXSConstants.INTEGER_DTXSSimpleTypeDecl nonPositiveDVXSConstants.NONPOSITIVEINTEGER_DTXSSimpleTypeDecl negativeDVXSConstants.NEGATIVEINTEGER_DTXSSimpleTypeDecl longDVXSConstants.LONG_DTXSSimpleTypeDecl intDVXSConstants.INT_DTXSSimpleTypeDecl shortDVXSConstants.SHORT_DTXSSimpleTypeDecl byteDVXSConstants.BYTE_DTXSSimpleTypeDecl nonNegativeDVXSConstants.NONNEGATIVEINTEGER_DTXSSimpleTypeDecl unsignedLongDVXSConstants.UNSIGNEDLONG_DTXSSimpleTypeDecl unsignedIntDVXSConstants.UNSIGNEDINT_DTXSSimpleTypeDecl unsignedShortDVXSConstants.UNSIGNEDSHORT_DTXSSimpleTypeDecl unsignedByteDVXSConstants.UNSIGNEDBYTE_DTXSSimpleTypeDecl positiveIntegerDVXSConstants.POSITIVEINTEGER_DTXSSimpleTypeDecl.DV_BOOLEANXSConstants.BOOLEAN_DTXSSimpleTypeDecl.DV_ANYURIXSConstants.ANYURI_DTXSSimpleTypeDecl.DV_BASE64BINARYXSConstants.BASE64BINARY_DTXSSimpleTypeDecl.DV_DATETIMEXSSimpleType.ORDERED_PARTIALXSConstants.DATETIME_DTXSSimpleTypeDecl.DV_TIMEXSConstants.TIME_DTXSSimpleTypeDecl.DV_DATEXSConstants.DATE_DTXSSimpleTypeDecl.DV_GYEARMONTHXSConstants.GYEARMONTH_DTXSSimpleTypeDecl.DV_GYEARXSConstants.GYEAR_DTXSSimpleTypeDecl.DV_GMONTHDAYXSConstants.GMONTHDAY_DTXSSimpleTypeDecl.DV_GDAYXSConstants.GDAY_DTXSSimpleTypeDecl.DV_GMONTHXSConstants.GMONTH_DTfacets.maxInclusiveapplyFacets1(...)XSSimpleType.FACET_MAXINCLUSIVEfacets.minInclusiveXSSimpleType.FACET_MININCLUSIVE// base schema simple type names//createBuiltInTypes(SymbolHash)//BaseDVFactoryimport XSDeclarationPool/** the base factory to create/return built-in schema DVs and create user-defined DVs ... */XSDeclarationPool fDeclPool;// create common built-in typesString DOUBLEString DURATIONString ENTITYString ENTITIESString FLOATString HEXBINARYString IDREFString IDREFSString NAMEString NCNAMEString NMTOKENString NMTOKENSString LANGUAGEString NORMALIZEDSTRINGString NOTATIONString QNAMEString TOKENXSSimpleTypeDecl durationDVXSSimpleTypeDecl.DV_DURATIONXSConstants.DURATION_DTXSSimpleTypeDecl normalizedDVXSConstants.NORMALIZEDSTRING_DTXSSimpleTypeDecl tokenDVXSConstants.TOKEN_DTXSSimpleTypeDecl languageDVXSConstants.LANGUAGE_DTXSSimpleTypeDecl nameDVXSConstants.NAME_DTXSSimpleTypeDecl ncnameDVXSConstants.NCNAME_DTXSSimpleTypeDecl idrefDVXSSimpleTypeDecl.DV_IDREFXSConstants.IDREF_DTXSSimpleTypeDecl tempDVXSSimpleTypeDecl idrefsDVXSSimpleTypeDecl entityDVXSSimpleTypeDecl.DV_ENTITYXSConstants.ENTITY_DTXSSimpleTypeDecl entitiesDVXSSimpleTypeDecl nmtokenDVXSConstants.NMTOKEN_DTXSSimpleTypeDecl nmtokensDVXSSimpleTypeDecl.DV_FLOATXSConstants.FLOAT_DTXSSimpleTypeDecl.DV_DOUBLEXSConstants.DOUBLE_DTXSSimpleTypeDecl.DV_HEXBINARYXSConstants.HEXBINARY_DTXSSimpleTypeDecl.DV_NOTATIONXSConstants.NOTATION_DTfacets.whiteSpaceXSSimpleType.WS_REPLACEXSSimpleType.FACET_WHITESPACEXSSimpleType.WS_COLLAPSEfacets.patternXSSimpleType.FACET_PATTERNXSSimpleTypeDecl.SPECIAL_PATTERN_NAMEXSSimpleTypeDecl.SPECIAL_PATTERN_NCNAMEXSSimpleTypeDecl.DV_QNAMEXSConstants.QNAME_DTXSSimpleTypeDecl.DV_IDXSConstants.ID_DTfacets.minLengthXSSimpleType.FACET_MINLENGTHXSSimpleTypeDecl.SPECIAL_PATTERN_NMTOKEN//createBuiltInTypes()XSSimpleTypeDecl stgetSimpleTypeDecl(...)setRestrictionValues(...)setListValues(...)setUnionValues(...)/** Implementation internal * */// all schema simple type names//BaseSchemaDVFactory/** Represent the schema type "boolean" ... */...[] fValueSpace;Boolean ret// class BooleanDVimport DatatypeConstants/** Validator for <date> datatype (W3C Schema datatypes) ... *//** Parses, validates and computes normalized version of dateTime object ... */DateTimeData dateparseTimeZone(...)validateDateTime(...)saveUnnormalized(...)newXMLGregorianCalendar(...)DatatypeConstants.FIELD_UNDEFINEDhasTimeZone(...)//validate and normalize//REVISIT: do we need SchemaDateTimeException?//save unnormalized values/** Validator for &lt;dateTime&gt; datatype (W3C Schema Datatypes) ... */int dateEndgetFractionalSecondsAsBigDecimal(...)// both time and date//Check the separator character between Date and Time/** Validator for &lt;gDay&gt; datatype (W3C Schema datatypes) ... */int DAY_SIZE;//size without time zone: ---09/** Parses, validates and computes normalized version of gDay object ... */new SchemaDateTimeException(...)date.position/** Converts gDay object representation to String ... *///initialize values/** Used to validate the <dayTimeDuration> type ... */DurationDV.DAYTIMEDURATION_TYPEnewDuration(...)import XSDecimal/** Represent the schema type "decimal" ... */XSSimpleTypeDecl.FACET_FRACTIONDIGITSXSSimpleTypeDecl.FACET_TOTALDIGITSnew XDecimal(...)(...).totalDigits(...).fracDigitsDecimalDV$XDecimal// Avoid using the heavy-weight java.math.BigDecimalint sign;// sign: 0 for vlaue 0; 1 for positive values; -1 for negative values// total digits. >= 1int intDigits;// integer digits when sign != 0int fracDigits;// fraction digits when sign != 0String ivalue;// the string representing the integer partString fvalue;// the string representing the fraction partboolean integer;// whether the canonical form contains decimal pointinitD(...)initI(...)int intStartint intEndint fracStartint fracEndint actualIntStartint fracPosXDecimal ovaloval.signoval.intDigitsoval.fracDigitsoval.ivalueoval.fvaluethis.signthis.intDigitsthis.fracDigitsthis.ivaluethis.fvalueval.signintComp(...)val.ivalueval.intDigitsval.fvaluemakeCanonical(...)BigInteger.ZEROparseShort(...)// these 4 variables are used to indicate where the integre/fraction// parts start/end.// Deal with leading sign symbol if present// skip '+', so intStart should be 1// keep '-', so intStart is stil 0// skip leading zeroes in integer part// Find the ending position of the integer part// Not reached the end yet// the remaining part is not ".DDD", error// fraction part starts after '.', and ends at the end of the input// no integer part, no fraction part, error.// ignore trailing zeroes in fraction part// check whether there is non-digit characters in the fraction part// ".00", treat it as "0"// these 2 variables are used to indicate where the integre start/end.// Not reached the end yet, error// no integer part, error.// "00", treat it as "0"// for -0.1, total digits is 1, so we need 3 extra spots// class DecimalDVimport XSDouble/** Represent the schema type "double" ... *///convert a String to Double form, we have to take care of cases specified in spec like INF, -INF and NaNnew XDouble(...)// Can't call Double#compareTo method, because it's introduced in jdk 1.2//getActualValue()//0.0 is equal but not identical to -0.0//distinguishes between identity and equality for double datatypeisIdentical(...)/** Returns true if it's possible that the given ... */DoubleDV$XDoubleisPossibleFP(...)Double.POSITIVE_INFINITYXDouble ovaloval.valuelong v// NOTE: 0.0 is equal but not identical to -0.0val.valuedouble ovalint edpint dpint nzp// NOTE: we don't distinguish 0.0 from -0.0// This check is necessary because doubleToLongBits(+0) != doubleToLongBits(-0)// this < other// this > other// this == other// one of the 2 values or both is/are NaN(s)// this = NaN = other// this is NaN <> other// other is NaN <> this// REVISIT: use the java algorithm for now, because we// don't know what to output for 1.1d (which is no// actually 1.1)// if it contains 'E', then it should be a valid schema// canonical representation// at most 3 longer: E, -, 9// expected decimal point position// for non-zero integer part// decimal point position// move the digits: ddd.d --> d.ddd// trim trailing zeros: d00.0 --> d.000 --> d.// add the last zero if necessary: d. --> d.0// append E: d.dd --> d.ddE// how far we shifted the decimal point// append the exponent --> d.ddEd// the exponent is at most 7// non-zero digit point// skip zeros: 0.003// put the first non-zero digit to the left of '.'// move other digits (non-zero) to the right of '.'// adjust the length// append 0 if nessary: 0.03 --> 3. --> 3.0// append E-: d.dd --> d.ddE-// the exponent is at most 3// class DoubleDV/** Validator for &lt;duration&gt; datatype (W3C Schema Datatypes) ... */new DateTimeData[]int DURATION_TYPE;int YEARMONTHDURATION_TYPE;int DAYTIMEDURATION_TYPE;...[] DATETIMES;// the dates are in format: {CCYY,MM,DD, H, S, M, MS, timezone}// see 3.2.6 duration W3C schema datatype specs// duration x and y is x<=y iff s+x<=s+y// for comparison of 2 durations, based on the fact that// order-relation on duration is a partial order. The dates below are used to/** Parses, validates and computes normalized version of duration object ... */boolean designatorint endDate/** Compares 2 given durations. (refer to W3C Schema Datatypes "3.2.6 duration") ... */short resultAshort resultBDateTimeData[] resultDateTimeData tempAaddDuration(...)DateTimeData tempBcompareResults(...)addto.monthdouble dtempaddto.secondresetDateObj(...)duration.monthduration.yearaddto.yearduration.secondaddto.minuteduration.minuteaddto.hourduration.hourduration.dayaddto.dayduration.utc//negative duration//at least one number and designator must be seen after P//find 'Y'//scan year//scan month//scan day//scan hours, minutes, seconds//REVISIT: can any item include a decimal fraction or only seconds?//scan hours//scan min//scan seconds// no additional data shouls appear after last item// P1Y1M1DT is illigal value as well//REVISIT: this is unoptimazed vs of comparing 2 durations//         Algorithm is described in 3.2.6.2 W3C Schema Datatype specs//add constA to both durations//try and see if the objects are equal//long comparison algorithm is required//REVISIT: some code could be shared between normalize() and this method,//         however is it worth moving it? The structures are different...//add months (may be modified additionaly below)//add years (may be modified additionaly below)//add seconds//add minutes//original duration was negative/** Represent the schema type "entity" ... */// class EntityDV/** A special factory to create/return built-in schema DVs and create user-defined DVs ... */SymbolHash fBuiltInTypes;String ANYATOMICTYPEString YEARMONTHDURATIONString DAYTIMEDURATIONXSSimpleTypeDecl.fAnyAtomicTypeXSSimpleTypeDecl.DV_YEARMONTHDURATIONXSSimpleTypeDecl.YEARMONTHDURATION_DTXSSimpleTypeDecl.DV_DAYTIMEDURATIONXSSimpleTypeDecl.DAYTIMEDURATION_DT// add anyAtomicType// add 2 duration typesimport XSFloat/** Represent the schema type "float" ... *///convert a String to Float form, we have to take care of cases specified in spec like INF, -INF and NaNnew XFloat(...)// Can't call Float#compareTo method, because it's introduced in jdk 1.2//distinguishes between identity and equality for float datatypeFloatDV$XFloatFloat.POSITIVE_INFINITYFloat.NEGATIVE_INFINITYFloat.NaNXFloat ovalfloat oval// This check is necessary because floatToIntBits(+0) != floatToIntBits(-0)// don't know what to output for 1.1f (which is no// class FloatDVSymbolHash fFullTypes;// there are 45 types. 89 is the closest prime number to 45*2=90.// create base types first// full schema simple type names//XFormsDVFactoryimport HexBin/** Represent the schema type "hexBinary" ... */new XHex(...)/** Represent the schema type "ID" ... */// class IDDV/** Represent the schema type "IDREF" ... *///IDREF class/** Represent the schema type "integer" ... */import ObjectList/** Represent the schema list types ... */// calling the item type for the convertion// this method should never be called: XSSimpleTypeDecl is responsible for// length of a list type is the number of items in the listListDV$ListDataObject[] odata//end of loop//everything went fine.// class ListDV/** Validator for &lt;gMonth&gt; datatype (W3C Schema Datatypes) ... *//** Convert a string to a compiled form ... *//** Parses, validates and computes normalized version of gMonth object ... *//** Converts month object representation to String ... *//* protected  short compareDates(DateTimeData date1, DateTimeData date2) { ... *//** Overwrite compare algorithm to optimize month comparison ... *///set constants// REVISIT: allow both --MM and --MM-- now.// need to remove the following 4 lines to disallow --MM--// when the errata is offically in the rec./** Validator for &lt;gMonthDay&gt; datatype (W3C Schema Datatypes) ... */int MONTHDAY_SIZE;//size without time zone: --MM-DD/** Parses, validates and computes normalized version of gMonthDay object ... *//** Converts gMonthDay object representation to String ... *//** Validator for <precisionDecimal> datatype (W3C Schema 1.1) ... */PrecisionDecimalDV$XPrecisionDecimal// sign: 0 for absent; 1 for positive values; -1 for negative values (except in case of INF, -INF)//int precision = 0;//precisionint pvalue;// and [1-9].[0-9]*[1-9]?(E[1-9][0-9]*)? for other numbers.// NaN for NaN, INF for +infinity, -INF for -infinity, 0 for zero,// The toString representation will be:// equals.// for the purpose of deriving a hashCode value compliant with// Construct a canonical String representation of this numberStringBuilder builderint ilenint flen0int lastNonZeroint iStartint exponentint fStartXPrecisionDecimal ovalcanonicalToStringForHashCode(...)StringBuffer temp1StringBuffer temp2truncateTrailingZeros(...)deleteCharAt(...)// to the max value of int.// To enable comparison - the exponent part of the decimal will be limitedval.pvalueint expDiffStringBuffer fbuffercompareDecimal(...)val.fracDigitsdecimal.ivaluedecimal.signdecimal.intDigitsdecimal.fracDigitsdecimal.pvaluedecimal.fvaluenew XPrecisionDecimal(...)// the remaining part is not ".DDD" or "EDDD" or "eDDD", error// find location of E or e (if present)// Find the ending position of the fracion part/* while (fracEnd > fracStart && content.charAt(fracEnd-1) == '0') { ... */// There's nothing else we can use easily, because equals could// return true for widely different representation of the// same number - and we don't have any canonical representation.// The problem here is that we must ensure that if two numbers// are equals then their hash code must also be equals.// hashCode for 1.01E1 should be the same as hashCode for 0.101E2// So we call cannonicalToStringForHashCode - which implements an// algorithm that invents a normalized string representation// for this number, and we return a hash for that.// seen NaN//INF is greater than everything and equal to itself//-INF is smaller than everything and equal itself//otherwise the 2 combined values are the same// REVISIT: to be determined by working groupimport XSQName/** Represent the schema type "QName" and "NOTATION" ... */int colonptrgetSymbol(...)new XQName(...)//          now we just return the length of the rawname// REVISIT: qname and notation shouldn't support length facets.(...).rawname/** represent QName data *//** Constructs a QName with the specified values. */// <init>(String,String,String,String)// equals(Object):boolean// get prefix and local part out of content// both prefix (if any) a nd localpart must be valid NCName// resove prefix to a uri, report an error if failed// class QNameDVDV// TODO: move specific 1.0 DV implementation from base//SchemaDVFactoryImpl/** Represent the schema type "string" ... */// class StringDV/** Validator for &lt;time&gt; datatype (W3C Schema Datatypes) ... *//** Parses, validates and computes normalized version of time object ... *//** Converts time object representation to String ... */// time// initialize to default values/** All primitive types plus ID/IDREF/ENTITY/INTEGER are derived from this abstract ... */// which facets are allowed for this type// get the BigDecimal, Double, Flout object.// for number types (decimal, double, float, and types derived from them),// convert a string to an actual value. for example,// facets// checked to be valid with respect to both lexical representation and// for ID/IDREF/ENTITY types, do some extra checking after the value isshort LESS_THAN;//order constants// doesn't support it.// and it's an *internal* error if a method is called on a DV that// but XSSimpleTypeDecl should know which type supports which methods,// the following methods might not be supported by every DV.short EQUAL;short GREATER_THAN;short INDETERMINATE;// -0.0 from 0.0// checks whether the two values are identical; for ex, this distinguishes// will be overwritten// where there is distinction between identity and equality, this method// check the order relation between the two values// get the length of the value// get the number of digits of the value// get the number of fraction digits of the value// check whether the character is in the range 0x30 ~ 0x39// otherwise, return -1// if the character is in the range 0x30 ~ 0x39, return its int value (0~9),// interface TypeValidator/** Represent the schema union types ... */// calling the member types for the convertion// class UnionDVimport DatatypeExceptionimport InvalidDatatypeFacetExceptionimport ValidatedInfoimport RegularExpressionimport SchemaSymbolsimport ShortListImplimport StringListImplimport StringListimport XSFacetimport XSMultiValueFacetimport XSNamespaceItem/** @xerces.internal ... */new TypeValidator[]new AnySimpleDV(...)new StringDV(...)new BooleanDV(...)new DecimalDV(...)new FloatDV(...)new DoubleDV(...)new DurationDV(...)new DateTimeDV(...)new TimeDV(...)new DateDV(...)new YearMonthDV(...)new YearDV(...)new MonthDayDV(...)new DayDV(...)new MonthDV(...)new HexBinaryDV(...)new Base64BinaryDV(...)new AnyURIDV(...)new QNameDV(...)new PrecisionDecimalDV(...)new IDDV(...)new IDREFDV(...)new EntityDV(...)new IntegerDV(...)new ListDV(...)new UnionDV(...)new YearMonthDurationDV(...)new DayTimeDurationDV(...)new AnyAtomicDV(...)new ValidationContext(...) { ... }XSSimpleTypeDecl$1XSConstants.ANYSIMPLETYPE_DTXSSimpleTypeDecl.ANYATOMICTYPE_DTXSSimpleTypeDecl$4short DV_STRING;short DV_BOOLEAN;short DV_DECIMAL;short DV_FLOAT;short DV_DOUBLE;short DV_DURATION;short DV_DATETIME;short DV_TIME;short DV_DATE;short DV_GYEARMONTH;short DV_GYEAR;short DV_GMONTHDAY;short DV_GDAY;short DV_GMONTH;short DV_HEXBINARY;short DV_BASE64BINARY;short DV_ANYURI;short DV_QNAME;short DV_PRECISIONDECIMAL;short DV_NOTATION;short DV_ANYSIMPLETYPE;short DV_ID;short DV_IDREF;short DV_ENTITY;short DV_INTEGER;short DV_LIST;short DV_UNION;short DV_YEARMONTHDURATION;short DV_DAYTIMEDURATION;short DV_ANYATOMICTYPE;...[] gDVs;short NORMALIZE_NONE;short NORMALIZE_TRIM;short NORMALIZE_FULL;...[] fDVNormalizeType;short SPECIAL_PATTERN_NONE;short SPECIAL_PATTERN_NMTOKEN;short SPECIAL_PATTERN_NAME;short SPECIAL_PATTERN_NCNAME;...[] SPECIAL_PATTERN_STRING;...[] WS_FACET_STRING;String ANY_TYPE;short YEARMONTHDURATION_DT;// XML Schema 1.1 type constantsshort DAYTIMEDURATION_DT;short PRECISIONDECIMAL_DT;short ANYATOMICTYPE_DT;int DERIVATION_ANY;// DOM Level 3 TypeInfo Derivation Method constantsint DERIVATION_RESTRICTION;int DERIVATION_EXTENSION;int DERIVATION_UNION;int DERIVATION_LIST;ValidationContext fEmptyContext;...[] fDVs;// may not be permitted to have any effect).// and hence must remain immutable (i.e., applyFacets// this will be true if this is a static XSSimpleTypeDeclXSSimpleTypeDecl fItemType;...[] fMemberTypes;short fBuiltInKind;// The most specific built-in type kind.String fTypeName;String fTargetNamespace;short fFinalSet;XSSimpleTypeDecl fBase;short fVariety;short fValidationDV;short fFacetsDefined;short fFixedFacet;short fWhiteSpace;//for constraining facetsint fMinLength;int fMaxLength;int fTotalDigits;int fFractionDigits;Vector<> fPattern;Vector<> fPatternStr;Vector<> fEnumeration;...[] fEnumerationType;...[] fEnumerationItemType;ShortList fEnumerationTypeList;// used in case fenumerationType value is LIST or LISTOFUNIONObjectList fEnumerationItemTypeList;StringList fLexicalPattern;StringList fLexicalEnumeration;ObjectList fActualEnumeration;Object fMaxInclusive;Object fMaxExclusive;Object fMinExclusive;Object fMinInclusive;// annotations for constraining facetsXSObjectList enumerationAnnotations;XSObjectListImpl fFacets;// facets as objectsXSObjectListImpl fMultiValueFacets;// enumeration and pattern facetsXSObjectList fAnnotations;// simpleType annotationsshort fPatternType;short fOrdered;// for fundamental facetsboolean fFinite;boolean fBounded;boolean fNumeric;XSNamespaceItem fNamespaceItem;// of the simple type definition, if it is globally declared; or null otherwise.// The namespace schema information item corresponding to the target namespace// default constructor//Create a new built-in primitive types (and id/idref/entity/integer/yearMonthDuration)this.fOrderedthis.fBoundedthis.fFinitethis.fNumeric//Create a new simple type for restriction for built-in types//Create a new simple type for restriction.fBase.fVarietyfBase.fValidationDVfBase.fItemTypefBase.fMemberTypesfBase.fLengthfBase.fMinLengthfBase.fMaxLengthfBase.fPatternfBase.fPatternStrfBase.fEnumerationfBase.fEnumerationTypefBase.fEnumerationItemTypefBase.fWhiteSpacefBase.fMaxExclusivefBase.fMaxInclusivefBase.fMinExclusivefBase.fMinInclusivefBase.fTotalDigitsfBase.fFractionDigitsfBase.fPatternTypefBase.fFixedFacetfBase.fFacetsDefinedfBase.lengthAnnotationfBase.minLengthAnnotationfBase.maxLengthAnnotationfBase.patternAnnotationsfBase.enumerationAnnotationsfBase.whiteSpaceAnnotationfBase.maxExclusiveAnnotationfBase.maxInclusiveAnnotationfBase.minExclusiveAnnotationfBase.minInclusiveAnnotationfBase.totalDigitsAnnotationfBase.fractionDigitsAnnotationcalcFundamentalFacets(...)base.fBuiltInKind//Create a new simple type for list.XSConstants.LIST_DT//Create a new simple type for union.//set values for restriction.//set values for list.//set values for union.XSConstants.TYPE_DEFINITIONgetAnonymous(...)fMemberTypes.lengthnew DatatypeException(...)/** Returns the closest built-in type category this type represents or ... */this.fBuiltInKind/** If variety is <code>atomic</code> the primitive type definition (a ... */XSSimpleTypeDecl pripri.fBase/** If variety is <code>list</code> the item type definition (an atomic or ... *//** If variety is <code>union</code> the list of member type definitions (a ... */new XSObjectListImpl(...)XSObjectListImpl.EMPTY_LIST/** If <restriction> is chosen */applyFacets(...)/** built-in derived types by restriction */InvalidDatatypeFacetException e/** If <restriction> is chosen, or built-in derived types by restriction */ValidatedInfo tempInfonew ValidatedInfo(...)short allowedFacetgetAllowedFacets(...)boolean needCheckBasefacets.lengthfacets.lengthAnnotationfacets.minLengthAnnotationfacets.maxLengthfacets.maxLengthAnnotationRegularExpression regexfacets.patternAnnotationsnew RegularExpression(...)getLocalizedMessage(...)facets.whiteSpaceAnnotationVector<> enumValsfacets.enumerationVector<> enumNSDeclsfacets.enumNSDeclsValidationContextImpl ctxnew ValidationContextImpl(...)new ShortList[]facets.enumAnnotationssetNSContext(...)ValidatedInfo infogetActualEnumValue(...)info.actualValueinfo.actualValueTypeinfo.itemValueTypesInvalidDatatypeValueException idegetBaseType(...)facets.maxInclusiveAnnotationgetActualValue(...)facets.maxExclusiveAnnotationfacets.maxExclusivefacets.minExclusiveAnnotationfacets.minExclusivefacets.minInclusiveAnnotationfacets.totalDigitsAnnotationfacets.totalDigitsfacets.fractionDigitsfacets.fractionDigitsAnnotationfBase.fBase.fMaxLengthfBase.fBasewhiteSpaceValue(...)addXSObject(...)/** validate a value, and return the compiled form *///applyFacets()boolean needNormalizeneedToNormalize(...)Object obvalidatedInfo.memberTypevalidateWithInfo(...)/** validate an actual value against this DV ... */needFacetChecking(...)checkFacets(...)needExtraChecking(...)checkExtraRules(...)validatedInfo.actualValuevalidatedInfo.normalizedValuevalidatedInfo.actualValueTypeShortList itemTypevalidatedInfo.itemValueTypesgetDataLength(...)boolean presentint enumSizeshort primitiveType1convertToPrimitiveKind(...)short primitiveType2XSConstants.LISTOFUNION_DTShortList enumItemTypeint typeList1Lengthint typeList2Lengthshort primitiveItem1short primitiveItem2getFractionDigits(...)int totalDigitsgetTotalDigits(...)ListDV.ListDataListData valuesXSSimpleType memberTypefItemType.fVarietyXSSimpleTypeDecl[] memberTypesvalidatedInfo.memberTypes//we can still return object for internal use.// checkExtraRules()String nvalueObject avalueboolean seenErrint countOfTokensObject[] avalueboolean isUniongetVariety(...)short[] itemTypesListData vnew ListData(...)fItemType.fBuiltInKindfItemType.fFacetsDefined...[...].fBuiltInKindnew ShortListImpl(...)itemTypes.lengthObject _contentStringBuffer typesBufferXSSimpleTypeDecl declObject aValue...[...].fFacetsDefinedInvalidDatatypeValueException invalidValuedecl.fTargetNamespacedecl.fTypeNamedecl.fEnumeration// determine whether the two values are identical//isEqual()// normalize the string according to the whiteSpace facetboolean isLeadingshort norm_typeString strContentsetCharAt(...)new InvalidDatatypeFacetException(...)/** Fundamental Facet: ordered. *//** Fundamental Facet: bounded. *//** Fundamental Facet: cardinality. *//** Fundamental Facet: numeric. *//** Convenience method. [Facets]: check whether a facet is defined on this ... *//** [facets]: all facets defined on this type. The value is a bit ... *//** Convenience method. [Facets]: check whether a facet is defined and ... *//** [facets]: all defined facets for this type which are fixed. *//** Convenience method. Returns a value of a single constraining facet for ... *//** A list of enumeration values if it exists, otherwise an empty ... */String[] strsStringListImpl.EMPTY_LISTnew StringListImpl(...)/** A list of actual enumeration values if it exists, otherwise an empty ... */new AbstractObjectList(...) { ... }XSSimpleTypeDecl$2/** A list of enumeration type values (as a list of ShortList objects) if it exists, otherwise returns ... */XSSimpleTypeDecl$3fEnumerationItemType.lengthShortListImpl.EMPTY_LISTfEnumerationType.length/** A list of pattern values if it exists, otherwise an empty ... *//** [annotations]: a set of annotations for this simple type component if ... */setOrdered(...)setNumeric(...)setBounded(...)setCardinality(...)fBase.fOrderedshort ancestorIdgetPrimitiveDV(...)...[...].fValidationDVboolean commonAncboolean allFalse...[...].fOrdered//setOrderedfBase.fNumericXSSimpleType[] memberTypesgetNumeric(...)//setNumericthis.fFacetsDefinedthis.fMemberTypesgetBounded(...)//setBounded//specialCardinalityCheck()fBase.fFinitespecialCardinalityCheck(...)getFinite(...)//setCardinality//getPrimitiveDV()XSTypeDefinition type/** Checks if a type is derived from another by restriction, given the name ... */SchemaSymbols.URI_SCHEMAFORSCHEMASchemaSymbols.ATTVAL_ANYTYPEisDerivedByRestriction(...)isDerivedByList(...)isDerivedByUnion(...)isDerivedByAny(...)/** Checks if a type is derived from another by any combination of restriction, list ir union. See: ... */boolean derivedFromXSTypeDefinition oldTypegetMemberTypes(...)getItemType(...)/** Checks if a type is derived from another by list. See: ... */XSTypeDefinition itemType/** Checks if a type is derived from another by union.  See: ... */XSObjectList memberTypesXSSimpleTypeDecl fAnySimpleType;XSSimpleTypeDecl fAnyAtomicType;ValidationContext fDummyContext;/** Validation context used to validate facet values. */boolean fAnonymous;XSSimpleTypeDecl$ValidationContextImpl/** A wrapper of ValidationContext, to provide a way of switching to a ... */ValidationContext fExternal;NamespaceContext fNSContext;// schema validation is predicated upon namespacesisEntityDeclared(...)this.fTypeNamethis.fTargetNamespace/** A list of constraining facets if it exists, otherwise an empty ... */XSFacetImpl[] facetsnew XSFacetImpl[]new XSFacetImpl(...)/** A list of enumeration and pattern constraining facets if it exists, ... */XSMVFacetImpl[] facetsnew XSMVFacetImpl[]new XSMVFacetImpl(...)getLexicalPattern(...)getLexicalEnumeration(...)XSSimpleTypeDecl$XSFacetImplshort kind;boolean fixed;XSObjectList annotations;this.fixedthis.annotations/** Optional. Annotation. *//** Optional. Annotations. */XSConstants.FACETXSSimpleTypeDecl$XSMVFacetImplStringList values;XSConstants.MULTIVALUE_FACETXSSimpleTypeDecl$AbstractObjectList/* Copyright 2001-2005 The Apache Software Foundation. ... */// XML Schema 1.1 type// notation use the same one as qname//AnySimpleDV(),//StringDV(),//BooleanDV(),//DecimalDV(),//FloatDV(),//DoubleDV(),//DurationDV(),//DateTimeDV(),//TimeDV(),//DateDV(),//YearMonthDV(),//YearDV(),//MonthDayDV(),//DayDV(),//MonthDV(),//HexBinaryDV(),//Base64BinaryDV(),  // Base64 know how to deal with spaces//AnyURIDV(),//QNameDV(),//PrecisionDecimalDV() (Schema 1.1)//QNameDV(),   // notation//IDDV(),//IDREFDV(),//EntityDV(),//IntegerDV(),//ListDV(),//UnionDV(),//YearMonthDurationDV() (Schema 1.1)//DayTimeDurationDV() (Schema 1.1)//AnyAtomicDV() (Schema 1.1)// To simplify the code for anySimpleType, we treat it as an atomic type// Specify the build in kind for this primitive type// Specify the build in kind for this built-in type// always inherit facets from the base.// in case a type is created, but applyFacets is not called// always inherit facet annotations in case applyFacets is not called.//we also set fundamental facets information in case applyFacets is not called.// Inherit from the base type//setting fundamental facets// Values of this type are lists// even for union, we set whitespace to something// this will never be used, but we can use fFacetsDefined to check// whether applyFacets() is allwwed: it's not allowed// if fFacetsDefined != 0// none of the schema-defined types are unions, so just set// fIsImmutable to false.// No value can be of this type, so it's unavailable.//decline to do anything if the object is immutable.// for anySimpleType, return absent variaty// REVISIT: error situation. runtime exception?// recursively get base, until we reach anySimpleType// should never gets here, internel error// we've now applied facets; so lock this object:// if the object is immutable, should not apply facets...// clear facets. because we always inherit facets in the constructor// REVISIT: in fact, we don't need to clear them.// we can convert 5 string values (4 bounds + 1 enum) to actual values,// store them somewhere, then do facet checking at once, instead of// going through the following steps. (lots of checking are redundant:// for example, ((presentFacet & FACET_XXX) != 0))// step 1: parse present facets// length// minLength// maxLength// pattern// whiteSpace// enumeration// check 4.3.5.c0 must: enumeration values from the value space of base// maxInclusive// check against fixed value in base// maxInclusive from base// maxExclusive// maxExclusive from base// If maxExclusive == base.maxExclusive, then we only need to check// maxExclusive <= base.maxInclusive// minExclusive// minExclusive from base// If minExclusive == base.minExclusive, then we only need to check// minExclusive >= base.minInclusive// minInclusive// minInclusive from base// totalDigits// fractionDigits// token type: internal use, so do less checking// step 2: check facets against each other: length, bounds// check 4.3.2.c1 must: minLength <= maxLength// check 4.3.8.c1 error: maxInclusive + maxExclusive// check 4.3.9.c1 error: minInclusive + minExclusive// check 4.3.7.c1 must: minInclusive <= maxInclusive// check 4.3.8.c2 must: minExclusive <= maxExclusive ??? minExclusive < maxExclusive// check 4.3.9.c2 must: minExclusive < maxInclusive// check 4.3.10.c1 must: minInclusive < maxExclusive// check 4.3.12.c1 must: fractionDigits <= totalDigits// step 3: check facets against base// check 4.3.1.c1 error: length & (fBase.maxLength | fBase.minLength)// length, fBase.minLength and fBase.maxLength defined// length and fBase.maxLength defined// check 4.3.1.c2 error: length != fBase.length// check 4.3.1.c1 error: fBase.length & (maxLength | minLength)// fBase.length, minLength and maxLength defined// check 4.3.2.c1 must: minLength <= fBase.maxLength// check 4.3.2.c2 error: minLength < fBase.minLength// check 4.3.2.c1 must: maxLength < fBase.minLength// check 4.3.3.c1 error: maxLength > fBase.maxLength/* // check 4.3.7.c2 error: ... */// check 4.3.11.c1 error: totalDigits > fBase.totalDigits// check 4.3.12.c1 must: fractionDigits <= base.totalDigits// check 4.3.12.c2 error: fractionDigits > fBase.fractionDigits// check fixed value for fractionDigits// check 4.3.6.c1 error:// (whiteSpace = preserve || whiteSpace = replace) && fBase.whiteSpace = collapese or// whiteSpace = preserve && fBase.whiteSpace = replace//fFacetsDefined != null// step 4: inherit other facets from base (including fTokeyType)// inherit length// inherit minLength// inherit maxLength// inherit pattern// inherit whiteSpace// inherit enumeration// inherit maxExclusive// inherit maxInclusive// inherit minExclusive// inherit totalDigits// inherit fractionDigits//inherit tokeytype// step 5: mark fixed values//step 6: setting fundamental facets// first normalize string value, and convert it to actual value// then validate the actual value against the facets// now check extra rules: for ID/IDREF/ENTITY// For QName and NOTATION types, we don't check length facets//minLength//length//enumeration//fractionDigits//totalDigits//maxinclusive//maxExclusive//minInclusive//minExclusive// (fVariety == VARIETY_ATOMIC)// (fVariety == VARIETY_UNION)// validate special kinds of token, in place of old pattern matching// PATTERN "\\c+"// PATTERN "\\i\\c*"// PATTERN "[\\i-[:]][\\c-[:]]*"// we can't call fItemType.validate(), otherwise checkExtraRules()// will be called twice: once in fItemType.validate, once in// validate method of this type.// so we take two steps to get the actual value:// 1. fItemType.getActualValue()// 2. fItemType.chekcFacets()// we can't call fMemberType[i].validate(), otherwise checkExtraRules()// will be called twice: once in fMemberType[i].validate, once in// 1. fMemberType[i].getActualValue()// 2. fMemberType[i].chekcFacets()// when it's replace, just replace #x9, #xa, #xd by #x20// when it's collapse// append real characters, so we passed leading ws// for whitespaces, we skip all following ws// if it's not a leading or tailing ws, then append a space// If pattern is not defined, we can skip some of the normalization.// Otherwise we have to normalize the data for correct result of// pattern validation.// When {variety} is atomic, {value} is inherited from {value} of {base type definition}. For all "primitive" types {value} is as specified in the table in Fundamental Facets (C.1).// When {variety} is list, {value} is false.// When {variety} is union, the {value} is partial unless one of the following:// 1. If every member of {member type definitions} is derived from a common ancestor other than the simple ur-type, then {value} is the same as that ancestor's ordered facet.// 2. If every member of {member type definitions} has a {value} of false for the ordered facet, then {value} is false.// REVISIT: is the length possible to be 0?// we need to process the first member type before entering the loop// for the other member types, check whether the value is false// and whether they have the same ancestor as the first one// REVISIT: all member types should have the same ordered value//          just use the first one. Can we assume this?// (!fBase.fFinite)// REVISIT: implement according to derivation// ancestor is null, return false// extract the actual XSTypeDefinition if the given ancestor is a delegate.// ancestor is anyType, return true// anyType is the only type whose base type is itself// recursively get base, and compare it with ancestor// compare with ancestor// reached anySimpleType// ancestor is null, retur false// restriction// list// extension// If the value of the parameter is 0 i.e. no bit (corresponding to// restriction, list, extension or union) is set to 1 for the// derivationMethod parameter.// for each base, item or member type// If the ancestor type is reached or is the same as this type.// check if derived by restriction or list or union// get the base, item or member type depending on the variety// If the variety is union// get the {item type}// T2 is the {item type definition}// T2 is derived from the other type definition by DERIVATION_RESTRICTION// get member types// One of the {member type definitions} is T2.// if it's immutable, can't be reset:// REVISIT: reset for fundamental facets/** Primitive datatypes. *//** Types derived from string. *//** Types derived from decimal. *//** Other types. */// class XSSimpleTypeDecl/** Base class for XSSimpleType wrapper implementations. ... */XSSimpleType type;getBuiltInKind(...)getDefinedFacets(...)getFacets(...)getFixedFacets(...)getLexicalFacetValue(...)getMultiValueFacets(...)getOrdered(...)getPrimitiveType(...)isDefinedFacet(...)isFixedFacet(...)derivedFrom(...)derivedFromType(...)getFinal(...)getTypeCategory(...)getNamespaceItem(...)getPrimitiveKind(...)getWhitespace(...)isEqual(...)/** Validator for &lt;gYear&gt; datatype (W3C Schema Datatypes) ... *//** Parses, validates and computes normalized version of gYear object ... *//** Converts year object representation to String ... */// check for preceding '-' sign/** Validator for &lt;gYearMonth&gt; datatype (W3C Schema Datatypes) ... *//** Parses, validates and computes normalized version of gYearMonth object ... */// get date/** Used to validate the <yearMonthDuration> type ... */DurationDV.YEARMONTHDURATION_TYPEimport BufferAllocatorimport ThreadLocalBufferAllocator/** A simple ASCII byte reader. This is an optimized reader for reading ... *//** Default byte buffer size (2048). *//** Input stream. */...[] fBuffer;/** Byte buffer. */MessageFormatter fFormatter;// exception messages// message formatter; used to produce localized//Locale to use for messages/** Constructs an ASCII reader from the specified input stream ... */// <init>(InputStream, MessageFormatter, Locale)BufferAllocator bagetBufferAllocator(...)/** Read a single character.  This method will block until a character is ... */// Reader methods// <init>(InputStream,int, MessageFormatter, Locale)new MalformedByteSequenceException(...)/** Read characters into a portion of an array.  This method will block ... */// read():intfBuffer.length/** Skip characters.  This method will block until some characters are ... */// read(char[],int,int)/** Tell whether this stream is ready to be read. ... */// skip(long):long/** Tell whether this stream supports the mark() operation. */// ready()/** Mark the present position in the stream.  Subsequent calls to reset() ... */// markSupported()/** Reset the stream.  If the stream has been marked, then attempt to ... */// mark(int)/** Close the stream.  Once a stream has been closed, further read(), ... */returnByteBuffer(...)// close()// class ASCIIReaderimport CharConversionException/** <p>Signals that a malformed byte sequence was detected ... *//** message formatter * *//** locale for error message * */String fDomain;/** error domain * */String fKey;/** key for the error message * */...[] fArguments;/** replacement arguements for the error message * *//** message text for this message, initially null * *//** Constructs a MalformedByteSequenceException with the given ... *//** <p>Returns the error domain of the error message.</p> ... */// <init>(MessageFormatter, Locale, String, String, Object[])/** <p>Returns the key of the error message.</p> ... */// getDomain/** <p>Returns the replacement arguments for the error ... */// getKey()/** <p>Returns the localized message for this exception.</p> ... */// getArguments();// The references to the message formatter and locale// aren't needed anymore so null them.// getMessage()// MalformedByteSequenceException/** Reader for UCS-2 and UCS-4 encodings. ... *//** Default byte buffer size (8192, larger than that of ASCIIReader ... */short UCS2LE;short UCS2BE;short UCS4LE;short UCS4BE;short fEncoding;// what kind of data we're dealing with// <init>(InputStream, short)// <init>(InputStream,int,short)int byteLengthint numCharsint numToReadint charReadint charWidthlong bytesSkipped// UCS-2// try and make count be a multiple of the number of bytes we're looking for// BigEndian// this looks ugly, but it avoids an if at any rate...// end of input; something likely went wrong!A  Pad buffer with nulls.// now count is a multiple of the right number of bytes// charWidth will represent the number of bits to move// n leftward to get num of bytes to skip, and then move the result rightward// to get num of chars effectively skipped.// The trick with &'ing, as with elsewhere in this dcode, is// intended to avoid an expensive use of / that might not be optimized// away.// class UCSReader/** <p>A UTF-8 reader.</p> ... */boolean DEBUG_READ;/** Debug read. *//** Offset into buffer. */int fSurrogate;/** Surrogate character. *//** Constructs a UTF-8 reader from the specified input stream ... */// <init>(InputStream, MessageFormatter)/** Constructs a UTF-8 reader from the specified input stream, ... */// <init>(InputStream, int, MessageFormatter, Locale)expectedByte(...)invalidByte(...)int uuuuuint wwwwint hsint lsinvalidSurrogate(...)int totalbyte byte1byte byte0int zzzzint yyyyyyint xxxxxxch.lengthlong skipped/** Throws an exception for expected byte. *//** Throws an exception for invalid byte. */// expectedByte(int,int)/** Throws an exception for invalid surrogate bits. */// invalidByte(int,int,int)// decode character// NOTE: We use the index into the buffer if there are remaining//       bytes from the last block read. -Ac// get first byte// UTF-8:   [0xxx xxxx]// Unicode: [0000 0000] [0xxx xxxx]// UTF-8:   [110y yyyy] [10xx xxxx]// Unicode: [0000 0yyy] [yyxx xxxx]// UTF-8:   [1110 zzzz] [10yy yyyy] [10xx xxxx]// Unicode: [zzzz yyyy] [yyxx xxxx]// UTF-8:   [1111 0uuu] [10uu zzzz] [10yy yyyy] [10xx xxxx]*// Unicode: [1101 10ww] [wwzz zzyy] (high surrogate)//          [1101 11yy] [yyxx xxxx] (low surrogate)//          * uuuuu = wwww + 1// use surrogate// return character// handle surrogate// read bytes// adjust length to read// perform read operation// skip read; last character was in error// NOTE: Having an offset value other than zero means that there was//       an error in the last character read. In this case, we have//       skipped the read so we don't consume any bytes past the//       error. By signalling the error on the next block read we//       allow the method to return the most valid characters that//       it can on the previous block read. -Ac// convert bytes to characters// check if output buffer is large enough to hold 2 surrogate chars// decode bytes into surrogate characters// set characters// return number of characters converted// invalidSurrogate(int)// class UTF8Reader/** XMLMessageFormatter provides error messages for the XML 1.0 Recommendation and for ... *//** The domain of messages concerning the XML 1.0 specification. */String XMLNS_DOMAIN;// private objects to cache the locale and resource bundleResourceBundle fResourceBundle;// MessageFormatter methods// memorize the most-recent locale/** The entity state interface defines methods that must be implemented ... *//** Query method to check if entity with this name was declared. ... *//** Query method to check if entity is unparsed. ... *//** ValidationManager is a coordinator property for validators in the ... */Vector<> fVSs;boolean fGrammarFound;boolean fCachedDTD;// scan external subset or entity decls.// cached DTD in hand so there's no reason to// used by the DTD validator to tell other components that it has a/** Each validator should call this method to add its ValidationState into ... *//** Set the information required to validate entity values. */// setCachedDTD(boolean)// isCachedDTD():  boolean/** Implementation of ValidationContext inteface. Used to establish an ... */boolean fExtraChecking;boolean fFacetChecking;boolean fNormalize;EntityState fEntityState;ArrayList<String> fIdList;ArrayList<String> fIdRefList;/** return null if all IDREF values have a corresponding ID value; ... *//** The same validation state can be used to validate more than one (schema) ... */// implementation of ValidationContext methods// get symbols// qname, notation// if there is no symbol table, we return java-internalized string,// because symbol table strings are also java-internalzied.// this guarantees that the returned string from this method can be// compared by reference with other symbol table string. -SG/** Bare minimum XPath parser. ... */boolean DEBUG_ALL;boolean DEBUG_XPATH_PARSE;boolean DEBUG_ANY;String fExpression;/** Expression. */...[] fLocationPaths;/** Location paths. *//** Constructs an XPath object from the specified expression. *//** Returns a representation of all location paths for this XPath. ... */// <init>(String,SymbolTable,NamespaceContext)LocationPath[] retnew LocationPath[]fLocationPaths.length/** Returns a representation of the first location path for this XPath. */// getLocationPath(LocationPath)/** Returns a string representation of this object. *//** Used by the {@link #parseExpression(NamespaceContext)} method ... */// toString():Stringnew XPathException(...)Step[] stepsnew Step[]new LocationPath(...)/** This method is implemented by using the XPathExprScanner and ... */XPath.TokensTokens xtokensnew Tokens(...)XPath.ScannerScanner scannernew XPath.Scanner(...) { ... }XPath$1XPath.Tokens.EXPRTOKEN_ATSIGNXPath.Tokens.EXPRTOKEN_AXISNAME_ATTRIBUTEXPath.Tokens.EXPRTOKEN_NAMETEST_QNAMEXPath.Tokens.EXPRTOKEN_OPERATOR_SLASHXPath.Tokens.EXPRTOKEN_PERIODXPath.Tokens.EXPRTOKEN_NAMETEST_ANYXPath.Tokens.EXPRTOKEN_NAMETEST_NAMESPACEXPath.Tokens.EXPRTOKEN_OPERATOR_DOUBLE_SLASHXPath.Tokens.EXPRTOKEN_OPERATOR_UNIONXPath.Tokens.EXPRTOKEN_AXISNAME_CHILDXPath.Tokens.EXPRTOKEN_DOUBLE_COLONaddToken(...)scanExpr(...)Vector<> stepsVectorVector<> locationPathsVectorboolean expectingStepboolean expectingDoubleColonint tokenbuildLocationPath(...)new Axis(...)parseNodeTest(...)Axis axisNodeTest nodeTestnew NodeTest(...)NodeTest.NODEpeekToken(...)/** Used by {@link #parseExpression} to parse a node test ... */// parseExpression(SymbolTable,NamespaceContext)nextTokenAsString(...)NodeTest.WILDCARD/** A location path representation for an XPath expression. ... */// location path information...[] steps;/** List of steps. *//** Creates a location path from a series of steps. */this.steps/** Copy constructor. */// <init>(Step[])path.steps.lengthpath.stepssteps.length// <init>(LocationPath)...[...].axis.type...[...].axis/** Returns a clone of this object. *//** A location path step comprised of an axis and node test. ... */// class locationPathAxis axis;/** Axis. */NodeTest nodeTest;/** Node test. *//** Constructs a step from an axis and node test. */this.axisthis.nodeTest// <init>(Axis,NodeTest)step.axisstep.nodeTest// <init>(Step)axis.type/** Axis. ... */// class Stepshort CHILD;/** Type: child. */short ATTRIBUTE;/** Type: attribute. */short SELF;/** Type: self. */short DESCENDANT;/** Type: descendant. *//** Axis type. *//** Constructs an axis with the specified type. */// <init>(short)// <init>(Axis)/** Node test. ... */// class Axisshort QNAME;/** Type: qualified name. */short WILDCARD;/** Type: wildcard. */short NODE;/** Type: node. */short NAMESPACE;/** Type: namespace *//** Node test type. *//** Node qualified name. *//** Constructs a node test of type WILDCARD or NODE. *//** Constructs a node test of type QName. */// <init>(int)/** Constructs a node test of type Namespace. */// <init>(QName)// <init>(String,String)nodeTest.typenodeTest.name// <init>(NodeTest)name.prefixXPath$Tokens/** List of tokens. ... *///       CVS directory when it's not needed. -Ac//       keeping the code in separate source files would "muddy" the//       and/or more appropriate implementation can be written.//       this implementation is just a temporary hack until a better// NOTE: The XPath implementation classes are kept internal because// xpath implementation// class NodeTestnew HashMap<Integer,String>(...)boolean DUMP_TOKENS;int EXPRTOKEN_OPEN_PAREN, ...;/** [28] ExprToken ::= '(' | ')' | '[' | ']' | '.' | '..' | '@' | ',' | '::' ... */...[] fgTokenNames;int INITIAL_TOKEN_COUNT;...[] fTokens;int fTokenCount;// for writingMap<String,Integer> fSymbolMapping;// REVISIT: Code something better here. -AcMap<Integer,String> fTokenNames;int fCurrentTokenIndex;/** Current position in the token list. */String[] symbols//            return fgTokenNames[token];//                return null;//            if (token < 0 || token >= fgTokenNames.length)//        public String getTokenName(int token) {Integer tokenIntEntry<Integer,String> entryMap<>.Entry<Integer,String>ArrayIndexOutOfBoundsException exint[] oldList/** Resets the current position to the head of the token list. *///            return fTokens[tokenIndex];//        public int getToken(int tokenIndex) {//            return fTokenCount;//        public int getTokenCount() {/** Returns true if the {@link #getNextToken()} method ... *//** Obtains the token at the current position, then advance ... *//** Obtains the token at the current position, without advancing ... *//** Obtains the token at the current position as a String. ... */getTokenString(...)XPath$Scanner// class Tokensbyte CHARTYPE_INVALID, ...;/** 7-bit ASCII subset ... */...[] fASCIICharMap;// Non-ASCII Unicode codepoint (>= 0x80)/** Symbol literals */String fAndSymbol;String fOrSymbol;String fModSymbol;String fDivSymbol;String fCommentSymbol;String fTextSymbol;String fPISymbol;String fNodeSymbol;String fAncestorSymbol;String fAncestorOrSelfSymbol;String fAttributeSymbol;String fChildSymbol;String fDescendantSymbol;String fDescendantOrSelfSymbol;String fFollowingSymbol;String fFollowingSiblingSymbol;String fNamespaceSymbol;String fParentSymbol;String fPrecedingSymbol;String fPrecedingSiblingSymbol;String fSelfSymbol;/** Constructs an XPath expression scanner. */int nameOffsetString nameHandleString prefixHandleboolean starIsMultiplyOperatorbyte chartypeint qcharint litOffsetint litLengthboolean isNameTestNCNameboolean isAxisNameXPath.Tokens.EXPRTOKEN_OPEN_PARENXPath.Tokens.EXPRTOKEN_CLOSE_PARENXPath.Tokens.EXPRTOKEN_OPEN_BRACKETXPath.Tokens.EXPRTOKEN_CLOSE_BRACKETXPath.Tokens.EXPRTOKEN_DOUBLE_PERIODXPath.Tokens.EXPRTOKEN_NUMBERscanNumber(...)XPath.Tokens.EXPRTOKEN_COMMAXPath.Tokens.EXPRTOKEN_OPERATOR_PLUSXPath.Tokens.EXPRTOKEN_OPERATOR_MINUSXPath.Tokens.EXPRTOKEN_OPERATOR_EQUALXPath.Tokens.EXPRTOKEN_OPERATOR_NOT_EQUALXPath.Tokens.EXPRTOKEN_OPERATOR_LESSXPath.Tokens.EXPRTOKEN_OPERATOR_LESS_EQUALXPath.Tokens.EXPRTOKEN_OPERATOR_GREATERXPath.Tokens.EXPRTOKEN_OPERATOR_GREATER_EQUALXPath.Tokens.EXPRTOKEN_LITERALscanNCName(...)XPath.Tokens.EXPRTOKEN_VARIABLE_REFERENCEXPath.Tokens.EXPRTOKEN_OPERATOR_MULTXPath.Tokens.EXPRTOKEN_OPERATOR_ANDXPath.Tokens.EXPRTOKEN_OPERATOR_ORXPath.Tokens.EXPRTOKEN_OPERATOR_MODXPath.Tokens.EXPRTOKEN_OPERATOR_DIVXPath.Tokens.EXPRTOKEN_NODETYPE_COMMENTXPath.Tokens.EXPRTOKEN_NODETYPE_TEXTXPath.Tokens.EXPRTOKEN_NODETYPE_PIXPath.Tokens.EXPRTOKEN_NODETYPE_NODEXPath.Tokens.EXPRTOKEN_FUNCTION_NAMEXPath.Tokens.EXPRTOKEN_AXISNAME_ANCESTORXPath.Tokens.EXPRTOKEN_AXISNAME_ANCESTOR_OR_SELFXPath.Tokens.EXPRTOKEN_AXISNAME_DESCENDANTXPath.Tokens.EXPRTOKEN_AXISNAME_DESCENDANT_OR_SELFXPath.Tokens.EXPRTOKEN_AXISNAME_FOLLOWINGXPath.Tokens.EXPRTOKEN_AXISNAME_FOLLOWING_SIBLINGXPath.Tokens.EXPRTOKEN_AXISNAME_NAMESPACEXPath.Tokens.EXPRTOKEN_AXISNAME_PARENTXPath.Tokens.EXPRTOKEN_AXISNAME_PRECEDINGXPath.Tokens.EXPRTOKEN_AXISNAME_PRECEDING_SIBLINGXPath.Tokens.EXPRTOKEN_AXISNAME_SELFXPath.Tokens.DUMP_TOKENSdumpTokens(...)// [6] NCNameChar ::= Letter | Digit | '.' | '-' | '_' | CombiningChar | Extender// [5] NCName ::= (Letter | '_') (NCNameChar)*// [31] Digits ::= [0-9]+// [30] Number ::= Digits ('.' Digits?)? | '.' Digitsint wholeint part/** This method adds the specified token to the token list. By ... *//** Main program entry. */// class ScannerXPath xpathXPathException e// tokens// scanner//fTokens.dumpTokens();// true when the next token should be 'Step' (as defined in// the production rule [3] of XML Schema P1 section 3.11.6// if false, we are expecting either '|' or '/'.// this is to make sure we can detect a token list like// 'abc' '/' '/' 'def' 'ghi'// unless this is the first step in this location path,// there's really no reason to keep them in LocationPath.// This amounts to shorten "a/././b/./c" to "a/b/c".// Also, the matcher fails to work correctly if XPath// has those redundant dots.// build step// consume '//'// this cannot appear in arbitrary position.// it is only allowed right after '.' when// '.' is the first token of a location path.// we should have covered all the tokens that we can possibly see.// save location path// consume QName token// assertion error// DEBUG: This code is just for debugging and should *not*//        be left in because it will mess up hashcodes of//        serialized versions of this object. -Ac// clone():Object// [37] NameTest ::= '*' | NCName ':' '*' | QName// followed by symbol handle of NCName or QName// [38] NodeType ::= 'comment' | 'text' | 'processing-instruction' | 'node'// [32] Operator ::= OperatorName//                 | MultiplyOperator//                 | '/' | '//' | '|' | '+' | '-' | '=' | '!=' | '<' | '<=' | '>' | '>='// [33] OperatorName ::= 'and' | 'or' | 'mod' | 'div'// [34] MultiplyOperator ::= '*'//EXPRTOKEN_FIRST_OPERATOR                = EXPRTOKEN_OPERATOR_AND,//EXPRTOKEN_LAST_OPERATOR                 = EXPRTOKEN_OPERATOR_GREATER_EQUAL,// [35] FunctionName ::= QName - NodeType// followed by symbol handle// [6] AxisName ::= 'ancestor' | 'ancestor-or-self'//                | 'attribute'//                | 'child'//                | 'descendant' | 'descendant-or-self'//                | 'following' | 'following-sibling'//                | 'namespace'//                | 'parent'//                | 'preceding' | 'preceding-sibling'//                | 'self'// [29] Literal ::= '"' [^"]* '"' | "'" [^']* "'"// followed by symbol handle for literal// followed by number handle// [36] VariableReference ::= '$' QName// followed by symbol handle for QName//if (DUMP_TOKENS) {// invalid XML character// not special - one of "#%&;?\^`{}~" or DEL// one of "\t\n\r " (0x09, 0x0A, 0x0D, 0x20)// '!' (0x21)// '\"' or '\'' (0x22 and 0x27)// '$' (0x24)// '(' (0x28)// ')' (0x29)// '*' (0x2A)// '+' (0x2B)// ',' (0x2C)// '-' (0x2D)// '.' (0x2E)// '/' (0x2F)// '0'-'9' (0x30 to 0x39)// ':' (0x3A)// '<' (0x3C)// '=' (0x3D)// '>' (0x3E)// '@' (0x40)// 'A'-'Z' or 'a'-'z' (0x41 to 0x5A and 0x61 to 0x7A)// '[' (0x5B)// ']' (0x5D)// '_' (0x5F)// '|' (0x7C)// save pool and tokens// [39] ExprWhitespace ::= S// [28] ExprToken ::= '(' | ')' | '[' | ']' | '.' | '..' | '@' | ',' | '::'//                  | NameTest | NodeType | Operator | FunctionName//                  | AxisName | Literal | Number | VariableReference// '('// ')'// '['// ']'//                                         ^^^^^^^^^^// '.', '..' or '.' Digits// '..'/* , encoding */// this is legal if the next token is non-existent or |// '.'// '@'// ','// '::'// System.out.println("abort 1a");// System.out.println("abort 1b");// '/' and '//'// '//'// '|'// '+'// '-'// '='// '!='// System.out.println("abort 2a");// System.out.println("abort 2b");// '<' and '<='// '<='// '>' and '>='// '>='// '\"' or '\''// System.out.println("abort 2c");// System.out.println("abort 2d");// System.out.println("abort 3a");// System.out.println("abort 3b");// System.out.println("abort 4a");// System.out.println("abort 4b");// '*'// 3.7 Lexical Structure//  If there is a preceding token and the preceding token is not one of @, ::, (, [, , or//  an Operator, then a * must be recognized as a MultiplyOperator.// Otherwise, the token must not be recognized as a MultiplyOperator.// NCName, QName and non-terminals// possibly a valid non-ascii 'Letter' (BaseChar | Ideographic)//  an Operator, then an NCName must be recognized as an OperatorName.//  If the character following an NCName (possibly after intervening ExprWhitespace) is (,//  then the token must be recognized as a NodeType or a FunctionName.//  If the two characters following an NCName (possibly after intervening ExprWhitespace)//  are ::, then the token must be recognized as an AxisName.//  Otherwise, the token must not be recognized as an OperatorName, a NodeType, a//  FunctionName, or an AxisName.// [6] AxisName ::= (see above)// [?] NCNameChar ::= Letter | Digit | '.' | '-' | '_'  (ascii subset of 'NCNameChar')// [?] QName ::= (NCName ':')? NCName// [?] Letter ::= [A-Za-z]                              (ascii subset of 'Letter')// [?] Digit ::= [0-9]                                  (ascii subset of 'Digit')// System.out.println("abort 4c");// System.out.println("abort 5");// System.out.println("abort 5b");// System.out.println("abort 6");// System.out.println("abort 7");// REVISIT - NCName:* where an OperatorName is required// System.out.println("abort 8");// REVISIT - AxisName:: where an OperatorName is required// System.out.println("abort 9");// System.out.println("abort 10");// REVISIT - "NCName:* ::" where "AxisName ::" is required/** * // REVISIT: Make sure this is a negation. *** ... *//* byte[] *//* , EncodingSupport encoding *//** int start = currentOffset; * *///part = fStringPool.addSymbol(data.substring(start, currentOffset));// addToken(int)// class XPath/** XPath exception. ... */// hold the value of the key this Exception refers to./** Constructs an exception. *//** Constructs an exception with the specified key. */// <init>(String)// getKey():  String// class XPathExceptionimport CharacterIterator/** Boyer-Moore searcher. ... */...[] pattern;...[] shiftTable;boolean ignoreCase;pattern.lengththis.shiftTablethis.ignoreCasethis.shiftTable.lengththis.pattern.lengthmatchesIgnoreCase(...)//System.err.println("Starts at "+index);/* public static void main(String[] argv) { ... *//** @version *//* 2^10 = 1k */...[] caseInsensitiveMap;/* up to 0xFFFF */Boolean mapBuilt;int LOWER_CASE_MATCH;int UPPER_CASE_MATCH;/** Return a list of code point characters (not including the input value) ... */buildCaseInsensitiveMap(...)int lcint ucnew int[][][]int[] mapint[] lcMapupdateMap(...)int[] ucMapexpandMap(...)srcMap.lengthint[] newMapciCodePointMap.lengthint[] cMapexpandAndAdd(...)// synchronized// if mapBuilt// lower/upper case value is not the same as code point/** An instance of this class has ranges captured in matching. ... */...[] beginpos;...[] endpos;int nofgroups;CharacterIterator ciSource;String strSource;...[] charSource;/** Creates an instance. */Match manew Match(...)this.nofgroupssetNumberOfGroups(...)this.ciSourcethis.strSourcesetBeginning(...)getBeginning(...)int oldnthis.beginposthis.endposthis.charSource/** Return the number of regular expression groups. ... *//** Return a start position in the target text matched to specified regular expression group. ... *//** Return an end position in the target text matched to specified regular expression group. ... *//** Return an substring of the target text matched to specified regular expression group. ... */String retint beginint CHAR;// Single characterint NRANGE;// [a-zA-Z]int ANCHOR;// [^a-zA-Z]// ^ $ ...int CLOSURE;// literal Stringint NONGREEDYCLOSURE;// X*int QUESTION;// X*?int NONGREEDYQUESTION;// X?int UNION;// X??int CAPTURE;// X|Yint BACKREFERENCE;// ( and )int LOOKAHEAD;// \1 \2 ...int NEGATIVELOOKAHEAD;// (?=...)int LOOKBEHIND;// (?!...)int NEGATIVELOOKBEHIND;// (?<=...)int INDEPENDENT;// (?<!...)int MODIFIER;// (?>...)int CONDITION;// (?ims-ims:...)int nofinstances;// (?(..)yes|no)boolean COUNT;Op.COUNTOp.nofinstancesnew Op(...)Op.DOTnew CharOp(...)Op.CHAROp.ANCHORCharOp opOp.CAPTUREop.nextnew UnionOp(...)Op.UNIONnew ModifierOp(...)Op.CLOSUREnew ChildOp(...)Op.NONGREEDYCLOSUREOp.NONGREEDYQUESTIONOp.QUESTIONnew RangeOp(...)Op.RANGEChildOp opsetChild(...)Op.BACKREFERENCEnew StringOp(...)Op.STRINGOp.INDEPENDENTModifierOp opOp.MODIFIERConditionOp opnew ConditionOp(...)Op.CONDITIONOp next;// ModifierOpOp$CharOp// ================================================================int charData;this.charDataOp$UnionOpVector<> branches;this.branchesOp$ChildOpOp child;this.childOp$ModifierOpint v1;int v2;this.v1this.v2Op$RangeOpToken tok;this.tokOp$StringOpthis.stringOp$ConditionOpint refNumber;Op condition;Op yes;Op no;this.refNumberthis.conditionthis.yesthis.no//System.err.println("Creates UnionOp");// for UNION// for UNIoN// for CLOSURE, QUESTION// CharOp  for CHAR, BACKREFERENCE, CAPTURE, ANCHOR,// RANGE, NRANGE// STRINGint location;/* public ParseException(String mes) { ... */this.location/** A regular expression parser for the XML Schema. ... */createChar(...)ex(...)this.offsetcreateClosure(...)createConcat(...)Token parcreateUnion(...)createEmpty(...)createParen(...)parseRegex(...)getTokenForShorthand(...)mergeRanges(...)/** Parses a character-class-expression, not a character-class-escape. ... */boolean nrangeboolean wasDecodedRangeToken baseRangeToken tokboolean firstloopthis.chardataaddRange(...)Token.UTF16_MAXboolean endsubtractRanges(...)int pstartRangeToken tok2processBacksolidus_pP(...)processCIinCharacterClass(...)decodeEscaped(...)RangeToken range2parseCharacterClass(...)RegularExpression.IGNORE_CASEaddCaseInsensitiveChar(...)int rangeendaddCaseInsensitiveCharRange(...)sortRanges(...)compactRanges(...)getRange(...)Map<String,Token> ranges;Map<String,Token> ranges2;new HashMap<String,Token>(...)setupRange(...)complementRanges(...)String SPACES;String NAMECHARS;String LETTERS;...[] LETTERS_INT;String DIGITS;...[] DIGITS_INT;//this.setLocale(Locale.getDefault());// X+ -> XX*// X? -> X|// Skips ')'// used to detect if the last - was escaped.// '^'// Don't use 'cotinue' for this loop.// single-range | from-to-range | subtraction// \ + c// backsolidus// Subraction// Exit this loop// if not shorthands...// if regex = '[-]' then invalid// Here is no '-'.// Found '-'// Is this '-' is a from-to token??// Skips '-'// c '-' ']' -> '-' is a single-range.// if - is at the last position of the group//tok.dumpRanges();// Skips ']'// LINE FEED U+000A// CRRIAGE RETURN U+000D// HORIZONTAL TABULATION U+0009// return actucal charnew RegularExpression[]char[] chschar[] srcRegularExpression.MULTIPLE_LINESRegularExpression.SINGLE_LINERegularExpression.EXTENDED_COMMENTRegularExpression.USE_UNICODE_CATEGORYRegularExpression.UNICODE_WORD_BOUNDARYRegularExpression.PROHIBIT_FIXED_STRING_OPTIMIZATIONRegularExpression.PROHIBIT_HEAD_CHARACTER_OPTIMIZATIONRegularExpression.XMLSCHEMA_MODERegularExpression.SPECIAL_COMMAint optionsgetOptionValue(...)/** Sample entry. ... */String optionsRegularExpression regMatch matchgetNumberOfGroups(...)getCapturedText(...)int locint CACHESIZE;...[] regexCache;/** Creates a RegularExpression instance. ... */RegularExpression reint intOptionsparseOptions(...)REUtil.regexCacheREUtil.CACHESIZERegularExpression cachedcreateRegex(...)// Skips a white space.// Skips chracters between '#' and a line end.// Strips an escaped white space.// Other escaped character.// As is./** This class represents a character class such as [a-z] or a period. ... */...[] ranges;boolean sorted;boolean compacted;RangeToken icaseCache;int nonMapIndex;setSorted(...)// for RANGE or NRANGEthis.icaseCachethis.rangesthis.ranges.lengththis.sortedthis.compactedisSorted(...)/** this.ranges is sorted. */boolean DEBUGint baseisCompacted(...)int baseendsetCompacted(...)tok.ranges.lengthtok.rangesint wpint subtoken.typeintersectRanges(...)int srcbeginint srcendint subbeginint subendint src1int src2int src1beginint src1endint src2beginint src2end/** for RANGE: Creates complement. ... */RangeToken retret.rangesRangeToken upperscreateNRange(...)Token.RANGERangeToken lowerschar uchuppers.ranges.lengthuppers.rangesboolean retcreateMap(...)this.nonMapIndexint MAPSIZE;int asizeint nonMapIndexToken.token_dotToken.token_0to9Token.token_wordcharsToken.token_spacesescapeCharInCharClass(...)Token.token_not_0to9Token.token_not_wordcharsToken.token_not_spacesString pre/* Copyright 1999-2002,2004,2005 The Apache Software Foundation. ... *///System.err.println("Token#addRange(): "+start+" "+end);//System.err.println("Do sorting: "+this.ranges.length);// Bubble sort// Why? -- In many cases,//         this.ranges has few elements.// Index of writing point// Index of processing point//System.err.println("Token#substractRanges(): Entry: "+this.ranges.length+", "+tok.ranges.length);// Not overlapped// src: o-----o// sub:         o-----o// res: o-----o// Reuse sub// Overlapped// src:    o--------o// sub:  o----o// sub:      o----o// sub:          o----o// sub:  o------------o// res: empty// res:       o-----o// Reuse src(=res)// res:    o-----o// res:    o-o    o-o// Reuse src(=right res)// src:          o-----o// sub: o----o// this.ranges is sorted and compacted.// src1: o-----o// src2:         o-----o// res:  empty// Reuse src2// src1:    o--------o// src2:  o----o// src2:      o----o// src2:          o----o// src2:  o------------o// res:     o--------o// res:     o--o// Reuse the rest of src1// res:           o--o// res:       o----o// src1:          o-----o// src2: o----o// 32 is the number of bits in `int'.// s&0x1f : 0-31//for (int i = 0;  i < asize;  i ++)  System.err.println("Map: "+Integer.toString(this.map[i], 16));//case 0x0b:  ret = "\\v";  break;/** A Regular Expression Parser. ... */int T_CHAR;int T_EOF;int T_OR;int T_STAR;int T_PLUS;int T_QUESTION;int T_LPAREN;// '?'int T_RPAREN;int T_DOT;int T_LBRACKET;int T_BACKSOLIDUS;int T_CARET;// '\'int T_DOLLAR;int T_LPAREN2;// '$'int T_LOOKAHEAD;// '(?:'int T_NEGATIVELOOKAHEAD;// '(?='int T_LOOKBEHIND;// '(?!'int T_NEGATIVELOOKBEHIND;// '(?<='int T_INDEPENDENT;// '(?<!'int T_SET_OPERATIONS;// '(?>'int T_POSIX_CHARCLASS_START;// '(?['int T_COMMENT;// '[:' in a character classint T_MODIFIERS;// '(?#'int T_CONDITION;// '(?' [\-,a-z,A-Z]int T_XMLSCHEMA_CC_SUBTRACTION;// '(?('RegexParser$ReferencePosition// '-[' in a character classint offset;String regex;int regexlen;int options;int chardata;int nexttoken;int S_NORMAL;int S_INBRACKETS;int S_INXBRACKETS;int context;int parenOpened;int parennumber;boolean hasBackReferences;Vector<> references;int parenCount;this.resourcesMissingResourceException mreToken retthis.parennumberthis.parenOpenedthis.hasBackReferencesthis.regexstripExtendedComment(...)this.regexlenthis.referencesReferencePosition positionposition.refNumberposition.position/* public RegularExpression createRegex(String regex, int options) throws ParseException { ... */this.nexttokencomposeFromSurrogates(...)/** regex ::= term (`|` term)* ... */parseTerm(...)Token parent/** term ::= factor+ */Token concatparseFactor(...)// ----------------------------------------------------------------Token.token_linebeginningToken.token_lineendcreateLook(...)Token.LOOKAHEADToken.NEGATIVELOOKAHEADToken.LOOKBEHINDToken.NEGATIVELOOKBEHINDToken.token_stringbeginningToken.token_stringend2Token.token_stringendToken.token_wordedgeToken.token_not_wordedgeToken.token_wordbeginningToken.token_wordendcreateNGClosure(...)int refnoToken conditionToken yesPatternToken noPatternint finalRefnonew ReferencePosition(...)condition.typeToken.ANCHORyesPattern.typeToken.UNIONcreateCondition(...)createModifierGroup(...)Token.INDEPENDENTint ch2getGraphemePattern(...)getCombiningCharacterSequence(...)int refnumint finalRefnumcreateBackReference(...)/** factor ::= ('^' | '$' | '\A' | '\Z' | '\z' | '\b' | '\B' | '\<' | '\>' ... */processCaret(...)processDollar(...)processLookahead(...)processNegativelookahead(...)processLookbehind(...)processNegativelookbehind(...)processBacksolidus_A(...)processBacksolidus_Z(...)processBacksolidus_z(...)processBacksolidus_b(...)processBacksolidus_B(...)processBacksolidus_lt(...)processBacksolidus_gt(...)parseAtom(...)processStar(...)processPlus(...)processQuestion(...)checkQuestion(...)setMin(...)setMax(...)/** atom ::= char | '.' | char-class | '(' regex ')' | '(?:' regex ')' | '\' [0-9] ... */processParen(...)processParen2(...)processCondition(...)processModifiers(...)processIndependent(...)parseSetOperations(...)createString(...)decomposeToSurrogates(...)processBacksolidus_c(...)processBacksolidus_C(...)processBacksolidus_i(...)processBacksolidus_I(...)processBacksolidus_g(...)processBacksolidus_X(...)processBackreference(...)char[] surboolean positiveint namestartint nameend/** char-class ::= '[' ( '^'? range ','?)+ ']' ... */RangeToken range/** '(?[' ... ']' (('-' | '+' | '&') '[' ... ']')? ')' */RangeToken t2int v1int uvhexChar(...)int[] caseMapcaseMap.length// In a character class, this.chardata has one character, that is to say,// a pair of surrogates is composed and stored to this.chardata.// Allow character class subtraction (regardless of whether we are in// XML Schema mode or not)// Through down// Options// conditional// this.offsets points the next of '('.//tok = Token.createConcat(tok, this.parseFactor());// this.offset points the next of '('// Parses a condition.// Points '('.// Parses yes/no-patterns.// this.offset points the next of '?'.// modifiers ::= [imsw]* ('-' [imsw]*)? ':'// '-' or ':'?// ':'?// such as (?-i)// Must be in 0x0040-0x005f// through down// this.offset -> next of '{'// {min,max}// assume {min,}// off -> next of '}'//System.err.println("CLOSURE: "+min+", "+max);// (?modifiers ... )// Skips '.'// handle category escape// POSIX Character class such as [:alnum:]// ESCAPE U+001B// FORM FEED U+000C//case 'v':  c = 0x0b;  break; // VERTICAL TABULATION U+000Bimport IntStack/** A regular expression matching engine using Non-deterministic Finite Automaton (NFA). ... *//** Compiles a token tree into an operation flow. */this.operationsthis.numberOfClosures/** Converts a token to an operation. */Op rettok.typeOp.UnionOpUnionOp uniToken childgetMin(...)getMax(...)Token.ConditionTokenConditionToken ctokint refctok.refNumberOp conditionctok.conditionOp yesctok.yesOp noctok.noToken.DOTcreateDot(...)ret.nextToken.CHARcreateAnchor(...)Token.NRANGEToken.CONCATToken.CLOSUREToken.NONGREEDYCLOSUREOp.ChildOpChildOp qcreateQuestion(...)q.nextcreateNonGreedyClosure(...)Token.EMPTYToken.STRINGToken.BACKREFERENCEgetReferenceNumber(...)Token.PARENgetParenNumber(...)createCapture(...)Op.LOOKAHEADOp.NEGATIVELOOKAHEADOp.LOOKBEHINDOp.NEGATIVELOOKBEHINDcreateIndependent(...)Token.MODIFIERGROUPcreateModifier(...)getOptions(...)getOptionsMask(...)Token.ModifierTokenToken.CONDITION/** Checks whether the <var>target</var> text <strong>contains</strong> this pattern or not. ... *///Public/** Checks whether the <var>target</var> text <strong>contains</strong> this pattern ... */Context concon.limitthis.minlengthint matchStartint matchEndprepare(...)new Context(...)this.context.inusethis.nofparencon.matchcon.startsetInUse(...)this.fixedStringOnlyint othis.fixedStringTablethis.fixedStringthis.operations.typegetChild(...).typeboolean previousIsEOLisEOLChar(...)this.firstCharExpressionTarget targetcon.targetStack<> opStackIntStack dataStacknew IntStack(...)boolean isSetIgnoreCaseint retValueboolean returnedop.typeint o1matchChar(...)Op.NRANGEgetToken(...)matchAnchor(...)int o2int literallencon.closureContextsaddOffset(...)int localoptsgetData2(...)Op.ConditionOpConditionOp copcop.refNumbercop.yescop.nocop.nextcop.conditionint savedint unionIndexmatchIgnoreCase(...)boolean gocon.lengthint aftergetWordType(...)int beforegetPreviousWordType(...)getWordType0(...)getBeginIndex(...)getEndIndex(...)/** A regular expression. ... *//** @serial */int nofparen;/** The number of parenthesis in the regular expression. ... */Token tokentree;/** Internal representation of the regular expression. ... */int minlength;Op operations;int numberOfClosures;Context context;RangeToken firstChar;String fixedString;int fixedStringOptions;BMPattern fixedStringTable;boolean fixedStringOnly;RegularExpression$ExpressionTargetRegularExpression$StringTargetRegularExpression$CharArrayTarget...[] target;regionMatchesIgnoreCase(...)char uch1char uch2RegularExpression$CharacterIteratorTargetCharacterIterator target;RegularExpression$ClosureContext...[] offsets;offsets.lengthexpandOffsets(...)int newLenint[] newOffsetsRegularExpression$ContextMatch match;boolean inuse;...[] closureContexts;StringTarget stringTarget;CharArrayTarget charArrayTarget;CharacterIteratorTarget characterIteratorTarget;ExpressionTarget target;this.limitthis.closureContextsthis.closureContexts.lengthnew ClosureContext[]new ClosureContext(...)new CharacterIteratorTarget(...)resetTarget(...)new StringTarget(...)new CharArrayTarget(...)this.inuse/** Prepares for matching.  This method is called just before starting matching. */this.tokentreegetMinLength(...)RangeToken firstCharint fresultanalyzeFirstCharacter(...)Token.FC_TERMINALthis.operations.nextchar[] acthis.fixedStringOptionsnew BMPattern(...)Token.FixedStringContainerFixedStringContainer containernew FixedStringContainer(...)findFixedString(...)container.tokencontainer.optionscreateOptionString(...)dumpString(...)int IGNORE_CASE;/** "i" *//** An option. ... */int SINGLE_LINE;/** "s" */int MULTIPLE_LINES;/** "m" */int EXTENDED_COMMENT;/** "x" */int USE_UNICODE_CATEGORY;/** This option redefines <span class="REGEX"><kbd>\d \D \w \W \s \S</kbd></span>. ... */int UNICODE_WORD_BOUNDARY;// "u"int PROHIBIT_HEAD_CHARACTER_OPTIMIZATION;/** "H" */// "w"int PROHIBIT_FIXED_STRING_OPTIMIZATION;/** "F" */int XMLSCHEMA_MODE;/** "X". XML Schema mode. */int SPECIAL_COMMA;/** ",". *//** Creates a new RegularExpression instance. ... *//** Creates a new RegularExpression instance with options. ... */setPattern(...)RegexParser rpnew ParserForXMLSchema(...)new RegexParser(...)rp.parennumberrp.hasBackReferences/** Represents this instence in String. *//** Returns a option string. ... *//** Return true if patterns are the same and the options are equivalent. */RegularExpression rr.regexr.optionsint WT_IGNORE;int WT_LETTER;int WT_OTHER;isWordChar(...)Character.UPPERCASE_LETTERCharacter.LOWERCASE_LETTERCharacter.TITLECASE_LETTERCharacter.MODIFIER_LETTERCharacter.OTHER_LETTERCharacter.LETTER_NUMBERCharacter.DECIMAL_DIGIT_NUMBERCharacter.OTHER_NUMBERCharacter.COMBINING_SPACING_MARKCharacter.FORMATCharacter.NON_SPACING_MARKCharacter.ENCLOSING_MARKCharacter.CONTROLint LINE_FEED;int CARRIAGE_RETURN;int LINE_SEPARATOR;int PARAGRAPH_SEPARATOR;// ret.next is null.// {n}// X{2,6} -> XX(X(X(XX?)?)?)?// Token.CLOSURE// switch (tok.type)// Need not to call setSource() because// a caller can not access this match instance.//System.err.println("DEBUG: matchEnd="+matchEnd);/* The pattern has only fixed string. ... *///System.err.println("DEBUG: fixed-only: "+this.fixedString);/* The pattern contains a fixed string. ... *///System.err.println("Non-match in fixed-string search.");/* Checks whether the expression starts with ".*". *//* Optimization against the first character. *///System.err.println("DEBUG: with firstchar-matching: "+this.firstChar);/* Straightforward matching. */// dx value is either 1 or -1// Saves current position to avoid zero-width repeats.// fall through// handle recursive operations// exhausted all the operations// Internal use only.// The @ always matches line beginnings.// switch anchor type// We do not check for duplicates, caller is responsible for that/* if  (this.operations.type == Op.CLOSURE && this.operations.getChild().type == Op.DOT) { // .* ... */// Op.CHAR// This pattern has a fixed string of which length is more than one.//+this.fixedString// L// N// Mc// Cf// Mn// Cc// Legacy word characters/** This class represents a node in parse tree. ... */Token.token_emptyToken.token_linebeginning2boolean COUNTTOKENS;int tokens;// Literal charint CONCAT;// .// XY// X|Y|Z// [a-zA-Z] etc.int PAREN;// [^a-zA-Z] etc.// (X) or (?:X)// ^ $ \b \B \< \> \A \Z \z// *? +?// strings// back referencesint MODIFIERGROUP;int UTF16_MAX;// (?(...)yes|no)Token token_dot;Token token_0to9;Token token_wordchars;Token token_not_0to9;Token token_not_wordchars;Token token_spaces;Token token_not_spaces;Token token_empty;Token token_linebeginning;Token token_linebeginning2;Token token_lineend;Token token_stringbeginning;Token token_stringend;Token token_stringend2;Token token_wordedge;Token token_not_wordedge;Token token_wordbeginning;Token token_wordend;Token.ParenTokenToken.tokensnew ParenToken(...)Token.ClosureTokennew ClosureToken(...)Token.ConcatTokennew ConcatToken(...)Token.UnionTokennew UnionToken(...)new RangeToken(...)Token.CharTokennew CharToken(...)Token.StringTokennew StringToken(...)new ModifierToken(...)new ConditionToken(...)/** A number of children. *//** How many characters are needed? */getMaxLength(...)int dint FC_CONTINUE;int FC_TERMINAL;int FC_ANY;int ret2boolean hasEmptyint ret3int ret4int chaint mylengthint otherlengthToken$FixedStringContainerToken token;Token prevTokenint prevOptionsisShorterThan(...)Map<String,Token> categories;// ------------------------------------------------------Map<String,Token> categories2;...[] categoryNames;int CHAR_INIT_QUOTE;// Schema Rec. {Datatypes} - Punctuationint CHAR_FINAL_QUOTE;// Pi - initial quoteint CHAR_LETTER;// Pf - final quoteint CHAR_MARK;int CHAR_NUMBER;int CHAR_SEPARATOR;int CHAR_OTHER;int CHAR_PUNCTUATION;int CHAR_SYMBOL;...[] blockNames;//blockNames in UNICODE 3.1 that supported by XML Schema RECString blockRanges;//FFF0..FFFD; "Specials",//100000..10FFFD; "Private Use"//F0000..FFFFD; "Private Use",//ADD THOSE MANUALLY...[] nonBMPBlockRanges;int NONBMP_BLOCK_START;Token.categoriesToken.categories2Token[] rangesnew Token[]Token.categoryNames.lengthToken.categoryNamesToken allToken isalphaToken isalnumToken isspaceToken iswordToken isasciiToken isnotgraphToken isxdigitranges.lengthCharacter.SPACE_SEPARATORCharacter.LINE_SEPARATORCharacter.PARAGRAPH_SEPARATORCharacter.SURROGATECharacter.PRIVATE_USECharacter.UNASSIGNEDCharacter.CONNECTOR_PUNCTUATIONCharacter.CURRENCY_SYMBOLCharacter.OTHER_SYMBOLToken.blockNames.lengthToken.blockNamesToken r1int locationString nint rstartToken.blockRangesint rendToken.nonBMPBlockRangesint cisetAlias(...)registerNonXS(...)isRegisterNonXS(...)Set<String> nonxs;/** This method is called by only getRange(). ... */Token.nonxsToken t1Token t2String viramaString;Token token_grapheme;//;TIBETAN MARK HALANTA;Mn;9;ON;;;;;N;TIBETAN VIRAMA;;;;Token base_charToken viramaToken combiner_wo_viramaToken leftToken fooToken.token_graphemeToken.viramaStringToken token_ccs;/** Combing Character Sequence in Perl 5.6. */Token.token_ccsToken$StringToken/** This class represents a node in parse tree. */quoteMeta(...)Token$ConcatTokenToken child;Token child2;this.child2this.child2.typeToken$CharTokenToken$ClosureTokenToken$ParenTokenToken$ConditionToken/** (?(condition)yes-pattern|no-pattern) */Token condition;Token yes;Token no;this.condition.typeToken$ModifierToken/** (ims-ims: .... ) */int add;int mask;this.addthis.maskToken$UnionTokenList<Token> children;/** @serialField */this.childrenToken previousint nextMaxLengthnew ArrayList<Token>(...)previous.typeToken chToken ch2ch2.type/** @serialData */Vector<Token> vChildrennew Vector<Token>(...)// *** It is not a bug.// for CLOSURE// for STRING// *******// ***** Really?// infinity// When this.child.getMaxLength() < 0,// this returns minus value// ******/* a|b|c -> FC_TERMINAL ... */// ****// **** We can not optimize./* int mylength; ... */// Ignore CHAR tokens.// **// 28// 29, 30// 31-37/* 0000..007F; *//* 0080..00FF; *//* 0100..017F; *//* 0180..024F; *//* 0250..02AF; *//* 02B0..02FF; *//* 0300..036F; *//* 0370..03FF; *//* 0400..04FF; *//* 0530..058F; *//* 0590..05FF; *//* 0600..06FF; *//* 0700..074F; *//* 0780..07BF; *//* 0900..097F; *//* 0980..09FF; *//* 0A00..0A7F; *//* 0A80..0AFF; *//* 0B00..0B7F; *//* 0B80..0BFF; *//* 0C00..0C7F; *//* 0C80..0CFF; *//* 0D00..0D7F; *//* 0D80..0DFF; *//* 0E00..0E7F; *//* 0E80..0EFF; *//* 0F00..0FFF; *//* 1000..109F; *//* 10A0..10FF; *//* 1100..11FF; *//* 1200..137F; *//* 13A0..13FF; *//* 1400..167F; *//* 1680..169F; *//* 16A0..16FF; *//* 1780..17FF; *//* 1800..18AF; *//* 1E00..1EFF; *//* 1F00..1FFF; *//* 2000..206F; *//* 2070..209F; *//* 20A0..20CF; *//* 20D0..20FF; *//* 2100..214F; *//* 2150..218F; *//* 2190..21FF; *//* 2200..22FF; *//* 2300..23FF; *//* 2400..243F; *//* 2440..245F; *//* 2460..24FF; *//* 2500..257F; *//* 2580..259F; *//* 25A0..25FF; *//* 2600..26FF; *//* 2700..27BF; *//* 2800..28FF; *//* 2E80..2EFF; *//* 2F00..2FDF; *//* 2FF0..2FFF; *//* 3000..303F; *//* 3040..309F; *//* 30A0..30FF; *//* 3100..312F; *//* 3130..318F; *//* 3190..319F; *//* 31A0..31BF; *//* 3200..32FF; *//* 3300..33FF; *//* 3400..4DB5; *//* 4E00..9FFF; *//* A000..A48F; *//* A490..A4CF; *//* AC00..D7A3; *//* E000..F8FF; *//* F900..FAFF; *//* FB00..FB4F; *//* FB50..FDFF; *//* FE20..FE2F; *//* FE30..FE4F; *//* FE50..FE6F; *//* FE70..FEFE; *//* FEFF..FEFF; *//* FF00..FFEF; *///missing Specials add manually/* 10300..1032F; */// 84/* 10330..1034F; *//* 10400..1044F; *//* 1D000..1D0FF; *//* 1D100..1D1FF; *//* 1D400..1D7FF; *//* 20000..2A6D6; *//* 2F800..2FA1F; *//* E0000..E007F; *///missing 2 private use add manually//build table of Pi values//build table of Pf values// for all characters// Unassigned//REVISIT: do we really need to support block names as in Unicode 3.1//         or we can just create all the names in IsBLOCKNAME format (XML Schema REC)?//DEBUGING//System.out.println(n+" " +Integer.toHexString(rstart)//                     +"-"+ Integer.toHexString(rend));// TR#18 1.2// Lu// Ll// Lo// Lu Ll Lo// Nd// Z// Lu Ll Lo Nd// Perl extension// if null//if (tok == null) System.out.println(name);// ;DEVANAGARI SIGN VIRAMA;Mn;9;ON;;;;;N;;;;;//;BENGALI SIGN VIRAMA;Mn;9;ON;;;;;N;;;;;//;GURMUKHI SIGN VIRAMA;Mn;9;ON;;;;;N;;;;;//;GUJARATI SIGN VIRAMA;Mn;9;ON;;;;;N;;;;;//;ORIYA SIGN VIRAMA;Mn;9;ON;;;;;N;;;;;//;TAMIL SIGN VIRAMA;Mn;9;ON;;;;;N;;;;;//;TELUGU SIGN VIRAMA;Mn;9;ON;;;;;N;;;;;//;KANNADA SIGN VIRAMA;Mn;9;ON;;;;;N;;;;;//;MALAYALAM SIGN VIRAMA;Mn;9;ON;;;;;N;;;;;//;THAI CHARACTER PHINTHU;Mn;9;ON;;;;;N;THAI VOWEL SIGN PHINTHU;;;;// [{ASSIGNED}]-[{M},{C}]// hangul_medial and hangul_final// extras// base_char?// \pM*// \PM + \pM*// This is CONCAT, and new child is CONCAT.// Recursion//System.err.println("Merge '"+previous+"' and '"+tok+"'.");// Replace previous token by STRING// Convert List to Vector//convert Vector back to Listimport XSAttributeDeclaration/** Attribute PSV infoset augmentations implementation. ... */...[] fErrorCodes;fErrorCodes.length/** Reset() *//* Copyright 2000-2002,2004 The Apache Software Foundation. ... */import XSElementDeclarationimport XSModelimport XSNotationDeclaration/** Element PSV infoset augmentations implementation. ... *//** true if the element value was provided by the schema; false otherwise. */...[] fGrammars;/** deferred XSModel * */new XSModelImpl(...)/** Reset() should be called in validator startElement(..) method. *//* Copyright 2000-2002,2004,2005 The Apache Software Foundation. ... */import IdentityConstraintimport ObjectListImplimport XSNamedMap4Typesimport XSNamedMapImplimport DOMParserimport XML11Configurationimport XSGrammarimport XSAttributeGroupDefinitionimport XSModelGroupDefinitionimport XSNamedMapimport XSParticleimport XSWildcard/** This class is to hold all schema component declaration that are declared ... */new XSComplexTypeDecl[]new SimpleLocator[]new XSGroupDecl[]new XSElementDecl[]new XSAnyType(...)new BuiltinSchemaGrammar(...)Constants.SCHEMA_VERSION_1_0Constants.SCHEMA_VERSION_1_0_EXTENDEDgetGlobalTypeDecl(...)SchemaSymbols.ATTVAL_ANYSIMPLETYPEXSTypeDefinition.SIMPLE_TYPE// the target namespace of grammarSymbolHash fGlobalAttrDecls;// global decls: map from decl name to decl objectSymbolHash fGlobalAttrGrpDecls;SymbolHash fGlobalElemDecls;SymbolHash fGlobalGroupDecls;SymbolHash fGlobalNotationDecls;SymbolHash fGlobalIDConstraintDecls;SymbolHash fGlobalTypeDecls;SymbolHash fGlobalAttrDeclsExt;// key is location,name// extended global decls: map from schema location + decl name to decl objectSymbolHash fGlobalAttrGrpDeclsExt;SymbolHash fGlobalElemDeclsExt;SymbolHash fGlobalGroupDeclsExt;SymbolHash fGlobalNotationDeclsExt;SymbolHash fGlobalIDConstraintDeclsExt;SymbolHash fGlobalTypeDeclsExt;SymbolHash fAllGlobalElemDecls;//  that are not added to either of the global element declarations above)// (handy when sharing components by reference, since we might end up with duplicate components// A global map of all global element declarations - used for substitution group computationXSDDescription fGrammarDescription;// the XMLGrammarDescription member...[] fAnnotations;// annotations associated with the "root" schema of this targetNamespaceint fNumAnnotations;// number of annotations declared// symbol table for constructing parsers (annotation support)SoftReference<> fSAXParser;// parsers for annotation supportSoftReference<> fDOMParser;// needed to make BuiltinSchemaGrammar work.SG_SchemaNS.fGlobalTypeDecls// Clone an existing schema grammar// <init>(String, XSDDescription)grammar.fTargetNamespacegrammar.fGrammarDescriptiongrammar.fSymbolTablegrammar.fGlobalAttrDeclsgrammar.fGlobalAttrGrpDeclsgrammar.fGlobalElemDeclsgrammar.fGlobalGroupDeclsgrammar.fGlobalNotationDeclsgrammar.fGlobalIDConstraintDeclsgrammar.fGlobalTypeDeclsgrammar.fGlobalAttrDeclsExtgrammar.fGlobalAttrGrpDeclsExtgrammar.fGlobalElemDeclsExtgrammar.fGlobalGroupDeclsExtgrammar.fGlobalNotationDeclsExtgrammar.fGlobalIDConstraintDeclsExtgrammar.fGlobalTypeDeclsExtgrammar.fAllGlobalElemDeclsgrammar.fNumAnnotationsnew XSAnnotationImpl[]grammar.fAnnotations.lengthgrammar.fAnnotationsgrammar.fSubGroupCountgrammar.fSubGroups.lengthgrammar.fSubGroupsgrammar.fCTCountgrammar.fComplexTypeDecls.lengthgrammar.fComplexTypeDeclsgrammar.fCTLocators.lengthgrammar.fCTLocatorsgrammar.fRGCountgrammar.fRedefinedGroupDecls.lengthgrammar.fRedefinedGroupDeclsgrammar.fRGLocators.lengthgrammar.fRGLocatorsgrammar.fImportedgrammar.fLocationsaddDocument(...)int BASICSET_COUNT;// datatype set// number of built-in XSTypes we need to create for base and fullint FULLSET_COUNT;int GRAMMAR_XS;int GRAMMAR_XSI;SchemaGrammar$BuiltinSchemaGrammar// are immutable.// this class makes sure the static, built-in schema grammarsString EXTENDED_SCHEMA_FACTORY_CLASS;/** Special constructor to create the grammars for the schema namespaces ... */SchemaDVFactory schemaFactoryXSTypeDefinition[] typeDefinitionsnew XSTypeDefinition[]new XSDDescription(...)fGrammarDescription.fContextTypeXSDDescription.CONTEXT_PREPARSEsetNamespace(...)getBuiltInTypes(...)XSTypeDefinition xtdsetNamespaceItem(...)String tnsXSSimpleType typeshort scopeXSConstants.SCOPE_GLOBALXSSimpleType anyURIgetBuiltInType(...)SchemaSymbols.ATTVAL_ANYURISchemaSymbols.URI_XSISchemaSymbols.XSI_TYPESchemaSymbols.ATTVAL_QNAMEnew BuiltinAttrDecl(...)SchemaSymbols.XSI_NILSchemaSymbols.ATTVAL_BOOLEANSchemaSymbols.XSI_SCHEMALOCATIONcreateTypeList(...)setAnonymous(...)SchemaSymbols.XSI_NONAMESPACESCHEMALOCATION// object// return the XMLGrammarDescription corresponding to this// objects cannot be modified once they're created.// override these methods solely so that these// annotation supportSchemaGrammar$Schema4Annotations/** <p>A partial schema for schemas for validating annotations.</p> ... */new Schema4Annotations(...)Schema4Annotations INSTANCE;/** Singleton instance. *//** Special constructor to create a schema ... */XSElementDecl annotationDeclcreateAnnotationElementDecl(...)SchemaSymbols.ELT_ANNOTATIONXSElementDecl documentationDeclSchemaSymbols.ELT_DOCUMENTATIONXSElementDecl appinfoDeclSchemaSymbols.ELT_APPINFOXSComplexTypeDecl annotationTypenew XSComplexTypeDecl(...)XSComplexTypeDecl documentationTypeXSComplexTypeDecl appinfoTypeXSAttributeGroupDecl annotationAttrsnew XSAttributeGroupDecl(...)XSAttributeGroupDecl documentationAttrsXSAttributeGroupDecl appinfoAttrsXSParticleDecl annotationParticlecreateUnboundedModelGroupParticle(...)XSParticleDecl anyWCSequenceParticlecreateUnboundedAnyWildcardSequenceParticle(...)annotationDecl.fNamedocumentationDecl.fNameappinfoDecl.fNameannotationDecl.fTypedocumentationDecl.fTypeappinfoDecl.fTypeXSAttributeUseImpl annotationIDAttrnew XSAttributeUseImpl(...)XSAttributeUseImpl documentationSourceAttrXSAttributeUseImpl documentationLangAttrXSAttributeUseImpl appinfoSourceAttrXSWildcardDecl otherAttrsnew XSWildcardDecl(...)annotationIDAttr.fAttrDeclnew XSAttributeDecl(...)SchemaSymbols.ATT_IDXSConstants.VC_NONEXSConstants.SCOPE_LOCALSchemaSymbols.ATTVAL_IDannotationIDAttr.fUseSchemaSymbols.USE_OPTIONALannotationIDAttr.fConstraintTypedocumentationSourceAttr.fAttrDeclSchemaSymbols.ATT_SOURCEdocumentationSourceAttr.fUsedocumentationSourceAttr.fConstraintTypedocumentationLangAttr.fAttrDeclSchemaSymbols.ATTVAL_LANGUAGEdocumentationLangAttr.fUsedocumentationLangAttr.fConstraintTypeappinfoSourceAttr.fAttrDeclappinfoSourceAttr.fUseappinfoSourceAttr.fConstraintTypeotherAttrs.fNamespaceListotherAttrs.fTypeXSWildcard.NSCONSTRAINT_NOTotherAttrs.fProcessContentsXSWildcard.PC_LAXaddAttributeUse(...)annotationAttrs.fAttributeWCdocumentationAttrs.fAttributeWCappinfoAttrs.fAttributeWCXSModelGroupImpl annotationChoicenew XSModelGroupImpl(...)annotationChoice.fCompositorXSModelGroupImpl.MODELGROUP_CHOICEannotationChoice.fParticleCountannotationChoice.fParticlesnew XSParticleDecl[]createChoiceElementParticle(...)annotationParticle.fValueSchemaGrammar.fAnyTypeXSConstants.DERIVATION_RESTRICTIONXSConstants.DERIVATION_NONEXSComplexTypeDecl.CONTENTTYPE_ELEMENTXSConstants.DERIVATION_EXTENSIONsetIsAnonymous(...)XSComplexTypeDecl.CONTENTTYPE_MIXEDXSElementDecl eDeclnew XSElementDecl(...)eDecl.fNameeDecl.fTargetNamespacesetIsGlobal(...)eDecl.fBlockXSConstants.DERIVATION_SUBSTITUTIONsetConstraintType(...)XSParticleDecl particlenew XSParticleDecl(...)particle.fMinOccursparticle.fMaxOccursSchemaSymbols.OCCURRENCE_UNBOUNDEDparticle.fTypeXSParticleDecl.PARTICLE_MODELGROUPXSParticleDecl.PARTICLE_ELEMENTparticle.fValueXSModelGroupImpl sequencesequence.fCompositorXSModelGroupImpl.MODELGROUP_SEQUENCEsequence.fParticleCountsequence.fParticlescreateAnyLaxWildcardParticle(...)XSWildcardDecl anyWCXSParticleDecl.PARTICLE_WILDCARDanyWC.fNamespaceListanyWC.fTypeXSWildcard.NSCONSTRAINT_ANYanyWC.fProcessContents// DTDGrammar methodsVector<> fImported;/** Returns this grammar's target namespace. *//** register one global attribute */// getTargetNamespace():Stringdecl.fName/** register one global attribute group *//** register one global element */decl.fSubGroupfSubGroups.length/** register one global group *//** register one global notation *//** register one global type *//** register one global complex type *//** register one global simple type *//** register one identity constraint */addIDConstraint(...)getIdentityConstraintName(...)/** get one global attribute *//** get one global attribute group *//** get one global element *//** get one global group *//** get one global notation *//** get one global type *//** get one identity constraint */// array to store complex type declsint INC_SIZE;int fCTCount;...[] fComplexTypeDecls;...[] fCTLocators;int REDEFINED_GROUP_INIT_SIZE;// even-numbered elements are the derived groups, odd-numbered ones their bases// an array to store groups being redefined by restrictionint fRGCount;...[] fRedefinedGroupDecls;...[] fRGLocators;boolean fFullChecked;// grammar.// a flag to indicate whether we have checked the 3 constraints on this/** add one complex type decl: for later constraint checking */fComplexTypeDecls.length/** add a group redefined by restriction: for later constraint checking */fRedefinedGroupDecls.length/** get all complex type decls: for later constraint checking *//** get the error locator of all complex type decls */fCTLocators.length/** get all redefined groups: for later constraint checking *//** get the error locator of all redefined groups *//** after the first-round checking, some types don't need to be checked ... */int fSubGroupCount;// this namespace// used to store all substitution group information declared in...[] fSubGroups;/** get all substitution group information: for the 3 constraint checking */XSComplexTypeDecl fAnyType;// we need direct access to these two types// anyType and anySimpleType: because there are so many places wheresuper.fTargetNamespaceXSWildcardDecl wildcardXSAttributeGroupDecl attrGrpwildcard.fProcessContentsXSWildcardDecl.PC_LAXattrGrp.fAttributeWCXSParticleDecl particleWXSModelGroupImpl groupXSParticleDecl particleGparticleW.fMinOccursparticleW.fMaxOccursparticleW.fTypeparticleW.fValuegroup.fCompositorgroup.fParticleCountgroup.fParticlesparticleG.fTypeparticleG.fValueBuiltinSchemaGrammar SG_SchemaNS;// the grammars to hold components of the schema namespace// class BuiltinAttrDeclBuiltinSchemaGrammar SG_SchemaNSExtended;XSSimpleType fAnySimpleType;BuiltinSchemaGrammar SG_XSI;// the grammars to hold components of the schema-instance namespaceXSComplexTypeDecl[] newArrayoldArray.lengthXSGroupDecl[] newArrayXSElementDecl[] newArraySimpleLocator[] newArrayshort MAX_COMP_IDX;// the max index / the max value of XSObject type// XSNamespaceItem methods...[] GLOBAL_COMP;...[] fComponents;// store a certain kind of components from all namespaces...[] fComponentsExt;Vector<> fDocuments;// REVISIT: use StringList and XSObjectList for there fields.// store the documents and their locations contributing to this namespaceVector<> fLocations;/** [schema namespace] ... */XML11Configuration confignew XML11Configuration(...)DOMParser parsernew DOMParser(...)Constants.DEFER_NODE_EXPANSION_FEATURESAXException excnew SoftReference<>(...)new SAXParser(...)/** [schema components]: a list of top-level components, i.e. element ... */XSNamedMapImpl.EMPTY_MAPnew XSNamedMap[]SymbolHash tableXSTypeDefinition.COMPLEX_TYPEXSConstants.ATTRIBUTE_DECLARATIONXSConstants.ELEMENT_DECLARATIONXSConstants.ATTRIBUTE_GROUPXSConstants.MODEL_GROUP_DEFINITIONXSConstants.NOTATION_DECLARATIONnew XSNamedMap4Types(...)new XSNamedMapImpl(...)ObjectListImpl.EMPTY_LISTnew ObjectList[]Object[] entriesnew ObjectListImpl(...)/** Convenience method. Returns a top-level simple or complex type ... *//** Convenience method. Returns a top-level attribute declaration. ... */getGlobalAttributeDecl(...)/** Convenience method. Returns a top-level element declaration. ... */getGlobalElementDecl(...)/** Convenience method. Returns a top-level attribute group definition. ... */getGlobalAttributeGroupDecl(...)/** Convenience method. Returns a top-level model group definition. ... */getGlobalGroupDecl(...)/** Convenience method. Returns a top-level notation declaration. ... */getGlobalNotationDecl(...)/** [document location] ... *//** Return an <code>XSModel</code> that represents components in this schema ... */new SchemaGrammar[]boolean hasSelfSchemaGrammar[] gstoXSModel(...)fAnnotations.lengthXSAnnotationImpl[] newArray// REVISIT: do we know the numbers of the following global decls// when creating this grammar? If so, we can pass the numbers in,// and use that number to initialize the following hashtables.// Extended tables// All global elements table// if we are parsing S4S, put built-in types in first// they might get overwritten by the types from S4S, but that's// considered what the application wants to do.//fGrammarDescription.fContextType |= XSDDescription.CONTEXT_COLLISION; // REVISIT// Annotations associated with the "root" schema of this targetNamespace// All substitution group information declared in this namespace// Array to store complex type decls for constraint checking// Groups being redefined by restriction// List of imported grammars// Locations// target namespace// grammar description// no global decls other than types// no extended global decls// all global element decls table// get all built-in types// assign the built-in schema grammar as the XSNamespaceItem// for each of the built-in simple type definitions.// add anyType// no global decls other than attributes// no all global element decls// 4 attributes, so initialize the size as 4*2 = 8// xsi:type// xsi:nil// xsi:schemaLocation// xsi:noNamespaceSchemaLocation// no global decls other than types and// element declarations for <annotation>, <documentation> and <appinfo>.// all global element declarations// create element declarations for <annotation>, <documentation> and <appinfo>// add global element declarations// create complex type declarations for <annotation>, <documentation> and <appinfo>// set the types on their element declarations// create attribute groups for <annotation>, <documentation> and <appinfo>// fill in attribute groups// create and fill attribute uses for <annotation>, <documentation> and <appinfo>// create lax attribute wildcard for <annotation>, <documentation> and <appinfo>// add attribute uses and wildcards to attribute groups for <annotation>, <documentation> and <appinfo>// create particles for <annotation>// create wildcard particle for <documentation> and <appinfo>// fill complex types// if there is a substitution group affiliation, store in an array,// for further constraint checking: UPA, PD, EDC// double array size each time.// don't allow this.// null implementation// the wildcard used in anyType (content and attribute)// the spec will change strict to skip for anyType// the particle for the content wildcard// the model group of a sequence of the above particle// the content of anyType: particle of the above model group// ignore this call.// also ignore this call.// attribute use// attribute group// group// model group// particle// wildcard// idc// annotation// facet// multi value facet// complex type// simple type// REVISIT:  when schema handles XML 1.1, will need to// revisit this (and the practice of not prepending an XML decl to the annotation string// note that this should never produce errors or require// entity resolution, so just a barebones configuration with// a couple of feature  set will do fine// get the hashtable for this type of components// for complex/simple types, create a special implementation,// which take specific types out of the hash table// class SchemaGrammar/** This class customizes the behaviour of the util.NamespaceSupport ... */// more effecient than NamespaceSupport(NamespaceContext)nSupport.fNamespaceSizefNamespace.lengthnSupport.fNamespacenSupport.fCurrentContextfContext.lengthnSupport.fContext/** This method takes a set of Strings, as stored in a ... */// end constructornamespaceDecls.lengthString[] tempNSArray/** This method returns an array of Strings, as would be stored in ... */// setEffectiveContext(String):voidString[] returnValint bottomLocalContextint copyCount// returned by getEffectiveLocalContext.// This method removes from this object all the namespaces// getEffectiveLocalContext():String// expand namespace's size...// the trick here is to recognize that all local contexts// happen to start at fContext[3].// context 1: empty// context 2: decls for xml and xmlns;// context 3: decls on <xs:schema>: the global ones// makeGlobal// class NamespaceSupport/** Collection of symbols used to parse a Schema Grammar. ... */String URI_XSI;// xsi attributes: in validator// symbol table that comes with the parser// the following strings (xsi:, xsd) will be added into the// the validator can choose to add them by itself.// are not symbols in the schema document.// strings that's not added to the schema symbol table, because theyString XSI_SCHEMALOCATION;String XSI_NONAMESPACESCHEMALOCATION;String XSI_TYPE;String XSI_NIL;// schema namespaceString ELT_ALL;// all possible schema element namesString ELT_ANNOTATION;String ELT_ANY;String ELT_ANYATTRIBUTE;String ELT_APPINFO;String ELT_ATTRIBUTE;String ELT_ATTRIBUTEGROUP;String ELT_CHOICE;String ELT_COMPLEXCONTENT;String ELT_COMPLEXTYPE;String ELT_DOCUMENTATION;String ELT_ELEMENT;String ELT_ENUMERATION;String ELT_EXTENSION;String ELT_FIELD;String ELT_FRACTIONDIGITS;String ELT_GROUP;String ELT_IMPORT;String ELT_INCLUDE;String ELT_KEY;String ELT_KEYREF;String ELT_LENGTH;String ELT_LIST;String ELT_MAXEXCLUSIVE;String ELT_MAXINCLUSIVE;String ELT_MAXLENGTH;String ELT_MINEXCLUSIVE;String ELT_MININCLUSIVE;String ELT_MINLENGTH;String ELT_NOTATION;String ELT_PATTERN;String ELT_REDEFINE;String ELT_RESTRICTION;String ELT_SCHEMA;String ELT_SELECTOR;String ELT_SEQUENCE;String ELT_SIMPLECONTENT;String ELT_SIMPLETYPE;String ELT_TOTALDIGITS;String ELT_UNION;String ELT_UNIQUE;String ELT_WHITESPACE;String ATT_ABSTRACT;// all possible schema attribute names (and xml:lang defined on <schema> and <documentation>)String ATT_ATTRIBUTEFORMDEFAULT;String ATT_BASE;String ATT_BLOCK;String ATT_BLOCKDEFAULT;String ATT_DEFAULT;String ATT_ELEMENTFORMDEFAULT;String ATT_FINAL;String ATT_FINALDEFAULT;String ATT_FIXED;String ATT_FORM;String ATT_ID;String ATT_ITEMTYPE;String ATT_MAXOCCURS;String ATT_MEMBERTYPES;String ATT_MINOCCURS;String ATT_MIXED;String ATT_NAME;String ATT_NAMESPACE;String ATT_NILLABLE;String ATT_PROCESSCONTENTS;String ATT_REF;String ATT_REFER;String ATT_SCHEMALOCATION;String ATT_SOURCE;String ATT_SUBSTITUTIONGROUP;String ATT_SYSTEM;String ATT_PUBLIC;String ATT_TARGETNAMESPACE;String ATT_TYPE;String ATT_USE;String ATT_VALUE;String ATT_VERSION;String ATT_XML_LANG;String ATT_XPATH;String ATTVAL_TWOPOUNDANY;// all possible schema attribute valuesString ATTVAL_TWOPOUNDLOCAL;String ATTVAL_TWOPOUNDOTHER;String ATTVAL_TWOPOUNDTARGETNS;String ATTVAL_POUNDALL;String ATTVAL_FALSE_0;String ATTVAL_TRUE_1;String ATTVAL_ANYSIMPLETYPE;String ATTVAL_ANYTYPE;String ATTVAL_ANYURI;String ATTVAL_BASE64BINARY;String ATTVAL_BOOLEAN;String ATTVAL_BYTE;String ATTVAL_COLLAPSE;String ATTVAL_DATE;String ATTVAL_DATETIME;String ATTVAL_DAY;String ATTVAL_DECIMAL;String ATTVAL_DOUBLE;String ATTVAL_DURATION;String ATTVAL_ENTITY;String ATTVAL_ENTITIES;String ATTVAL_EXTENSION;String ATTVAL_FALSE;String ATTVAL_FLOAT;String ATTVAL_HEXBINARY;String ATTVAL_ID;String ATTVAL_IDREF;String ATTVAL_IDREFS;String ATTVAL_INT;String ATTVAL_INTEGER;String ATTVAL_LANGUAGE;String ATTVAL_LAX;String ATTVAL_LIST;String ATTVAL_LONG;String ATTVAL_NAME;String ATTVAL_NEGATIVEINTEGER;String ATTVAL_MONTH;String ATTVAL_MONTHDAY;String ATTVAL_NCNAME;String ATTVAL_NMTOKEN;String ATTVAL_NMTOKENS;String ATTVAL_NONNEGATIVEINTEGER;String ATTVAL_NONPOSITIVEINTEGER;String ATTVAL_NORMALIZEDSTRING;String ATTVAL_NOTATION;String ATTVAL_OPTIONAL;String ATTVAL_POSITIVEINTEGER;String ATTVAL_PRESERVE;String ATTVAL_PROHIBITED;String ATTVAL_QNAME;String ATTVAL_QUALIFIED;String ATTVAL_REPLACE;String ATTVAL_REQUIRED;String ATTVAL_RESTRICTION;String ATTVAL_SHORT;String ATTVAL_SKIP;String ATTVAL_STRICT;String ATTVAL_STRING;String ATTVAL_SUBSTITUTION;String ATTVAL_TIME;String ATTVAL_TOKEN;String ATTVAL_TRUE;String ATTVAL_UNBOUNDED;String ATTVAL_UNION;String ATTVAL_UNQUALIFIED;String ATTVAL_UNSIGNEDBYTE;String ATTVAL_UNSIGNEDINT;String ATTVAL_UNSIGNEDLONG;String ATTVAL_UNSIGNEDSHORT;String ATTVAL_YEAR;String ATTVAL_YEARMONTH;short FORM_UNQUALIFIED;// form qualified/unqualifiedshort FORM_QUALIFIED;short USE_OPTIONAL;short USE_REQUIRED;short USE_PROHIBITED;int OCCURRENCE_UNBOUNDED;// maxOccurs = "unbounded"/** To store and validate information about substitutionGroup ... */new HashMap<XSElementDecl,Object>(...)new HashMap<XSElementDecl,XSElementDecl[]>(...)new OneSubGroup[]...[] EMPTY_GROUP;XSGrammarBucket fGrammarBucket;// grammar resolver// check whether one element decl matches an element with the given qname// 3.9.4 Element Sequence Locally Valid (Particle) 2.3.3SchemaGrammar sGrammarelement.localpartexemplar.fNameexemplar.fTargetNamespaceexemplar.fScopeexemplar.fBlocksubstitutionGroupOK(...)// check whether element can substitute exemplar// 3.3.6 Substitution Group OK (Transitive)XSElementDecl subGroupelement.fSubGroupsubGroup.fSubGrouptypeDerivationOK(...)element.fTypeexemplar.fTypeshort devMethodshort blockConstraint(...).fDerivedBy(...).fBlockXSSimpleTypeDefinition stXSSimpleTypeDefinition.VARIETY_UNION// check whether element is in exemplar's substitution groupMap<XSElementDecl,Object> fSubGroupsB;// - an array of OneSubGroup, which contains its substitution group before block.//   substitution group affilication// - a Vector, which contains all elements that has this element as their// the key to the map is an element decl, and the value is// to store substitution group information...[] EMPTY_VECTOR;Map<XSElementDecl,XSElementDecl[]> fSubGroups;// The real substitution groups (after "block")/** clear the internal registry of substitutionGroup information *//** add a list of substitution group information. */XSElementDecl subHeadXSElementDecl elementVector<> subGroupelements.length/** get all elements that can substitute the given element, ... */XSElementDecl[] subGroupOneSubGroup[] groupBgetSubGroupB(...)new OneSubGroup(...)groupB.lengthint rlenXSElementDecl[] retelement.fBlock...[...].dMethod...[...].subXSElementDecl[] ret1// Get potential sub group element (without considering "block")Object subGroupVector<> groupVector<> newGroupOneSubGroup[] group1short dMethodshort bMethodshort dSubMethodshort bSubMethodOneSubGroup[] retXSElementDecl subgetDBMethods(...)sub.fTypemethods.dMethodmethods.bMethodgroup1.length...[...].bMethodSubstitutionGroupHandler$OneSubGroup// Record the information about how one element substitute another onethis.subthis.dMethodthis.bMethodXSElementDecl sub;// The element that substitutes another oneshort dMethod;// the head's type// The combination of all derivation methods from sub's type toshort bMethod;// excluding sub's type// The combination of {block} of the types in the derivation chain// if the exemplar is not a global element decl, then it's not possible// to be substituted by another element.// if the decl blocks substitution, return false// get grammar of the element// get the decl for the element// and check by using substitutionGroup information// For an element declaration (call it D) to be validly substitutable for another element declaration (call it C) subject to a blocking constraint (a subset of {substitution, extension, restriction}, the value of a {disallowed substitutions}) one of the following must be true:// 1. D and C are the same element declaration.// 2 All of the following must be true:// 2.1 The blocking constraint does not contain substitution.// 2.2 There is a chain of {substitution group affiliation}s from D to C, that is, either D's {substitution group affiliation} is C, or D's {substitution group affiliation}'s {substitution group affiliation} is C, or . . .// 2.3 The set of all {derivation method}s involved in the derivation of D's {type definition} from C's {type definition} does not intersect with the union of the blocking constraint, C's {prohibited substitutions} (if C is complex, otherwise the empty set) and the {prohibited substitutions} (respectively the empty set) of any intermediate {type definition}s in the derivation of D's {type definition} from C's {type definition}.// prepare the combination of {derivation method} and// {disallowed substitution}// "derived" should be derived from "base"// add derivation methods of derived types to devMethod;// add block of base types to blockConstraint.// type == null means the current type is anySimpleType,// whose base type should be anyType// If the base is a union, check if "derived" is allowed through any of the member types.// [Definition:]  Every element declaration (call this HEAD) in the {element declarations} of a schema defines a substitution group, a subset of those {element declarations}, as follows:// Define PSG, the potential substitution group for HEAD, as follows:// 1 The element declaration itself is in PSG;// 2 PSG is closed with respect to {substitution group affiliation}, that is, if any element declaration in the {element declarations} has a {substitution group affiliation} in PSG, then it is also in PSG itself.// HEAD's actual substitution group is then the set consisting of each member of PSG such that all of the following must be true:// 1 Its {abstract} is false.// 2 It is validly substitutable for HEAD subject to an empty blocking constraint, as defined in Substitution Group OK (Transitive) (3.3.6).// for all elements with substitution group affiliation// check whether this an entry for this element// if not, create a new one// add to the vactor// If we already have sub group for this element, just return it.// Otherwise, get all potential sub group elements// (without considering "block" on this element// For each of such elements, check whether the derivation methods// overlap with "block". If not, add it to the sub group// Resize the array if necessary// Store the subgroup// substitution group for this one is empty// we've already calculated the element, just return.// we only have the *direct* substitutions// then for each of the direct substitutions, get its substitution// group, and combine the groups together.// Check whether this element is blocked. If so, ignore it.// Remember derivation methods and blocks from the types// Add this one to potential group// Get potential group for this element// For each of them, check whether it's blocked (by type)// Ignore it if it's blocked// Convert to an array// Store the potential sub group// No derivation relation, or blocked, return false// Remember the derivation methods and blocks, return true.// class SubstitutionGroupHandler/** This exception might be thrown by any constraint checking method. ... */// store a datatype error: error code plus the arguments// report an errorimport DOMErrorImplimport DOMMessageFormatterimport DOMStringListImplimport SchemaDVFactoryImplimport CMBuilderimport CMNodeFactoryimport XSDHandlerimport LSInputListimport XSLoader/** This class implements xni.grammars.XMLGrammarLoader. ... */new ParserConfigurationSettings(...)new CMNodeFactory(...)Constants.VALIDATE_ANNOTATIONS_FEATUREConstants.GENERATE_SYNTHETIC_ANNOTATIONS_FEATUREConstants.HONOUR_ALL_SCHEMALOCATIONS_FEATUREConstants.SCHEMA_LOCATIONConstants.SCHEMA_NONS_LOCATIONXMLConstants.ACCESS_EXTERNAL_SCHEMA/** Feature identifier: schema full checking */// Feature identifiers:/** Feature identifier: allow java encodings to be recognized when parsing schema docs. */String VALIDATE_ANNOTATIONS;/** Feature identifier: validate annotations. */String DISALLOW_DOCTYPE;/** Feature: disallow doctype */String GENERATE_SYNTHETIC_ANNOTATIONS;/** Feature: generate synthetic annotations */String HONOUR_ALL_SCHEMALOCATIONS;/** Feature identifier: honour all schemaLocations */String AUGMENT_PSVI;/** Feature identifier: tolerate duplicates */String OVERRIDE_PARSER;String XMLGRAMMAR_POOL;/** Property identifier: schema location. *//** Property identifier: no namespace schema location. *//** Property identifier: JAXP schema source. */String ACCESS_EXTERNAL_DTD;/** Property identifier: access to external dtd */String ACCESS_EXTERNAL_SCHEMA;/** Property identifier: access to external schema */// recognized propertiesParserConfigurationSettings fLoaderConfig;// features and propertiesXMLEntityResolver fUserEntityResolver;String fExternalSchemas;String fExternalNoNSSchema;Object fJAXPSource;// JAXP property: schema sourceboolean fIsCheckedFully;// is Schema Full Checking enabledboolean fJAXPProcessed;// boolean that tells whether we've tested the JAXP property.boolean fSettingsChanged;// if features/properties has not been changed, the value of this attribute is "false"XSDHandler fSchemaHandler;// xml schema parsingSubstitutionGroupHandler fSubGroupHandler;CMNodeFactory fNodeFactory;CMBuilder fCMBuilder;//component mgr will be set laterXSDDescription fXSDDescription;String faccessExternalSchema;Map<> fJAXPCache;// XSLoader attributesDOMErrorHandlerWrapper fErrorHandler;/** DOM L3 error handler */DOMEntityResolverWrapper fResourceResolver;/** DOM L3 resource resolver */// default constructor.  Create objects we absolutely need:/** This constractor is used by the XMLSchemaValidator. Additional properties, i.e. XMLEntityManager, ... */XSMessageFormatter.SCHEMA_DOMAINnew XSMessageFormatter(...)new XSGrammarBucket(...)new SubstitutionGroupHandler(...)new CMBuilder(...)new XSDHandler(...)// getRecognizedFeatures():  String[]/** Sets the state of a feature. ... */// getFeature (String):  booleansetGenerateSyntheticAnnotations(...)// setFeature(String, boolean)// getRecognizedProperties():  String[]/** Sets the state of a property. ... */XMLSecurityPropertyManager.Property.ACCESS_EXTERNAL_SCHEMA// setProperty(String, Object)int numSourcesource.lengthloadGrammar(...)XSDDescription descMap<> locationPairsSchemaGrammar grammarloadSchema(...)desc.fContextTypesetLiteralSystemId(...)processExternalHints(...)getGrammars(...)fullSchemaChecking(...)/** This method is called either from XMLGrammarLoader.loadGrammar or from XMLSchemaValidator. ... */parseSchema(...)processJAXPSchemaSource(...)/** This method tries to resolve location of the given schema. ... */// loadSchema(XSDDescription, XMLInputSource):  SchemaGrammarString locString expandedLocfromInstance(...)getContextType(...)XSDDescription.CONTEXT_IMPORTgetTargetNamespace(...)LocationArray tempLAgetFirstLocation(...)String[] hintsgetLocationHints(...)hints.length// add external schema locations to the location pairsXMLSchemaLoader.LocationArrayXSAttributeDecl attrDeclSchemaGrammar.SG_XSIattrDecl.fTypetokenizeSchemaLocationStr(...)LocationArray lanew LocationArray(...)addLocation(...)// @return true if no problems; false if string could not be tokenized// @param locations     HashMap mapping namespaces to LocationArray objects holding lists of locaitons// @param schemaStr     The schemaLocation string to tokenize// is augmented to include as many tokens as possible.// otherwise, true is returned.  In either case, locations// If an error is encountered, false is returned;// this method takes a SchemaLocation string./** Translate the various JAXP SchemaSource property types to XNI ... */// tokenizeSchemaLocation(String, HashMap):  booleanXMLInputSource xisString sidObject[] objArrVector<> jaxpSchemaSourceNamespacesSchemaGrammar gxsdToXMLInputSource(...)fXSDDescription.fContextTypefXSDDescription.fLocationHintsInputSource.classStatus.NOT_SUPPORTEDobjArr.lengthString targetNamespace//processJAXPSchemaSourcesaxToXMLInputSource(...)//Convert a SAX InputSource to an equivalent XNI XMLInputSourceReader charStreamInputStream byteStreamXMLSchemaLoader$LocationArray...[] locations;locations.length//setLocation()//getLocationArray()//locationArrayXMLSecurityManager smSchemaDVFactory dvFactoryboolean psviinitGrammarBucket(...)getDVFactory(...)setDVFactory(...)new XSDeclarationPool(...)setDeclPool(...)boolean fatalErrorGrammar[] initialGrammarsinitialGrammars.lengthGrammar gdom2xmlInputSource(...)reportDOMFatalError(...)DOMErrorImpl errorerror.fExceptionboolean featureObject propertygetStringData(...)// XML Component API// store properties and features in configuration// make sure error reporter knows about schemas...// entity manager is null if XMLSchemaValidator creates the loader// by default augment PSVI (i.e. don't use declaration pool)// REVISIT: this method should have a namespace parameter specified by// user. In this case we can easily detect if a schema asked to be loaded// is already in the local cache.// none of the other fields make sense for preparsing// Process external schema location properties.// We don't call tokenizeSchemaLocationStr here, because we also want// to check whether the values are valid URI.// NOTE: we only need to verify full checking in case the schema was not provided via JAXP// since full checking already verified for all JAXP schemas// this should only be done once per invocation of this object;// unless application alters JAXPSource in the mean time.// we consider the schema location properties for import// use empty string as the key for absent namespace// get the location hint for that namespace// if it's not import, or if the target namespace is not set// in the schema location properties, use location hint// get the attribute decl for xsi:schemaLocation// because external schema location property has the same syntax// as xsi:schemaLocation// validation the string value to get the list of URI's// report warning (odd number of items)// report warning (not list of URI's)// similarly for no ns schema location property// report warning (not a URI)// error!// Not an array// it is possible that we won't be able to resolve JAXP schema-source location// Not an Object[], String[], File[], InputStream[], InputSource[]// JAXP spec. allow []s of type String, File, InputStream,// InputSource also, apart from [] of type Object.//make local vector for storing targetn namespaces of schemasources specified in object arrays.// load schema//when an array of objects is passed it is illegal to have two schemas that share same namespace.//REVISIT: What should be the acutal behavior if grammar can't be loaded as specified in schema source?// String value is treated as a URI that is passed through the// EntityResolver// REVISIT: can this happen?// Treat value as a URI and pass in as systemId// TODO Auto-generated method stub// need to reprocess JAXP schema sources// reinitialize grammar bucket//pass the component manager to the factory..// get registered entity manager to be able to resolve JAXP schema-source property:// Note: in case XMLSchemaValidator has created the loader,// the entity manager property is null// get the error reporter// Determine schema dv factory to use// get schema location properties// get JAXP sources if available// clear grammars, and put the one for schema namespace there// get continue-after-fatal-error feature// set full validation to false// get generate-synthetic-annotations feature// put this grammar into the bucket, along with grammars// imported by it (directly or indirectly)// REVISIT: a conflict between new grammar(s) and grammars// in the bucket. What to do? A warning? An exception?// need to wrap the LSInput with an XMLInputSource/** An LSParser looks at inputs specified in LSInput in ... */// check whether there is a Reader// according to DOM, we need to treat such reader as "UTF-16".// check whether there is an InputStream// if there is a string data, use a StringReader// according to DOM, we need to treat such data as "UTF-16".// otherwise, just use the public/system/base Ids// XMLGrammarLoaderimport FieldActivatorimport KeyRefimport UniqueOrKeyimport ValueStoreimport XPathMatcherimport XSCMValidatorimport XMLParserimport MalformedURIException/** The XML Schema validator. The validator implements a document ... */new ElementPSVImpl(...)new XSIErrorReporter(...)new HashMap<String,LocationArray>(...)SchemaGrammar.SG_SchemaNSnew XMLSchemaLoader(...)fXSIErrorReporter.fErrorReporternew XSNotationDecl[]new XSCMValidator[]new XPathMatcherStack(...)new ValueStoreCache(...)Constants.SCHEMA_ELEMENT_DEFAULTConstants.USE_GRAMMAR_POOL_ONLY_FEATUREConstants.SUN_SCHEMA_FEATURE_PREFIXConstants.SUN_REPORT_IGNORED_ELEMENT_CONTENT_WHITESPACEString SCHEMA_VALIDATION;/** Feature identifier: expose schema normalized value *//** Feature identifier: send element default value via characters() *//** Feature identifier: augment PSVI *//** Feature identifier: whether to recognize java encoding names */String USE_GRAMMAR_POOL_ONLY;/** Feature identifier: use grammar pool only *//** Feature identifier: whether to continue parsing a schema after a fatal error is encountered */String REPORT_WHITESPACE;/** Property identifier: JAXP schema language. */int ID_CONSTRAINT_NUM;// never > 1; so leave it at that.// we expect an element to have.  It's almost// this is the number of valuestores of each kindElementPSVImpl fCurrentPSVI;/** current PSVI element info */AugmentationsImpl fAugmentations;// clear this before we introduce it into the pipeline.// If it is not present in calls that we're passing on, we *must*// having to create this object continually, it is created here.// Augmentations parameter if one is null, to save ourselves from// since it is the responsibility of each component to anHashMap<> fMayMatchFieldMap;/** Map which is used to catch instance documents that try ... */XMLString fDefaultValue;// this is included for the convenience of handleEndElement// Validation featuresboolean fSchemaDynamicValidation;boolean fDoValidation;boolean fFullChecking;boolean fNormalizeData;boolean fSchemaElementDefault;boolean fAugPSVI;boolean fIdConstraint;boolean fUseGrammarPoolOnly;boolean fNamespaceGrowth;// Namespace growth featureboolean fEntityRef;// to indicate whether we are in the scope of entity reference or CDataboolean fInCDATA;boolean fSawOnlyWhitespaceInElementContent;// Did we see only whitespace in element content?/** While parsing a document, keep the location of the document. */XMLSchemaValidator$XSIErrorReporter/** A wrapper of the standard error reporter. We'll store all schema errors ... */// the error reporter propertyVector<> fErrors;// number of element (depth); and whether to record error// store error codes; starting position of the errors for each element;...[] fContext;int fContextCount;// set the external error reporter, clear errors// store the starting position for the current context// should be called when starting process an element or an attribute.// should be called on endElement: get all errors of the current elementint contextPosString[] errors// also called after an element was strictly assessed.// this attribute, but leave the errors to the containing element// should be called when an attribute is done: get all errors of// reportError(String,String,Object[],short)XSIErrorReporter fXSIErrorReporter;/** Entity resolver */// schema location property valuesString fExternalNoNamespaceSchema;Object fJaxpSchemaSource;//JAXP Schema Source property/** Schema Grammar Description passed,  to give a chance to application to supply the Grammar */Map<String,LocationArray> fLocationPairs;boolean reportWhitespace;setNamespaceSupport(...)Augmentations modifiedAugs// startElement(QName,XMLAttributes, Augmentations)// emptyElement(QName,XMLAttributes, Augmentations)handleIgnorableWhitespace(...)// endElement(QName, Augmentations)// DOMRevalidationHandler methods// endDocument(Augmentations)XSSimpleType.WS_PRESERVEfNormalizedStr.chfNormalizedStr.offsetfNormalizedStr.lengthXSComplexTypeDecl ctypectype.fContentType// XMLDocumentHandler and XMLDTDHandler methodsint INITIAL_STACK_SIZE;int INC_STACK_SIZE;boolean DEBUG_NORMALIZATION;// Schema NormalizationXMLString fEmptyXMLStr;// temporary empty string buffer.// temporary character buffer, and empty string buffer.XMLString fNormalizedStr;boolean fFirstChunk;boolean fTrailing;// got first chunk in characters() (SAX)// Previous chunk had a trailing spaceboolean fUnionType;//whiteSpace: preserve/replace/collapse/** Schema grammar resolver. */XSSimpleType fQNameDV;//          so that we can QNameDV.getCompiledForm()// REVISIT: in new simple type design, make things in DVs static,/** the DV usd to convert xsi:type to a QName */CMNodeFactory nodeFactory;// REVISIT: create decl pool, and pass it to each traversers/** used to build content models */XMLSchemaLoader fSchemaLoader;// Schema grammar loaderString fValidationRoot;// REVISIT: what do we store here? QName, XPATH, some ID? use rawname now./** String representation of the validation root. */int fSkipValidationDepth;/** Skip validation: anything below this level should be skipped */int fNFullValidationDepth;/** anything above this level has validation_attempted != full */int fNNoneValidationDepth;/** anything above this level has validation_attempted != none *//** Element depth: -2: validator not in pipeline; >= -1 current depth. */boolean fSubElement;/** Seen sub elements. */...[] fSubElementStack;/** Seen sub elements stack. */XSElementDecl fCurrentElemDecl;/** Current element declaration. */...[] fElemDeclStack;/** Element decl stack. *//** nil value of the current element */...[] fNilStack;/** nil value stack */XSNotationDecl fNotation;/** notation value of the current element */...[] fNotationStack;/** notation stack */XSTypeDefinition fCurrentType;/** Current type. */...[] fTypeStack;/** type stack. */XSCMValidator fCurrentCM;/** Current content model. */...[] fCMStack;/** Content model stack. */...[] fCurrCMState;/** the current state of the current content model */...[] fCMStateStack;/** stack to hold content model states */boolean fStrictAssess;/** whether the curret element is strictly assessed */...[] fStrictAssessStack;/** strict assess stack */boolean fAppendBuffer;/** Whether need to append characters to fBuffer */boolean fSawText;/** Did we see any character data? */...[] fSawTextStack;/** stack to record if we saw character data */boolean fSawCharacters;/** Did we see non-whitespace character data? */...[] fStringContent;/** Stack to record if we saw character data outside of element content *//** temporary qname */ValidatedInfo fValidatedInfo;/** temporary validated info */ValidationState fState4XsiType;// only need to check facets, so we set extraChecking to false (in reset)// used to validate default/fixed values against xsi:typeValidationState fState4ApplyDefault;// only need to check id/idref/entity, so we set checkFacets to false// used to apply default/fixed valuesXPathMatcherStack fMatcherStack;/** Stack of active XPath matchers for identity constraints. All ... */// identity constraint informationValueStoreCache fValueStoreCache;/** Cache of value stores for identity constraint fields. */setExtraChecking(...)setFacetChecking(...)XMLSchemaValidator.SCHEMA_VALIDATIONsetSymbolTable(...)/** Start the value scope for the specified identity constraint. This ... */// FieldActivator methodsValueStoreBase valueStoregetValueStoreFor(...)startValueScope(...)/** Request to activate the specified field. This method returns the ... */// startValueScopeFor(IdentityConstraint identityConstraint)ValueStore valueStoregetIdentityConstraint(...)XPathMatcher matchercreateMatcher(...)setMayMatch(...)addMatcher(...)startDocumentFragment(...)/** Ends the value scope for the specified identity constraint. ... */// activateField(Field):XPathMatcherendValueScope(...)/** Sets whether the given field is permitted to match a value. ... */// endValueScopeFor(IdentityConstraint)/** Returns whether the given field is permitted to match a value. ... */// setMayMatch(Field, Boolean)// a utility method for Identity constraints// mayMatch(Field):BooleanFieldActivator activatorfElemDeclStack.lengthboolean[] newArrayBXSElementDecl[] newArrayEXSNotationDecl[] newArrayNXSTypeDefinition[] newArrayTXSCMValidator[] newArrayCint[][] newArrayIA// handle start documentfCurrentPSVI.fGrammarsfCurrentPSVI.fSchemaInformation// handleStartDocument(XMLLocator,String)// returns the normalized string if possible, otherwise the original string// handle character contents// handleEndDocument()/** Normalize whitespace in an XMLString according to the rules defined ... */// handleCharacters(XMLString)boolean sawNonWSboolean leadingboolean trailingfNormalizedStr.ch.length// handle ignorable whitespace/** Handle element. */// handleIgnorableWhitespace(XMLString)String sLocationString nsLocationfindSchemaGrammar(...)XSDDescription.CONTEXT_ELEMENTObject declString xsiTypeString xsiNilgetMatcherCount(...)isGrammarFound(...)storeLocations(...)getEmptyAugs(...)oneTransition(...)XSCMValidator.FIRST_ERRORVector<> nextctype.fParticlewhatCanGoHere(...)expectedStr(...)reportSchemaError(...)XSWildcardDecl.PC_SKIPfCurrentElemDecl.fTypeXSWildcardDecl.PC_STRICTgetAndCheckXsiType(...)getConstraintType(...)XSConstants.VC_FIXEDXSComplexTypeDecl.CONTENTTYPE_SIMPLEgetAbstract(...)XSSimpleType.VARIETY_UNIONctype.fXSSimpleTypeDatatypeException eXSSimpleType dvgetContentModel(...)getXsiNil(...)getAttrGrp(...)fCurrentElemDecl.fIDCPosinitValueStoresFor(...)processAttributes(...)addDefaultAttributes(...)getMatcherAt(...)fCurrentPSVI.fValidationContextfCurrentPSVI.fDeclarationfCurrentPSVI.fTypeDeclfCurrentPSVI.fNotation/** Handle end element. If there is not text content, and there is a ... */int oldCountint newCountSchemaGrammar[] grammarsprocessElementContent(...)fValidatedInfo.actualValuefValidatedInfo.actualValueTypefValidatedInfo.itemValueTypesgetNillable(...)fCurrentElemDecl.fDefault.actualValuefCurrentElemDecl.fDefaultfCurrentElemDecl.fDefault.actualValueTypefCurrentElemDecl.fDefault.itemValueTypesSelector.MatcherMatcher selMatcherIdentityConstraint idgetCategory(...)IdentityConstraint.IC_KEYREFtransplant(...)getInitialDepth(...)ValueStoreBase valuesendDocumentFragment(...)String invIdRefsetImmutable(...)endElementPSVI(...)// handleEndElement(QName,boolean)*/this.fCurrentElemDeclthis.fCurrentTypethis.fValidationRootfCurrentPSVI.fValidationAttemptedElementPSVI.VALIDATION_FULLElementPSVI.VALIDATION_PARTIALfCurrentPSVI.fSpecifiedfCurrentPSVI.fNilfCurrentPSVI.fMemberTypefValidatedInfo.memberTypefCurrentPSVI.fNormalizedValuefValidatedInfo.normalizedValuefCurrentPSVI.fActualValuefCurrentPSVI.fActualValueTypefCurrentPSVI.fItemValueTypesmergeContext(...)fCurrentPSVI.fErrorCodesfCurrentPSVI.fValidityElementPSVI.VALIDITY_VALIDElementPSVI.VALIDITY_INVALID//tries to parse the grammar using location hints from the give namespace.//the local pool, if not in local pool, it gives chance to application to be able to retrieve the grammar, then it//this is the function where logic of retrieving grammar is written , parser first tries to get the grammar from//storeLocationsMap<String,LocationArray> locationPairsLocationArray locationArrayfXSDDescription.fEnclosedElementNamefXSDDescription.fTriggeringComponentfXSDDescription.fAttributesgetLocationArray(...)temp.lengthsetLocationHints(...)boolean toParseSchemaresolveDocument(...)getDocumentLocations(...)String[] locationHints//findSchemaGrammarQName typeNameInvalidDatatypeValueException etypeName.uritypeName.localpartXSDDescription.CONTEXT_XSITYPEshort blockfCurrentElemDecl.fBlockcheckTypeDerivationOk(...)//getAndCheckXsiTypeSchemaSymbols.ATTVAL_TRUESchemaSymbols.ATTVAL_TRUE_1String wildcardIDNameint attCountAttributePSVImpl attrPSVIXSObjectList attrUsesint useCountXSWildcardDecl attrWildcardgetAttributeUses(...)XSAttributeUseImpl currUseXSAttributeUseImpl oneUseXSAttributeDecl currDeclnew AttributePSVImpl(...)attrPSVI.fValidationContextfTempQName.urifTempQName.localpartprocessOneAttribute(...)fTempQName.rawnameoneUse.fAttrDecl.fNameoneUse.fAttrDecloneUse.fAttrDecl.fTargetNamespaceallowNamespace(...)currUse.fAttrDeclXSDDescription.CONTEXT_ATTRIBUTEattrWildcard.fProcessContentscurrDecl.fTypecurrDecl.fNameattrGrp.fIDAttrName//processAttributesXSSimpleType attDVObject actualValueXMLAttributesImpl attrsboolean schemaIdsetSchemaId(...)XSSimpleType.VARIETY_ATOMICXSSimpleType.PRIMITIVE_NOTATIONqName.uriqName.localpartInvalidDatatypeValueException idveisComparable(...)currDecl.fDefaultcurrDecl.fDefault.actualValuecurrUse.fConstraintTypecurrUse.fDefaultcurrUse.fDefault.actualValueattrPSVI.fActualValueattrPSVI.fDeclarationattrPSVI.fTypeDeclattrPSVI.fMemberTypeattrPSVI.fNormalizedValueattrPSVI.fActualValueTypeattrPSVI.fItemValueTypesattrPSVI.fValidationAttemptedAttributePSVI.VALIDATION_FULLattrPSVI.fErrorCodesattrPSVI.fValidityAttributePSVI.VALIDITY_VALIDAttributePSVI.VALIDITY_INVALIDshort constTypeValidatedInfo defaultValueboolean isSpecifiedQName attNamecurrDecl.fTargetNamespacecurrUse.fUseSchemaSymbols.USE_REQUIREDString normalizeddefaultValue.memberTypedefaultValue.actualValuedefaultValue.actualValueTypedefaultValue.itemValueTypesattrPSVI.fSpecified/** If there is not text content, and there is a ... */// addDefaultAttributesString strvint bufLenthis.fValidatedInfoElementDefaultValidImmediate(...)elementLocallyValidType(...)fCurrentElemDecl.fDefault.normalizedValue// processElementContentObject retValuesetNormalizationRequired(...)elementLocallyValidComplexType(...)// elementLocallyValidTypeXSComplexTypeDecl.CONTENTTYPE_EMPTYArrayList<> errorscheckMinMaxBounds(...)// elementLocallyValidComplexType/** Returns true if the two ValidatedInfo objects can be compared in the same value space. * */info1.actualValueTypeinfo2.actualValueTypeShortList typeList1info1.itemValueTypesShortList typeList2info2.itemValueTypesStringBuffer retXMLSchemaValidator$XPathMatcherStack/** Stack of XPath matchers for identity constraints. ... */// xpath matcher information/** ******************************* */new XPathMatcher[]...[] fMatchers;/** Active matchers. */int fMatchersCount;/** Count of active matchers. */IntStack fContextStack;/** Offset stack for contexts. *//** Resets the XPath matcher stack. *//** Returns the size of the stack. *//** Returns the count of XPath matchers. */// size():int/** Adds a matcher. */// getMatcherCount():intensureMatcherCapacity(...)/** Returns the XPath matcher at the specified index. */// addMatcher(XPathMatcher)/** Pushes a new context onto the stack. */// getMatcherAt(index):XPathMatcher/** Pops a context off of the stack. */// pushContext()/** Ensures the size of the matchers array. */// popContext()fMatchers.lengthXPathMatcher[] arrayXMLSchemaValidator$ValueStoreBase/** Value store implementation base class. There are specific subclasses ... */// value store implementations// class XPathMatcherStackIdentityConstraint fIdentityConstraint;/** Identity constraint. */int fFieldCount;...[] fFields;...[] fLocalValues;/** current data */...[] fLocalValueTypes;...[] fLocalItemValueTypes;int fValuesCount;/** Current data value count. */Vector<> fValues;/** global data */ShortVector fValueTypes;Vector<> fItemValueTypes;boolean fUseValueTypeVector;int fValueTypesLength;short fValueType;boolean fUseItemValueTypeVector;int fItemValueTypesLength;ShortList fItemValueType;StringBuffer fTempBuffer;/** buffer for error messages *//** Constructs a value store for the specified identity constraint. */getFieldCount(...)getFieldAt(...)// locally-scoped ID constraint is involved.// destroys this ValueStore; useful when, for instance, a// <init>(IdentityConstraint)// appends the contents of one ValueStore to those of us.// end clear():voidnewVal.fValues/** Start scope for value store. */// append(ValueStoreBase)/** Ends scope for value store. */// startValueScope()IdentityConstraint.IC_KEYString codegetElementName(...)UniqueOrKey key// of an ID Constraint goes out of scope.// This method is called whenever the DocumentFragment// override this method for purposes of their own.// in the correct scope.  Unique and Key may also need to// This is needed to allow keyref's to look for matched keys// endValueScope()/** Signals the end of the document. This is where the specific ... */// endDocumentFragment():void/* reports an error if an element is matched ... */// ValueStore methods/** Adds the specified value to the value store. ... */// reportError(String,Object[])mayMatch(...)checkDuplicateValues(...)addValueType(...)addItemValueType(...)/** Returns true if this value store contains the locally scoped value stores */// addValue(String,Field)Object value1Object value2short valueType1short valueType2getValueTypeAt(...)ShortList list1ShortList list2getItemValueTypeAt(...)/** Returns -1 if this value store contains the specified ... */// contains():booleanVector<> valuesvsb.fValuesshort valvalueTypeContains(...)itemValueTypeContains(...)// contains(Vector):Object/** Returns a string of the specified values. */// duplicateValue(Map)// toString(Object[]):String// toString(Vector,int,int):Stringint index1int index2new ShortVector(...)valueAt(...)/** Unique value store. ... */// class ValueStoreBase/** Constructs a unique value store. *//** Called when a duplicate value is added. */// ValueStoreBase protected methods// <init>(Unique)/** Key value store. ... */// class UniqueValueStore/** Constructs a key value store. */// REVISIT: Implement a more efficient storage mechanism. -Ac// <init>(Key)/** Key reference value store. ... */// class KeyValueStoreValueStoreBase fKeyValueStore;/** Key value store. */// up keyRef loose ends.// end the value Scope; here's where we have to tie// ValueStoreBase methods// <init>(KeyRef)int errorIndexfValueStoreCache.fGlobalIDConstraintMapString values/** End document. */// endDocumentFragment()XMLSchemaValidator$ValueStoreCache/** Value store cache. This class is used to store the values for ... */// value store management// class KeyRefValueStorenew LocalIDKey(...)new HashMap<LocalIDKey,ValueStoreBase>(...)new Stack<Map<IdentityConstraint,ValueStoreBase>>(...)new HashMap<IdentityConstraint,ValueStoreBase>(...)LocalIDKey fLocalId;Vector<> fValueStores;/** stores all global Values stores. */// values storesMap<LocalIDKey,ValueStoreBase> fIdentityConstraint2ValueStoreMap;/** Values stores associated to specific identity constraints. ... */Stack<Map<IdentityConstraint,ValueStoreBase>> fGlobalMapStack;// keyrefs can only match descendants+self.// the fGlobalIDConstraintMap contains descendants+self.// the preceding siblings' eligible id constraints;// i.e., the top of the fGlobalIDMapStack always contains// fGlobalIDConstraintMap.// When a start tag is encountered, we create a new// below in the stack.// When an endElement is found, this Map is merged with the one// (which comprises all the "eligible" id constraints);// - validation always occurs against the fGlobalIDConstraintMap// The fGlobalIDMapStack has the following structure://    validate them.// - as we encounter keyref's, we look at the global table to//   its values are merged into the fGlobalIDConstraintMap;// - Once it is validated (i.e., when it goes out of scope),//   values are stored in the (local) fIdentityConstraint2ValueStoreMap;// - when a constraint is first encountered, its// sketch of algorithm:Map<IdentityConstraint,ValueStoreBase> fGlobalIDConstraintMap;/** Resets the identity constraint cache. */// onto fGlobalMapStack and clears fGlobalIDConstraint map.// startElement:  pushes the current fGlobalIDConstraintMap// startDocument()/** endElement():  merges contents of fGlobalIDConstraintMap with the ... */// startElement(void)Map<IdentityConstraint,ValueStoreBase> oldMapEntry<IdentityConstraint,ValueStoreBase> entryMap<>.Entry<IdentityConstraint,ValueStoreBase>ValueStoreBase oldValValueStoreBase currVal/** Initializes the value stores for the specified element ... */// endElement()IdentityConstraint[] icArrayeDecl.fIDConstraintsint icCounteDecl.fIDCPosUniqueOrKey uniqueLocalIDKey toHashUniqueValueStore uniqueValueStoreKeyValueStore keyValueStoreKeyRef keyRefKeyRefValueStore keyRefValueStoreIdentityConstraint.IC_UNIQUEnew UniqueValueStore(...)activateSelectorFor(...)new KeyValueStore(...)new KeyRefValueStore(...)/** Returns the value store associated to the specified IdentityConstraint. */// initValueStoresFor(XSElementDecl)fLocalId.fDepthfLocalId.fId/** Returns the global value store associated to the specified IdentityConstraint. */// getValueStoreFor(IdentityConstraint, int):ValueStoreBase// If it's a <keyRef>, then we leave it for later.// map, if id is a <unique> or a <key>.// associated with id and moves them into the global// This method takes the contents of the (local) ValueStore// getValueStoreFor(IdentityConstraint):ValueStoreBaseValueStoreBase newValsValueStoreBase currVals/** Check identity constraints. */// transplant(id)// pairs to be used easily as keys in Maps.// the purpose of this class is to enable IdentityConstraint,int// class ValueStoreCacheIdentityConstraint fId;// object method// init(IdentityConstraint, int)LocalIDKey lIDKeylIDKey.fIdlIDKey.fDepthXMLSchemaValidator$ShortVector/** A simple vector for <code>short</code>s. */// class LocalIDKey/** Current length. *//** Returns the length of the vector. *//** Adds the value to the vector. *//** Returns the short value at the specified position in the vector. *//** Returns whether the short is contained in the vector. *//** Ensures capacity. */short[] newdata// NOTE: The following defaults are nulled out on purpose.//       If they are set, then when the XML Schema validator//       is constructed dynamically, these values may override//       those set by the application. This goes against the//       whole purpose of XMLComponent#getFeatureDefault but//       it can't be helped in this case. -Ac//Boolean.FALSE,// resize array if necessary// get starting position of the current element// number of errors of the current element// if no errors, return null// copy errors from the list to an string array// remove errors of the current element// don't resize the vector: leave the errors for this attribute// to the containing element// reportError(XMLLocator,String,String,Object[],short)// Init reportWhitespace for this handler// in the case where there is a {value constraint}, and the element// doesn't have any text content, change emptyElement call to// start + characters + end// fElementDepth == -2 indicates that the schema validator was removed// from the pipeline. then we don't need to call handleEndElement.// for union types we can't normalize data// thus we only need to send augs information if any;// the normalized data for union will be send// after normalization is performed (at the endElement())// doesn't have any text content, add a characters call.// REVISIT: what should we do here if schema normalization is on??// REVISIT: this methods basically duplicates implementation of//          handleCharacters(). We should be able to reuse some code// if whitespace == -1 skip normalization, because it is a complexType// or a union type.// normalize data// When it's a complex type with element-only content, we need to// find out whether the content contains any non-whitespace character.// data outside of element content// REVISIT: what should happen if normalize_data_ is on??//reset XSDDescription// cleanup id table// reset schema loader// datatype normalization// should only clear this if the last schema had identity constraints.// get error reporter// Re-parse external schema location properties.// get symbol table. if it's a new one, add symbols to it.// store the external schema locations. they are set when reset is called,// so any other schemaLocation declaration for the same namespace will be// effectively ignored. becuase we choose to take first location hint// available for a particular namespace.// Note: data in EntityRef and CDATA is normalized as well// ensure the ch array is big enough// don't include the leading ' ' for now. might include it later.// this is a leading whitespace, record it// if we finished on a space trim it but also record it// if all we had was whitespace we skipped record it as// trailing whitespace as well// previous chunk ended on whitespace// insert whitespace// previous chunk ended on character,// this chunk starts with whitespace// The length includes the leading ' '. Now removing it.// REVISIT: the same process needs to be performed as handleCharacters.// only it's simpler here: we know all characters are whitespaces.// root element// schemaType is not specified// if a DTD grammar is found, we do the same thing as Dynamic:// if a schema grammar is found, validation is performed;// otherwise, skip the whole document.// [1] Either schemaType is DTD, and in this case validate/schema is turned off// [2] Validating against XML Schemas only//   [a] dynamic validation is false: report error if SchemaGrammar is not found//   [b] dynamic validation is true: if grammar is not found ignore.// get xsi:schemaLocation and xsi:noNamespaceSchemaLocation attributes,// parse them to get the grammars//store the location hints..  we need to do it so that we can defer the loading of grammar until//there is a reference to a component from that namespace. To provide location hints to the//application for a namespace// if we are in the content of "skip", then just skip this element// REVISIT:  is this the correct behaviour for ID constraints?  -NG//try to find schema grammar by different means..// if we are not skipping this element, and there is a content model,// we try to find the corresponding decl object for this element.// the reason we move this part of code here is to make sure the// error reported here (if any) is stored within the parent element's// context, instead of that of the current element.// it could be an element decl or a wildcard decl//REVISIT: is it the only case we will have particle = null?// if it's not the root element, we push the current states in the stacks// increase the element depth after we've saved// all states for the parent element// and the buffer to hold the value of the element// check what kind of declaration the "decl" from// oneTransition() maps to// if the wildcard is skip, then return// try again to get the element decl:// case 1: find declaration for root element// case 2: find declaration for element from another namespace// then get the type// get type from xsi:type// if no decl/type found for the current element// if this is the validation root, report an error, because// we can't find eith decl or type for this element// REVISIT: should we report error, or warning?// for dynamic validation, skip the whole content,// because no grammar was found.// no schema grammar was found, but it's either dynamic// validation, or another kind of grammar was found (DTD,// for example). The intended behavior here is to skip// the whole document. To improve performance, we try to// remove the validator from the pipeline, since it's not// supposed to do anything.// indicate that the validator was removed.// We don't call reportSchemaError here, because the spec// doesn't think it's invalid not to be able to find a// declaration or type definition for an element. Xerces is// reporting it as an error for historical reasons, but in// PSVI, we shouldn't mark this element as invalid because// of this. - SG// if wildcard = strict, report error.// needs to be called before fXSIErrorReporter.pushContext()// so that the error belongs to the parent element.// report error, because wilcard = strict// no element decl or type found for this element.// Allowed by the spec, we can choose to either laxly assess this// element, or to skip it. Now we choose lax assessment.// any type has mixed content, so we don't need to append buffer// push error reporter context: record the current position// This has to happen after we process skip contents,// otherwise push and pop won't be correctly paired.// get xsi:type// If it fails, use the old type. Use anyType if ther is no old type.// if the element has a fixed value constraint, we need to append// if the type is simple, we need to append// if the type is simple content complex type, we need to append// Element Locally Valid (Element)// 2 Its {abstract} must be false.// make the current element validation root// update normalization flags// reset values// Element Locally Valid (Type)// find out if the content type is simple and if variety is union// to be able to do character normalization// normalization: simple type// if !union type// then try to get the content model// and get the initial content model state// get information about xsi:nil// only deal with xsi:nil when there is an element declaration// now validate everything related with the attributes// first, get the attribute group// activate identity constraints// initialize when identity constrains are defined for the elem// add default attributes// call all active identity constraints// PSVI: add validation context// PSVI: add element declaration// PSVI: add element type// PSVI: add notation attribute// if we are skipping, return// but if this is the top element that we are skipping,// restore the states.// set the partial validation depth to the depth of parent// PSVI: validation attempted:// use default values in psvi item for// validation attempted, validity, and error codes// check extra schema constraints on root element// now validate the content of the element// 6 The element information item must be valid with respect to each of the {identity-constraint definitions} as per Identity-constraint Satisfied (3.11.4).// call matchers and de-activate context// handle everything *but* keyref's.// now handle keyref's/...// nothing to do if nothing matched!// have we reached the end tag of the validation root?// 7 If the element information item is the validation root, it must be valid per Validation Root Valid (ID/IDREF) (3.3.4).// check extra schema constraints// return the final set of grammars validator ended up with// Set grammars as immutable// decrease element depth and restore states// get the states for the parent element.// We should have a stack for whitespace value, and pop it up here.// But when fWhiteSpace != -1, and we see a sub-element, it must be// an error (at least for Schema 1.0). So for valid documents, the// only value we are going to push/pop in the stack is -1.// Here we just mimic the effect of popping -1. -SG// Same for append buffer. Simple types and elements with fixed// value constraint don't allow sub-elements. -SG// same here.// the 4 properties sent on startElement calls// PSVI: validation attempted// nothing below or at the same level has none or partial// (which means this level is strictly assessed, and all chidren// are full), so this one has full// nothing below or at the same level has full or partial// (which means this level is not strictly assessed, and all chidren// are none), so this one has none// otherwise partial, and anything above this level will be partial// get all errors for the current element, its attribute,// and subelements (if they were strictly assessed).// any error would make this element invalid.// and we merge these errors to the parent element.// PSVI: error codes// PSVI: validity// Discard the current context: ignore any error happened within// the sub-elements/attributes of this element, because those// errors won't affect the validity of the parent elements.// store [schema information] in the PSVI//get the grammar from local pool...// give a chance to application to be able to retreive the grammar.// use location hints instead// try to parse the grammar using location hints from that namespace..// if we are dealing with a different schema location, then include the new schema// into the existing grammar// This method also deals with clause 1.2.1.2 of the constraint// Validation Rule: Schema-Validity Assessment (Element)// 4 If there is an attribute information item among the element information item's [attributes] whose [namespace name] is identical to http://www.w3.org/2001/XMLSchema-instance and whose [local name] is type, then all of the following must be true:// 4.1 The normalized value of that attribute information item must be valid with respect to the built-in QName simple type, as defined by String Valid (3.14.4);// 4.2 The local name and namespace name (as defined in QName Interpretation (3.15.3)), of the actual value of that attribute information item must resolve to a type definition, as defined in QName resolution (Instance) (3.15.4)// if the namespace is schema namespace, first try built-in types// if it's not schema built-in types, then try to get a grammar//try to find schema grammar by different means....// still couldn't find the type, report an error// if there is no current type, set this one as current.// and we don't need to do extra checking// 4.3 The local type definition must be validly derived from the {type definition} given the union of the {disallowed substitutions} and the {type definition}'s {prohibited substitutions}, as defined in Type Derivation OK (Complex) (3.4.6) (if it is a complex type definition), or given {disallowed substitutions} as defined in Type Derivation OK (Simple) (3.14.6) (if it is a simple type definition).// 3 The appropriate case among the following must be true:// 3.1 If {nillable} is false, then there must be no attribute information item among the element information item's [attributes] whose [namespace name] is identical to http://www.w3.org/2001/XMLSchema-instance and whose [local name] is nil.// 3.2 If {nillable} is true and there is such an attribute information item and its actual value is true , then all of the following must be true:// 3.2.2 There must be no fixed {value constraint}.// whether we have seen a Wildcard ID.// for each present attribute// Element Locally Valid (Complex Type)// 3 For each attribute information item in the element information item's [attributes] excepting those whose [namespace name] is identical to http://www.w3.org/2001/XMLSchema-instance and whose [local name] is one of type, nil, schemaLocation or noNamespaceSchemaLocation, the appropriate case among the following must be true:// get the corresponding attribute decl// PSVI attribute: validation context// 3.1.1 The element information item's [attributes] must be empty, excepting those// whose [namespace name] is identical to http://www.w3.org/2001/XMLSchema-instance and// whose [local name] is one of type, nil, schemaLocation or noNamespaceSchemaLocation.// for the 4 xsi attributes, get appropriate decl, and validate// for namespace attributes, no_validation/unknow_validity// simple type doesn't allow any other attributes// it's not xmlns, and not xsi, then we need to find a decl for it// 3.2 otherwise all of the following must be true:// 3.2.1 There must be an {attribute wildcard}.// 3.2.2 The attribute information item must be valid with respect to it as defined in Item Valid (Wildcard) (3.10.4).// if failed, get it from wildcard//if (attrWildcard == null)//    reportSchemaError("cvc-complex-type.3.2.1", new Object[]{element.rawname, fTempQName.rawname});// so this attribute is not allowed// which means it matches a wildcard// skip it if processContents is skip//try to find grammar by different means...// if can't find// if strict, report error// then continue to the next attribute// 5 Let [Definition:]  the wild IDs be the set of all attribute information item to which clause 3.2 applied and whose validation resulted in a context-determined declaration of mustFind or no context-determined declaration at all, and whose [local name] and [namespace name] resolve (as defined by QName resolution (Instance) (3.15.4)) to an attribute declaration whose {type definition} is or is derived from ID. Then all of the following must be true:// 5.1 There must be no more than one item in wild IDs.// end of for (all attributes)// 5.2 If wild IDs is non-empty, there must not be any attribute uses among the {attribute uses} whose {attribute declaration}'s {type definition} is or is derived from ID.// Attribute Locally Valid// For an attribute information item to be locally valid with respect to an attribute declaration all of the following must be true:// 1 The declaration must not be absent (see Missing Sub-components (5.3) for how this can fail to be the case).// 2 Its {type definition} must not be absent.// 3 The item's normalized value must be locally valid with respect to that {type definition} as per String Valid (3.14.4).// get simple type// store the normalized value// PSVI: element notation//REVISIT: is it possible for the notation to be in different namespace than the attribute//with which it is associated, CHECK !!  <fof n1:att1 = "n2:notation1" ..>// should we give chance to the application to be able to  retrieve a grammar - nb//REVISIT: what would be the triggering component here.. if it is attribute value that// triggered the loading of grammar ?? -nb// get the value constraint from use or decl// 4 The item's actual value must match the value of the {value constraint}, if it is present and fixed.                 // now check the value against the simpleType// 3.1 If there is among the {attribute uses} an attribute use with an {attribute declaration} whose {name} matches the attribute information item's [local name] and whose {target namespace} is identical to the attribute information item's [namespace name] (where an absent {target namespace} is taken to be identical to a [namespace name] with no value), then the attribute information must be valid with respect to that attribute use as per Attribute Locally Valid (Use) (3.5.4). In this case the {attribute declaration} of that attribute use is the context-determined declaration for the attribute information item with respect to Schema-Validity Assessment (Attribute) (3.2.4) and Assessment Outcome (Attribute) (3.2.5).// PSVI: attribute declaration// PSVI: attribute type// PSVI: attribute memberType// PSVI: attribute normalized value// NOTE: we always store the normalized value, even if it's invlid,// because it might still be useful to the user. But when the it's// not valid, the normalized value is not trustable.// REVISIT: should we check prohibited attributes?// (2) report error for PROHIBITED attrs that are present (V_TAGc)// (3) add default attrs (FIXED and NOT_FIXED)// for each attribute use// get value constraint// whether this attribute is specified// 4 The {attribute declaration} of each attribute use in the {attribute uses} whose// {required} is true matches one of the attribute information items in the element// information item's [attributes] as per clause 3.1 above.// if the attribute is not specified, then apply the value constraint// PSVI: attribute is "schema" specified// for// 1 If the item is ?valid? with respect to an element declaration as per Element Locally Valid (Element) (?3.3.4) and the {value constraint} is present, but clause 3.2 of Element Locally Valid (Element) (?3.3.4) above is not satisfied and the item has no element or character information item [children], then schema. Furthermore, the post-schema-validation infoset has the canonical lexical representation of the {value constraint} value as the item's [schema normalized value] property.// fixed values are handled later, after xsi:type determined.// 3.2.1 The element information item must have no character or element information item [children].// 5 The appropriate case among the following must be true:// 5.1 If the declaration has a {value constraint}, the item has neither element nor character [children] and clause 3.2 has not applied, then all of the following must be true:// 5.1.1 If the actual type definition is a local type definition then the canonical lexical representation of the {value constraint} value must be a valid default for the actual type definition as defined in Element Default Valid (Immediate) (3.3.6).//REVISIT:we should pass ValidatedInfo here.// 5.1.2 The element information item with the canonical lexical representation of the {value constraint} value used as its normalized value must be valid with respect to the actual type definition as defined by Element Locally Valid (Type) (3.3.4).// REVISIT: don't use toString, but validateActualValue instead//          use the fState4ApplyDefault// The following method call also deal with clause 1.2.2 of the constraint// 5.2 If the declaration has no {value constraint} or the item has either element or character [children] or clause 3.2 has applied, then all of the following must be true:// 5.2.1 The element information item must be valid with respect to the actual type definition as defined by Element Locally Valid (Type) (3.3.4).// 5.2.2 If there is a fixed {value constraint} and clause 3.2 has not applied, all of the following must be true:// 5.2.2.1 The element information item must have no element information item [children].// 5.2.2.2 The appropriate case among the following must be true:// 5.2.2.2.1 If the {content type} of the actual type definition is mixed, then the initial value of the item must match the canonical lexical representation of the {value constraint} value.// REVISIT: how to get the initial value, does whiteSpace count?// 5.2.2.2.2 If the {content type} of the actual type definition is a simple type definition, then the actual value of the item must match the canonical lexical representation of the {value constraint} value.// REVISIT: the spec didn't mention this case: fixed//          value with simple type// for union types we need to send data because we delayed sending// this data when we received it in the characters() call.// 3.1 If the type definition is a simple type definition, then all of the following must be true:// 3.1.2 The element information item must have no element information item [children].// 3.1.3 If clause 3.2 of Element Locally Valid (Element) (3.3.4) did not apply, then the normalized value must be valid with respect to the type definition as defined by String Valid (3.14.4).// 3.2 If the type definition is a complex type definition, then the element information item must be valid with respect to the type definition as per Element Locally Valid (Complex Type) (3.4.4);// For an element information item to be locally valid with respect to a complex type definition all of the following must be true:// 1 {abstract} is false.// 2 If clause 3.2 of Element Locally Valid (Element) (3.3.4) did not apply, then the appropriate case among the following must be true:// 2.1 If the {content type} is empty, then the element information item has no character or element information item [children].// 2.2 If the {content type} is a simple type definition, then the element information item has no element information item [children], and the normalized value of the element information item is valid with respect to that simple type definition as defined by String Valid (3.14.4).// REVISIT: eventually, this method should return the same actualValue as elementLocallyValidType...// obviously it'll return null when the content is complex.// 2.3 If the {content type} is element-only, then the element information item has no character information item [children] other than those whose [character code] is defined as a white space in [XML 1.0 (Second Edition)].// 2.4 If the {content type} is element-only or mixed, then the sequence of the element information item's element information item [children], if any, taken in order, is valid with respect to the {content type}'s particle, as defined in Element Sequence Locally Valid (Particle) (3.9.4).// if the current state is a valid state, check whether// it's one of the final states.// Constant space algorithm for a{n,m} for n > 1 and m <= unbounded// After the DFA has completed, check minOccurs and maxOccurs// for all elements and wildcards in this content model where// a{n,m} is subsumed to a* or a+// ensureMatcherCapacity()// Validation Rule: Identity-constraint Satisfied// 4.2 If the {identity-constraint category} is key, then all of the following must be true:// 4.2.1 The target node set and the qualified node set are equal, that is, every member of the// target node set is also a member of the qualified node set and vice versa.// If the IDC is a key check whether we have all the fields.// do we even know this field?// store values// REVISIT: we can improve performance by using hash codes, instead of// traversing global vector that could be quite large.// found it// didn't find it/** Handle n-tuples. * *//** Iterate over each set of fields. * *//** Check whether this set is contained in the value store. * */// no values// construct value string// one value// is this value as a group duplicated?// do all the necessary management...// verify references// get the key store corresponding (if it exists):// report error// only clone the hashtable when there are elements// must be an invalid doc!// return if there is no element// initialize value stores for unique fields// initialize value stores for key fields// initialize value stores for keyRef fields// class SchemaValidatorimport CoreDocumentImpl/** This is an implementation of the XSAnnotation schema component. ... */// with any non-schema attributes from its parent// the content of the annotation node, including all children, alongSchemaGrammar fGrammar;// from here when we need them// the grammar which owns this annotation; we get parsers/** Write contents of the annotation to the specified DOM object. If the ... */XSAnnotation.W3C_DOM_ELEMENTXSAnnotation.W3C_DOM_DOCUMENTwriteToDOM(...)writeToSAX(...)/** A text representation of annotation. *//** The <code>type</code> of this object, i.e. ... */// XSObject methodsXSConstants.ANNOTATION/** The name of type <code>NCName</code> of this declaration as defined in ... *//** The [target namespace] of this object, or <code>null</code> if it is ... *//** A namespace schema information item corresponding to the target ... */getSAXParser(...)StringReader aReaderInputSource aSourceIOException i// of the Node// this creates the new Annotation element as the first childDocument futureOwnergetDOMParser(...)Document aDocumentElement annotationNode newElemdropDocumentReferences(...)adoptNode(...)// nothing must go wrong with this parse...// this should never happen!// REVISIT:  what to do with this?; should really not// eat it...// ditto with above// Release the reference to the user's ContentHandler.// adoptNode will return null when the DOM implementations are not compatible.import XSComplexTypeDefinition/** The XML representation for an attribute declaration ... */XSConstants.SCOPE_ABSENTshort SCOPE_ABSENT;// scopesshort SCOPE_GLOBAL;short SCOPE_LOCAL;String fName;// the name of the attribute// the target namespace of the attributeXSSimpleType fType;// the simple type of the attributeQName fUnresolvedTypeName;short fConstraintType;// value constraint type: default, fixed or !specifiedshort fScope;// scopeXSComplexTypeDecl fEnclosingCT;// enclosing complex type, when the scope is local// optional annotationsValidatedInfo fDefault;// value constraint value// of the attribute declaration, if it is globally declared; or null otherwise./** Get the type of the object, i.e ELEMENT_DECLARATION. *//** The <code>name</code> of this <code>XSObject</code> depending on the ... *//** The namespace URI of this node, or <code>null</code> if it is ... *//** A simple type definition *//** Optional. Either global or a complex type definition ( ... *//** Locally scoped declarations are available for use only within the ... *//** Value constraint: one of default, fixed. *//** Value constraint: The actual value (with respect to the {type ... */fDefault.actualValuefDefault.actualValueTypefDefault.itemValueTypes// REVISIT: SCAPI: what's the proper representation// class XSAttributeDeclimport XSAttributeUse/** The XML representation for an attribute group declaration ... */new XSAttributeUseImpl[]// name of the attribute group// target namespace of the attribute groupint fAttrUseNum;// number of attribute uses included by this attribute group// attribute uses included by this attribute group...[] fAttributeUses;XSWildcardDecl fAttributeWC;// attribute wildcard included by this attribute groupString fIDAttrName;// whether there is an attribute use whose type is or is derived from ID.// optional annotationXSObjectListImpl fAttrUses;// of the attribute group definition, if it is globally declared; or null otherwise.// otherwise, return null// use of type ID, then return the name of the other attribute use;// if the type is derived from ID, but there is already another attribute// add an attribute useattrUse.fUseSchemaSymbols.USE_PROHIBITEDattrUse.fAttrDecl.fTypeattrUse.fAttrDeclattrUse.fAttrDecl.fNamefAttributeUses.length...[...].fAttrDecl.fTargetNamespace...[...].fAttrDecl...[...].fAttrDecl.fName...[...].fUseXSAttributeUseImpl[] uses/** Check that the attributes in this group validly restrict those from a base group. ... */Object[] errorArgsXSAttributeUseImpl attrUseXSAttributeUseImpl baseAttrUseXSAttributeDecl baseAttrDeclgetAttributeUse(...)attrDecl.fTargetNamespaceattrDecl.fNameint baseConsTypebaseAttrUse.fConstraintTypeint thisConstTypeattrUse.fConstraintTypegetRequired(...)SchemaSymbols.ATTVAL_OPTIONALSchemaSymbols.ATTVAL_PROHIBITEDbaseAttrUse.fAttrDeclcheckSimpleDerivationOk(...)baseAttrDecl.fTypeValidatedInfo baseFixedValuebaseAttrUse.fDefaultbaseAttrDecl.fDefaultValidatedInfo thisFixedValueattrUse.fDefaultattrDecl.fDefaultbaseFixedValue.actualValuethisFixedValue.actualValuebaseGroup.fAttributeWCbaseGroup.fAttrUseNumbaseGroup.fAttributeUsesbaseAttrUse.fUsebaseAttrDecl.fTargetNamespacebaseAttrDecl.fNamebaseAttrUse.fAttrDecl.fNameisSubsetOf(...)weakerProcessContents(...)getProcessContentsAsString(...)XSAttributeUseImpl[] newArray// reset the attribute group declaration/** {attribute uses} A set of attribute uses. *//** {attribute wildcard} Optional. A wildcard. */// if this attribute use is prohibited, then don't check whether it's// of type ID// if there is already an attribute use of type ID,// return its name (and don't add it to the list, to avoid// interruption to instance validation.// Remove all prohibited attributes.// Do not remove attributes that have the same name as the prohibited// ones, because they are specified at the same level. Prohibited// attributes are only to remove attributes from the base type in a// restriction.//        int newCount = 0;//        if (pCount > 0) {//            OUTER: for (int i = 0; i < fAttrUseNum; i++) {//                if (fAttributeUses[i].fUse == SchemaSymbols.USE_PROHIBITED)//                    continue;//                for (int j = 1; j <= pCount; j++) {//                    if (fAttributeUses[i].fAttrDecl.fName == pUses[fAttrUseNum-pCount].fAttrDecl.fName &&//                        fAttributeUses[i].fAttrDecl.fTargetNamespace == pUses[fAttrUseNum-pCount].fAttrDecl.fTargetNamespace) {//                        continue OUTER;//                    }//                pUses[newCount++] = fAttributeUses[i];//            fAttributeUses = pUses;//            fAttrUseNum = newCount;// Look for a match in the base// derivation-ok-restriction.  Constraint 2.1.1// if this attribute is prohibited in the derived type, don't// need to check any of the following constraints.// derivation-ok-restriction.  Constraint 2.1.3// check the values are the same.// No matching attribute in base - there should be a matching wildcard// derivation-ok-restriction.  Constraint 2.2// Check that any REQUIRED attributes in the base have matching attributes// in this group// derivation-ok-restriction.  Constraint 3// Look for a match in this group// Now, check wildcards// derivation-ok-restriction.  Constraint 4// reset attribute uses// class XSAttributeGroupDecl/** The XML representation for an attribute use ... */XSAttributeDecl fAttrDecl;// the referred attribute declshort fUse;// use information: SchemaSymbols.USE_OPTIONAL, REQUIRED, PROHIBITEDXSConstants.ATTRIBUTE_USE/** {required} determines whether this use of an attribute declaration ... *//** {attribute declaration} provides the attribute declaration itself, ... *//** Value Constraint: one of default, fixed. *//** Value Constraint: The actual value (with respect to the {type ... */// class XSAttributeUseImpl/** The XML representation for a complexType ... */// name of the complexType// target namespace of the complexTypeXSTypeDefinition fBaseType;// base type of the complexTypeshort fDerivedBy;// derivation method of the complexTypeshort fFinal;// final set of the complexTypeshort fBlock;// block set (prohibited substitution) of the complexTypeshort fMiscFlags;//        whether it's an anonymous tpye// flags: whether is abstract; whether contains ID type;XSAttributeGroupDecl fAttrGrp;// the attribute group that holds the attribute uses and attribute wildcardshort fContentType;// the content type of the complexTypeXSSimpleType fXSSimpleType;// if the content type is simple, then the corresponding simpleTypeXSParticleDecl fParticle;// if the content type is element or mixed, the particleXSCMValidator fCMValidator;// if there is a particle, the content model corresponding to that particleXSCMValidator fUPACMValidator;// the content model that's sufficient for computing UPAXSObjectListImpl fAnnotations;// list of annotations affiliated with this type// of the complex type definition, if it is globally declared; or null otherwise.short CT_IS_ABSTRACT;// flags for the misc flagshort CT_HAS_TYPE_ID;short CT_IS_ANONYMOUS;// methods to get/set misc flag// return the attribute group for this complex type// some utility methods:StringBuilder strappendTypeInfo(...)String[] contentTypeString[] derivedBycontainsTypeID(...)SchemaGrammar.fAnySimpleType/** Checks if a type is derived from another given the the name, namespace ... */isDerivedByExtension(...)/** Checks if a type is derived from another by any combination of ... *//** Checks if a type is derived from another by restriction. See: ... */getDerivationMethod(...)/** Checks if a type is derived from another by extension. See: ... */boolean extensionclearXSObjectList(...)/** A boolean that specifies if the type definition is anonymous. ... *//** {base type definition} Either a simple type definition or a complex ... *//** {derivation method} Either extension or restriction. The valid constant ... *//** {final} For complex type definition it is a subset of {extension, ... *//** {final} For complex type definition it is a subset of {extension, restriction}. ... *//** {abstract} A boolean. Complex types for which {abstract} is true must ... */getAttributeWildcard(...)/** {content type} One of empty, a simple type definition (see ... *//** A simple type definition corresponding to simple content model, ... *//** A particle for mixed or element-only content model, otherwise ... *//** {prohibited substitutions} A subset of {extension, restriction}. ... *//** {prohibited substitutions} ... */// do-nothing constructor for now.// for complex type with empty or simple content,// there is no content model validator// reached anyType// list or union// Check if this type is derived from the base by restriction or// ancestor is anySimpleType, return false// if the name and namespace of this type is the same as the// ancestor return true// If the base type is a complexType with simpleContent// If the base type is a complex type// Every derivation step till the base type should be// restriction. If not return false// If ancestor is anySimpleType return false.// returns true if atleast one derivation step was extension// derivationMethod extension will always return false for a// simpleType,// we treat it like a restriction// At least one derivation step upto the ancestor type should be// extension.// reset attribute group// help out the garbage collector// class XSComplexTypeDecl/** Constaints shared by traversers and validator ... */SchemaSymbols.ATTVAL_STRINGXSConstraints$1XSParticleDecl pDecl1XSParticleDecl pDecl2XSElementDecl decl1pDecl1.fValueXSElementDecl decl2pDecl2.fValueString namespace1String namespace2String name1boolean sameNamespaceint namespaceComparisonint OCCURRENCE_UNKNOWN;// (IHR@xbrl.org) (Ignacio@Hernandez-Ros.com)// to help the checkRecurseLax to know when expansion has happened and no order is required// Added a boolean return value to particleValidRestriction (it was a void function)// IHR: Visited on 2006-11-17XSSimpleType STRING_TYPE;XSParticleDecl fEmptyParticle;group.fAnnotationsparticle.fAnnotationsComparator<> ELEMENT_PARTICLE_COMPARATOR;/** check whether derived is valid derived from base, given a subset ... */checkSimpleDerivation(...)checkComplexDerivation(...)/** check whether simple type derived is valid derived from base, ... *//** check whether complex type derived is valid derived from base, ... *//** Note: this will be a private method, and it assumes that derived is not ... */XSSimpleType directBaseXSSimpleType.VARIETY_LISTXSObjectList subUnionMemberDVint subUnionSizeXSTypeDefinition directBasederived.fBaseTypederived.fDerivedBy/** check whether a value is a valid default for some type ... */emptiable(...)getParticle(...)/** used to check the 3 constraints against each complex type ... */XSParticleDecl fakeDerivedXSParticleDecl fakeBaseXSComplexTypeDecl[] typesSimpleLocator[] ctLocatorsboolean furtherboolean fullCheckedint keepTypeSymbolHash elemTableaddSubstitutionGroup(...)getSubstitutionGroups(...)fakeDerived.fTypefakeBase.fTypeXSGroupDecl[] redefinedGroupsgetRedefinedGroupDecls(...)SimpleLocator[] rgLocatorsgetRGLocators(...)redefinedGroups.lengthXSGroupDecl derivedGrpXSModelGroupImpl derivedMGderivedGrp.fModelGroupXSGroupDecl baseGrpXSModelGroupImpl baseMGbaseGrp.fModelGroupfakeDerived.fValuefakeBase.fValuederivedGrp.fNameparticleValidRestriction(...)XMLSchemaException e...[...].fFullCheckedgetUncheckedComplexTypeDecls(...)getUncheckedCTLocators(...)XSCMValidator cm...[...].fParticlecheckElementDeclsConsistent(...)...[...].fBaseType...[...].fDerivedByXSParticleDecl derivedParticleXSParticleDecl baseParticle(...).fParticle...[...].fNamecheckUniqueParticleAttribution(...)setUncheckedTypeNum(...)/* Check that a given particle is a valid restriction of a base particle. */int pTypeXSElementDecl elemfindElemInTable(...)elem.fScopegetSubstitutionGroup(...)subGroup.lengthelem.fTargetNamespaceelem.fNameXSElementDecl existingElemelem.fTypeexistingElem.fTypenew XMLSchemaException(...)type.fName// to keep the order and when to ignore it.// With this information the checkRecurseLax function knows when is// in the bParticle.// Returns a boolean indicating if there has been expansion of substitution group// IHR: 2006/11/17// Check that a given particle is a valid restriction of a base particle.Vector<> dChildrenVector<> bChildrenint dMinEffectiveTotalRangeint dMaxEffectiveTotalRangeboolean bExpansionHappenedshort dTypedParticle.fTypeint dMinOccursdParticle.fMinOccursint dMaxOccursdParticle.fMaxOccursshort bTypebParticle.fTypeint bMinOccursbParticle.fMinOccursint bMaxOccursbParticle.fMaxOccursXSParticleDecl dtmpgetNonUnaryGroup(...)(...).fCompositordParticle.fValueremovePointlessChildren(...)XSElementDecl dElementdElement.fScopeaddElementToParticleVector(...)XSParticleDecl btmpbParticle.fValueXSElementDecl bElementbElement.fScopeXSElementDecl[] bsubGroupbsubGroup.lengthcheckNameAndTypeOK(...)checkNSCompat(...)checkRecurseLax(...)XSModelGroupImpl.MODELGROUP_ALLcheckRecurse(...)checkNSSubset(...)minEffectiveTotalRange(...)maxEffectiveTotalRange(...)checkNSRecurseCheckCardinality(...)checkRecurseUnordered(...)int min1int max1checkMapAndSum(...)XSParticleDecl pp.fValuep.fTypep.fMinOccursp.fMaxOccurs(...).fParticleCount(...).fParticlesVector<> childrengatherChildren(...)int blockSet1dElement.fBlockint blockSet2bElement.fBlockdElement.fNamebElement.fNamedElement.fTargetNamespacebElement.fTargetNamespacecheckOccurrenceRange(...)bElement.fDefaultdElement.fType(...).fContentTypebElement.fDefault.normalizedValuedElement.fDefault.normalizedValuedElement.fDefaultbElement.fDefault.actualValuedElement.fDefault.actualValuecheckIDConstraintRestriction(...)bElement.fTypeXSConstants.DERIVATION_UNIONXSConstants.DERIVATION_LIST// checkIDConstraintRestrictionXSParticleDecl particle1int count1int count2XSParticleDecl particle2boolean[] foundIt// to check whether two element overlap, as defined in constraint UPAelement1.fNameelement2.fNameelement1.fTargetNamespaceelement2.fTargetNamespace...[...].fTargetNamespace// as defined in constraint UPA// to check whether an element overlaps with a wildcard,element.fTargetNamespaceXSWildcardDecl intersectperformIntersectionWith(...)wildcard1.fProcessContentsintersect.fTypeXSWildcardDecl.NSCONSTRAINT_LISTintersect.fNamespaceList.lengthintersect.fNamespaceList// call one of the above methods according to the type of declsoverlapUPA(...)//This assumes that the names are never null.// if derived is anyType, then it's valid only if base is anyType too// if derived is anySimpleType, then it's valid only if the base// is ur-type// if derived is simple type// if base is complex type// if base is anyType, change base to anySimpleType,// otherwise, not valid// 1 They are the same type definition.// 2.1 restriction is not in the subset, or in the {final} of its own {base type definition};// 2.2 One of the following must be true:// 2.2.1 D's base type definition is B.// 2.2.2 D's base type definition is not the simple ur-type definition and is validly derived from B given the subset, as defined by this constraint.// 2.2.3 D's {variety} is list or union and B is the simple ur-type definition.// 2.2.4 B's {variety} is union and D is validly derived from a type definition in B's {member type definitions} given the subset, as defined by this constraint.// 2.1 B and D must be the same type definition.// 1 If B and D are not the same type definition, then the {derivation method} of D must not be in the subset.// 2 One of the following must be true:// 2.2 B must be D's {base type definition}.// 2.3 All of the following must be true:// 2.3.1 D's {base type definition} must not be the ur-type definition.// 2.3.2 The appropriate case among the following must be true:// 2.3.2.1 If D's {base type definition} is complex, then it must be validly derived from B given the subset as defined by this constraint.// 2.3.2.2 If D's {base type definition} is simple, then it must be validly derived from B given the subset as defined in Type Derivation OK (Simple) (3.14.6).// e-props-correct// For a string to be a valid default with respect to a type definition the appropriate case among the following must be true:// 1 If the type definition is a simple type definition, then the string must be valid with respect to that definition as defined by String Valid (3.14.4).// 2 If the type definition is a complex type definition, then all of the following must be true:// 2.1 its {content type} must be a simple type definition or mixed.// 2.2 The appropriate case among the following must be true:// 2.2.1 If the {content type} is a simple type definition, then the string must be valid with respect to that simple type definition as defined by String Valid (3.14.4).// 2.2.2 If the {content type} is mixed, then the {content type}'s particle must be emptiable as defined by Particle Emptiable (3.9.6).// get the simple type declaration, and validate// complex type with mixed. to make sure that we store correct// information in vinfo and return the correct value, we use// "string" type for validation// validate the original lexical rep, and set the actual value// validate the canonical lexical rep// get all grammars, and put all substitution group information// in the substitution group handler// before worrying about complexTypes, let's get// groups redefined by restriction out of the way.// can't be a restriction!// for each complex type, check the 3 constraints.// types need to be checked// to hold the errors// REVISIT: do we want to report all errors? or just one?//XMLSchemaError1D errors = new XMLSchemaError1D();// whether need to check this type again;// whether only do UPA checking// if do all checkings, how many need to be checked again.// i: grammar; j: type; k: error// for all grammars// get whether to skip EDC, and types need to be checked// for each type// if we've already full-checked this grammar, then// skip the EDC constraint// 1. Element Decl Consistent// 2. Particle Derivation// 3. UPA// get the content model and check UPA// now report all errors/* for (k = errors.getErrorCodeNum()-1; k >= 0; k--) { ... */// if we are doing all checkings, and this one needs further// checking, store it in the type array.// clear errors for the next type.//errors.clear();// we've done with the types in this grammar. if we are checking// all constraints, need to trim type array to a proper size:// only contain those need further checking.// and mark this grammar that it only needs UPA checking.// check for elements in the tree with the same name and namespace// Check for subsitution groups.// How can we avoid this concat?  LM.// just add it in// If this is the same check element, we're O.K.// Types are not the same// By default there has been no expansion// Check for empty particles.   If either base or derived particle is empty,// (and the other isn't) it's an error.// Do setup prior to invoking the Particle (Restriction) cases.// This involves://   - removing pointless occurrences for groups, and retrieving a vector of//     non-pointless children//   - turning top-level elements with substitution groups into CHOICE groups.// Handle pointless groups for the derived particle// Find a group, starting with this particle, with more than 1 child.   There// may be none, and the particle of interest trivially becomes an element or// wildcard.// Particle has been replaced.   Retrieve new type info.// Fill in a vector with the children of the particle, removing any// pointless model groups in the process.// For elements which are the heads of substitution groups, treat as CHOICE// Check for subsitution groups.   Treat any element that has a// subsitution group as a choice.   Fill in the children vector with the// members of the substitution group// Now, set the type to be CHOICE.  The "group" will have the same// occurrence information as the original particle.// Fill in the vector of children// Set the handler to null, to indicate that we've finished handling// substitution groups for this particle.// Handle pointless groups for the base particle// Now, set the type to be CHOICE// if we are here expansion of bParticle happened// O.K. - Figure out which particle derivation rule applies and call it// Elt:Elt NameAndTypeOK// Elt:Any NSCompat// Elt:All RecurseAsIfGroup// Treat the element as if it were in a group of the same type// as the base Particle// Any:Any NSSubset// All:Any NSRecurseCheckCardinality// Choice:Any NSRecurseCheckCardinality// Check that the names are the same// Check nillable// Check occurrence range// Check for consistent fixed values// derived one has to have a fixed value// if there is no simple type, then compare based on string// Check identity constraints// Check for disallowed substitutions// Check that the derived element's type is derived from the base's.// check Occurrence ranges// check wildcard allows namespace of element// check wildcard subset// Check that each member of the group is a valid restriction of the wildcard// REVISIT: should we really just ignore original cause of this error?//          how can we report it?// Now, see if there are some elements in the base we didn't match up// didn't find a match.  Detect an error// IHR: go back one element on b list because the next element may match// this as well.// See if the sequence group is a valid restriction of the choice// Here is an example of a valid restriction://   <choice minOccurs="2">//       <a/>//       <b/>//       <c/>//   </choice>//   <sequence>//        <b/>//        <a/>//   </sequence>// if the two element have the same name and namespace,// or if there is an element decl in element1's substitution group,// who has the same name/namespace with element2// or if there is an element decl in element2's substitution group,// who has the same name/namespace with element1// if the wildcard allows the element// or if the wildcard allows any element in the substitution group// if the intersection of the two wildcard is not empty list// class XSContraintsimport XMLSchemaDescription/** All information specific to XML Schema grammars. ... */short CONTEXT_INITIALIZE;/** Indicate that this description was just initialized. */// used to indicate what triggered the callshort CONTEXT_INCLUDE;/** Indicate that the current schema document is <include>d by another ... */short CONTEXT_REDEFINE;/** Indicate that the current schema document is <redefine>d by another ... */short CONTEXT_IMPORT;/** Indicate that the current schema document is <import>ed by another ... */short CONTEXT_PREPARSE;/** Indicate that the current schema document is being preparsed. */short CONTEXT_INSTANCE;/** Indicate that the parse of the current schema document is triggered ... */short CONTEXT_ELEMENT;/** Indicate that the parse of the current schema document is triggered by ... */short CONTEXT_ATTRIBUTE;short CONTEXT_XSITYPE;short fContextType;// REVISIT: write description of these fields...[] fLocationHints;QName fTriggeringComponent;QName fEnclosedElementName;XMLAttributes fAttributes;/** the type of the grammar (e.g., DTD or XSD); ... *//** Get the context. The returned value is one of the pre-defined ... *//** If the context is "include" or "redefine", then return the target ... *//** For import and references from the instance document, it's possible to ... *//** If a call is triggered by an element/attribute/xsi:type in the instance, ... *//** If a call is triggered by an attribute or xsi:type, then this mehtod ... */XMLSchemaDescription desclocationHints.length/** resets all the fields */desc.fAttributesthis.fAttributesdesc.fBaseSystemIdthis.fBaseSystemIdthis.fContextTypedesc.fEnclosedElementNamethis.fEnclosedElementNamedesc.fExpandedSystemIdthis.fExpandedSystemIddesc.fLiteralSystemIdthis.fLiteralSystemIddesc.fLocationHintsthis.fLocationHintsdesc.fPublicIdthis.fPublicIddesc.fNamespacethis.fNamespacedesc.fTriggeringComponentthis.fTriggeringComponent// fNamespace == null//fLocationHints = locationHints ;// XSDDescription/** This class is pool that enables caching of XML Schema declaration objects. ... */new XSElementDecl[][]new XSParticleDecl[][]new XSModelGroupImpl[][]new XSAttributeDecl[][]new XSComplexTypeDecl[][]new XSSimpleTypeDecl[][]new XSAttributeUseImpl[][]/** Initial chunk count (). */...[] fElementDecl;/** Element declaration pool */int fElementDeclIndex;...[] fParticleDecl;/** Particle declaration pool */int fParticleDeclIndex;...[] fModelGroup;int fModelGroupIndex;...[] fAttrDecl;/** Attribute declaration pool */int fAttrDeclIndex;...[] fCTDecl;/** ComplexType declaration pool */int fCTDeclIndex;...[] fSTDecl;/** SimpleType declaration pool */int fSTDeclIndex;...[] fAttributeUse;/** AttributeUse declaration pool */int fAttributeUseIndex;SchemaDVFactoryImpl dvFactory;this.dvFactoryensureAttrDeclCapacity(...)ensureAttributeUseCapacity(...)ensureCTDeclCapacity(...)ensureSTDeclCapacity(...)newXSSimpleTypeDecl(...)ensureParticleDeclCapacity(...)ensureModelGroupCapacity(...)//          in the pool.//          components, so it probably is not worth keeping those components//          it seems like each schema would use a small number of those//          notations?// REVISIT: do we need decl pool for group declarations, attribute group,fElementDecl.lengthXSElementDecl[][] newarrayfParticleDecl.lengthfModelGroup.lengthnew XSModelGroupImpl[]XSParticleDecl[][] newarrayXSModelGroupImpl[][] newarrayfAttrDecl.lengthnew XSAttributeDecl[]XSAttributeDecl[][] newarrayfAttributeUse.lengthXSAttributeUseImpl[][] newarrayfSTDecl.lengthXSSimpleTypeDecl[][] newarrayfCTDecl.lengthXSComplexTypeDecl[][] newarray/** The XML representation for an element declaration ... */new IdentityConstraint[]// name of the element// target namespace of the elementXSTypeDefinition fType;// type of the element// misc flag of the element: nillable/abstract/fixed// block set (disallowed substitutions) of the element// final set (substitution group exclusions) of the elementXSElementDecl fSubGroup;// the substitution group affiliation of the element// identity constraintsint fIDCPos;...[] fIDConstraints;// of the element declaration, if it is globally declared; or null otherwise.short CONSTRAINT_MASK;short NILLABLE;short ABSTRACT;fIDConstraints.lengthIdentityConstraint[] newArrayString fDescription;/** get the string description of this element *//** get the hash code *//** whether two decls are the same *//** Reset current element declaration *//** Either a simple type definition or a complex type definition. *//** A value constraint: one of default, fixed. *//** A value constraint: The actual value (with respect to the {type ... *//** If {nillable} is true, then an element may also be valid if it carries ... *//** {identity-constraint definitions} A set of constraint definitions. *//** {substitution group affiliation} Optional. A top-level element ... *//** Convenience method. Check if <code>exclusion</code> is a substitution ... *//** Specifies if this declaration can be nominated as ... *//** Convenience method. Check if <code>disallowed</code> is a disallowed ... *//** The supplied values for {disallowed substitutions} ... *//** {abstract} A boolean. */// first clear the bits// then set the proper one// reset identity constraints// class XSElementDecl/** A class used to hold the internal schema grammar set for the current instance ... */Map<String,SchemaGrammar> fGrammarRegistry;/** Map that maps between Namespace and a Grammar */SchemaGrammar fNoNSGrammar;/** Get the schema grammar for the specified namespace ... *//** Put a schema grammar into the registry ... *//** put a schema grammar and any grammars imported by it (directly or ... */SchemaGrammar sgVector<> currGrammarsgetImportedGrammars(...)Vector<> grammarsSchemaGrammar sg1SchemaGrammar sg2Vector<> gssg1.fTargetNamespace/** get all grammars in the registry ... */Entry<String,SchemaGrammar> entryMap<>.Entry<String,SchemaGrammar>/** Clear the registry. ... */// whether there is one with the same tns// if the one we have is different from the one passed, it's an error// not deep import, then just add this one grammar// get all imported grammars, and make a copy of the Vector, so that// we can recursively process the grammars, and add distinct ones// to the same vector// for all (recursively) imported grammars// get the grammar// check whether the bucket has one with the same tns// we need to add grammars imported by sg1 too// for all grammars imported by sg2, but not in the vector// we add them to the vector// we found one with the same target namespace// if the two grammars are not the same object, then it's an error// now we have all imported grammars stored in the vector. add them// if grammar already exist in the bucket, we ignore the request// not adding the imported grammars// we found one with the same target namespace, ignore it// get the number of grammars// get grammars with target namespace// add the grammar without target namespace, if any// class XSGrammarBucketimport XSModelGroup/** The XML representation for a group declaration ... */// name of the group// target namespace of the groupXSModelGroupImpl fModelGroup;// model group of the group// of the model group definition, if it is globally declared; or null otherwise./** {model group} A model group. */// class XSGroupDeclimport CoreDOMImplementationImplimport XSImplementation/** Implements XSImplementation interface that allows one to retrieve an instance of <code>XSLoader</code>. ... */new XSImplementationImpl(...)XSImplementationImpl singleton;XSLoader loadernew XSLoaderImpl(...)XSException.NOT_SUPPORTED_ERRStringListImpl list// class XSImplementationImplimport XSGrammarPool/** <p>An implementation of XSLoader which wraps XMLSchemaLoader.</p> ... */new XSGrammarMerger(...)XSGrammarPool fGrammarPool;/** Grammar pool. Need this to prevent us from ... *//** Schema loader. * *//** No-args constructor. */XMLSchemaLoader.XMLGRAMMAR_POOL/** The configuration of a document. It maintains a table of recognized ... *//** Parses the content of XML Schema documents specified as the list of URI ... *//** Parses the content of XML Schema documents specified as a list of ... *//** Parse an XML Schema document from a location identified by a URI ... *//** Parse an XML Schema document from a resource identified by a ... */canSetParameter(...)getParameterNames(...)XSLoaderImpl$XSGrammarMerger/** Grammar pool which merges grammars from the same namespace into one. This eliminates ... */SchemaGrammar cachedGrammartoSchemaGrammar(...)SchemaGrammar newGrammarmergeSchemaGrammars(...)XSNamedMap mapXSObjectList annotationsXSElementDecl decladdGlobalElementDecl(...)XSAttributeDecl decladdGlobalAttributeDecl(...)addGlobalTypeDecl(...)XSAttributeGroupDecl decladdGlobalAttributeGroupDecl(...)XSConstants.MODEL_GROUPXSGroupDecl decladdGlobalGroupDecl(...)XSNotationDecl decladdGlobalNotationDecl(...)addAnnotation(...)/** Add new top-level element declarations. * *//** Add new top-level attribute declarations. * *//** Add new top-level type definitions. * *//** Add new top-level attribute group definitions. * *//** Add new top-level model group definitions. * *//** Add new top-level notation declarations. * *//** Add all annotations. Since these components are not named it's ... *//** SchemaMessageProvider implements an XMLMessageProvider that ... */String SCHEMA_DOMAIN;/** The domain of messages concerning the XML Schema: Structures specification. *//** Store schema model group declaration. ... */short MODELGROUP_CHOICE;// to check whether the content is an element or a sequence.// there are place where the constants are used together. For example,// REVISIT: can't use same constants as those for particles, because// types of model groupsshort MODELGROUP_SEQUENCE;short MODELGROUP_ALL;short fCompositor;// compositor of the model group...[] fParticles;// particlesint fParticleCount;// this particle's optional annotations// whether this model group contains nothing/** 3.8.6 Effective Total Range (all and sequence) and ... */minEffectiveTotalRangeChoice(...)minEffectiveTotalRangeAllSeq(...)// return the sum of all min values of the particles// return the min of all min values of the particlesint onemaxEffectiveTotalRangeChoice(...)maxEffectiveTotalRangeAllSeq(...)// otherwise return the sum of all max values// if one of the max value of the particles is unbounded, return unbounded;// otherwise return the max of all max values/** get the string description of this particle *//** {compositor} One of all, choice or sequence. The valid constants values ... */XSModelGroup.COMPOSITOR_CHOICEXSModelGroup.COMPOSITOR_SEQUENCEXSModelGroup.COMPOSITOR_ALL/** {particles} A list of particles */// REVISIT: Commented code may help to eliminate redundant parentheses (test first before committing)//if (fMinOccurs != 1 || fMaxOccurs != 1)//if (fCompositor == MODELGROUP_ALL || fMinOccurs != 1 || fMaxOccurs != 1)// class XSModelGroupImplimport XSNamespaceItemListimport XSObject/** Implements XSModel:  a read-only interface that represents an XML Schema, ... */int fGrammarCount;// number of grammars/namespaces stored here...[] fNamespaces;// all target namespaces...[] fGrammarList;// all schema grammar objects (for each namespace)SymbolHash fGrammarMap;// a map from namespace to schema grammarSymbolHash fSubGroupMap;// a map from element declaration to its substitution group...[] fGlobalComponents;...[] fNSComponents;// store a certain kind of components from one namespaceStringList fNamespacesList;// a string list of all the target namespaces.// store all annotationsboolean fHasIDC;// whether there is any IDC in this XSModel/** Construct an XSModelImpl, by storing some grammars and grammars imported ... */int initialSizeString[] namespacesSchemaGrammar[] grammarListboolean hasS4Sboolean hasIDCgetS4SGrammar(...)grammarList.lengthString[] newSASchemaGrammar[] newGAnull2EmptyString(...)hasIDConstraints(...)new XSNamedMap[][]buildSubGroups(...)SubstitutionGroupHandler sgHandlerXSNamedMap elementsSymbolHash subGroupMapXSElementDecl headXSElementDeclaration[] subGroupXSObjectListImpl elementsgetGlobalElements(...)SymbolHash[] tablesnew SymbolHash[]XSObject[] componentsnew XSObject[]...[...].fAllGlobalElemDecls/** Convenience method. Returns a list of all namespaces that belong to ... *//** A set of namespace schema information information items (of type ... *//** Returns a list of top-level components, i.e. element declarations, ... */...[...].fGlobalTypeDecls...[...].fGlobalAttrDecls...[...].fGlobalElemDecls...[...].fGlobalAttrGrpDecls...[...].fGlobalGroupDecls...[...].fGlobalNotationDecls/** Convenience method. Returns a list of top-level component declarations ... */sg.fGlobalTypeDeclssg.fGlobalAttrDeclssg.fGlobalElemDeclssg.fGlobalAttrGrpDeclssg.fGlobalGroupDeclssg.fGlobalNotationDecls/** [annotations]: a set of annotations if it exists, otherwise an empty ... */int totalAnnotationsXSAnnotationImpl[] annotationsint currPos...[...].fNumAnnotationsSchemaGrammar currGrammarcurrGrammar.fNumAnnotationscurrGrammar.fAnnotations/** REVISIT: to expose identity constraints from XSModel. ... *//** Convenience method. Returns a list containing the members of the ... *//** The number of <code>XSNamespaceItem</code>s in the list. The range of ... */// XSNamespaceItemList methods/** Returns the <code>index</code>th item in the collection or ... */// java.util.List methodslistIterator0(...)new XSNamespaceItemListIterator(...)Object[] atoArray0(...)Class<> arrayClassXSModelImpl$XSNamespaceItemListIterator/* Copyright 2002-2005 The Apache Software Foundation. ... */// copy namespaces/grammars from the array to our arrays// If a schema for the schema namespace isn't included, include it here.// and recursively get all imported grammars, add them to our arrays// for each imported grammar// check whether this grammar is already in the list// if it's not, add it to the list// ensure the capacity of the arrays// establish the mapping from namespace to grammars// update the idc field// build substitution groups// get all hashtables from all namespaces for this type of components// try to find the grammar// do this in two passes to avoid inaccurate array size// class XSModelImpl/** The XML representation for a NOTATION declaration ... */// public id of the notation// system id of the notation// of the notation declaration, if it is globally declared; or null otherwise./** Optional if {public identifier} is present. A URI reference. *//** Optional if {system identifier} is present. A public identifier, ... */// class XSNotationDeclimport XSTerm/** Store schema particle declaration. ... */short PARTICLE_EMPTY;// types of particlesshort PARTICLE_ELEMENT;short PARTICLE_WILDCARD;short PARTICLE_MODELGROUP;short PARTICLE_ZERO_OR_MORE;short PARTICLE_ZERO_OR_ONE;short PARTICLE_ONE_OR_MORE;short fType;// type of the particleXSTerm fValue;// for PARTICLE_MODELGROUP: the model group// for PARTICLE_WILDCARD: the wildcard decl// for PARTICLE_ELEMENT : the element decl// term of the particleint fMinOccurs;// minimum occurrence of this particleint fMaxOccurs;// maximum occurrence of this particle// clone this declparticle.fDescription/** 3.9.6 Schema Component Constraint: Particle Emptiable ... */// whether this particle contains nothingXSParticleDecl.PARTICLE_EMPTYappendParticle(...)/** append the string description of this particle to the string buffer ... */XSConstants.PARTICLE/** {min occurs} determines the minimum number of terms that can occur. *//** {max occurs} whether the maxOccurs value is unbounded. *//** {max occurs} determines the maximum number of terms that can occur. *//** {term} One of a model group, a wildcard, or an element declaration. */// class XSParticleDecl/** The XML representation for a wildcard declaration ... */String ABSENT;// the type of wildcard: any, other, or listshort fProcessContents;// the type of process contents: strict, lax, or skip...[] fNamespaceList;// for NSCONSTRAINT_NOT, it means not any of the namespaces in the list// for NSCONSTRAINT_LIST, it means one of the namespaces in the list// the namespace list:/** Validation Rule: Wildcard allows Namespace Name */// * When we really support not(NS1,NS2,...,NSN), we need to revisit these items.//   comments on where we didn't follow the spec exactly.// / Since we store ##other as not(NS1,NS2,...,NSN), we need to put some// + Bullet added as proposed by Sandy Gao, IBM.// - Bullet removed from w3c specification.// In the following in-line comments://       what's required by Schema, and allows future enhanced features.//       The way we store ##other is not(NS1,NS2,...,NSN), which covers// NOTE: Schema spec only requires that ##other not(tNS,absent).// spec). -SG// easy to maintain, and easy to find a bug (either in the code, or in the// to be much easier solutions. But it makes it easy to understand,// spec describes. Sometimes it seems redundant, and sometimes there seems// I'm trying to implement the following constraint exactly as what theint listNumfNamespaceList.length/** Schema Component Constraint: Wildcard Subset */superWildcard.fTypesuperWildcard.fNamespaceListsubset2sets(...)elementInSet(...)/** Check whether this wildcard has a weaker process contents than the super. */// isSubsetOfsuperWildcard.fProcessContents/** Schema Component Constraint: Attribute Wildcard Union */XSWildcardDecl unionWildcardunionWildcard.fProcessContentsareSame(...)unionWildcard.fTypeunionWildcard.fNamespaceListwildcard.fTypeunion2sets(...)wildcard.fNamespaceListString[] otherString[] listboolean foundAbsentboolean foundNS/** Schema Component Constraint: Attribute Wildcard Intersection */// performUnionWithXSWildcardDecl intersectWildcardintersectWildcard.fProcessContentsintersectWildcard.fTypeintersectWildcard.fNamespaceListXSWildcardDecl otherother.fTypeother.fNamespaceListString[] intersectintersect2sets(...)// performIntersectionWithwildcard.fNamespaceList.length// areSameone.lengththeOther.lengthString[] result2String[] result1subSet.lengthset.length/** get the string description of this wildcard */SchemaSymbols.ATTVAL_TWOPOUNDANYSchemaSymbols.ATTVAL_TWOPOUNDOTHERXSConstants.WILDCARD/** Namespace constraint: A constraint type: any, not, list. *//** Namespace constraint. For <code>constraintType</code> ... *//** {process contents} One of skip, lax or strict. Valid constants values ... *//** String valid of {process contents}. One of "skip", "lax" or "strict". */// For a value which is either a namespace name or absent to be valid with respect to a wildcard constraint (the value of a {namespace constraint}) one of the following must be true:// 1 The constraint must be any.// 2.1 The constraint is a pair of not and a namespace name or absent ([Definition:]  call this the namespace test).// 2.2 The value must not be identical to the namespace test.// 2.3 The value must not be absent.// / we store ##other as not(list), so our actual rule is// / 2 The constraint is a pair of not and a set, and the value is not in such set.// 3 The constraint is a set, and the value is identical to one of the members of the set.// none of the above conditions applied, so return false.// if the super is null (not expressible), return false// For a namespace constraint (call it sub) to be an intensional subset of another// namespace constraint (call it super) one of the following must be true:// 1 super must be any.//   2.1 sub must be a pair of not and a namespace name or absent.//   2.2 super must be a pair of not and the same value.//   * we can't just compare whether the namespace are the same value//     since we store other as not(list)// 3 All of the following must be true://   3.1 sub must be a set whose members are either namespace names or absent.//   3.2 One of the following must be true://       3.2.1 super must be the same set or a superset thereof.//       -3.2.2 super must be a pair of not and a namespace name or absent and//              that value must not be in sub's set.//       +3.2.2 super must be a pair of not and a namespace name or absent and//              either that value or absent must not be in sub's set.//       * since we store ##other as not(list), we acturally need to make sure//         that none of the namespaces in super.list is in sub.list.// if the other wildcard is not expressible, the result is still not expressible// For a wildcard's {namespace constraint} value to be the intensional union of two// other such values (call them O1 and O2): the appropriate case among the following// must be true:// 1 If O1 and O2 are the same value, then that value must be the value.// 2 If either O1 or O2 is any, then any must be the value.// 3 If both O1 and O2 are sets of (namespace names or absent), then the union of//   those sets must be the value.// -4 If the two are negations of different namespace names, then the intersection//    is not expressible.// +4 If the two are negations of different namespace names or absent, then//    a pair of not and absent must be the value.// * now we store ##other as not(list), the result should be//   not(intersection of two lists).// 5 If either O1 or O2 is a pair of not and a namespace name and the other is a set of//   (namespace names or absent), then The appropriate case among the following must be true://      -5.1 If the set includes the negated namespace name, then any must be the value.//      -5.2 If the set does not include the negated namespace name, then whichever of O1 or O2//           is a pair of not and a namespace name must be the value.//    +5.1 If the negated value is a namespace name, then The appropriate case//         among the following must be true://        +5.1.1 If the set includes both the namespace name and absent, then any//               must be the value.//        +5.1.2 If the set includes the namespace name but does not include//               absent, then a pair of not and absent must be the value.//        +5.1.3 If the set does not include the namespace name but includes//               absent, then the union is not expressible.//        +5.1.4 If the set does not include either the namespace name or absent,//               then whichever of O1 or O2 is a pair of not and a namespace name must be//               the value.//    +5.2 If the negated value is absent, then The appropriate case among the//         following must be true://        +5.2.1 If the set includes absent, then any must be the value.//        +5.2.2 If the set does not include absent, then whichever of O1 or O2 is//               a pair of not and a namespace name must be the value.// * when we have not(list), the operation is just not(otherlist-list)// !foundNS && !foundAbsent// other[0] == ABSENT// !foundAbsent// For a wildcard's {namespace constraint} value to be the intensional intersection of// two other such values (call them O1 and O2): the appropriate case among the following// 2 If either O1 or O2 is any, then the other must be the value.// both cannot be ANY, if we have reached here.// -3 If either O1 or O2 is a pair of not and a namespace name and the other is a set of//    (namespace names or absent), then that set, minus the negated namespace name if//    it was in the set, must be the value.// +3 If either O1 or O2 is a pair of not and a namespace name and the other//    is a set of (namespace names or absent), then that set, minus the negated//    namespace name if it was in the set, then minus absent if it was in the//    set, must be the value.// * when we have not(list), the operation is just list-otherlist// 4 If both O1 and O2 are sets of (namespace names or absent), then the intersection of those//   sets must be the value.// -5 If the two are negations of different namespace names, then the intersection is not expressible.// +5 If the two are negations of namespace names or absent, then The//    appropriate case among the following must be true://    +5.1 If the two are negations of different namespace names, then the//         intersection is not expressible.//    +5.2 If one of the two is a pair of not and absent, the other must be//         the value.// * when we have not(list), the operation is just not(onelist+otherlist)// ##any, true// ##other, only check the negated value// * when we support not(list), we need to check in the same way//   as for NSCONSTRAINT_LIST.// ## list, must have the same length,// and each item in one list must appear in the other one// (we are assuming that there are no duplicate items in a list)// simple implemention,// class XSWildcardDeclimport XPathException/** Schema identity constraint field. ... */Field.XPath fXPath;Field.XPath/** Field XPath. *//** Constructs a field. *//** Returns the field XPath. */// <init>(Field.XPath,IdentityConstraint)/** Returns the identity constraint. */// getXPath():com.sun.org.apache.xerces.internal.impl.v1.schema.identity.XPath/** Creates a field matcher. */// factory method// getIdentityConstraint():IdentityConstraintnew Matcher(...)Field.Matcher// createMatcher(ValueStore):XPathMatcher/** Field XPath. ... *//** Constructs a field XPath expression. */...[...].steps.length...[...].stepsXPath.AxisXPath.Axis.ATTRIBUTEField$Matcher/** Field matcher. ... */FieldActivator fFieldActivator;/** Field activator. */ValueStore fStore;/** Value store for data values. *//** Constructs a field matcher. *//** This method is called when the XPath handler matches the ... */// XPathHandler methods// <init>(Field.XPath,ValueStore)matched(...)Field.this// matched(String)XSComplexTypeDefinition.CONTENTTYPE_SIMPLE// NOTE: We have to prefix the field XPath with "./" in//       order to handle selectors such as "@attr" that//       select the attribute because the fields could be//       relative to the selector element. -Ac//       Unless xpath starts with a descendant node -Achille Fokoue//      ... or a / or a . - NG// verify that only one attribute is selected per branch// <init>(String,SymbolTable,NamespacesContext)// once we've stored the value for this field, we set the mayMatch// member to false so that, in the same scope, we don't match any more// values (and throw an error instead).// the content must be simpleType content// handleContent(XSElementDecl, String)// class Matcher// class Field/** Interface for a field activator. The field activator is responsible ... *//* Copyright 2001,2002,2004 The Apache Software Foundation. ... */// interface FieldActivatorimport XSIDCDefinitionimport XSAnnotationImpl/** Base class of Schema identity constraint. ... */String fNamespace;/** target namespace */String fIdentityConstraintName;/** Identity constraint name. */String fElementName;/** name of owning element */Selector fSelector;/** Selector. *//** Field count. *//** Fields. */// number of annotations in this identity constraint/** Returns the identity constraint name. *//** Sets the selector. */// getIdentityConstraintName():String/** Returns the selector. */// setSelector(Selector)/** Adds a field. */// getSelector():SelectorfFields.length/** Returns the field count. */// addField(Field)/** Returns the field at the specified index. */// getFieldCount():int// get the name of the owning element// getFieldAt(int):Field// getElementName(): String// the elenemtName field) are equal.// representations of all members of both objects (except for// equals:  returns true if and only if the Stringboolean areEqualid.fIdentityConstraintNameid.fSelectorid.fFieldCountid.fFieldsField[] newArrayXSConstants.IDENTITY_CONSTRAINT/** {identity-constraint category} One of key, keyref or unique. *//** {selector} A restricted XPath ([XPath]) expression *//** {fields} A non-empty list of restricted XPath ([XPath]) expressions. *//** {referenced key} Required if {identity-constraint category} is keyref, ... */// class IdentityConstraint/** Schema key reference identity constraint. ... */UniqueOrKey fKey;/** The key (or unique) being referred to. *//** Constructs a keyref with the specified name. *//** Returns the key being referred to. */// <init>(String,String,String)// getKey(): int// class KeyRef/** Schema identity constraint selector. ... */Selector.XPath fXPath;Selector.XPath/** XPath. */IdentityConstraint fIDConstraint;// used for selectors!// the Identity constraint we're the matcher for.  Only/** Constructs a selector. *//** Returns the selector XPath. */// <init>(Selector.XPath,IdentityConstraint)// getXPath():com.sun.org.apache.xerces.internal.v1.schema.identity.XPath/** Creates a selector matcher. ... */// getIDConstraint():IdentityConstraint// createMatcher(FieldActivator):XPathMatcherSelector$XPath/** Schema identity constraint selector XPath expression. ... *//** Constructs a selector XPath expression. */// <init>(String,SymbolTable,NamespacesScope)StringBuffer modifiedXPath/** Selector matcher. ... */// class Selector.XPathint fInitialDepth;/** Initial depth in the document at which this matcher was created. */int fMatchedDepth;/** Depth at match. *//** Constructs a selector matcher. */// XMLDocumentFragmentHandler methods// <init>(Selector.XPath,FieldActivator)/** The start of an element. If the document specifies the start element ... */// startDocumentFragment()isMatched(...)startValueScopeFor(...)activateField(...)// startElement(QName,XMLAttrList,int)endValueScopeFor(...)/** get the initial depth at which this selector matched. */// verify that an attribute is not selected// NOTE: We have to prefix the selector XPath with "./" in//       order to handle selectors such as "." that select//       the element container because the fields could be//       relative to that element. -Ac//      ... or a '.' or a '/' - NG//  And we also need to prefix exprs to the right of | with ./ - NG// activate the fields, if selector is matched//int matched = isMatched();/* (fMatchedDepth == -1 && ((matched & MATCHED) == MATCHED)) || ... */// getInitialDepth():  int// class Selector/** Schema unique or key identity constraint. ... *//** Constructs a unique or a key identity constraint. */// class Unique/** Interface for storing values associated to an identity constraint. ... *//** Since the valueStore will have access to an error reporter, this ... *//* Copyright 2001, 2002,2004,2005 The Apache Software Foundation. ... */// interface ValueStore/** XPath matcher. ... *//** Compile to true to debug everything. */boolean DEBUG_METHODS;/** Compile to true to debug method callbacks. */boolean DEBUG_METHODS2;/** Compile to true to debug important method callbacks. */boolean DEBUG_METHODS3;/** Compile to true to debug the <em>really</em> important methods. */boolean DEBUG_MATCH;/** Compile to true to debug match. */boolean DEBUG_STACK;/** Compile to true to debug step index stack. *//** Don't touch this value unless you add more debug constants. */int MATCHED;// matched any way// and if so how.// constants describing whether a match was made,int MATCHED_ATTRIBUTE;// matched on the attribute axisint MATCHED_DESCENDANT;// matched on the descendant-or-self axixsint MATCHED_DESCENDANT_PREVIOUS;// matched some previous (ancestor) node on the descendant-or-self-axis, but not this nodeXPath.LocationPath/** XPath location path. */...[] fMatched;/** True if XPath has been matched. */Object fMatchedString;/** The matching string. */...[] fStepIndexes;/** Integer stack of step indexes. */...[] fCurrentStep;/** Current step. */...[] fNoMatchDepth;/** No match depth. The value of this field will be zero while ... *//** Constructs an XPath matcher that implements a document fragment ... */getLocationPaths(...)new IntStack[]fStepIndexes.length/** Returns value of first member of fMatched that ... */// <init>(XPath)// that care about matching element content.// a place-holder method; to be overridden by subclasses// isMatched():int/** The start of the document fragment. */// ~XMLDocumentFragmentHandler methods// matched(String content, XSSimpleType val)int startStepint descendantStepboolean sawDescendantXPath.StepXPath.Axis.SELFXPath.Axis.DESCENDANTXPath.Axis.CHILDXPath.NodeTestXPath.NodeTest.QNAME...[...].nodeTestint aIndexhandleContent(...)/** Normalizes text. */// xpath has been matched if any one of the members of the union have matched.// reset state// push context// try next xpath, if not matching// consume self::node() steps// now if the current step is a descendant step, we let the next// step do its thing; if it fails, we reset ourselves// to look at this step for next time we're called.// so first consume all descendants:// match child::... step, if haven't consumed any self::node()// match attribute::... step// go back a step// don't do anything, if not matching// signal match, if appropriate// only certain kinds of matchers actually// match element content.  This permits// them a way to override this to do nothing// and hopefully save a few operations.// normalize(String):String// NOTE: The main of this class is here for debugging purposes.//       However, javac (JDK 1.1.8) has an internal compiler//       error when compiling. Jikes has no problem, though.//       If you want to use this main, use Jikes to compile but//       *never* check in this code to CVS without commenting it//       out. -Ac/** Main program. */// class XPathMatcherimport XSElementDeclimport XSModelGroupImplimport XSParticleDecl/** This class constructs content models for a given grammar. ... */new XSEmptyCM(...)// REVISIT: should update the decl pool to cache XSCM objects tooXSEmptyCM fEmptyCM;// It never changes, so a static member is good enough// needed for DFA construction// needed for UPA//Factory to create Bin, Uni, Leaf nodes/** Get content model for the a given type ... */short contentTypeXSCMValidator cmValidatorcreateAllCM(...)createDFACM(...)resetNodeCount(...)XSAllCM allContentnew XSAllCM(...)...[...].fValue...[...].fMinOccursCMNode nodeuseRepeatingLeafNodes(...)buildCompactSyntaxTree(...)new XSDFACM(...)// 4. make sure each leaf node (XSCMLeaf) has a distinct position//    binary tree: (((a,b),c),...) or (((a|b)|c)|...)// 3. convert model groups (a, b, c, ...) or (a | b | c | ...) to//                                  a{n, m} -> a, a, ..., a?, a?, ...// 2. expand all occurrence values: a{n, unbounded} -> a, a, ..., a+// 1. convert particle tree to CM tree:int maxOccursint minOccursgetCMLeafNode(...)expandContentModel(...)CMNode tempboolean twoChildrengetCMBinOpNode(...)getCMUniOpNode(...)XSParticleDecl.PARTICLE_ZERO_OR_ONEXSParticleDecl.PARTICLE_ZERO_OR_MOREXSParticleDecl.PARTICLE_ONE_OR_MOREmultiNodes(...)int num1copyNode(...)XSCMBinOp binXSCMUniOp uniXSCMLeaf leafgetLeaf(...)getParticleId(...)// useRepeatingLeafNodes() returns true.// for building the syntax tree is chosen over buildSyntaxTree() when// containing compound leaf nodes which carry occurence information. This method// A special version of buildSyntaxTree() which builds a compact syntax treebuildCompactSyntaxTree2(...)getCMRepeatingLeafNode(...)// contains only one element/wildcard particle with minOccurs/maxOccurs == 1.// it returns true if each model group has minOccurs/maxOccurs == 1 or// tree containing compound leaf nodes which carry occurence information. Currently// This method checks if this particle can be transformed into a compact syntaxshort type2particle2.fTypeparticle2.fMinOccursparticle2.fMaxOccurs// if the content is element only or mixed, but no particle// is defined, return the empty content model// if the content model contains "all" model group,// we create an "all" content model, otherwise a DFA content model//now we are throught building content model and have passed sucessfully of the nodecount check//if set by the application// if the validator returned is null, it means there is nothing in// the content model, so we return the empty content model.// get the model group, and add all children of it to the content model// create an all content model. the parameter indicates whether// the <all> itself is optional// add the element decl to the all content model// convert particle tree to CM tree// build DFA content model from the CM tree// (task 1) element and wildcard particles should be converted to// leaf nodes// REVISIT: Make a clone of the leaf particle, so that if there// are two references to the same group, we have two different// leaf particles for the same element or wildcard decl.// This is useful for checking UPA.// (task 2) expand occurrence values// (task 1,3) convert model groups to binary trees// when the model group is a choice of more than one particles, but// only one of the particle is not empty, (for example// <choice>//   <sequence/>//   <element name="e"/>// </choice>// ) we can't not return that one particle ("e"). instead, we should// treat such particle as optional ("e?").// the following boolean variable is true when there are at least// 2 non-empty children.// first convert each child to a CM tree// then combine them using binary operation// record the fact that there are at least 2 children// when the group is "choice", there is only one non-empty// child, and the group had more than one children, we need// to create a zero-or-one (optional) node for the non-empty// particle.//zero or one//zero or more//one or more// Only for elements and wildcards, subsume e{n,m} and e{n,unbounded} to e*// or e+ and, once the DFA reaches a final state, check if the actual number// of elements is between minOccurs and maxOccurs. This new algorithm runs// in constant space.// TODO: What is the impact of this optimization on the PSVI?// => a,a,..,a+// create a+ node first, then put minOccurs-1 a's in front of it// for the first time "node" is used, we don't need to make a copy// and for other references to node, we make copies// (task 4) we need to call copyNode here, so that we append// an entire new copy of the node (a subtree). this is to ensure// all leaf nodes have distinct position// we know that minOccurs > 1// {n,m} => a,a,a,...(a),(a),...// first n a's, then m-n a?'s.// copyNode is called, for the same reason as above// for choice or sequence, copy the two subtrees, and combine them// for ?+*, copy the subtree, and put it in a new ?+* node// for element/wildcard (leaf), make a new leaf node,// with a distinct position// the following int variable keeps track of the number of non-empty children// when the group is "choice" and the group has one or more empty children,// we need to create a zero-or-one (optional) node for the non-empty particles.// Convert element and wildcard particles to leaf nodes. Wrap repeating particles in a CMUniOpNode.// zero or one// zero or more// one or more// {n,m}: Instead of expanding this out, create a compound leaf node which carries the// occurence information and wrap it in the appropriate CMUniOpNode.import XSMessageFormatterint MULTIPLICITY;int nodeCount;//count of number of nodes createdint maxNodeLimit;//No. of nodes allowed.// been set on the configuration.// stores defaults for different security holes (maxOccurLimit in current context) if it has/** default constructor */XMLSecurityManager.Limit.MAX_OCCUR_NODE_LIMIT//reset()new XSCMLeaf(...)nodeCountCheck(...)new XSCMRepeatingLeaf(...)new XSCMUniOp(...)new XSCMBinOp(...)//reset the node count//nodeCountCheck()/* Copyright (c) 2011, 2017, Oracle and/or its affiliates. All rights reserved. *///we are setting the limit of number of nodes to 3times the maxOccur value..// similarly to entity manager behaviour, take into accont// behaviour if continue-after-fatal-error is set.//CMNodeFactory()import SubstitutionGroupHandlerimport XMLSchemaExceptionimport XSConstraints/** XSAllCM implements XSCMValidator and handles &lt;all&gt;. ... */short STATE_START;// start the content model: did not see any childrenshort STATE_VALID;short STATE_CHILD;...[] fAllElements;...[] fIsOptionalElement;boolean fHasOptionalContent;int fNumElements;/** This methods to be called on entering a first element whose type ... */// XSCMValidator methodsint[] state// from the candidate elements.// convinient method: when error occurs, to find a matching declObject matchingDeclgetMatchingElemDecl(...)/** The method corresponds to one transition in the content model. ... */XSCMValidator.SUBSEQUENT_ERRORfindMatchingDecl(...)/** The method indicates the end of list of children ... *//** check whether this content violates UPA constraint. ... *//** Check which elements are valid to appear at this point. This method also ... */Vector<> ret// error state// seen child// we only try to look for a matching decl if we have not seen// this element yet.// found the decl, mark this element as "seen".// couldn't find the decl, change to error state.// If <all> has minOccurs of zero and there are// no children to validate, it is trivially valid// if one element is required, but not present, then error// check whether there is conflict between any two leaves// class XSAllCMimport CMStateSet// XSCMBinOpObject fLeaf;/** This is the leaf: element decl or wildcard decl. */int fParticleId;/** Identify the particle: for UPA checking */// class XSCMLeaf/** A compound content model leaf node which carries occurence information. ... */// XSCMUniOp/** Note: State of the content model is stored in the validator ... */short FIRST_ERROR;short SUBSEQUENT_ERROR;// an error// on subsequent errors the validator should not report/** The method corresponds to one transaction in the content model. ... *//** Used by constant space algorithm for a{n,m} for n > 1 and ... */// XSCMValidatorimport XSWildcardDecl/** DFAContentModel is the implementation of XSCMValidator that does ... */...[] fElemMapId;/** id of the unique input symbol */...[] fCountingStates;/** Array containing occurence information for looping states ... */XSDFACM$Occurenceint minOccurs;int maxOccurs;int elemIndex;getMinOccurs(...)getMaxOccurs(...)this.elemIndex...[] fElemMapCounter;/** Array of counters for all the for elements (or wildcards) ... */...[] fElemMapCounterLowerBound;/** Array of lower bounds for all the for elements (or wildcards) ... */...[] fElemMapCounterUpperBound;/** Array of upper bounds for all the for elements (or wildcards) ... */// -1 if no upper boundXSDFACM.time/** check whether the given state is one of the final states ... *//** one transition only ... */int nextStateOccurence oo.maxOccurso.minOccurso.elemIndex// oneTransition(QName, int[], SubstitutionGroupHandler):  Object// findMatchingDecl(QName, SubstitutionGroupHandler): Object// This method returns the start states of the content model.// findMatchingDecl(QName, int[], SubstitutionGroupHandler, int): Object// this method returns whether the last state was a valid final state// startContentModel():int[]// but we can put it back later.// Killed off whatCanGoHere; we may need it for DOM canInsert(...) etc.,// endContentModel(int[]):  booleanint EOCPosXSCMLeaf nodeEOCOccurence[] elemOccurenceMapnew XSCMLeaf[]int[] boundsnew Occurence[]new Occurence(...)int[] transitionstransitions.lengthbyte[][] conflictTablefTransTable.lengthXSWildcardDecl.NSCONSTRAINT_NOTArrayList<> result/* Copyright (c) 2006, 2017, Oracle and/or its affiliates. All rights reserved. *///  Create some string pool indexes that represent the names of some//  magical nodes in the syntax tree.//  (already done in static initialization...// there was an error last time; so just go find correct Object in fElemmMap.// ... after resetting state[0].// Increment counter if constant space algorithm applies// if we still can't find a match, set the state to first_error// and return null// It's likely that we looped too many times on the current state// however it's possible that we actually matched another particle// which allows the same name.// Consider:// <xs:sequence>//  <xs:element name="foo" type="xs:string" minOccurs="3" maxOccurs="3"/>//  <xs:element name="foo" type="xs:string" fixed="bar"/>// </xs:sequence>//  <xs:any namespace="##any" processContents="skip"/>// In the DFA there will be two transitions from the current state which// allow "foo". Note that this is not a UPA violation. The ambiguity of which// transition to take is resolved by the current value of the counter. Since// we've already seen enough instances of the first "foo" perhaps there is// another element declaration or wildcard deeper in the element map which// matches.// not enough loops on the current state.// Exiting a counting state. If we're entering a new// counting state, reset the counter.// Entering a new counting state. Reset the counter.// If we've already seen one instance of the looping// particle set the counter to 1, otherwise set it// to 0.// if we still can't find a match, set the state to FIRST_ERROR and return null// if we found a match, set the next state and reset the// counter if the next state is a counting state.// Clear all constant space algorithm counters in use// [0] : the current state// [1] : if [0] is an error state then the//       last valid state before the error// [2] : occurence counter for counting states// not enough loops on the current state to be considered final.// optimization from Henry Zongaro://fElemMap[outIndex] = new Object ();// Init counters and bounds for a{n,m} algorithm// the last entry in the element map must be the EOC element.// remove it from the map.//  Next lets create some arrays, some that hold transient// Fill in the occurence information for each looping state// if we're using counters.// Unique Particle Attribution// store the conflict results between any two elements in fElemMap// 0: not compared; -1: no conflict; 1: conflict// initialize the conflict table (all 0 initially)// for each state, check whether it has overlap transitions// If "i" is a counting state and exactly one of the transitions// loops back to "i" then the two particles do not overlap if// minOccurs == maxOccurs.// report all errors//errors.newError("cos-nonambig", new Object[]{fElemMap[i].toString(),//                                             fElemMap[j].toString()});// if there is a other or list wildcard, we need to check this CM// again, if this grammar is cached.// Do not include transitions which loop back to the// current state if we've looped the maximum number// of times or greater.// Do not include transitions which advance past the// current state if we have not looped enough times./** XSEmptyCM is a derivative of the abstract content model base class that ... */Vector<> EMPTY;boolean isFinal// restore content model state:// class XSEmptyCM/** This class represents a single attribute. ... */Element element;/** Constructs an attribute. ... */this.element// org.w3c.dom.Document methods// DOM Level 3 methods./** public void setInputEncoding(String actualEncoding){ ... *//** An attribute specifying, as part of the XML declaration, whether this ... *//** An attribute specifying, as part of the XML declaration, the encoding ... *//** An attribute specifying, as part of the XML declaration, the version ... *//** An attribute specifying whether errors checking is enforced or not. ... *//** The location of the document or <code>null</code> if undefined. ... *//** DOM Level 3 */// getter methods// org.w3c.dom.Element methods// setter methods// org.w3c.dom.Node methods/** The <code>Text</code> interface inherits from <code>CharacterData</code> ... *//* @author Neil Graham, IBM *//** The character data of the node that implements this interface. The DOM ... *//** The number of 16-bit units that are available through <code>data</code> ... *//** Extracts a range of data from the node. ... *//** Append the string to the end of the character data of the node. Upon ... *//** Insert a string at the specified 16-bit unit offset. ... *//** Remove a range of 16-bit units from the node. Upon success, ... *//** Replace the characters starting at the specified 16-bit unit offset ... *//** Breaks this node into two nodes at the specified <code>offset</code>, ... */// Text node methods/** DOM Level 3 CR *//** The start of a namespace prefix mapping. This method will only be ... *//** The end of a namespace prefix mapping. This method will only be ... *//* public void textDecl(String version, String encoding, ... *//* public void processingInstruction(String target, XMLString data, ... *//* public void comment(XMLString text, Augmentations augmentations) ... */// set the source of this handler// return the source from which this handler derives its eventsXMLDTDContentModelSource fCMSource;SchemaDOM schemaDOM;...[] attrs;int row;int col;int parentRow;int charOffset;String fAnnotation;String fSyntheticAnnotation;this.lineschemaDOM.relationsnsEquals(...)/** Returns the line number. *//** Returns the column number. *//** Returns the character offset. *//** Compares two namespace URIs with an extra case for null entries */this.attrsString prefix;String localpart;String rawname;String uri;short nodeType;boolean hidden;this.localpartthis.rawnamethis.urithis.nodeType// other methodsint relationsRowResizeFactor;int relationsColResizeFactor;...[] relations;ElementImpl parent;// parent must be an element in this schemeint currLoc;int nextFreeLoc;boolean inCDATA;StringBuffer fAnnotationBuffer;// for annotation support:ElementImpl nodeprocessElement(...)Attr[] attrsnew Attr[]boolean foundPlacenode.prefixnode.rawnamenode.urinode.schemaDOMnode.attrsrelations.lengthresizeRelations(...)parent.parentRownode.rownode.colparent.row// note that this will only be called within appinfo/documentationdata.chdata.offsetStringBuffer annotationBufferelemName.rawnameannotation.fAnnotationendAnnotationElement(...)endSyntheticAnnotationElement(...)parent.fSyntheticAnnotationNodeImpl[][] tempnew NodeImpl[][]new NodeImpl[]NodeImpl[] tempparent.rawname// debug methodstraverse(...)// org.w3c.dom methods// commence the serialization of an annotationstartAnnotation(...)ArrayList<> namespacesEnumeration<> currPrefixesgetAllPrefixes(...)String aPrefixString aQNameprocessAttValue(...)startAnnotationElement(...)char currCharescapeAttValue(...)StringBuffer newVal// now the current node added, becomes the parent// populate node// set the attributes// check if array needs to be resized// store the current parent//if (relations[currLoc][0] == null || relations[currLoc][0] != parent) {// add the current node as child of parent// the parent of current parent node becomes the parent// for the next node.// escape characters if necessary// character sequence "]]>" cannot appear in content,// therefore we should escape '>'.// If CR is part of the document's content, it// must not be printed as a literal otherwise// it would be normalized to LF when the document// is reparsed.// apparently, there is no sensible way of resetting these things// note that this is always called after endElement on <annotation>'s// child and before endElement on annotation.// hence, we must make this the child of the current// parent's only child.// apparently, there is no sensible way of resetting// these things//capturing character calls/* for (int i=0; i<relations.length; i++) { ... *///traverse(getDocumentElement(), 0);// this returns a parent node, known to be an ElementImpl// attributes are a bit of a pain.  To get this right, we have to keep track// of the namespaces we've seen declared, then examine the namespace context// for other namespaces so that we can also include them.// optimized for simplicity and the case that not many// namespaces are declared on this annotation...// if it's xmlns:* or xmlns, must be a namespace decl// now we have to look through currently in-scope namespaces to see what// wasn't declared here// have to declare this one// normally, nothing will happen// Must escape 0x09, 0x0A and 0x0D if they appear in attribute// value so that they may be round-tripped. They would otherwise// be transformed to a 0x20 during attribute value normalization.new SchemaDOMImplementation(...)SchemaDOMImplementation singleton;new BooleanStack(...)String GENERATE_SYNTHETIC_ANNOTATION;/** Feature identifier: generate synthetic annotations. */// the locator containing line/column information// representations of annotations// namespace context, needed for producingXMLParserConfiguration config;this.configElementImpl fCurrentAnnotationElement;// Reference to the current annotation element.int fAnnotationDepth;// -1 means not in an annotation's scope// where an annotation element itself beginsint fInnerAnnotationDepth;// -1 means not in the scope of either of the two elements.// Where xs:appinfo or xs:documentation starts;// The current element depth// Use to report the error when characters are not allowed.boolean fGenerateSyntheticAnnotation;// fields for generate-synthetic annotations featureBooleanStack fHasNonSchemaAttributes;BooleanStack fSawAnnotation;XMLAttributes fEmptyAttr;new SchemaDOM(...)// startDocument(XMLLocator,String,NamespaceContext, Augmentations)String txthasNonSchemaAttributes(...)ElementImpl newElemString schemaPrefixString annRawNameString elemRawNamecharactersRaw(...)endAnnotation(...)boolean sawannSchemaSymbols.ATT_XML_LANGSchemaSymbols.ELT_SCHEMAstartAnnotationCDATA(...)endAnnotationCDATA(...)/** Returns the DOM document object. *//** Delegates to SchemaParsingConfig.setFeature ... *//** Delegates to SchemaParsingConfig.getFeature ... *//** Delegates to SchemaParsingConfig.setProperty. ... *//** Delegates to SchemaParsingConfig.getProperty. ... *//** Delegates to SchemaParsingConfig.setEntityResolver. ... *//** Delegates parsing to SchemaParsingConfig ... *//** Reset SchemaParsingConfig *//** ResetNodePool on SchemaParsingConfig */resetNodePool(...)SchemaDOMParser$BooleanStack/** A simple boolean based stack. ... *//** Stack depth. *//** Stack data. *//** Pushes a value onto the stack. *//** Pops a value off of the stack. *//** Clears the stack. */boolean[] newdata// To debug the DOM created uncomment the line below// schemaDOM.printDOM();// when it's not within xs:appinfo or xs:documentation// and there is a non-whitespace character// the string we saw: starting from the first non-whitespace character.// don't call super.characters() when it's not within one of the 2// annotation elements: the traversers ignore them anyway. We can// save time/memory creating the text nodes.// when it's within either of the 2 elements, characters are allowed// and we need to store them.// while it is true that non-whitespace character data// may only occur in appInfo or documentation// elements, it's certainly legal for comments and PI's to// occur as children of annotation; we need// to account for these here.// avoid falling through; don't call startElement in this case// the order of events that occurs here is://   schemaDOM.startAnnotation/startAnnotationElement (if applicable)//   schemaDOM.emptyElement  (basically the same as startElement then endElement)//   schemaDOM.endAnnotationElement (if applicable)// the order of events that would occur if this was <element></element>://   schemaDOM.startElement//   schemaDOM.endElementElement// Thus, we can see that the order of events isn't the same.  However, it doesn't// seem to matter.  -- PJM// this is messed up, but a case to consider:// when we reach the endElement of xs:appinfo or xs:documentation,// change fInnerAnnotationDepth to -1// inside a child of annotation// not in an annotation at all// unlikely to be called, but you never know...// only deal with CDATA boundaries within an annotation.import XML11NSDocumentScannerImplimport XMLNSDocumentScannerImplimport XMLVersionDetectorimport BasicParserConfigurationimport FeatureStateimport XMLPullParserConfigurationConstants.NAMESPACE_BINDER_PROPERTYConstants.SCHEMA_VALIDATOR_PROPERTY/** Feature identifier: warn on duplicate attribute definition. *//** Feature identifier: warn on undeclared element definition. *///  protected static final String WARN_ON_DUPLICATE_ENTITYDEF = Constants.XERCES_FEATURE_PREFIX + Constants.WARN_ON_DUPLICATE_ENTITYDEF_FEATURE;/** Feature identifier: warn on duplicate entity definition. *//** Feature identifier: notify character refereces. *//** Property identifier: DTD validator. */String NAMESPACE_BINDER;/** Property identifier: namespace binder. */String SCHEMA_VALIDATOR;/** Property identifier: XML Schema validator. */boolean PRINT_EXCEPTION_STACK_TRACE;/** Set to true and recompile to print exception stack trace. *//** The XML 1.0 Datatype validator factory. */// XML 1.0 componentsXMLNSDocumentScannerImpl fNamespaceScanner;/** The XML 1.0 Document scanner. *//** The XML 1.0 DTD scanner. */DTDDVFactory fXML11DatatypeFactory;/** The XML 1.1 Datatype validator factory. */// XML 1.1 componentsXML11NSDocumentScannerImpl fXML11NSDocScanner;/** The XML 1.1 Document scanner. */XML11DTDScannerImpl fXML11DTDScanner;/** The XML 1.1 DTD scanner. * */DTDDVFactory fCurrentDVFactory;/** Current Datatype validator factory. */// common components (non-configurable)XMLDocumentScanner fCurrentScanner;/** Current scanner */XMLDTDScanner fCurrentDTDScanner;/** Current DTD scanner. *//** Grammar pool. */XMLVersionDetector fVersionDetector;/** XML version detector. */// common components (configurable)/** Locator */boolean fParseInProgress;/** True if a parse is in progress. This state is needed because ... */boolean fConfigUpdated;/** fConfigUpdated is set to true if there has been any change to the configuration settings, ... */boolean f11Initialized;/** Flag indiciating whether XML11 components have been initialized. *//** Constructs a parser configuration using the specified symbol table and ... *//** Constructs a parser configuration using the specified symbol table, ... */// <init>(SymbolTable,XMLGrammarPool)addRecognizedParamsAndSetDefaults(...)new XMLVersionDetector(...)XSMessageFormatter xmftis(...)getFeatureState(...)// getFeature(String):boolean/** Returns the value of a property. ... */getPropertyState(...)/** Sets the input source for the document to parse. ... */// parsing// XMLPullParserConfiguration methods/** Parses the document in a pull parsing fashion. ... */short versiondetermineDocVersion(...)configurePipeline(...)resetXML10(...)initXML11Components(...)configureXML11Pipeline(...)resetXML11(...)startDocumentParsing(...)scanDocument(...)/** If the application decides to terminate parsing before the xml document ... */// parse(boolean):boolean/** Parses the specified input source. ... */cleanup(...)/** Reset all components before parsing. ... */// parse(InputSource)/** Configures the XML 1.0 pipeline. */setDTDSource(...)setDTDContentModelSource(...)/** Configures the XML 1.1 pipeline. */// configurePipeline()/** Check a feature. If feature is know and supported, this method simply ... */// configureXML11Pipeline()FeatureState.RECOGNIZEDConstants.DEFAULT_ATTRIBUTE_VALUES_FEATUREFeatureState.NOT_SUPPORTEDConstants.VALIDATE_CONTENT_MODELS_FEATUREConstants.LOAD_DTD_GRAMMAR_FEATUREConstants.VALIDATE_DATATYPES_FEATUREcheckFeature(...)/** Check a property. If the property is know and supported, this method ... */// checkFeature(String)PropertyState.RECOGNIZED/** Adds all of the component's recognized features and properties ... */recognizedFeatures.lengthString featureIdBoolean staterecognizedProperties.lengthString propertyId/** Reset all XML 1.0 components before parsing *//** Reset all XML 1.1 components before parsing */// resetXML10()// resetXML11()//setFeature(WARN_ON_DUPLICATE_ENTITYDEF, false);// make this feature special// forward to every XML 1.0 component// forward to every XML 1.1 component// ignore the exception// REVISIT: this method used to reset all the components and//          construct the pipeline. Now reset() is called//          in parse (boolean) just before we parse the document//          Should this method still throw exceptions..?// reset and configure pipeline and set InputSource.// XML 1.0// XML 1.1// Unrecoverable error reported during version detection// mark configuration as fixed// resets and sets the pipeline.// REVISIT - need to add new error message// close all streams opened by xerces// initialize the common components// use XML 1.0 datatype library// setup document pipeline// setup dtd pipeline// use XML 1.1 datatype library// Xerces Features// http://apache.org/xml/features/validation/dynamic//   Allows the parser to validate a document only when it//   contains a grammar. Validation is turned on/off based//   on each document instance, automatically.// http://apache.org/xml/features/validation/default-attribute-values// http://apache.org/xml/features/validation/nonvalidating/load-dtd-grammar// http://apache.org/xml/features/validation/nonvalidating/load-external-dtd// Not recognized// Xerces Properties// set default values// Do not overwrite values already set on the configuration.// For newly added components who recognize this feature// but did not offer a default value, we need to make// sure these components will get an opportunity to read// the value before parsing begins.// For newly added components who recognize this property// Reset XML 1.0 components// Reset XML 1.1 components// REVISIT: to implement: introduce a node pool to reuse DTM nodes.//          reset this pool here.// create datatype factory// setup XML 1.1 DTD pipeline// setup XML 1.1. document pipeline - namespace awareSchemaDOM fSchemaDOM;int fRow;int fCol;fSchemaDOM.relationsimport SchemaDOMParserimport SAXLocatorWrapperimport LocatorImpl/** <p>SchemaContentHandler converts SAX events into XNI ... */new SAXLocatorWrapper(...)/** Symbol table * */SchemaDOMParser fSchemaDOMParser;/** SchemaDOMParser, events will be delegated to SchemaDOMParser to pass */SAXLocatorWrapper fSAXLocatorWrapper;/** XML Locator wrapper for SAX. * */NamespaceSupport fNamespaceContext;boolean fNeedPushNSContext;/** Indicate if push NamespaceContest is needed */boolean fNamespacePrefixes;/** Flag used to track whether namespace declarations are reported as attributes. */boolean fStringsInternalized;/** Flag used to track whether XML names and Namespace URIs have been internalized. *//** Fields for start element, end element and characters. *//** <p>Constructs an SchemaContentHandler.</p> *//* @see org.xml.sax.ContentHandler#setDocumentLocator(org.xml.sax.Locator) */setLocator(...)/* @see org.xml.sax.ContentHandler#startDocument() */XMLParseException econvertToSAXParseException(...)convertToSAXException(...)/* @see org.xml.sax.ContentHandler#endDocument() *//* @see org.xml.sax.ContentHandler#startPrefixMapping(java.lang.String, java.lang.String) *//* @see org.xml.sax.ContentHandler#endPrefixMapping(java.lang.String) *//* @see org.xml.sax.ContentHandler#startElement(java.lang.String, java.lang.String, java.lang.String, org.xml.sax.Attributes) */fillQName(...)fillXMLAttributes(...)int prefixCountaddNamespaceDeclarations(...)/* @see org.xml.sax.ContentHandler#endElement(java.lang.String, java.lang.String, java.lang.String) *//* @see org.xml.sax.ContentHandler#characters(char[], int, int) *//* @see org.xml.sax.ContentHandler#ignorableWhitespace(char[], int, int) *//* @see org.xml.sax.ContentHandler#processingInstruction(java.lang.String, java.lang.String) *//* @see org.xml.sax.ContentHandler#skippedEntity(java.lang.String) *//* Other methods */int prefixIdxString nsPrefixString nsURI/* Static methods */LocatorImpl locatorImplnew LocatorImpl(...)setColumnNumber(...)new SAXParseException(...)// Fill element QName and XMLAttributes// Add namespace declarations if necessary// do-nothing// local part may be an empty string if this is a namespace declaration// must be a parser exception; mine it for locator info and throw// a SAXParseException// why did we create an XMLParseException?// SchemaContentHandlerimport JAXPNamespaceContextWrapperimport StAXLocationWrapper/** <p>StAXSchemaParser reads StAX events, converts them into XNI events ... */new StAXLocationWrapper(...)new JAXPNamespaceContextWrapper(...)/** Chunk size (1024). */...[] fCharBuffer;/** Array for holding character data. * */StAXLocationWrapper fLocationWrapper;JAXPNamespaceContextWrapper fNamespaceContext;ArrayList<> fDeclaredPrefixes;setDeclaredPrefixes(...)XMLEvent currentEventStartElement startEndElement endsetNamespaceContext(...)fillDeclaredPrefixes(...)sendCharactersToSchemaParser(...)fillProcessingInstruction(...)/** Send characters to the validator in CHUNK_SIZE character chunks. */// processing instructions must be sent all in one chunkchar[] charBuffercharBuffer.lengthIterator<> attrs/** Fills in the list of declared prefixes. *//** Fills in a QName object. */String raw/* There shouldn't be a DTD in the schema *//* Not needed for schemas *//* No point in sending comments *//* We automatically call startDocument before the loop *//* We automatically call endDocument after the loop */// toCharArray() creates a newly allocated array, so it's okay// to keep a reference to it.// StAXSchemaParserimport ElementImpl/** Objects of this class contain the textual representation of ... *//** Textual representation of annotation. * */int fLine;/** Line number of &lt;annotation&gt; element. * */int fColumn;/** Column number of &lt;annotation&gt; element. * */int fCharOffset;/** Character offset of &lt;annotation&gt; element. * */XSAnnotationInfo next;/** Next annotation. * */ElementImpl annotationDeclImpl// XSAnnotationInfoimport SchemaGrammarimport SchemaNamespaceSupportimport XSAttributeDeclimport XSGrammarBucketimport XIntimport XIntPoolimport DOMUtil/** Class <code>XSAttributeCheck</code> is used to check the validity of attributes ... */new XIntPool(...)getXInt(...)SchemaSymbols.FORM_QUALIFIEDSchemaSymbols.FORM_UNQUALIFIEDXSWildcardDecl.NSCONSTRAINT_ANYnew XSSimpleType[]SchemaSymbols.ATTVAL_TOKENSchemaSymbols.ATTVAL_NCNAMEint ATT_ABSTRACT_Dint ATT_ATTRIBUTE_FD_Dint ATT_BASE_Rint ATT_BASE_Nint ATT_BLOCK_Nint ATT_BLOCK1_Nint ATT_BLOCK_D_Dint ATT_DEFAULT_Nint ATT_ELEMENT_FD_Dint ATT_FINAL_Nint ATT_FINAL1_Nint ATT_FINAL_D_Dint ATT_FIXED_Nint ATT_FIXED_Dint ATT_FORM_Nint ATT_ID_Nint ATT_ITEMTYPE_Nint ATT_MAXOCCURS_Dint ATT_MAXOCCURS1_Dint ATT_MEMBER_T_Nint ATT_MINOCCURS_Dint ATT_MINOCCURS1_Dint ATT_MIXED_Dint ATT_MIXED_Nint ATT_NAME_Rint ATT_NAMESPACE_Dint ATT_NAMESPACE_Nint ATT_NILLABLE_Dint ATT_PROCESS_C_Dint ATT_PUBLIC_Rint ATT_REF_Rint ATT_REFER_Rint ATT_SCHEMA_L_Rint ATT_SCHEMA_L_Nint ATT_SOURCE_Nint ATT_SUBSTITUTION_G_Nint ATT_SYSTEM_Nint ATT_TARGET_N_Nint ATT_TYPE_Nint ATT_USE_Dint ATT_VALUE_NNI_Nint ATT_VALUE_PI_Nint ATT_VALUE_STR_Nint ATT_VALUE_WS_Nint ATT_VERSION_Nint ATT_XML_LANGint ATT_XPATH_Rint ATT_XPATH1_ROneAttr[] allAttrsnew OneAttr[]Container attrListnew OneAttr(...)SchemaSymbols.ATT_ABSTRACTSchemaSymbols.ATT_ATTRIBUTEFORMDEFAULTSchemaSymbols.ATT_BASESchemaSymbols.ATT_BLOCKSchemaSymbols.ATT_BLOCKDEFAULTSchemaSymbols.ATT_DEFAULTSchemaSymbols.ATT_ELEMENTFORMDEFAULTSchemaSymbols.ATT_FINALSchemaSymbols.ATT_FINALDEFAULTSchemaSymbols.ATT_FIXEDSchemaSymbols.ATT_FORMSchemaSymbols.ATT_ITEMTYPESchemaSymbols.ATT_MAXOCCURSSchemaSymbols.ATT_MEMBERTYPESSchemaSymbols.ATT_MINOCCURSSchemaSymbols.ATT_MIXEDSchemaSymbols.ATT_NAMESchemaSymbols.ATT_NAMESPACESchemaSymbols.ATT_NILLABLESchemaSymbols.ATT_PROCESSCONTENTSSchemaSymbols.ATT_PUBLICSchemaSymbols.ATT_REFSchemaSymbols.ATT_REFERSchemaSymbols.ATT_SCHEMALOCATIONSchemaSymbols.ATT_SUBSTITUTIONGROUPSchemaSymbols.ATT_SYSTEMSchemaSymbols.ATT_TARGETNAMESPACESchemaSymbols.ATT_TYPESchemaSymbols.ATT_USESchemaSymbols.ATT_VALUESchemaSymbols.ATT_VERSIONSchemaSymbols.ATT_XPATHgetContainer(...)SchemaSymbols.ELT_ATTRIBUTESchemaSymbols.ELT_ELEMENTSchemaSymbols.ELT_COMPLEXTYPESchemaSymbols.ELT_NOTATIONSchemaSymbols.ELT_SIMPLECONTENTSchemaSymbols.ELT_RESTRICTIONSchemaSymbols.ELT_EXTENSIONSchemaSymbols.ELT_ATTRIBUTEGROUPSchemaSymbols.ELT_ANYATTRIBUTESchemaSymbols.ELT_COMPLEXCONTENTSchemaSymbols.ELT_GROUPSchemaSymbols.ELT_ALLSchemaSymbols.ELT_CHOICESchemaSymbols.ELT_SEQUENCESchemaSymbols.ELT_ANYSchemaSymbols.ELT_UNIQUESchemaSymbols.ELT_KEYSchemaSymbols.ELT_KEYREFSchemaSymbols.ELT_SELECTORSchemaSymbols.ELT_FIELDSchemaSymbols.ELT_SIMPLETYPESchemaSymbols.ELT_LISTSchemaSymbols.ELT_UNIONSchemaSymbols.ELT_INCLUDESchemaSymbols.ELT_REDEFINESchemaSymbols.ELT_IMPORTSchemaSymbols.ELT_LENGTHSchemaSymbols.ELT_MINLENGTHSchemaSymbols.ELT_MAXLENGTHSchemaSymbols.ELT_FRACTIONDIGITSSchemaSymbols.ELT_TOTALDIGITSSchemaSymbols.ELT_PATTERNSchemaSymbols.ELT_ENUMERATIONSchemaSymbols.ELT_WHITESPACESchemaSymbols.ELT_MAXINCLUSIVESchemaSymbols.ELT_MAXEXCLUSIVESchemaSymbols.ELT_MININCLUSIVESchemaSymbols.ELT_MINEXCLUSIVEString ELEMENT_N;//          we'd better move such checking to the traverser.//          are only allowed to have one of name or ref, or neither of them.//          it's possible to have either name or ref. all the others// REVISIT: only local element and attribute are different from others.String ELEMENT_R;String ATTRIBUTE_N;String ATTRIBUTE_R;int ATTIDX_COUNT;int ATTIDX_ABSTRACT;int ATTIDX_AFORMDEFAULT;int ATTIDX_BASE;int ATTIDX_BLOCK;int ATTIDX_BLOCKDEFAULT;int ATTIDX_DEFAULT;int ATTIDX_EFORMDEFAULT;int ATTIDX_FINAL;int ATTIDX_FINALDEFAULT;int ATTIDX_FIXED;int ATTIDX_FORM;int ATTIDX_ID;int ATTIDX_ITEMTYPE;int ATTIDX_MAXOCCURS;int ATTIDX_MEMBERTYPES;int ATTIDX_MINOCCURS;int ATTIDX_MIXED;int ATTIDX_NAME;int ATTIDX_NAMESPACE;int ATTIDX_NAMESPACE_LIST;int ATTIDX_NILLABLE;int ATTIDX_NONSCHEMA;int ATTIDX_PROCESSCONTENTS;int ATTIDX_PUBLIC;int ATTIDX_REF;int ATTIDX_REFER;int ATTIDX_SCHEMALOCATION;int ATTIDX_SOURCE;int ATTIDX_SUBSGROUP;int ATTIDX_SYSTEM;int ATTIDX_TARGETNAMESPACE;int ATTIDX_TYPE;int ATTIDX_USE;int ATTIDX_VALUE;int ATTIDX_ENUMNSDECLS;int ATTIDX_VERSION;int ATTIDX_XML_LANG;int ATTIDX_XPATH;int ATTIDX_FROMDEFAULT;int ATTIDX_ISRETURNED;//public static final int ATTIDX_OTHERVALUES     = ATTIDX_COUNT++;XIntPool fXIntPool;XInt INT_QUALIFIED;// constants to returnXInt INT_UNQUALIFIED;XInt INT_EMPTY_SET;XInt INT_ANY_STRICT;XInt INT_ANY_LAX;XInt INT_ANY_SKIP;XInt INT_ANY_ANY;XInt INT_ANY_LIST;XInt INT_ANY_NOT;XInt INT_USE_OPTIONAL;XInt INT_USE_REQUIRED;XInt INT_USE_PROHIBITED;XInt INT_WS_PRESERVE;XInt INT_WS_REPLACE;XInt INT_WS_COLLAPSE;XInt INT_UNBOUNDED;Map<> fEleAttrsMapG;// for 14 global elements// used to store the map from element name to attribute listMap<> fEleAttrsMapL;// for 39 local elememntsint DT_ANYURI;// DT_??? <  0 : validate directly, which is done in "validate()"// DT_??? >= 0 : validate using a validator, which is initialized staticly// step 1: all possible data types// used to initialize fEleAttrsMapint DT_ID;int DT_QNAME;int DT_STRING;int DT_TOKEN;int DT_NCNAME;int DT_XPATH;int DT_XPATH1;int DT_LANGUAGE;int DT_COUNT;// used to store extra datatype validators...[] fExtraDVs;int DT_BLOCK;int DT_BLOCK1;int DT_FINAL;int DT_FINAL1;int DT_FINAL2;int DT_FORM;int DT_MAXOCCURS;int DT_MAXOCCURS1;int DT_MEMBERTYPES;int DT_MINOCCURS1;int DT_NAMESPACE;int DT_PROCESSCONTENTS;int DT_USE;int DT_WHITESPACE;int DT_BOOLEAN;int DT_NONNEGINT;int DT_POSINT;// used to resolver namespace prefixes// used to store symbols.Map<> fNonSchemaAttrs;// used to store the mapping from processed element to attributesVector<> fNamespaceList;// temprory vector, used to hold the namespace list...[] fSeen;// whether this attribute appeared in the current element...[] fSeenTemp;// constructor. Sets fErrorReproter and get datatype validators/** Check whether the specified element conforms to the attributes restriction ... */checkAttributes(...)getAttrs(...)Map<> eleAttrsMapString lookupNameObject[] attrValuesgetAvailableArray(...)long fromDefaultAttr sattrOneAttr[] reqAttrsattrList.valuesresolveNamespace(...)schemaDoc.fNamespaceSupportgetAttr(...)String attrValOneAttr oneAttroneAttr.valueIndexoneAttr.dvIndexschemaDoc.fValidationContextschemaDoc.fIsChameleonSchemaschemaDoc.fTargetNamespaceoneAttr.dfltValuenew SchemaNamespaceSupport(...)reqAttrs.lengthfSchemaHandler.fSecurityManagerboolean optimizeint maxOccurNodeLimitreportSchemaFatalError(...)Vector<> memberTypeint choiceSchemaSymbols.ATTVAL_FALSESchemaSymbols.ATTVAL_FALSE_0SchemaSymbols.ATTVAL_POUNDALLSchemaSymbols.ATTVAL_EXTENSIONSchemaSymbols.ATTVAL_RESTRICTIONSchemaSymbols.ATTVAL_SUBSTITUTIONSchemaSymbols.ATTVAL_LISTSchemaSymbols.ATTVAL_UNIONSchemaSymbols.ATTVAL_QUALIFIEDSchemaSymbols.ATTVAL_UNQUALIFIEDSchemaSymbols.ATTVAL_UNBOUNDEDString tempNamespaceSchemaSymbols.ATTVAL_TWOPOUNDLOCALSchemaSymbols.ATTVAL_TWOPOUNDTARGETNSSchemaSymbols.ATTVAL_STRICTSchemaSymbols.ATTVAL_LAXSchemaSymbols.ATTVAL_SKIPSchemaSymbols.ATTVAL_REQUIREDSchemaSymbols.ATTVAL_PRESERVESchemaSymbols.ATTVAL_REPLACESchemaSymbols.ATTVAL_COLLAPSE// REVISIT: pass the proper element node to reportSchemaError//          of structure {element node, attr name/qname, attr value)?// REVISIT: why we store the attributes in this way? why not just a list// validate attriubtes from non-schema namespacesIterator<> entriesString attrRNameint INIT_POOL_SIZE;// initial size of the array pool. 10 is big enough// it calls returnAttrArray to return that array to the pool.// an array from the pool; when the caller is done with the array,// when checkAttribute is called, it calls getAvailableArray to get// the following part implements an attribute-value-array pool.int INC_POOL_SIZE;// the incremental size of the array pool...[] fArrayPool;// the array pool...[] fTempArray;// I think System.arrayCopy is more efficient than setting 35 fields to null// used to clear the returned arrayint fPoolPos;// current position of the array pool (# of arrays not returned)// get the next available arrayObject[] retArrayfArrayPool.length// return an array back to the poolattrArray.length// name of the attributeint dvIndex;// index of the datatype validator// whether it's optional, and has default valueObject dfltValue;// the default value of this attributethis.dvIndexthis.valueIndexthis.dfltValueint THRESHOLD;new LargeContainer(...)new SmallContainer(...)int pos;Map<> items;OneAttr ret// step 5: register all datatype validators for new types// anyURI// ID// QName// token// NCName// xpath = a subset of XPath expression// language// step 2: all possible attributes for all elements// step 3: store all these attributes in an array// step 4: for each element, make a list of possible attributes// for element "attribute" - global// default = string// fixed = string// id = ID// name = NCName// type = QName// for element "attribute" - local name// form = (qualified | unqualified)// use = (optional | prohibited | required) : optional// for element "attribute" - local ref// ref = QName// for element "element" - global// abstract = boolean : false// block = (#all | List of (extension | restriction | substitution))// final = (#all | List of (extension | restriction))// nillable = boolean : false// substitutionGroup = QName// for element "element" - local name// maxOccurs = (nonNegativeInteger | unbounded)  : 1// minOccurs = nonNegativeInteger : 1// for element "element" - local ref// for element "complexType" - global// block = (#all | List of (extension | restriction))// mixed = boolean : false// for element "notation" - global// public = A public identifier, per ISO 8879// system = anyURI// for element "complexType" - local// for element "simpleContent" - local// for element "restriction" - local// base = QName// for element "extension" - local// for element "attributeGroup" - local ref// for element "anyAttribute" - local// namespace = ((##any | ##other) | List of (anyURI | (##targetNamespace | ##local)) )  : ##any// processContents = (lax | skip | strict) : strict// for element "complexContent" - local// mixed = boolean// for element "attributeGroup" - global// for element "group" - global// for element "group" - local ref// for element "all" - local// maxOccurs = 1 : 1// minOccurs = (0 | 1) : 1// for element "choice" - local// for element "sequence" - local// for element "any" - local// for element "unique" - local// for element "key" - local// for element "keyref" - local// refer = QName// for element "selector" - local// for element "field" - local// for element "annotation" - global// for element "annotation" - local// for element "appinfo" - local// source = anyURI// for element "documentation" - local// xml:lang = language// for element "simpleType" - global// final = (#all | List of (list | union | restriction))// for element "simpleType" - local// already registered for complexType// for element "list" - local// itemType = QName// for element "union" - local// memberTypes = List of QName// for element "schema" - global// attributeFormDefault = (qualified | unqualified) : unqualified// blockDefault = (#all | List of (extension | restriction | substitution))  : ''// elementFormDefault = (qualified | unqualified) : unqualified// finalDefault = (#all | List of (extension | restriction | list | union))  : ''// targetNamespace = anyURI// version = token// for element "include" - global// schemaLocation = anyURI// for element "redefine" - global// for element "import" - global// namespace = anyURI// for element "length" - local// value = nonNegativeInteger// fixed = boolean : false// for element "minLength" - local// for element "maxLength" - local// for element "fractionDigits" - local// for element "totalDigits" - local// value = positiveInteger// for element "pattern" - local// value = string// for element "enumeration" - local// value = anySimpleType// for element "whiteSpace" - local// value = preserve | replace | collapse// for element "maxInclusive" - local// for element "maxExclusive" - local// for element "minInclusive" - local// for element "minExclusive" - local// get all attributes// update NamespaceSupport// get desired attribute list of this element// should never gets here.// when this method is called, the call already knows that// the element can appear.// clear the "seen" flag.// traverse all attributes// get the attribute name/value//String attrName = DOMUtil.getLocalName(sattr);// we don't want to add namespace declarations to the non-schema attributes// Both <schema> and <documentation> may have an xml:lang attribute.// Set the URI for this attribute to null so that we process it// like any other schema attribute.// for attributes with namespace prefix// attributes with schema namespace are not allowed// and not allowed on "document" and "appInfo"// these are usually small// for attributes from other namespace// store them in a list, and TRY to validate them after// schema traversal (because it's "lax")//otherValues.put(attrName, attrVal);// REVISIT:  actually use this some day...// String attrRName = attrURI + "," + attrName;// Vector values = (Vector)fNonSchemaAttrs.get(attrRName);// if (values == null) {// values = new Vector();// values.addElement(attrName);// values.addElement(elName);// values.addElement(attrVal);// fNonSchemaAttrs.put(attrRName, values);// check whether this attribute is allowed// we've seen this attribute// check the value against the datatype// no checking on string needs to be done here.// no checking on xpath needs to be done here.// xpath values are validated in xpath parser// kludge to handle chameleon includes/redefines...//attrValues.put(attrName, oneAttr.dfltValue);// For "enumeration", and type is possible to be a QName, we need// to return namespace context for later QName resolution.// apply default values// if the attribute didn't apprear, and// if the attribute is optional with default value, apply it//attrValues.put(oneAttr.name, oneAttr.dfltValue);//attrValues[ATTIDX_OTHERVALUES] = otherValues;// Check that minOccurs isn't greater than maxOccurs.// p-props-correct 2.1// maxOccurLimit is only check in secure mode// The maxOccurs restriction no longer applies to elements// and wildcards in a sequence in which they are the only// particle. These are now validated using a constant// space algorithm. The restriction still applies to all// other cases.// Determine if constant-space algorithm can be applied//Revisit :: IMO this is not right place to check// maxOccurNodeLimit.// reset max values in case processing continues on error//new Integer(maxOccurNodeLimit);// To validate these types, we don't actually need to normalize the// strings. We only need to remove the whitespace from both ends.// In some special cases (list types), StringTokenizer can correctly// process the un-normalized whitespace.//choice = SchemaSymbols.EXTENSION|SchemaSymbols.RESTRICTION;// REVISIT: if #all, then make the result the combination of//          everything: substitution/externsion/restriction/list/union.//          would this be a problem?// the reason doing so is that when final/blockFinal on <schema>// is #all, it's not always the same as the conbination of those// values allowed by final/blockFinal.// for example, finalDefault="#all" is not always the same as// finalDefault="extension restriction".// if finalDefault="#all", final on any simple type would be// "extension restriction list union".//choice = SchemaSymbols.RESTRICTION|SchemaSymbols.LIST|//         SchemaSymbols.UNION;// same reason as above DT_BLOCK1/DT_FINAL// finalDefault = (#all | List of (extension | restriction | list | union))// maxOccurs = (nonNegativeInteger | unbounded)// maxOccurs = 1// minOccurs = (0 | 1)// namespace = ((##any | ##other) | List of (anyURI | (##targetNamespace | ##local)) )// ##any// ##other// tokenize// we have found namespace URI here// need to add it to the symbol table//check for duplicate namespaces in the list// convert the vector to an array// processContents = (lax | skip | strict)// use = (optional | prohibited | required)// get name, uri, localpart// find associated grammar// and get the datatype validator, if there is one// get all values appeared with this attribute name// for each of the values// and validate it using the XSSimpleType// REVISIT: what would be the proper validation context?//          guess we need to save that in the vectors too.// if no array left in the pool, increase the pool size// increase size// initialize each *new* array// get the next available one// clear it from the pool. this is for GC: if a caller forget to// return the array, we want that array to be GCed.// to make sure that one array is not returned twice, we use// the last entry to indicate whether an array is already returned// now set it to false.// pop the namespace context// if 1. the pool is full; 2. the array is null;// 3. the array is of wrong size; 4. the array is already returned// then we can't accept this array to be returned// mark this array as returned// better clear nonschema vector// and put it into the pool// push the namespace context/** This class contains code that all three IdentityConstraint ... */Element sElemgetFirstChildElement(...)Element selChildString sTextXSAttributeChecker.ATTIDX_XPATHXPath sXpathElement fElemgetNextSiblingElement(...)traverseAnnotationDecl(...)getSyntheticAnnotation(...)traverseSyntheticAnnotation(...)new Selector(...)setSelector(...)returnAttrArray(...)Element fieldChildString fTextXPath fXpath// General Attribute Checking will have been done on icElem by caller// check for <annotation> and get selector// General Attribute Checking on sElem// first child could be an annotation// if no more children report an error// must be <selector>// make sure <selector>'s content is fine:// traverse annotation if any// put back attr values...// get fields// General Attribute Checking// and make sure <field>'s content is fine:// traverse annotation// traverseIdentityConstraint(IdentityConstraint,Element, XSDocumentInfo)// XSDAbstractIDConstraintTraversernew ParticleArray(...)/** Traverse the "All" declaration ... */Element childXSAnnotationImpl annotationXInt minAttXSAttributeChecker.ATTIDX_MINOCCURSXInt maxAttXSAttributeChecker.ATTIDX_MAXOCCURSLong defaultValsXSAttributeChecker.ATTIDX_FROMDEFAULTtraverseLocal(...)fSchemaHandler.fElementTraverseraddParticle(...)getParticleCount(...)checkOccurrences(...)/** Traverse the Sequence declaration ... */traverseSeqChoice(...)/** Traverse the Choice declaration ... *//** Common traversal for <choice> and <sequence> ... */fSchemaHandler.fGroupTraverserhasAllContent(...)traverseChoice(...)traverseSequence(...)traverseAny(...)fSchemaHandler.fWildCardTraverser// Determines whether a content spec tree represents an "all" content modelXSDAbstractParticleTraverser$ParticleArray// current traversal before starting the traversal of another model group.// etc.), so we have push/pos context methods to save the same of the// traversing one (one inside another one; referring to a global group,// it's possible that we need to traverse another model group while// XSParticleDecl[] containing all particles for the current model group.// for model groups. when the traversal finishes, this class returns an// each model group, we use this one big array to store all particles// to avoid creating a new Vector in each model group, or when traversing// the inner class: used to store particles for model groups// big array to contain all particles...[] fPos;// computed simply by fPos[i] - fPos[i-1].// context. so that the number of particles for context 'i' can be// index 0 is reserved, with value 0. index 1 is used for the fist// the ending position of particles in the array for each context// number of contexts// start a new context (start traversing a new model group)fPos.length// get the number of particles of this context (model group)// add a particle to the current contextfParticles.lengthXSParticleDecl[] newArray// end the current context, and return an array of particlesXSParticleDecl[] arrayParticleArray fPArray;// the big particle array to hold all particles in model groups// Only elements are allowed in <all>// A content type of all can only appear// as the content type of a complex type definition.// don't insert the "all" particle, otherwise we won't be// able to create DFA from this content model// If the content is not empty, is the top node ALL?// resize position array if necessary// the initial ending position of the current context is the// ending position of the previsous context. which means there is// no particle for the current context yet.// resize the particle array if necessary// clear the particle array, to release memoryimport XSAttributeGroupDeclimport XSAttributeUseImpl/** Class <code>XSDAbstractTraverser</code> serves as the base class for all ... */int NOT_ALL_CONTEXT;//    PROCESSING_ALL_GP  - processing an <all> group itself//    CHILD_OF_GROUP     - processing a child of a model group definition//    GROUP_REF_WITH_ALL - processing <group> reference that contained <all>//    PROCESSING_ALL_EL  - processing an <element> in an <all>//    NOT_ALL_CONTEXT    - not processing an <all>// restrictions on minOccurs and maxOccurs relating to "all".// Flags for checkOccurrences to indicate any specialint PROCESSING_ALL_EL;int GROUP_REF_WITH_ALL;int CHILD_OF_GROUP;int PROCESSING_ALL_GP;//Shared dataXSAttributeChecker fAttrChecker;boolean fValidateAnnotations;// used to validate default/fixed attribute values// @return XSAnnotationImpl object//          as name/value pairs (string)? in parsed form?// REVISIT: how to pass the parentAttrs? as DOM attributes?// traverse the annotation declarationString contentsVector<> annotationLocalAttrsXSAttributeChecker.ATTIDX_NONSCHEMAStringBuffer localStrBufferStringBuffer contentBufferint annotationTokenEndString annotationgetAttributeNS(...)new XSAnnotationInfo(...)new XSAnnotationImpl(...)// the QName simple type used to resolve qnamesStringBuffer fPattern;// Temp data structures to be re-used in traversing facetsXSFacets xsFacets;XSDAbstractTraverser$FacetInfoXSFacets facetdata;Element nodeAfterFacets;short fPresentFacets;short fFixedFacets;this.nodeAfterFacetsshort facetsPresentshort facetsFixedString facetboolean hasQNamecontainsQName(...)Vector<> enumDataXSObjectListImpl enumAnnotationsXSObjectListImpl patternAnnotationsint currentFacetObject[] attrsString enumValXSAttributeChecker.ATTIDX_VALUENamespaceSupport nsDeclsXSAttributeChecker.ATTIDX_ENUMNSDECLSObject notationQName tempgetGlobalDecl(...)XSDHandler.NOTATION_TYPEString patternValXSSimpleType.FACET_MAXLENGTHXSSimpleType.FACET_MAXEXCLUSIVEXSSimpleType.FACET_MINEXCLUSIVEXSSimpleType.FACET_TOTALDIGITSXSSimpleType.FACET_FRACTIONDIGITSXSSimpleType.FACET_LENGTHXSAttributeChecker.ATTIDX_FIXEDxsFacets.minLengthxsFacets.maxLengthxsFacets.maxExclusivexsFacets.maxInclusivexsFacets.minExclusivexsFacets.minInclusivexsFacets.totalDigitsxsFacets.fractionDigitsxsFacets.whiteSpacexsFacets.lengthxsFacets.minLengthAnnotationxsFacets.maxLengthAnnotationxsFacets.maxExclusiveAnnotationxsFacets.maxInclusiveAnnotationxsFacets.minExclusiveAnnotationxsFacets.minInclusiveAnnotationxsFacets.totalDigitsAnnotationxsFacets.fractionDigitsAnnotationxsFacets.whiteSpaceAnnotationxsFacets.lengthAnnotationXSSimpleType.FACET_ENUMERATIONxsFacets.enumerationxsFacets.enumNSDeclsxsFacets.enumAnnotationsxsFacets.patternxsFacets.patternAnnotationsnew FacetInfo(...)// return whether QName/NOTATION is part of the given typeshort primitiveXSSimpleType.PRIMITIVE_QNAMEXSObjectList members// This method will return the first non-attribute/attrgrp found// Needed by complexType and attributeGroup traversal// Traverse a set of attribute and attribute group elementsXSAttributeGroupDecl tempAttrGrpXSAttributeUseImpl tempAttrUseXSAttributeUse otherUsefSchemaHandler.fAttributeTraversertempAttrUse.fUsegetAttributeUseNoProhibited(...)tempAttrUse.fAttrDeclattrGrp.fNameXSObjectList attrUseSXSAttributeUseImpl oneAttrUsefSchemaHandler.fAttributeGroupTraverseroneAttrUse.fUseoneAttrUse.fAttrDecltempAttrGrp.fAttributeWCattrGrp.fAttributeWC.fProcessContentsXSWildcardDecl tempAttrWCtraverseAnyAttribute(...)tempAttrWC.fProcessContents/** Element/Attribute traversers call this method to check whether ... */// Checks constraints for minOccurs, maxOccursboolean defaultMinboolean defaultMaxboolean processingAllElboolean processingAllGPboolean groupRefWithAllboolean isGroupChild// this is not terribly performant!// the only valid children of "annotation" are// "appinfo" and "documentation"// There is no difference between global or local appinfo/documentation,// so we assume it's always global.// if contents was null, must have been some kind of error;// nothing to contribute to PSVI// find the grammar; fSchemaHandler must be known!// fish out local attributes passed from parent// optimize for case where there are no local attributes// Vector should contain rawname value pairs// skip the next value, too// search for pesky "s and <s within attr value:// and now splice it into place; immediately after the annotation token, for simplicity's sake// annotation must occur somewhere or we're in big trouble...// facets that have fixed="true"// The facet can't be used if the value is missing. Ignore// this facet element.// for NOTATION types, need to check whether there is a notation// declared with the same name as the enumeration value.// need to use the namespace context returned from checkAttributes// try to get the notation decl. if failed, getGlobalDecl// reports an error, so we don't need to report one again.// Either the QName value is invalid, or it doens't// resolve to a notation declaration.// Ignore this facet, to avoid instance validation problems// restore to the normal namespace context// ---------------------------------------------//datatypes: 5.2.4 pattern: src-multiple-pattern// a non-facet// check for duplicate facets// Ignore this facet, to avoid corrupting the previous facet// Report an error if the "value" attribute is missing.// If it's not missing, then its value is invalid, and an// error should have already been reported by the// attribute checker.// check for fixed facet//REVISIT: do we need to save some state at this point??// perform intersection of attribute wildcard// Success// Neither minOccurs nor maxOccurs may be specified// for the child of a model group definition.// If minOccurs=maxOccurs=0, no component is specified// For the elements referenced in an <all>, minOccurs attribute// must be zero or one, and maxOccurs attribute must be one.// For a complex type definition that contains an <all> or a// reference a <group> whose model group is an all model group,// minOccurs and maxOccurs must be one./** The attribute group definition schema component traverser. ... */QName refAttrXSAttributeChecker.ATTIDX_REFXSDHandler.ATTRIBUTEGROUP_TYPErefAttr.rawname// traverseLocalString nameAttrXSAttributeChecker.ATTIDX_NAMEElement nextNodetraverseAttrsAndAttrGrps(...)XSAttributeGroupDecl redefinedAttrGrpgetGrpOrAttrGrpRedefinedByRestriction(...)schemaDocument2SystemId(...)XSAttributeGroupDecl attrGrp2attrGrp.fTargetNamespaceremoveProhibitedAttrs(...)Object[] errArgsvalidRestrictionOf(...)errArgs.lengthattrGrp.fAnnotationsfSchemaHandler.fTolerateDuplicates// General Attribute Checking for elmNode declared locally// get attribute// ref should be here.// get global decl// no children are allowed here except annotation, which is optional.// General Attribute Checking for elmNode declared globally// global declaration must have a name// check the content// Traverse the attribute and attribute group elements and fill in the// attributeGroup structure// An invalid element was found...// if a global group doesn't have a name, then don't add it.// Remove prohibited attributes from the set// check for restricted redefine:// make an entry in global declarations.// also add it to extended map// handle duplicates// traverseGlobal// XSDAttributeGroupTraverser/** The attribute declaration schema component traverser. ... */String defaultAttXSAttributeChecker.ATTIDX_DEFAULTString fixedAttString nameAttQName refAttXInt useAttXSAttributeChecker.ATTIDX_USEXSAttributeDecl attributeshort consTypeXSDHandler.ATTRIBUTE_TYPErefAtt.rawnamerefAtt.localparttraverseNamedAttr(...)XSConstants.VC_DEFAULTfSchemaHandler.fDeclPoolattrUse.fDefault.normalizedValueattrUse.fAnnotationscheckDefaultValid(...)getValInfo(...).actualValueattrUse.fDefault.actualValuegetValInfo(...)/** Traverse a globally declared attribute. ... */XInt formAttXSAttributeChecker.ATTIDX_FORMQName typeAttXSAttributeChecker.ATTIDX_TYPEString tnsAttXSComplexTypeDecl enclCTXSAttributeDecl.SCOPE_ABSENTValidatedInfo attDefaultshort constraintTypeXSSimpleType attrTypeboolean haveAnonTypeXSAttributeDecl.SCOPE_GLOBALXSAttributeDecl.SCOPE_LOCALschemaDoc.fAreLocalAttributesQualifiedattDefault.normalizedValuefSchemaHandler.fSimpleTypeTraverserXSDHandler.TYPEDECL_TYPEtypeAtt.rawnameattribute.fUnresolvedTypeNamecheckNotationType(...)XSAttributeDecl attribute2// throws an error if the constraint value is invalid for the given typegetValInfo(...).normalizedValue// get 'attribute declaration'// for error reporting// get 'value constraint'// Get the annotation associated witht the local attr decl//src-attribute// 1 default and fixed must not both be present.// 2 If default and use are both present, use must have the actual value optional.// Recover by honouring the default value// a-props-correct// 2 if there is a {value constraint}, the canonical lexical representation of its value must be valid with respect to the {type definition} as defined in String Valid (3.14.4).// Recover by removing the default value// 3 If the {type definition} is or is derived from ID then there must not be a {value constraint}.// check 3.5.6 constraint// Attribute Use Correct// 2 If the {attribute declaration} has a fixed {value constraint}, then if the attribute use itself has a {value constraint}, it must also be fixed and its value must match that of the {attribute declaration}'s {value constraint}.// Recover by using the decl's {value constraint}// Step 1: get declaration information// get 'name'// get 'target namespace'// for local named attribute, value constraint is absent// get 'annotation'// get 'type definition'// Handle Anonymous type if there is one// Handle type attribute// Step 3: check against schema for schemas// required attributes// Step 4: check 3.2.3 constraints// src-attribute// This is checked in "traverse" method// 3 If the item's parent is not <schema>, then all of the following must be true:// 3.1 One of ref or name must be present, but not both.// This is checked in XSAttributeChecker// 3.2 If ref is present, then all of <simpleType>, form and type must be absent.// Attributes are checked in XSAttributeChecker, elements are checked in "traverse" method// 4 type and <simpleType> must not both be present.// Step 5: check 3.2.6 constraints// check for NOTATION type// no-xmlns// The {name} of an attribute declaration must not match xmlns.// no-xsi// The {target namespace} of an attribute declaration, whether local or top-level, must not match http://www.w3.org/2001/XMLSchema-instance (unless it is one of the four built-in declarations given in the next section).// Attribute without a name. Return null.// Step 2: register attribute decl to the grammar/** A complex type definition schema component traverser. ... */int GLOBAL_NUM;// size of stack to hold globals:XSParticleDecl fErrorContent;XSWildcardDecl fErrorWildcard;XSParticleDecl errorContentgetErrorWildcard(...)errorContent.fTypeerrorContent.fValue// globals for building XSComplexTypeDeclsboolean fIsAbstract;XSComplexTypeDecl fComplexTypeDecl;...[] fGlobalStore;// our own little stack to retain state when getGlobalDecls is called:int fGlobalStorePos;XSDComplexTypeTraverser$ComplexTypeRecoverableError...[] errorSubstText;Element errorElem;/** Traverse local complexType declarations ... */String complexTypeNamegenAnonTypeName(...)XSComplexTypeDecl typetraverseComplexTypeDecl(...)contentBackup(...)contentRestore(...)addComplexTypeDecl(...)element2Locator(...)/** Traverse global complexType declarations ... */XSTypeDefinition type2addGlobalComplexTypeDecl(...)Boolean abstractAttXSAttributeChecker.ATTIDX_ABSTRACTXInt blockAttXSAttributeChecker.ATTIDX_BLOCKBoolean mixedAttXSAttributeChecker.ATTIDX_MIXEDXInt finalAttXSAttributeChecker.ATTIDX_FINALschemaDoc.fBlockDefaultschemaDoc.fFinalDefaultnew ComplexTypeRecoverableError(...)processComplexContent(...)Element elemTmptraverseSimpleContent(...)String siblingNametraverseComplexContent(...)ComplexTypeRecoverableError ehandleComplexTypeError(...)e.errorSubstTexte.errorElemObject[] simpleContentAttrValuesElement simpleContentString simpleContentNameObject[] derivationTypeAttrValuesQName baseTypeNameXSAttributeChecker.ATTIDX_BASEXSSimpleType baseValidatorXSComplexTypeDecl baseComplexTypeint baseFinalSetElement scElementgetSimpleType(...)String errorKeyElement attrNodeXSFacets facetDatashort presentFacetsshort fixedFacetsFacetInfo fitraverseFacets(...)fi.nodeAfterFacetsfi.facetdatafi.fPresentFacetsfi.fFixedFacetscreateTypeRestriction(...)fSchemaHandler.fDVFactoryInvalidDatatypeFacetException exisAttrOrAttrGroup(...)mergeAttributes(...)Object[] complexContentAttrValuesboolean mixedContentElement complexContentString complexContentNameXSComplexTypeDecl baseTypeXSParticleDecl baseContentfParticle.fTypefParticle.fValue(...).fType(...).fValue// LM: may want to merge with attributeGroup processing.// This method merges attribute uses from the base, into the derived set.// end of traverseComplexContentXSAttributeUse existingAttrUsereplaceAttributeUse(...)toAttrGrp.fAttributeWCfromAttrGrp.fAttributeWCperformUnionWith(...)toAttrGrp.fAttributeWC.fProcessContentsboolean emptyParticletraverseAll(...)getEmptySequence(...)// end processComplexContent/* Generate a name for an anonymous type */StringBuffer typeNamegetRoot(...)getErrorContent(...)fAttrGrp.fAttributeWCfGlobalStore.lengthObject[] newArrayXSAnnotationImpl[] tempArray// need to add the type to the grammar for later constraint checking//discard valid Block/Final 'Default' values that are invalid for Block/Final// ---------------------------------------------------------------// First, handle any ANNOTATION declaration and get next child// Process the content of the complex type definition// EMPTY complexType with complexContent// set the base to the anyType// SIMPLE CONTENT// We must have ....// GROUP, ALL, SEQUENCE or CHOICE, followed by optional attributes// Note that it's possible that only attributes are specified.// -----------------------------------------------------------------------// Set content type// If there are no children, return// The content should be either "restriction" or "extension"// Need a base type.// If the base type is complex, it must have simpleContent// base is a CT with simple content (both restriction and extension are OK)// base is a CT with mixed/emptiable content (only restriction is OK)// base is a ST (only extension is OK)// Check that the base permits the derivation// Skip over any potential annotations// Process a RESTRICTION// There may be a simple type definition in the restriction element// The data type validator will be based on it, if specified//check that this datatype validator is validly derived from the base//according to derivation-ok-restriction 5.1.2.1// this only happens when restricting a mixed/emptiable CT// but there is no <simpleType>, which is required// Traverse any facets// Recreate the type, ignoring the facets// Traverse any attributes// Prohibited uses must be removed after merge for RESTRICTION// Process a EXTENSION// Remove prohibited uses.   Should be done prior to any merge.// and finally, since we've nothing more to traverse, we can// return the attributes (and thereby reset the namespace support)// Determine if this is mixed content// Since the type must have complex content, set the simple type validators// to null// Need a base type.  Check that it's a complex type// Process the content.  Note:  should I try to catch any complexType errors// here in order to return the attr array?// Compose the final content and attribute uses// This is an RESTRICTION// N.B. derivation-ok-restriction.5.3 is checked under schema// full checking.   That's because we need to wait until locals are// traversed so that occurrence information is correct.// Remove prohibited uses.   Must be done after merge for RESTRICTION.// This is an EXTENSION// Create the particle// Check if the contentType of the base is consistent with the new type// cos-ct-extends.1.4.3.2// if the content of either type is an "all" model group, error.// the "sequence" model group to contain both particles// the particle to contain the above sequence// Remove prohibited uses.   Must be done before merge for EXTENSION.// and *finally* we can legitimately return the attributes!// Recover by using the attribute use from the base type,// to make the resulting schema "more valid".// For extension, the wildcard must be formed by doing a union of the wildcards// REVISIT: XML Schema 1.0 2nd edition doesn't actually specify this constraint. It's a bug in the spec// which will eventually be fixed. We're just guessing what the error code will be. If it turns out to be// something else we'll need to change it. -- mrglavas// whether there is a particle with empty model group// GROUP, ALL, SEQUENCE or CHOICE, followed by attributes, if specified.// Should be attributes here - will check below...// if the particle is empty because there is no non-annotation chidren,// we need to make the particle itself null (so that the effective// content is empty).// get the first child// if it's annotation, get the next one// if there is no (non-annotation) children, mark particle empty// child != null means we might have seen an element with// minOccurs == maxOccurs == 0// Set the content type// Now, process attributes// Only remove prohibited attribute uses if this isn't a derived type// Derivation-specific code worries about this elsewhere// Generate a unique name for the anonymous type by concatenating together the// names of parent nodes// The name is quite good for debugging/error purposes, but we may want to// revisit how this is done for performance reasons (LM).//  Mock up the typeInfo structure so that there won't be problems during//  validation// REVISIT: do we need to remove all attribute uses already added into// the attribute group? maybe it's ok to leave them there. -SG// let's save ourselves a couple of objects...// it isn't very likely that there will be more than one annotation// in a complexType decl.  This saves us fromhaving to push/pop// one more object from the fGlobalStore, and that's bound// to be a savings for most applications/** The element declaration schema component traverser. ... */XSElementDecl fTempElementDecl;boolean fDeferTraversingLocalElements;// We may not encounter all local elements when first parsing.// this controls what happens when a local element is encountered./** Traverse a locally declared element (or an element reference). ... */getParticleDecl(...)String minfillInLocalElemInfo(...)setEffectiveContext(...)XSDHandler.ELEMENT_TYPEtraverseNamedElement(...)element.fAnnotations/** Traverse a globally declared element. ... */Boolean nillableAttXSAttributeChecker.ATTIDX_NILLABLEQName subGroupAttXSAttributeChecker.ATTIDX_SUBSGROUPXSTypeDefinition elementTypeelement.fNamesetIsLocal(...)schemaDoc.fAreLocalElementsQualifiedXSConstants.DERIVATION_ALLXSConstants.DERIVATION_EXTENSION_RESTRICTION_SUBSTITIONelement.fFinalsetIsNillable(...)setIsAbstract(...)element.fDefaultelement.fDefault.normalizedValuefSchemaHandler.fComplexTypeTraverserelement.fUnresolvedTypeNameelement.fSubGroup.fTypesetHidden(...)fSchemaHandler.fHiddenNodesfSchemaHandler.fUniqueOrKeyTraversergetAttrValue(...)checkForDuplicateNames(...)fSchemaHandler.ATTRIBUTE_TYPEgetIDRegistry(...)getIDRegistry_sub(...)storeKeyRef(...)element.fSubGroup.fFinalsubGroupAtt.localpartsubGroupAtt.prefixXSElementDecl element2addGlobalElementDeclAll(...)// The only thing we care about now is whether this element has// minOccurs=0. This affects (if the element appears in a complex// type) whether a type has emptiable content.// If it's an empty particle, return null.// Element Declaration Representation OK// 2 If the item's parent is not <schema>, then all of the following must be true:// 2.1 One of ref or name must be present, but not both.// 2.2 If ref is present, then all of <complexType>, <simpleType>, <key>, <keyref>, <unique>, nillable, default, fixed, form, block and type must be absent, i.e. only minOccurs, maxOccurs, id are allowed in addition to ref, along with <annotation>.// General Attribute Checking'// get 'block', 'final', 'nillable', 'abstract'// use defaults// discard valid Block 'Default' values that are invalid for Block// respect #all// use specified values// check for valid values// discard valid Final 'Default' values that are invalid for Final// get 'substitutionGroup affiliation'// Handler type attribute// Get it from the substitutionGroup declaration// get 'identity constraint'// see if there's something here; it had better be key, keyref or unique.// need to set <key>/<unique> to hidden before traversing it,// because it has global scope// Step 4: check 3.3.3 constraints// src-element// 3 type and either <simpleType> or <complexType> are mutually exclusive.// Step 5: check 3.3.6 constraints// 2 If there is a {value constraint}, the canonical lexical representation of its value must be valid with respect to the {type definition} as defined in Element Default Valid (Immediate) (3.3.6).// 4 If there is an {substitution group affiliation}, the {type definition} of the element declaration must be validly derived from the {type definition} of the {substitution group affiliation}, given the value of the {substitution group exclusions} of the {substitution group affiliation}, as defined in Type Derivation OK (Complex) (3.4.6) (if the {type definition} is complex) or as defined in Type Derivation OK (Simple) (3.14.6) (if the {type definition} is simple).// 5 If the {type definition} or {type definition}'s {content type} is or is derived from ID then there must not be a {value constraint}.// Element without a name. Return null.// Step 5: register the element decl to the grammar// we also add the element to the tolerate duplicates list as well// if we are tolerating duplicates, and we found a duplicate declaration// use the duplicate one insteadimport XSGroupDecl/** The model group schema component traverser. ... */XInt minAttrXInt maxAttrXSGroupDecl groupXSDHandler.GROUP_TYPEgroup.fModelGroupgroup.fModelGroup.fCompositorString strNameAttrnew XSGroupDecl(...)Element l_elmChildXSGroupDecl group2group.fNamegroup.fTargetNamespaceObject redefinedGrpaddRedefinedGroupDecl(...)// index is a particle index.// no children other than "annotation?" are allowed// not empty group, not empty particle// create a particle to contain this model group// must have a name// Create the group defi up-front, so it can be passed// to the traversal methods// must have at least one child// add global group declaration to the grammar// Add group declaration to grammar// name attribute is not there, don't return this group.// store groups redefined by restriction in the grammar so// that we can get at them at full-schema-checking time.// store in grammarimport XMLSchemaLoaderimport XSDDescriptionimport XSNotationDeclimport SchemaParsingConfigimport XSInputSourceimport DOMInputSourceimport ErrorHandlerWrapperimport SAXInputSourceimport StAXInputSource/** The purpose of this class is to co-ordinate the construction of a ... */new HashMap<String,Element>(...)new HashMap<String,XSDocumentInfo>(...)new HashMap<>[]new HashMap<XSDocumentInfo,Vector<XSDocumentInfo>>(...)new HashMap<XSDKey,Element>(...)new HashMap<Element,String>(...)new XSDocumentInfo[]Constants.NAMESPACE_PREFIXES_FEATUREString XMLSCHEMA_VALIDATION;/** feature identifier: XML Schema validation *//** Feature identifier:  allow java encodings *//** Feature identifier:  continue after fatal error */String NAMESPACE_PREFIXES;/** Feature identifier: namespace prefixes. *//** Feature identifier: string interning. *//** Property identifier: security manager. */boolean DEBUG_NODE_POOL;int ATTRIBUTE_TYPE;// traverser calling more efficient/less bulky.// different sorts of declarations; should make lookup andint ATTRIBUTEGROUP_TYPE;int ELEMENT_TYPE;int GROUP_TYPE;int IDENTITYCONSTRAINT_TYPE;int NOTATION_TYPE;int TYPEDECL_TYPE;String REDEF_IDENTIFIER;// as unlikely as possible to cause collisions.// this string gets appended to redefined names; it's purpose is to be//protected data that can be accessible by any traverser// the Security manager in effect.String fAccessExternalSchema;boolean registryEmpty;// XSDocumentInfo object.// XSDocumentInfoRegistry we can easily get the corresponding// By asking the node for its ownerDocument and looking in// their values are nodes corresponding to the given name's decl.// They are keyed with a QName (that is, String("URI,localpart) and// spec.// These tables correspond to the symbol spaces defined in theMap<String,Element> fUnparsedAttributeRegistry;Map<String,Element> fUnparsedAttributeGroupRegistry;Map<String,Element> fUnparsedElementRegistry;Map<String,Element> fUnparsedGroupRegistry;Map<String,Element> fUnparsedIdentityConstraintRegistry;Map<String,Element> fUnparsedNotationRegistry;Map<String,Element> fUnparsedTypeRegistry;Map<String,XSDocumentInfo> fUnparsedAttributeRegistrySub;// corresponding XSDocumentInfo object just using above maps.// Since we may take Schema Element directly, so can not get the// Compensation for the above maps to locate XSDocumentInfo,Map<String,XSDocumentInfo> fUnparsedAttributeGroupRegistrySub;Map<String,XSDocumentInfo> fUnparsedElementRegistrySub;Map<String,XSDocumentInfo> fUnparsedGroupRegistrySub;Map<String,XSDocumentInfo> fUnparsedIdentityConstraintRegistrySub;Map<String,XSDocumentInfo> fUnparsedNotationRegistrySub;Map<String,XSDocumentInfo> fUnparsedTypeRegistrySub;...[] fUnparsedRegistriesExt;// components declared within the same xsd document// Stores XSDocumentInfo (keyed by component name), to check for duplicateMap<XSDocumentInfo,Vector<XSDocumentInfo>> fDependencyMap;// <import>ed or <redefine>d by the key XSDocumentInfo.// are Vectors containing the XSDocumentInfo objects <include>d,// this map is keyed on by XSDocumentInfo objects.  Its valuesMap<String,Vector<>> fImportMap;// if an imported schema has absent namespace, the value "null" is stored.// with the key target namespace.// are Vectors containing namespaces imported by schema documents// this map is keyed on by a target namespace.  Its valuesVector<String> fAllTNSs;// (because the key of a map can't be null.)// if the importing schema has absent namespace, empty string is stored.// all namespaces that imports other namespaces// stores instance document mappings between namespaces and schema hintsMap<Node,String> fHiddenNodes;// Records which nodes are hidden when the input is a DOMInputSource.// convenience methods// use Schema Element to lookup the SystemId.String documentURIMap<XSDKey,Element> fTraversed;// schema document that is included in multiple other schemas.// EntityResolver can provide a consistent way of identifying a// schema document.  This combination is used so that the user's// publicId and systemId of the inputSource corresponding to a// This vector stores strings which are combinations of theMap<Element,String> fDoc2SystemId;// this is useful to resolve a uri relative to the referring document// this map contains a mapping from Schema Element to its systemIdXSDocumentInfo fRoot;// the primary XSDocumentInfo we were called to parseMap<> fDoc2XSDocumentMap;// This map's job is to act as a link between the Schema Element and itsMap<> fRedefine2XSDMap;// objects that correspond to the documents being redefined.// map between <redefine> elements and the XSDocumentInfoMap<> fRedefine2NSSupport;// map between <redefine> elements and the namespace supportMap<> fRedefinedRestrictedAttributeGroupRegistry;// validity.// Group and AttributeGroup traversers to check these restrictions for// they redefine by restriction (implicitly).  It is up to the// groups/attributeGroups and the groups/AttributeGroups which// these objects store a mapping between the names of redefiningMap<> fRedefinedRestrictedGroupRegistry;boolean fLastSchemaWasDuplicate;// processed (by getSchema) was a duplicate.// a variable storing whether the last schema document// validate annotations featureboolean fHonourAllSchemaLocations;//handle multiple import feature//handle namespace growth featureboolean fTolerateDuplicates;// handle tolerate duplicates feature// the XMLErrorReporter// the XMLErrorHandler// the LocaleXMLEntityResolver fEntityManager;// the XMLEntityManagerXSAttributeChecker fAttributeChecker;// the XSAttributeChecker// the symbol table// the GrammarResolverXSDDescription fSchemaGrammarDescription;// the Grammar description// the Grammar Pool// the security property managerboolean fOverrideDefaultParser;XSDAttributeGroupTraverser fAttributeGroupTraverser;//************ Traversers **********XSDAttributeTraverser fAttributeTraverser;XSDComplexTypeTraverser fComplexTypeTraverser;XSDElementTraverser fElementTraverser;XSDGroupTraverser fGroupTraverser;XSDKeyrefTraverser fKeyrefTraverser;XSDNotationTraverser fNotationTraverser;XSDSimpleTypeTraverser fSimpleTypeTraverser;XSDUniqueOrKeyTraverser fUniqueOrKeyTraverser;XSDWildcardTraverser fWildCardTraverser;SchemaDVFactory fDVFactory;SchemaDOMParser fSchemaParser;SchemaContentHandler fXSContentHandler;StAXSchemaParser fStAXSchemaParser;XML11Configuration fAnnotationValidator;XSAnnotationGrammarPool fGrammarBucketAdapter;int INIT_STACK_SIZE;// the initial size of the array to store deferred local elements// of local elements.// these data members are needed for the deferred traversal// the incremental size of the array to store deferred local elementsint fLocalElemStackPos;// current position of the array (# of deferred local elements)...[] fParticle;...[] fLocalElementDecl;...[] fLocalElementDecl_schema;...[] fAllContext;//JACK...[] fParent;...[] fLocalElemNamespaceContext;int INIT_KEYREF_STACK;// the initial size of the array to store deferred keyrefs// of keyrefs.int INC_KEYREF_STACK_AMOUNT;// the incremental size of the array to store deferred keyrefsint fKeyrefStackPos;// current position of the array (# of deferred keyrefs)...[] fKeyrefs;...[] fKeyrefsMapXSDocumentInfo;...[] fKeyrefElems;...[] fKeyrefNamespaceContext;new SchemaDOMParser(...)new SchemaParsingConfig(...)// constructed.// multiple schema documents; this will allow one to be// it should be possible to use the same XSDHandler to parse/** This method initiates the parse of a schema.  It will likely be ... */String schemaNamespaceshort referTypeElement schemaRootArrayList<> annotationInfoisExistingGrammar(...)findGrammar(...)prepareForParse(...)getSchemaDocument(...)Element schemaElemString schemaIdXSDKey keynew XSDKey(...)setTargetNamespace(...)prepareForTraverse(...)constructTrees(...)buildGlobalNameRegistries(...)traverseSchemas(...)traverseLocalElements(...)resolveKeyRefs(...)Vector<> insemptyString2Null(...)SchemaGrammar isgsetImportedGrammars(...)validateAnnotations(...)fRoot.fTargetNamespace// end parseSchemacreateAnnotationValidator(...)refreshGrammars(...)XSAnnotationInfo annotationannotation.nextnew XSAnnotationGrammarPool(...)/** Pull the grammar out of the bucket simply using ... *//** First try to find a grammar in the bucket, if failed, consult the ... */reportSchemaWarning(...)...[] NS_ERROR_CODES;// EntityResolver...// may wish to have setter methods for ErrorHandler,...[] ELE_ERROR_CODES;// called to parse is correct.// It also makes sure the targetNamespace of the schema it was// depends on.// the DependencyMap object what XSDocumentInfo objects its XSDocumentInfo// itself recursively on that document's root.  It also records in// requested schema document, initiates a DOM parse, and calls// <redefine>, and <import> children, it attempts to resolve the// schemaRoot node.  Then, for each <include>,// It constructs an instance of an XSDocumentInfo object using the// This method does several things:String callerTNSXSDocumentInfo currSchemaInfoVector<XSDocumentInfo> dependenciesnew Vector<XSDocumentInfo>(...)Element rootNodeElement newSchemaRootnew XSDocumentInfo(...)XMLSchemaException securrSchemaInfo.fTargetNamespaceint secondIdxXSDDescription.CONTEXT_INCLUDEXSDDescription.CONTEXT_REDEFINEcurrSchemaInfo.fIsChameleonSchemaaddAllowedNS(...)new SchemaGrammar(...)updateImportListWith(...)updateImportListFor(...)currSchemaInfo.fSchemaElementString schemaHintshort refTypeboolean importCollisionXSDocumentInfo newSchemaInfoObject[] importAttrsElement importChildXSAttributeChecker.ATTIDX_SCHEMALOCATIONXSAttributeChecker.ATTIDX_NAMESPACEString importComponentTypeisAllowedNS(...)setContextType(...)doc2SystemId(...)resolveSchema(...)Object[] includeAttrsboolean mustResolveboolean alreadyTraversedXMLInputSource schemaSourceresolveSchemaSource(...)currSchemaInfo.fNamespaceSupportElement includeChildString includeComponentTypeElement redefinedChildString redefinedComponentTypenonAnnotationContent(...)// end constructTrees/** Namespace growth ... */Vector<> importedGrammarsSchemaGrammar isg1SchemaGrammar isg2SchemaGrammar[] schemaGrammarsschemaGrammars.length// that implicit redefinitions of groups and attributeGroups can be handled).// components, and to record which components redefine others (so// by the spec.  It is also this method's job to rename redefined// names.  A registry will be built for each symbol space defined// This method builds registries for all globally-referenceableStack<> schemasToProcessXSDocumentInfo currSchemaDocElement currDoccurrSchemaDoc.fSchemaElementElement currRootboolean dependenciesCanOccurVector<XSDocumentInfo> currSchemaDependsisHidden(...)Element globalCompElement redefineCompcurrSchemaDoc.fTargetNamespaceString componentTypeString targetLNamerenameRedefiningComponents(...)// DependencyMap and marked them as traversed.// when it has visited all XSDocumentInfo objects in the// as traversed (or hidden) in order to avoid infinite loops.  It completes// an XSDocumentInfo object have been traversed, it marks that object// appropriate traverser to traverse it.  Once all global decls in// readOnly field on that node has not been set, it calls an// corresponding to an XSDocumentInfo object.  If the// schema document (and of each <redefine> element)// examines each child (global schema information item) of each// (fRoot), this method// Beginning at the first schema processing was requested for// end buildGlobalNameRegistriessetSchemasVisible(...)SchemaGrammar currSGboolean sawAnnotationgetFirstVisibleChildElement(...)getNextVisibleSiblingElement(...)backupNSSupport(...)Element redefinedComptraverseGlobal(...)restoreNSSupport(...)getSchemaAttrs(...)XSAnnotationInfo inforeturnSchemaAttrs(...)Vector<> fReportedTNS;// is found for the given namespace uri// store whether we have reported an error about that no grammar// end traverseSchemas// otherwise we reported the error, and remember this fact.// if we have reported an error, then we don't need to report again;// check whether we need to report an error against the given uri....[] COMP_TYPE;...[] CIRCULAR_CODES;// add a global attribute decl from a current schema load (only if no existing decl is found)String declKey// add a global attribute group decl from a current schema load (only if no existing decl is found)// add a global element decl from a current schema load (only if no existing decl is found)// add a global group decl from a current schema load (only if no existing decl is found)// add a global notation decl from a current schema load (only if no existing decl is found)// add a global type decl from a current schema load (only if no existing decl is found)// add a identity constraint decl from a current schema load (only if no existing decl is found)// that lives in the Grammar.// this will be an Object of some kind// This method returns whatever the traverser it called returned;// well), call the appropriate traverser with the appropriate// 3. depending on declType (which will be relevant to step 1 as// in DependencyMap);// schema document where declToTraverse lives (i.e., do a lookup// 2. if so, determine if there is a path from currSchema to the// 1.  See if a global definition matching declToTraverse exists;// This method will:// may bear no relation to the one the handler is operating on.// required because the XSDocumentInfo that the traverser is traversing// for the traversal of some declaration.  An XSDocumentInfo is// this provides a generic means for a traverser to call// directly (except wen a traverser encounters a local declaration),// since it is forbidden for traversers to talk to each otherdeclToTraverse.uriObject retObjgetGlobalDeclFromGrammar(...)declToTraverse.localpartXSDocumentInfo schemaWithDeclElement declXSDocumentInfo declDocneedReportTNSError(...)declToTraverse.rawnamecurrSchema.fSchemaElementObject retObj2getElementFromMap(...)getDocInfoFromMap(...)findXSDocumentForDecl(...)declToTraverse.prefixtraverseGlobalDecl(...)// use the declaration from the current schema load (if it exists)// If we are tolerating duplicate declarations and allowing namespace growth// getGlobalDecl(XSDocumentInfo, int, QName):  ObjectgetIDConstraintDecl(...)SchemaNamespaceSupport nsSupportElement parentschemaDoc.fSchemaElement// otherwise.// @return:  Object representing decl redefined if present, null// @param currSchema:  schema doc in which the redefining component lives.// @param name:  the QName of the component doing the redefining.// attributeGroup or a group;// @param type:  whether what's been redefined is an// restriction.  If so, it returns it; else it returns null.// (attributeGroup) which the given one has redefined by// This method determines whether there is a groupString realNameString nameToFindint commaPosQName qNameToFind// but there seems to be no efficient way around this...// from the elementTraverser class (which must ignore keyrefs),// of the KeyRef nodes.  This unfortunately removes this knowledge// fIdentityConstraintRegistry and calling traverseKeyRef on all// after all parsing is complete.  This we can simply do by running through// which seems terribly inefficient, we need to resolve keyrefs// constraints while we're building our global name registries,// wish to completely traverse all our DOM trees looking for ID// Since ID constraints can occur in local elements, unless we// getGrpOrAttrGrpRedefinedByRestriction(int, QName, XSDocumentInfo):  ObjectXSDocumentInfo keyrefSchemaDocSchemaGrammar keyrefGrammarkeyrefSchemaDoc.fTargetNamespacemakeGlobal(...)keyrefSchemaDoc.fNamespaceSupport// who want the Identity constraint registry vaguely know what they're about.// an accessor method.  Just makes sure callers// end resolveKeyRefs// an accessor method.// decls and namespace bindings they might find handy.// This method squirrels away <keyref> declarations--along with the elementString keyrefNameString keyrefQNamefKeyrefs.lengthElement[] elemArrayXSElementDecl[] declArrayString[][] stringArrayXSDocumentInfo[] xsDocumentInfogetEffectiveLocalContext(...)/** resolveSchema method is responsible for resolving location of the schema (using XMLEntityResolver), ... */// storeKeyref (Element, XSDocumentInfo, XSElementDecl): voidMap<String,LocationArray> pairs// getSchema(String, String, String, boolean, short):  Document/** getSchemaDocument method uses XMLInputSource to parse a schema document. ... */boolean hasInputIOException exceptionElement schemaElementDocument schemaDocumentgetSchemaDocument0(...)getSchemaDocument1(...)/** getSchemaDocument method uses SAXInputSource to parse a schema document. ... */// getSchemaDocument(String, XMLInputSource, boolean, short, Element): ElementXMLReader parserInputSource inputSourceboolean namespacePrefixesboolean stringsInternalizedSAXNotRecognizedException excnew SchemaContentHandler(...)getSAXErrorHandler(...)SAXParseException specreateXMLParseException0(...)createXNIException0(...)/** getSchemaDocument method uses DOMInputSource to parse a schema document. ... */// getSchemaDocument(String, SAXInputSource, boolean, short, Element): ElementElement schemaRootElementshort nodeTypeboolean isDocument/** getSchemaDocument method uses StAXInputSource to parse a schema document. ... */// getSchemaDocument(String, DOMInputSource, boolean, short, Element): Elementboolean consumeRemainingContentshouldConsumeRemainingContent(...)XMLStreamReader streamReaderXMLEventReader eventReaderXMLStreamReader.START_DOCUMENTnew StAXSchemaParser(...)StAXLocationWrapper slw/** Code shared between the various getSchemaDocument() methods which ... */// getSchemaDocument(String, StAXInputSource, boolean, short, Element): Element/** Error handling code shared between the various getSchemaDocument() methods. */// getSchemaDocument0(XSDKey, String, Element): Element// getSchemaDocument1(boolean, boolean, XMLInputSource, Element): ElementVector<> expandedGrammarsexpandGrammars(...)existingGrammars(...)addGrammars(...)Map<String,Vector<>> importDependenciesVector<> expandedComponentsexpandComponents(...)canAddComponents(...)addGlobalComponents(...)// getSchemaDocument(String, XSInputSource, boolean, short, Element): ElementXSObject componentcanAddComponent(...)short componentTypeaddGrammarComponents(...)SchemaGrammar tmpGrammarcreateGrammarFrom(...)addNewGrammarLocations(...)addNewImportedGrammars(...)addNewGrammarComponents(...)StringList locationsint locSizeStringList locations2Vector<> igs1Vector<> igs2updateImportList(...)containedImportedGrammar(...)resetComponents(...)addGlobalElementDecls(...)addGlobalAttributeDecls(...)addGlobalAttributeGroupDecls(...)addGlobalGroupDecls(...)addGlobalTypeDecls(...)addGlobalNotationDecls(...)XSNamedMap componentsXSElementDecl srcDeclXSElementDecl dstDeclObjectList componentsExtgetComponentsExt(...)XSAttributeDecl srcDeclXSAttributeDecl dstDeclreportSharingError(...)XSAttributeGroupDecl srcDeclXSAttributeGroupDecl dstDeclXSNotationDecl srcDeclXSNotationDecl dstDeclXSGroupDecl srcDeclXSGroupDecl dstDeclXSTypeDefinition srcDeclXSTypeDefinition dstDeclVector<> newComponentsexpandRelatedComponents(...)expandRelatedTypeComponents(...)expandRelatedAttributeComponents(...)expandRelatedAttributeGroupComponents(...)expandRelatedElementComponents(...)expandRelatedModelGroupDefinitionComponents(...)addRelatedType(...)XSElementDeclaration subElemDeclgetSubstitutionGroupAffiliation(...)addRelatedElement(...)expandRelatedComplexTypeComponents(...)expandRelatedSimpleTypeComponents(...)expandRelatedModelGroupComponents(...)getModelGroup(...)expandRelatedAttributeUsesComponents(...)XSParticle particleexpandRelatedParticleComponents(...)XSTypeDefinition baseTypeXSTypeDefinition primitiveTypeint attrUseSizeexpandRelatedAttributeUseComponents(...)addRelatedAttribute(...)getAttrDeclaration(...)XSTerm termgetTerm(...)XSObjectList particlesgetParticles(...)Vector<> importedNamespacesfindDependentNamespaces(...)addNamespaceDependency(...)getScope(...)addGlobalComponent(...)updateImportDependencies(...)getSchemaGrammar(...)XSElementDecl.SCOPE_GLOBALVector<> importListEntry<String,Vector<>> entryMap<>.Entry<String,Vector<>>expandImportList(...)Vector<> isgsaddImportList(...)//       otherwise the grammar should have existed// NOTE: always assuming that fNamespaceGrowth is enabledVector<> namespaceListgetFromMap(...)String ns1String ns2// construct schemaGrammars.// of this object; it creates the traversers that will be used to// this should only need to be called once during the construction// initialize all the traversers.new XSAttributeChecker(...)new XSDAttributeGroupTraverser(...)new XSDAttributeTraverser(...)new XSDComplexTypeTraverser(...)new XSDElementTraverser(...)new XSDGroupTraverser(...)new XSDKeyrefTraverser(...)new XSDNotationTraverser(...)new XSDSimpleTypeTraverser(...)new XSDUniqueOrKeyTraverser(...)new XSDWildcardTraverser(...)// parsing schemas// before parsing a schema, need to clear registries associated with// createTraversers()// clear all registries// before traversing a schema's parse tree, need to reset all traversers andLocale localecreateTraversers(...)XMLEntityResolver er/** Traverse all the deferred local elements. This method should be called ... */fElementTraverser.fDeferTraversingLocalElementsElement currElemXSDocumentInfo currSchemacurrSchema.fTargetNamespace...[...].fTypeXSParticle p(...).fModelGroupremoveParticle(...)XSParticleDecl membermember.fTypemember.fValue// we'll need for the feferred traversal of local elements.// the purpose of this method is to keep up-to-date structuresfParticle.lengthXSParticleDecl[] newStackPElement[] newStackEXSDocumentInfo[] newStackE_schemaint[] newStackIXSObject[] newStackCString[][] newStackN/** This method makes sure that ... */// end fillInLocalElemInfo(...)Object objElemElement collidingElemXSDocumentInfo collidingElemSchemaElement elemParentXSDocumentInfo redefinedSchemaboolean collidedWithRedefine// checkForDuplicateNames(String, Map, Element, XSDocumentInfo):voidint namespaceEnd// traversers.// relating to implicit restrictions is preserved for those// <group>s and <attributeGroup>s to ensure that information// refer to the object being redefined.  It takes special care of// specified type and rename references to itself so that they// the purpose of this method is to take the component of theElement grandKidString grandKidNameQName derivedBasederivedBase.uriderivedBase.localpartderivedBase.prefixElement greatGrandKidString greatGrandKidNameString processedBaseNameint attGroupRefsCountchangeRedefineGroup(...)int groupRefsCount//          in this method.//          validate() method, we should just call QNameDV.validate()//          And when the DV's are ready to return compiled values from//          as a key to the SymbolHash.//          QName#equals() to compare two QNames, and use QName directly//          save lots of string concatenation time. we can use// REVISIT: should have it return QName, instead of String. this would// decl maps.// information in the form (nsURI,b) suitable for lookups in the global// to by a in the current SchemaNamespaceSupport object, and returns this// this method takes a name of the form a:b, determines the URI mapped// renameRedefiningComponents(XSDocumentInfo, Element, String, String, String):voidSchemaNamespaceSupport currNSMapint colonPtr// being redefined.// It also resets the value of ref so that it will refer to the renamed type from the schema// the sum of the values returned by calls to itself on curr's children.// calls to itself on all other children.  In all other cases it returns 0 plus// to originalQName.  If it does, it returns 1 + the value returned by// If it finds one, it evaluates whether its ref attribute contains a reference// This function looks among the children of curr for an element of type elementSought.// findQName(String, XSDocumentInfo):  StringString processedReffindQName(...)String minOccursString maxOccurs// this method is superficial now. ---Jack// @param:  decl:  the declaration being ref'd.// decl ref'ing us.// @param:  currSchema:  the XSDocumentInfo object containing the// method returns null; it's up to the caller to throw an error.// document cannot be referred to from those of currSchema, this// component corresponding to decl.  If components from this// this method returns the XSDocumentInfo object that contains the// changeRedefineGroupXSDocumentInfo declDocInfo// returns whether more than <annotation>s occur in children of elem// findXSDocumentForDecl(XSDocumentInfo, Element):  XSDocumentInfo// nonAnnotationContent(Element):  booleanstartSchema.fSchemaElementVector<XSDocumentInfo> dependingSchemasSimpleLocator xl;// setSchemasVisible(XSDocumentInfo): void/** Extract location information from an Element node, and create a ... */SimpleLocator l/** Extract location information from an Element node, store such ... */ElementImpl eleint columnreportSchemaErr(...)XSDHandler$XSAnnotationGrammarPool/** Grammar pool used for validating annotations. This will return all of the ... */...[] fInitialGrammarSet;SchemaGrammar.Schema4Annotations.INSTANCESchemaGrammar.Schema4AnnotationsGrammar grammarXSDHandler$XSDKey/** used to identify a reference to a schema document ... */short referType;String referNS;// for import/preparse/instance, this is the target namespace// for inclue/redefine, this is the enclosing namespacethis.referTypethis.referNSkey.referNSkey.systemIdXSDHandler$SAX2XNIUtilcreateXMLParseException(...)createXNIException(...)// ATTRIBUTE_TYPE// ATTRIBUTEGROUP_TYPE// ELEMENT_TYPE// GROUP_TYPE// IDENTITYCONSTRAINT_TYPE// NOTATION_TYPE// TYPEDECL_TYPE/** REVISIT: Casting until DOM Level 3 interfaces are available. -- mrglavas */// Note: don't use SchemaConfiguration internally//       we will get stack overflaw because//       XMLSchemaValidator will be instantiating XSDHandler...// if loading using JAXP schemaSource property, or using grammar caching loadGrammar// the desc.targetNamespace is always null.// Therefore we should not attempt to find out if// the schema is already in the bucket, since in the case we have// no namespace schema in the bucket, findGrammar will always return the// no namespace schema.// first try to find it in the bucket/pool, return if one is found//REVISIT: return the grammar?// handle empty string URI as null// first phase:  construct trees.// DOMInputSource// SAXInputSource// StAXInputSource// XSInputSource//is instanceof XMLInputSource// something went wrong right off the hop// Since now we've discovered a namespace, we need to update xsd key// and store this schema in traversed schemas bucket// When namespace growth is enabled and a null location is provided we cannot tell// whether we've loaded this schema document before so we must assume that we haven't.// before constructing trees and traversing a schema, need to reset// all traversers and clear all registries// second phase:  fill global registries.// third phase:  call traversers// fourth phase: handle local element decls// fifth phase:  handle Keyrefs// sixth phase:  validate attribute of non-schema namespaces// REVISIT: skip this for now. we really don't want to do it.//fAttributeChecker.checkNonSchemaAttributes(fGrammarBucket);// seventh phase:  store imported grammars// for all grammars with <import>s// get its target namespace// get all namespaces it imports// for imported namespace// get imported grammar// reuse the same vector// set the imported grammars/** validate annotations * */// and return./** set security manager and XML Security Property Manager * *//** Set error handler. * *//** Set locale. * */// note that attributes are freed at end of traverseSchemas()// targetNamespace="" is not valid, issue a warning, and ignore it// the second index to the NS_ERROR_CODES array// if the caller/expected NS is not absent, we use the first column// for include and redefine// if the referred document has no targetNamespace,// it's a chameleon schema// if the referred document has a target namespace differing// from the caller, it's an error// for instance and import, the two NS's must be the same// now there is no caller/expected NS, it's an error for the referred// document to have a target namespace, unless we are preparsing a schema// set the target namespace of the description// if the caller/expected NS is absent, we use the second column// the other cases (callerTNS == currSchemaInfo.fTargetNamespce == null)// are valid// a schema document can always access it's own target namespace// we have a namespace collision// update all the grammars in the bucket to point to the new grammar.// update import list of the new grammar// store the document and its location// REVISIT: don't expose the DOM tree// have to handle some validation here too!// call XSAttributeChecker to fill in attrs// check contents and process optional annotations// promoting annotations to parent component// a document can't import another document with the same namespace// if this namespace has not been imported by this document,//  then import if multiple imports support is enabled.// also record the fact that one namespace imports another one// convert null to ""// get all namespaces imported by this one// if no namespace was imported, create new Vector// record that this one imports other(s)// if a grammar with the same namespace and location exists (or being// built), ignore this one (don't traverse it).//if ((!fHonourAllSchemaLocations && findGrammar(fSchemaGrammarDescription) != null) || isExistingGrammar(fSchemaGrammarDescription))//    continue;// If "findGrammar" returns a grammar, then this is not the// the first time we see a location for a given namespace.// Don't consult the location pair map in this case,// otherwise the location will be ignored because it'll get// resolved to the same location as the first hint.// validation for redefine/include will be the same here; just// make sure TNS is right (don't care about redef contents// yet).// store the namespace decls of the redefine element// check annotations.  Must do this here to avoid having to// re-parse attributes later// catch all other content errors later// schemaLocation is required on <include> and <redefine>// pass the systemId of the current document as the base systemId// no more possibility of schema references in well-formed// schema...// If the schema is duplicate, we needn't call constructTrees() again.// To handle mutual <include>s// must record which schema we're redefining so that we can// rename the right things later!// Starting with fRoot, we examine each child of the schema// element.  Skipping all imports and includes, we record the names// of all other global components (and children of <redefine>).  We// also put <redefine> names in a registry that we look through in// case something needs renaming.  Once we're done with a schema we// set its Document node to hidden so that we don't try to traverse// it again; then we look to its Dependency map entry.  We keep a// stack of schemas that we haven't yet finished processing; this// is a depth-first traversal.// must have processed this already!// process this schema's global decls// this loop makes sure the <schema> element ordering is// also valid.//skip it; traverse it later// an error we'll catch later// the check will have changed our name;// and all we need to do is error-check+rename our kkids:// must be simpleType// and all we need to do is error-check+rename our kids:// end march through <redefine> children// and now set as traversed//DOMUtil.setHidden(globalComp);// end for// now we're done with this one!// now add the schemas this guy depends on// the process here is very similar to that in// buildGlobalRegistries, except we can't set our schemas as// hidden for a second time; so make them all visible again// first!// traverse this schema's global decls// includes and imports will not show up here!// use the namespace decls for the redefine, instead of for the parent <schema>// annotations will have been processed already; this is now// unnecessary//else if (redefinedComponentType.equals(SchemaSymbols.ELT_ANNOTATION)) {//    fElementTraverser.traverseAnnotationDecl(redefinedComp, null, true, currSchemaDoc);/** Collect annotation information for validation. * *//** Only add annotations to the list if there were any in this document. * */// index 0//or ct-props-correct.3// from the schema spec, all built-in types are present in all schemas,// so if the requested component is a type, and could be found in the// default schema grammar, we should return that type.// otherwise (since we would support user-defined schema grammar) we'll// use the normal way to get the decl// now check whether this document can access the requsted namespace// cannot get to this schema from the one containing the requesting decl// Recover and continue to look for the component.// return null;// check whether there is grammar for the requested namespace// if there is such grammar, check whether the requested component is in the grammar// if the component is parsed, return it// the component is not parsed, try to find a DOM element for it// no DOM element found, so the component can't be located// get the schema doc containing the component to be parsed// it should always return non-null value, but since null-checking// comes for free, let's be safe and check again// a component is hidden, meaning either it's traversed, or being traversed.// but we didn't find it in the grammar, so it's the latter case, and// a circular reference. error!// decl must not be null if we're here...// if the parent is <redefine> use the namespace delcs for it.// back up the current SchemaNamespaceSupport, because we need to provide// a fresh one to the traverseGlobal methods.// traverse the referenced global component// identity constraints should have been parsed already...// we should never get here// restore the previous SchemaNamespaceSupport, so that the caller can get// proper namespace binding.// need to set <keyref> to hidden before traversing it,// now set up all the registries we'll need...// check array sizes// contents of this method will depend on the system we adopt for entity resolution--i.e., XMLEntityHandler, EntityHandler, etc.// when the system id and byte stream and character stream// of the input source are all null, it's// impossible to find the schema document. so we skip in// this case. otherwise we'll receive some NPE or// file not found errors. but schemaHint=="" is perfectly// legal for import.// When the system id of the input source is used, first try to// expand it, and check whether the same document has been// parsed before. If so, return the document corresponding to// that system id.// check whether the same document has been parsed before.// If so, return the document corresponding to that system id.// If this is a Xerces SAX parser set the security manager if there is one// If XML names and Namespace URIs are already internalized we// can avoid running them through the SymbolTable.// The feature isn't recognized or getting it is not supported.// In either case, assume that strings are not internalized.// Disconnect the schema loader and other objects from the XMLReader// Ignore any exceptions thrown by the XMLReader. Old versions of SAX// required an XMLReader to throw a NullPointerException if an attempt// to set a handler to null was made.// now we need to store the mapping information from system id// to the document. also from the document to the system id.// either an error occured (exception), or empty input source was// returned, we need to report an error or a warning// check for existing grammars in our bucket// and if there exist any, and namespace growth is// not enabled - we do nothing// add any new locations// add any new imported grammars// add any new global components// add global components// TODO: if not tolerating duplicate, generate an error message// add any extended (duplicate) global components// REVISIT - do we report an error?// REVIST - do we report an error?//expandRelatedAttributeUseComponents((XSAttributeUse)component, componentList, dependencies);/* final XSComplexTypeDefinition enclosingType = decl.getEnclosingCTDefinition(); ... *//* final XSTypeDefinition enclosingType = decl.getEnclosingCTDefinition(); ... *///REVISIT - do we use == instead// store the declaration in the extended map, using an empty location// shouldn't be null//REVIST: report an error message// clear local element stack// and do same for keyrefs.// create traversers if necessary// reset traversers// set symbol table// set security manager//set entity manager//set entity resolver// set error reporter// Setting a parser property can be much more expensive// than checking its value.  Don't set the ERROR_HANDLER// or LOCALE properties unless they've actually changed.// security features//Passing on the setting to the parser//XSDocumentInfo currSchema = (XSDocumentInfo)fDoc2XSDocumentMap.get(DOMUtil.getDocument(currElem));//XSDocumentInfo currSchema = (XSDocumentInfo)fDoc2XSDocumentMap.get(DOMUtil.getRoot(DOMUtil.getDocument(currElem)));// If it's an empty particle, remove it from the containing component.// if the stack is full, increase the size// REVISIT:  when we add derivation checking, we'll have to make// sure that ID constraint collisions don't necessarily result in error messages.// need to check whether we have a global declaration in the corresponding// grammar// just add it in!// case where we've collided with a redefining element// (the parent of the colliding element is a redefine)// case where we're a redefining element.//redefinition involved somehow// If both components belong to the same document then// report an error and return.// object comp. okay here// now have to do some renaming...// and take care of nested redefines by calling recursively:// we may be redefining the wrong schema// error that redefined element in wrong schema// we've just got a flat-out collision (we tolerate duplicate// declarations, only if they are defined in different schema// documents)// store the lastest current document info// now we have to do the renaming...//                            return true;// have to go one more level down; let another pass worry whether complexType is valid.//                                    return true;//                return true;// if we get here then we must have reported an error and failed somewhere...//        return false;// if ref was null some other stage of processing will flag the error// something went badly wrong; we don't know this doc?/** ******* ... */// make it visible// if it's visible already than so must be its children// get system id from document object// line/column numbers are stored in the element node/** If the grammar bucket already contains the schema for schemas ... */// according to the description at the beginning of this class,// we use the hashcode of the namespace as the hashcoe of this key.// condition 1: both are redefine/** if (referType == XSDDescription.CONTEXT_REDEFINE || ... */// condition 2: same namespace// condition 3: same non-null location// XSDHandler/** This class contains code that is used to traverse <keyref>s. ... */String krNameQName kNameXSAttributeChecker.ATTIDX_REFERIdentityConstraint retXSDHandler.IDENTITYCONSTRAINT_TYPEnew KeyRef(...)kName.rawnametraverseIdentityConstraint(...)IdentityConstraint idcaddIDConstraintDecl(...)// create identity constraint//return this array back to pool// if ret == null, we've already reported an error in getGlobalDecl// we report an error only when ret != null, and the return type keyref// If errors occurred in traversing the identity constraint, then don't// add it to the schema, to avoid errors when processing the instance.//Schema Component Constraint: Identity-constraint Definition Properties Correct//2 If the {identity-constraint category} is keyref, the cardinality of the {fields} must equal that of the {fields} of the {referenced key}.// add key reference to element decl// and stuff this in the grammar// and put back attributes// traverse(Element,int,XSDocumentInfo, SchemaGrammar)// XSDKeyrefTraverser/** The notation declaration schema component traverser. ... */String publicAttrXSAttributeChecker.ATTIDX_PUBLICString systemAttrXSAttributeChecker.ATTIDX_SYSTEMXSNotationDecl notationnew XSNotationDecl(...)Element contentXSNotationDecl notation2notation.fNamenotation.fTargetNamespacenotation.fPublicIdnotation.fSystemIdnotation.fAnnotations// General Attribute Checking for elmNode//get attributes//check content/** The simple type definition schema component traverser. ... */boolean fIsBuiltIn;// whether the type being parsed is a S4S built-in type.//return qualified name of simpleType or empty string if error occuredtraverseSimpleTypeDecl(...)addGlobalSimpleTypeDecl(...)XInt finalAttrint finalPropertyString varietyPropertyboolean restrictionboolean listboolean unionElement nextChildObject[] contentAttrsXSAttributeChecker.ATTIDX_ITEMTYPEVector<> memberTypesXSAttributeChecker.ATTIDX_MEMBERTYPESArrayList<> dTValidatorsXSObjectList dvsXSSimpleType newDeclerrorType(...)findDTValidator(...)isListDatatype(...)XSSimpleType[] memberDeclscreateTypeUnion(...)// REVISIT: can this code be re-used?// also throws an error if the base type won't allow itself to be used in this context.//return XSSimpleType available for the baseTypeStr, null if not found or disallowed.//@param: baseRefContext:  whether the caller is using this type as a base for restriction, union or list//@param: baseTypeStr - type (base/itemType/memberTypes)//@param: elm - top elementbaseTypeStr.rawnamecheckBuiltIn(...)// built-in type. update fIsBuiltIn at the same time.// check whethe the type denoted by the name and namespace is a S4S// find if a datatype validator is a list or has list datatype member.XSObjectList temp//isListDatatype(XSSimpleTypeDecl):booleanXSSimpleType stringType// if it's a global type without a name, return null// don't add global components without name to the grammar// get name and final values// annotation?,(list|restriction|union)// (list|restriction|union)// derivation type: restriction/list/union// nothing should follow this element// General Attribute Checking: get base/item/member types//content = {annotation?,simpleType?...}//check content (annotation?, ...)// get base type from "base" attribute// if its the built-in type, return null from here// get types from "memberTypes" attribute// for each qname in the list// get the type decl// if it's a union, expand it// check if there is a child "simpleType"// it's an error for both "base" and "simpleType" to appear// traverse this child to get the base type// get the next element// traverse this child to get the member type// it's an error if neither "base/itemType" nor "simpleType" appears// it's an error if "memberTypes" is empty and no "simpleType" appears// error finding "base" or error traversing "simpleType".// don't need to report an error, since some error has been reported.// error finding "memberTypes" or error traversing "simpleType".// item type of list types can't have list content// create the simple type based on the "base" type// now traverse facets, if it's derived by restriction// no element should appear after this point// return the new type// if it's a complex type, or if its restriction of anySimpleType// if the base type is anySimpleType and the current type is// a S4S built-in type, return null. (not an error).//class XSDSimpleTypeTraverser/** This class contains code that is used to traverse both <key>s and ... */String uNameUniqueOrKey uniqueOrKeynew UniqueOrKey(...)// it's XSDElementTraverser's job to ensure that there's no// duplication (or if there is that restriction is involved// and there's identity).// and fix up attributeChecker// traverse(Element,XSDElementDecl,XSDocumentInfo, SchemaGrammar)// XSDUniqueOrKeyTraverser/** The wildcard schema component traverser. ... *//** constructor ... *//** Traverse &lt;any&gt; ... */traverseWildcardDecl(...)wildcard.fAnnotations/** Traverse &lt;anyAttribute&gt; ... */XInt namespaceTypeAttrXInt processContentsAttrXSAttributeChecker.ATTIDX_PROCESSCONTENTSXSAttributeChecker.ATTIDX_NAMESPACE_LIST// for <any>, need to create a new particle to reflect the min/max values//get all attributes// namespace type// namespace list// process contents// traverseWildcardDecl// XSDWildcardTraverser/** Objects of this class hold all information pecular to a ... */SchemaNamespaceSupport fNamespaceSupport;SchemaNamespaceSupport fNamespaceSupportRoot;Stack<> SchemaNamespaceSupportStack;boolean fAreLocalAttributesQualified;// schema's attributeFormDefaultboolean fAreLocalElementsQualified;// elementFormDefaultshort fBlockDefault;// [block | final]Defaultshort fFinalDefault;// targetNamespaceboolean fIsChameleonSchema;// represents whether this is a chameleon schema (i.e., whether its TNS is natural or comes from without)Element fSchemaElement;// the root of the schema Document tree itselfVector<> fImportedNS;// all namespaces that this document can refer toValidationState fValidationContext;// once we've been told that we're done with them// attribute checker to which we'll return the attributes...[] fSchemaAttrs;// once returnSchemaAttrs has been called.// array of objects on the schema's root element.  This is nullXSAnnotationInfo fAnnotations;// once removeAnnotations has been called.// list of annotations contained in the schema document. This is null// to avoid memory leaks!// note that the caller must ensure to call returnSchemaAttrs()initNamespaceSupport(...)Element rootXSAttributeChecker.ATTIDX_AFORMDEFAULTXSAttributeChecker.ATTIDX_EFORMDEFAULTXSAttributeChecker.ATTIDX_BLOCKDEFAULTXSAttributeChecker.ATTIDX_FINALDEFAULTXSAttributeChecker.ATTIDX_TARGETNAMESPACE/** Initialize namespace support by collecting all of the namespace ... */Element eparent// if no ns support is passed-in, use the one for <schema> element// backup the current ns support, and use the one passed-in.// some Object methods// can't access components from the given namespace// store whether we have reported an error about that this document// return the attributes on the schema element itself:// deallocate the storage set aside for the schema element's// adds an annotation to the list of annotationsinfo.next// schema document or null if the document contained no annotations.// returns the list of annotations conatined in the// removes reference to annotation list// schemaAttrs == null means it's not an <xsd:schema> element// throw an exception, but we don't know the document systemId,// so we leave that to the caller.//set namespace support// pass null as the schema document, so that the namespace// context is not popped.// don't return the attribute array yet!//attrChecker.returnAttrArray(schemaAttrs, null);// Check if attribute is an ns decl -- requires ns support// Declare prefix if not set -- moving upwards// XSDocumentInfo/** Contains a list of LSInputs. ... */new LSInputListImpl(...)new LSInput[]LSInputListImpl EMPTY_LIST;/** An immutable empty list. */...[] fArray;// The array to hold all data// Number of elements in this list/** Construct an LSInputList implementation ... *//** The number of <code>LSInput</code>s in the list. The range of valid ... */// LSInputListImpl/** Contains a list of Objects. ... */ObjectListImpl EMPTY_LIST;/** Containts a list of Object's. ... */ShortListImpl EMPTY_LIST;/** Construct an XSObjectList implementation ... *//** The number of <code>Objects</code> in the list. The range of valid ... *//** Checks if the <code>unsigned short</code> <code>item</code> is a ... */ShortList rhs// class ShortListImpl/** An XMLLocator implementation used for schema error reporting. ... */String lsid, ...;int line, ...;this.lsidthis.esidStringListImpl EMPTY_LIST;Vector<> fVector;//          instead of the Vector.// REVISIT: this is temp solution. In general we need to use this class/** Checks if the <code>GenericString</code> <code>item</code> is a member ... */// class StringListImplint fValue;this.fValuecompareVal.fValuenew XInt[]new XInt(...)short POOL_SIZE;...[] fXIntPool;fXIntPool.lengthimport XSModelImpl/** Add a method that return an <code>XSModel</code> that represents components in ... *//** Return an <code>XSModel</code> that represents components in ... */fGrammars.lengthEntry entryentry.nextentry.descentry.grammar// class XSGrammarPool/** Containts the map between qnames and XSObject's. ... */// the type of component stored here: complex or simple type/** Construct an XSNamedMap implementation for one namespace ... *//** Construct an XSNamedMap implementation for a list of namespaces ... *//** The number of <code>XSObjects</code> in the <code>XSObjectList</code>. The ... */XSObject[] array/** Retrieves an <code>XSObject</code> specified by local name and namespace ... *//** Returns the <code>index</code>th item in the map. The index starts at ... */// first get the number of components for all types// then copy all types to an temporary array// then copy either simple or complex types to fArray,// depending on which kind is required// only return it if it matches the required type// class XSNamedMapImplXSNamedMapImpl EMPTY_MAP;/** An immutable empty map. */// components of these namespaces are stored in this mapint fNSNum;// number of namespaces...[] fMaps;// each entry contains components in one namespace// used when this map is accessed as a list.// store all components from all namespace.// store the number of components.Set<> fEntrySet;// Set of Map.Entry<QName,XSObject> for the java.util.Map methods/** Construct an XSNamedMap implementation one namespace from an array ... *//** The number of <code>XSObjects</code> in the <code>XSObjectList</code>. ... *//** Retrieves an <code>XSObject</code> specified by local name and ... */XSObject ret/* java.util.Map methods */String namespaceURIString localPartXMLConstants.NULL_NS_URIitemByName(...)XSNamedMapEntry[] entriesnew XSNamedMapEntry[]XSObject xsonew XSNamedMapEntry(...)XSNamedMapImpl$1XSNamedMapImpl$1$1XSNamedMapImpl$XSNamedMapEntry/** An entry in the XSNamedMap. * */QName key;XSObject value;Entry<> eObject otherKeyObject otherValue// because all components are from the same target namesapce,// get the namespace from the first one.// copy elements to the Vector// when this map is created from SymbolHash's// get the component from SymbolHash// Otherwise (it's created from an array)// go through the array to find a matching name// calculate the total number of elements// get components from all SymbolHashes// Defer creation of the entry set until it is actually needed.// Create a view of this immutable map./** Containts a list of XSObject's. ... */new ListIterator<>(...) { ... }XSObjectListImpl$1XSObjectListImpl EMPTY_LIST;ListIterator<> EMPTY_ITERATOR;int DEFAULT_SIZE;/** The number of <code>XSObjects</code> in the list. The range of valid ... */// clear this objectfArray.lengthXSObject[] tempcontainsNull(...)containsObject(...)new XSObjectListIterator(...)XSObjectListImpl$XSObjectListIterator// class XSObjectListImplimport SAXMessageFormatterint ERROR_COUNT_LIMIT;int errorCount;// XXX Fix message i18n// Ignore all errors after reaching the limit// Print a warning before the first errorimport SchemaMap<String,Object> attributes;/** These are DocumentBuilderFactory attributes not DOM attributes */Map<String,Boolean> features;Schema grammar;boolean isXIncludeAware;boolean fSecureProcess;/** State of the secure processing feature, initially <code>false</code> *//** Creates a new instance of a {@link javax.xml.parsers.DocumentBuilder} ... */JAXPConstants.JAXP_SCHEMA_LANGUAGEnew ParserConfigurationException(...)JAXPConstants.JAXP_SCHEMA_SOURCEnew DocumentBuilderImpl(...)/** Allows the user to set specific attributes on the underlying ... *//** Allows the user to retrieve specific attributes on the underlying ... */DOMParser domParserSAXException se1SAXException se2this.grammarthis.isXIncludeAwarenew HashMap<String,Boolean>(...)/** Check that if a Schema has been specified that neither of the schema properties have been set. */// Handles both SAXNotSupportedException, SAXNotRecognizedException// This handles removal of attributes// Unrecognized attributes do not cause an exception// This is ugly.  We have to collect the attributes and then// later create a DocumentBuilderImpl to verify the attributes.// Create the Map if none existed before// Test the attribute name by possibly throwing an exception// See if it's in the attributes Map// We create a dummy DocumentBuilderImpl in case the attribute// name is not one that is in the attributes map.// assert(name is not recognized or not supported), try feature// Must have been a feature// Not a property or a feature// See if it's in the features map// If this is the secure processing feature, save it then return.// Test the feature by possibly throwing SAX exceptionsimport DOMImplementationImplimport XMLSchemaValidatorimport XSGrammarPoolContainerConstants.INCLUDE_IGNORABLE_WHITESPACEConstants.CREATE_ENTITY_REF_NODES_FEATUREConstants.INCLUDE_COMMENTS_FEATUREConstants.CREATE_CDATA_NODES_FEATUREConstants.XINCLUDE_FEATURE/** Feature identifier: include ignorable white space. *//** Feature identifier: create entiry ref nodes feature. *//** Feature identifier: include comments feature. *//** Feature identifier: create cdata nodes feature. *//** Feature identifier: XInclude processing */String XMLSCHEMA_VALIDATION_FEATURE;/** Feature identifier: validation *//** property identifier: access external dtd. */DOMParser domParser;XMLComponent fSchemaValidator;XMLComponentManager fSchemaValidatorComponentManager;ValidationManager fSchemaValidationManager;UnparsedEntityHandler fUnparsedEntityHandler;ErrorHandler fInitErrorHandler;/** Initial ErrorHandler */EntityResolver fInitEntityResolver;/** Initial EntityResolver */isValidating(...)new DefaultValidationErrorHandler(...)getXMLParserConfiguration(...)isNamespaceAware(...)isIgnoringElementContentWhitespace(...)isExpandEntityReferences(...)isIgnoringComments(...)isCoalescing(...)isXIncludeAware(...)Boolean tempConstants.IS_JDK8_OR_ABOVEConstants.EXTERNAL_ACCESS_DEFAULT_FSPProperty.ACCESS_EXTERNAL_SCHEMAgetSchema(...)XMLParserConfiguration configXMLComponent validatorComponentnew XMLSchemaValidator(...)new UnparsedEntityHandler(...)new SchemaValidatorConfiguration(...)new JAXPValidatorComponent(...)newValidatorHandler(...)setFeatures(...)setDocumentBuilderFactoryAttributes(...)Entry<String,Boolean> entryMap<>.Entry<String,Boolean>/** Set any DocumentBuilderFactory attributes of our underlying DOMParser ... *//** Non-preferred: use the getDOMImplementation() method instead of this ... */resetSchemaValidator(...)SAXException x/** Gets the XInclude processing mode for this parser ... */// package private// If validating, provide a default ErrorHandler that prints// validation errors with a warning telling the user to set an// ErrorHandler// "namespaceAware" == SAX Namespaces feature// Set various parameters obtained from DocumentBuilderFactory// Avoid setting the XInclude processing feature if the value is false.// This will keep the configuration from throwing an exception if it// does not support XInclude./** If secure processing is explicitly set on the factory, the ... *//** For Xerces grammars, use built-in schema validator. * *//** For third party grammars, use the JAXP validator component. * */// Must set before calling setDocumentHandler()//setAttribute override those that may be set by other means// Initial EntityResolver// Assume feature// Assume property// JAXP 1.2 support//None of the properties will take effect till the setValidating(true) has been called// this should allow us not to emit DTD errors, as expected by the// spec when schema validation is enabled/** Restore the initial error handler. * *//** Restore the initial entity resolver. * */// This should never be thrown from the schema validator./** This interface holds JAXP constant property/attribute names and values. ... */String W3C_XML_SCHEMA;import TypeInfoProviderimport ValidatorHandlerimport DOMInputImplimport DefaultXMLDocumentHandlerimport AttributesProxyimport LocatorProxy/** Runs events through a {@link javax.xml.validation.ValidatorHandler} ... */new XNI2SAX(...)new SAX2XNI(...)new TypeInfoProvider(...) { ... }JAXPValidatorComponent$3ValidatorHandler validator;// pipeline partsXNI2SAX xni2sax;SAX2XNI sax2xni;TypeInfoProvider typeInfoProvider;// never be nullAugmentations fCurrentAug;/** Used to store the {@link Augmentations} associated with the ... */XMLAttributes fCurrentAttributes;/** {@link XMLAttributes} version of {@link #fCurrentAug}. */// components obtained from a manager / propertyTypeInfoProvider tipgetTypeInfoProvider(...)this.validatorthis.typeInfoProvidersetSide(...)JAXPValidatorComponent$1XMLErrorHandler handlernew ErrorHandlerWrapper(...)setResourceResolver(...)new LSResourceResolver(...) { ... }JAXPValidatorComponent$2LSInput disetBaseURI(...)setByteStream(...)JAXPValidatorComponent$SAX2XNI/** Uses {@link DefaultHandler} as a default implementation of ... */Augmentations fAugmentations;/** {@link Augmentations} to send along with events. ... *//** {@link QName} to send along events. ... */handler(...)aug(...)toSAXException(...)updateAttributes(...)toQName(...)elementAug(...)Augmentations aug/** Gets the {@link Augmentations} that should be associated with ... */Augmentations r/** Get the handler to which we should send events. */JAXPValidatorComponent.this/** Converts the {@link XNIException} received from a downstream ... *//** Creates a proper {@link QName} object from 3 parts. ... */symbolize(...)JAXPValidatorComponent$XNI2SAX/** Converts {@link XNI} events to {@link ContentHandler} events. ... */new AttributesProxy(...)ContentHandler fContentHandler;/** Namespace context */AttributesProxy fAttributesProxy;/** For efficiency, we reuse one instance. */this.fContentHandlerthis.fVersionnew LocatorProxy(...)JAXPValidatorComponent$DraconianErrorHandlernew DraconianErrorHandler(...)DraconianErrorHandler ERROR_HANDLER_INSTANCE;/** Returns the one and only instance of this error handler. *//** Warning: Ignore. *//** Error: Throws back SAXParseException. *//** Fatal Error: Throws back SAXParseException. *//** Compares the given {@link Attributes} with {@link #fCurrentAttributes} ... */// DraconianErrorHandlerString aqnString avTypeInfoProvider noInfoProvider;/** {@link TypeInfoProvider} that returns no info. */// no property/feature supported// XMLComponent implementation.// configure wiring between internal components.// configure validator with proper EntityResolver/ErrorHandler.// erors thrown by the callback is not supposed to be// reported to users.// mostly to make it easy to find any bug.// since a validator may change the contents,// let this one go through a validator// obtain references from the manager/** aug.putItem(Constants.TYPEINFO,typeInfoProvider.getElementTypeInfo()); * */// we "consumed" this augmentation.// notify handlers// start namespace prefix mappings// send endPrefixMapping events// newly added attribute. add to the current attribute list.// the attribute is present.// but the value was changed./** Augmentations augs = fCurrentAttributes.getAugmentations(j); ... *//** This is the implementation specific class for the ... *//** Creates a new instance of <code>SAXParser</code> using the currently ... */SAXParser saxParserImplnew SAXParserImpl(...)/** Common code for translating exceptions */SAXParserImpl saxParserImpl/** Sets the particular feature in the underlying implementation of ... */putInFeatures(...)newSAXParserImpl(...)/** returns the particular property requested for in the underlying ... */getFromFeatures(...)// Translate to ParserConfigurationException// XXX This is ugly.  We have to collect the features and then// later create an XMLReader to verify the features.// Check for valid name by creating a dummy XMLReader to get// feature valueimport PSVIProviderimport HandlerBase/** Feature identifier: XML Schema validation */JAXPSAXParser xmlReader;String schemaLanguage;// null means DTD/** Create a SAX parser with the associated features ... */new JAXPSAXParser(...)setFeature0(...)setProperty0(...)XMLSecurityPropertyManager.State.FSP/** Set any features of our XMLReader based on any features set on the ... *//** Returns the XMLReader that is encapsulated by the implementation of ... *//** Sets the particular property in the underlying implementation of ... */restoreInitState(...)/* PSVIProvider methods */getElementPSVI(...)getAttributePSVI(...)getAttributePSVIByName(...)SAXParserImpl$JAXPSAXParser/** Extension of SAXParser. This class tracks changes to ... */HashMap<> fInitFeatures;HashMap<> fInitProperties;SAXParserImpl fSAXParser;/** Override SAXParser's setFeature method to track the initial state ... */SAXNotSupportedException excboolean currentfSAXParser.fSchemaValidatorsetSchemaValidatorFeature(...)/** Override SAXParser's setProperty method to track the initial state ... */fSAXParser.grammarfSAXParser.schemaLanguagesetSchemaValidatorProperty(...)fSAXParser.fSchemaValidationManagerfSAXParser.fUnparsedEntityHandlerString identifiernew SAXNotRecognizedException(...)fSAXParser.fSchemaValidatorComponentManager/* Copyright (c) 2010, 2017, Oracle and/or its affiliates. All rights reserved. */// Instantiate a SAXParser directly and not through SAX so that we use the right ClassLoader// JAXP "namespaceAware" == SAX Namespaces feature// Note: there is a compatibility problem here with default values:// JAXP default is false while SAX 2 default is true!// SAX "namespaces" and "namespace-prefixes" features should not// both be false.  We make them opposite for backward compatibility// since JAXP 1.0 apps may want to receive xmlns* attributes./** By default, secure processing is set, no external access is allowed. ... */// Set application's features, followed by validation features.// ErrorHandler.// Get the Schema object from the factory// Xerces2 AbstractSAXParser implements SAX1 Parser// assert(xmlReader instanceof Parser);/** Restore initial values of features and properties. * */// This should never happen. We only store recognized// features and properties in the hash maps. For now// just ignore it./** Restore various handlers. * *//** This class may be used directly. So initialize the security manager if ... */// TODO: Add localized error message.// If the property is not supported// re-throw the exception if the value is true./** Forward feature to the schema validator if there is one. * */// The spec says if a schema is given via SAXParserFactory// the JAXP 1.2 properties shouldn't be allowed.// this will allow the parser not to emit DTD-related// errors, as the spec demands// REVISIT: It would be nice if we could format this message// using a user specified locale as we do in the underlying// XMLReader -- mrglavas/** Forward property to the schema validator if there is one. * *//** <p>Parser configuration for Xerces' XMLSchemaValidator.</p> ... *//** Feature identifier: schema validation. *//** Feature identifier: use grammar pool only. *//** Feature identifier: parser settings. *//** Property identifier: validation manager. */XMLComponentManager fParentComponentManager;/** Parent component manager. * *//** The Schema's grammar pool. * *//** Tracks whether the validator should use components from ... *//** Validation manager. */getGrammarPool(...)isFullyComposed(...)XMLErrorReporter errorReporterXMLConfigurationException excFeatureState stateisExceptional(...)state.statusstate.statePropertyState state// add schema message formatter to error reporter// Ignore exception./** <p>XMLDocumentHandler which forks the pipeline to two other components.</p> ... */XMLDocumentHandler next;/** The next component in the pipeline who receives the event. ... */XMLDocumentHandler side;/** The component who intercepts events. */XMLDocumentSource source;/** The source of the event. */this.side//  XMLDocumentHandler implementation/** <p>This filter records which unparsed entities have been ... *//** DTD source and handler. * */HashMap<> fUnparsedEntities;/** Map for tracking unparsed entities. *//* XMLDTDHandler methods *//* XMLDTDSource methods *//* EntityState methods */// should only clear this if the last document contained unparsed entitiesimport GregorianCalendar/** <p>Factory that creates new <code>javax.xml.datatype</code> <code>Object</code>s that map XML to/from Java <code>Object</code>s.</p> ... *//** <p>Public constructor is empty..</p> ... *//** <p>Obtain a new instance of a <code>Duration</code> ... */new DurationImpl(...)/** <p>Create a <code>Duration</code> of type <code>xdt:yearMonthDuration</code> using the specified ... */new DurationYearMonthImpl(...)/** <p>Create a <code>Duration</code> of type <code>xdt:yearMonthDuration</code> by parsing its <code>String</code> representation, ... *//** <p>Create a <code>Duration</code> of type <code>xdt:yearMonthDuration</code> using the specified milliseconds as defined in ... *//** <p>Create a <code>Duration</code> of type <code>xdt:dayTimeDuration</code> by parsing its <code>String</code> representation, ... */new DurationDayTimeImpl(...)/** <p>Create a <code>Duration</code> of type <code>xdt:dayTimeDuration</code> using the specified milliseconds as defined in ... *//** <p>Create a <code>Duration</code> of type <code>xdt:dayTimeDuration</code> using the specified ... *//** <p>Create a new instance of an <code>XMLGregorianCalendar</code>.</p> ... */new XMLGregorianCalendarImpl(...)/** <p>Create a new XMLGregorianCalendar by parsing the String as a lexical representation.</p> ... *//** <p>Create an <code>XMLGregorianCalendar</code> from a {@link GregorianCalendar}.</p> ... *//** <p>Constructor allowing for complete value spaces allowed by ... */// lexicalRepresentation must be non-null/** <p>Represent a subtype <code>xdt:dayTimeDuration</code> of a <code>Duration</code> ... */convertToCanonicalDayTime(...)/** <p>Construct a <code>Duration</code> of type <code>xdt:dayTimeDuration</code> by parsing its <code>String</code> representation, ... */getYears(...)getMonths(...)/** The value space of xs:dayTimeDuration is the set of fractional second values. ... */float secgetMinutes(...)getHours(...)getDays(...)getSeconds(...)subtract(...)BigInteger.ONE/* ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms. *//* Copyright (c) 2009 by Oracle Corporation. All Rights Reserved. */// only day, hour, minute, and second should have valuesimport RoundingModeimport DatatypeMessageFormatter/** <p>Immutable representation of a time span as defined in ... */DatatypeConstants.FieldDatatypeConstants.YEARSDatatypeConstants.MONTHSDatatypeConstants.DAYSDatatypeConstants.HOURSDatatypeConstants.MINUTESDatatypeConstants.SECONDSnew XMLGregorianCalendar[]new BigDecimal[]int FIELD_NUM;/** <p>Number of Fields.</p> */...[] FIELDS;/** <p>Internal array of value Fields.</p> */...[] FIELD_IDS;/** <p>Internal array of value Field ids.</p> */TimeZone GMT;/** TimeZone for GMT. */BigDecimal ZERO;/** <p>BigDecimal value of 0.</p> */int signum;/** <p>Indicates the sign. -1, 0 or 1 if the duration is negative, ... */BigInteger years;/** These were final since Duration is immutable. But new subclasses need ... *//** <p>Years of this <code>Duration</code>.</p> */BigInteger months;/** <p>Months of this <code>Duration</code>.</p> */BigInteger days;/** <p>Days of this <code>Duration</code>.</p> */BigInteger hours;/** <p>Hours of this <code>Duration</code>.</p> */BigInteger minutes;/** <p>Minutes of this <code>Duration</code>.</p> */BigDecimal seconds;/** <p>Seconds of this <code>Duration</code>.</p> *//** Returns the sign of this duration in -1,0, or 1. ... *//** TODO: Javadoc ... *//** <p>Constructs a new Duration object by specifying each field individually.</p> ... */this.yearsthis.monthsthis.daysthis.hoursthis.minutesthis.secondsthis.signumcalcSignum(...)testNonNegative(...)/** <p>Makes sure that the given number is non-negative. If it is not, ... *//** <p>Constructs a new Duration object by specifying each field ... *//** <p>Constructs a new Duration object by specifying the duration ... */GregorianCalendar gregorianCalendarnew GregorianCalendar(...)long int2longsetTimeInMillis(...)Calendar.MILLISECOND/** Constructs a new Duration object by ... */int[] idxboolean timeRequiredint dateLenString[] datePartsint[] datePartsIndexint timeLenString[] timePartsint[] timePartsIndexparsePiece(...)isDigitOrPeriod(...)organizeParts(...)parseBigInteger(...)parseBigDecimal(...)/** TODO: Javadoc. ... */...[] TEST_POINTS;/** <p>Four constants defined for the comparison of durations.</p> *//** <p>Partial order relation comparison with this <code>Duration</code> instance.</p> ... */BigInteger maxintAsBigIntegerBigInteger minintAsBigIntegerBigInteger rhsYearsBigInteger rhsMonthsBigInteger rhsDaysBigInteger rhsHoursBigInteger rhsMinutesBigDecimal rhsSecondsAsBigDecimalBigInteger rhsSecondsGregorianCalendar lhsCalendarGregorianCalendar rhsCalendartoBigInteger(...)GregorianCalendar.YEARgetSign(...)GregorianCalendar.MONTHGregorianCalendar.DAY_OF_YEARGregorianCalendar.HOUR_OF_DAYGregorianCalendar.MINUTEGregorianCalendar.SECONDDatatypeConstants.EQUALint resultADatatypeConstants.INDETERMINATEint resultBXMLGregorianCalendar tempAXMLGregorianCalendar tempB/** Returns a hash code consistent with the definition of the equals method. ... */toGregorianCalendar(...)addTo(...)getCalendarTimeInMillis(...)/** Returns a string representation of this duration object. ... *//** <p>Turns {@link BigDecimal} to a string representation.</p> ... */String intStringint insertionPoint/** Checks if a field is set. ... *//** Gets the value of a field. ... *//** Obtains the value of the YEARS field as an integer value, ... *//** Obtains the value of the MONTHS field as an integer value, ... *//** Obtains the value of the DAYS field as an integer value, ... *//** Obtains the value of the HOURS field as an integer value, ... *//** Obtains the value of the MINUTES field as an integer value, ... *//** Obtains the value of the SECONDS field as an integer value, ... *//** <p>Return the requested field value as an int.</p> ... */Number n/** <p>Returns the length of the duration in milli-seconds.</p> ... *//** <p>Converts the years and months fields into the days field ... *///        return null;//    public Duration normalize() {//     *///     *      always return a non-null valid value.//     * @return//     *//     * </ul>//     *  <li>!x.normalize().isSet(Duration.MINUTES)//     *  <li>!x.normalize().isSet(Duration.HOURS)//     *  <li>!x.normalize().isSet(Duration.DAYS)//     *  <li>!x.normalize().isSet(Duration.YEARS)//     *  <li>x.normalize().equals(x)//     * <ul>//     * Formally, this method satisfies the following conditions://     * into SECONDS (by x86400, x3600, and x60 respectively.)//     * MONTHS (by x12) and moves DAYS, HOURS, and MINUTES fields//     * Intuitively, the normalization moves YEARS into//     * Returns an equivalent but "normalized" duration value.//    /**Calendar clong diff/** <p>Computes a new duration whose value is <code>factor</code> times ... */multiply(...)/** Computes a new duration whose value is <code>factor</code> times ... */BigDecimal carryint factorSignBigDecimal[] bufBigDecimal bdgetFieldAsBigDecimal(...)setScale(...)RoundingMode.DOWN/** <p>Gets the value of the field as a {@link BigDecimal}.</p> ... */BigInteger bi/** <p>BigInteger value of BigDecimal value.</p> ... */...[] FACTORS;/** 1 unit of FIELDS[i] is equivalent to <code>FACTORS[i]</code> unit of ... *//** <p>Computes a new duration whose value is <code>this+rhs</code>.</p> ... */Duration lhssanitize(...)alignSigns(...)boolean touchedBigDecimal borrowdivide(...)RoundingMode.UP/** Compute <code>value*signum</code> where value==null is treated as ... *//** <p>Compute <code>value*signum</code> where <code>value==null</code> is treated as <code>value==0</code></p>. ... *//** <p>Computes a new duration whose value is <code>this-rhs</code>.</p> ... *//** Returns a new {@link Duration} object whose ... *//** Adds this duration to a {@link Calendar} object. ... */Calendar.HOURBigDecimal fractionint millisecmovePointRight(...)/** Adds this duration to a {@link Date} object. ... *//** <p>Stream Unique Identifier.</p> ... *//** Writes {@link Duration} as a lexical representation ... */new DurationStream(...)DurationImpl$DurationStream/** Representation of {@link Duration} in the object stream. ... */String lexical;this.lexical/** Calls the {@link Calendar#getTimeInMillis} method. ... */// sanity check//"all the fields are null"// field may not be set// int -> BigInteger// negating 0x8000000000000000L causes an overflow// let GregorianCalendar do the heavy lifting// duration is the offset from the Epoch// now find out how much each field has changed// years// months// days// hours// minutes// seconds & milliseconds// only if I could use the JDK1.4 regular expression ....//,idx[0]-1);// phase 1: chop the string into chunks// (where a chunk is '<number><a symbol>'//--------------------------------------// ,idx[0]-1);// ,idx[0]);// phase 2: check the ordering of chunks// parse into numbers// ,partsIndex[i]+parts[i].length()-1);//        try {//        } catch( NumberFormatException e ) {//            throw new ParseException( whole, index );// NumberFormatException is IllegalArgumentException// check for fields that are too large in this Duration//this.getClass().getName() + "#compare(Duration duration)"//+ " years too large to be supported by this implementation "//+ years.toString()//+ " months too large to be supported by this implementation "//+ months.toString()//+ " days too large to be supported by this implementation "//+ days.toString()//+ " hours too large to be supported by this implementation "//+ hours.toString()//+ " minutes too large to be supported by this implementation "//+ minutes.toString()//+ " seconds too large to be supported by this implementation "//+ seconds.toString()// check for fields that are too large in rhs Duration//+ rhsYears.toString()//+ rhsMonths.toString()//+ rhsDays.toString()//+ rhsHours.toString()//+ rhsMinutes.toString()//+ rhsSeconds.toString()// turn this Duration into a GregorianCalendar// turn compare Duration into a GregorianCalendar// component wise hash is not correct because 1day = 24hours/* Insert decimal point *//* Point goes right before intVal *//* Point goes inside intVal *//* We must insert zeros between point and intVal *///"cannot be called with field == null"/** throw new IllegalArgumentException( ... */// using int may cause overflow, but// Calendar internally treats value as int anyways.// obtain the difference in terms of days// illegal carry-down/* undefined */// align sign// Y,M// D,h,m,s// make sure that the sign bit is consistent across all 6 fields.// repeat until all the sign bits become consistent// sign of the left fields// this field has different sign than its left field.// compute the number of unit that needs to be borrowed.// update values// this will throw NPE if date==null//            } catch( ParseException e ) {//                throw new StreamCorruptedException("unable to parse "+lexical+" as duration");/** <p>Represent a subtype <code>xdt:yearMonthDuration</code> of a <code>Duration</code> ... */convertToCanonicalYearMonth(...)/** <p>Construct a <code>Duration</code> of type <code>xdt:yearMonthDuration</code> using the specified ... *//** <p>Construct a <code>Duration</code> of type <code>xdt:yearMonthDuration</code> using the specified milliseconds as defined in ... *//** <p>Construct a <code>Duration</code> of type <code>xdt:yearMonthDuration</code> by parsing its <code>String</code> representation, ... *//** The value space of xs:yearMonthDuration is the set of xs:integer month values. ... *///Any remaining milliseconds after determining the year and month are discarded./** <p>Representation for W3C XML Schema 1.0 date/time datatypes. ... */Long.MIN_VALUEcreateDateTime(...)DatatypeConstants.JANUARYBigInteger eon;/** <p>Eon of this <code>XMLGregorianCalendar</code>.</p> */int year;/** <p>Year of this <code>XMLGregorianCalendar</code>.</p> */int month;/** <p>Month of this <code>XMLGregorianCalendar</code>.</p> */int day;/** <p>Day of this <code>XMLGregorianCalendar</code>.</p> */int timezone;/** <p>Timezone of this <code>XMLGregorianCalendar</code> in minutes.</p> */int hour;/** <p>Hour of this <code>XMLGregorianCalendar</code>.</p> */int minute;/** <p>Minute of this <code>XMLGregorianCalendar</code>.</p> */int second;/** <p>Second of this <code>XMLGregorianCalendar</code>.</p> */BigDecimal fractionalSecond;/** <p>Fractional second of this <code>XMLGregorianCalendar</code>.</p> */BigInteger BILLION;/** <p>Constant to represent a billion.</p> */Date PURE_GREGORIAN_CHANGE;/** <p>Obtain a pure Gregorian Calendar by calling ... *//** Year index for MIN_ and MAX_FIELD_VALUES. *//** Month index for MIN_ and MAX_FIELD_VALUES. *//** Day index for MIN_ and MAX_FIELD_VALUES. */int HOUR;/** Hour index for MIN_ and MAX_FIELD_VALUES. */int MINUTE;/** Minute index for MIN_ and MAX_FIELD_VALUES. */int SECOND;/** Second index for MIN_ and MAX_FIELD_VALUES. */int MILLISECOND;int TIMEZONE;/** Timezone index for MIN_ and MAX_FIELD_VALUES */...[] FIELD_NAME;/** field names indexed by YEAR..TIMEZONE. */XMLGregorianCalendar LEAP_YEAR_DEFAULT;/** <p>Use as a template for default field values when ... *//** Constructs a new XMLGregorianCalendar object. ... */String lexRepint NOT_FOUNDint lexRepLengthParser pint countSeparatorint timezoneOffset/** <p>Create an instance with all date/time datatype fields set to ... *//** <p>Private constructor allowing for complete value spaces allowed by ... */setYear(...)setMonth(...)setDay(...)setTimezone(...)/** <p>Private constructor of value spaces that a ... */setMillisecond(...)/** <p>Convert a <code>java.util.GregorianCalendar</code> to XML Schema 1.0 ... */int year1int offsetInMinutesGregorianCalendar.BCCalendar.ERA/** <p>Create a Java representation of XML Schema builtin datatype <code>dateTime</code>. ... */// Factories/** <p>Create a Java instance of XML Schema builtin datatype dateTime.</p> ... *//** <p>Create a Java representation of XML Schema builtin datatype <code>date</code> or <code>g*</code>.</p> ... *//** Create a Java instance of XML Schema builtin datatype <code>time</code>. ... *//** <p>Create a Java instance of XML Schema builtin datatype time.</p> ... *//** <p>Return high order component for XML Schema 1.0 dateTime datatype field for ... *//** <p>Return low order component for XML Schema 1.0 dateTime datatype field for ... *//** <p>Return XML Schema 1.0 dateTime datatype field for ... *//** <p>Return number of month or {@link DatatypeConstants#FIELD_UNDEFINED}.</p> ... *//** Return day in month or {@link DatatypeConstants#FIELD_UNDEFINED}.</p> ... *//** Return timezone offset in minutes or ... *//** Return hours or {@link DatatypeConstants#FIELD_UNDEFINED}. ... *//** Return minutes or {@link DatatypeConstants#FIELD_UNDEFINED}.<\p> ... *//** <p>Return seconds or {@link DatatypeConstants#FIELD_UNDEFINED}.<\p> ... *//** <p>Return millisecond precision of {@link #getFractionalSecond()}.<\p> ... *//** <p>Return fractional seconds.</p> ... *//** <p>Set low and high order component of XSD <code>dateTime</code> year field.</p> ... */// settersthis.eonBigInteger tempremainder(...)setEon(...)/** <p>Set year of XSD <code>dateTime</code> year field.</p> ... */BigInteger theYearBigInteger remainder/** <p>Set high order part of XSD <code>dateTime</code> year field.</p> ... *//** <p>Set month.</p> ... */DatatypeConstants.DECEMBERinvalidFieldValue(...)/** <p>Set days in month.</p> ... *//** <p>Set the number of minutes in the timezone offset.</p> ... */this.timezone/** <p>Set time as one unit.</p> ... */getHour(...)getMinute(...)setHour(...)testHour(...)/** <p>Set time as one unit, including the optional infinite precison ... */setMinute(...)setSecond(...)setFractionalSecond(...)/** <p>Set time as one unit, including optional milliseconds.</p> ... *//** <p>Compare two instances of W3C XML Schema 1.0 date/time datatypes ... */// comparisonsXMLGregorianCalendar lhsXMLGregorianCalendarImpl PXMLGregorianCalendarImpl QgetTimezone(...)internalCompare(...)XMLGregorianCalendar MinQnormalizeToTimezone(...)DatatypeConstants.MIN_TIMEZONE_OFFSETXMLGregorianCalendar MaxQDatatypeConstants.MAX_TIMEZONE_OFFSETDatatypeConstants.LESSERDatatypeConstants.GREATERXMLGregorianCalendar MaxPXMLGregorianCalendar MinP/** <p>Normalize this instance to UTC.</p> ... */XMLGregorianCalendar normalizedgetMillisecond(...)XMLGregorianCalendar resultDuration d/** <p>Implements Step B from http://www.w3.org/TR/xmlschema-2/#dateTime-order </p> ... */getEon(...)compareField(...)getYear(...)getEonAndYear(...)getMonth(...)getDay(...)getFractionalSecond(...)/** <p>Implement Step B from ... *//** <p>Indicates whether parameter <code>obj</code> is "equal to" this one.</p> ... *//** <p>Returns a hash code consistent with the definition of the equals method.</p> ... */int timezoneXMLGregorianCalendar gc/** <p>Constructs a new XMLGregorianCalendar object by ... *//** <p>Return the lexical representation of <code>this</code> instance. ... */QName typekindgetXMLSchemaType(...)String formatStringDatatypeConstants.DATETIMEDatatypeConstants.DATEDatatypeConstants.TIMEDatatypeConstants.GMONTHDatatypeConstants.GDAYDatatypeConstants.GYEARDatatypeConstants.GYEARMONTHDatatypeConstants.GMONTHDAY/** <p>Return the name of the XML Schema date/time type that this instance ... *//** Validate instance by <code>getXMLSchemaType()</code> constraints. ... */DatatypeConstants.FEBRUARYint maxDaysmaximumDayInMonthFor(...)BigInteger yearsBigInteger yearField/** <p>Add <code>duration</code> to this instance.<\p> ... */boolean[] fieldUndefinedint signumint startMonthBigInteger dMonthsBigInteger carryRoundingMode.FLOORBigInteger startYearBigInteger dYearsBigInteger endYearBigDecimal startSecondsBigDecimal dSecondsBigDecimal tempBDBigDecimal fQuotientBigDecimal endSecondsBigDecimal tempFracSecondsint startMinutesBigInteger dMinutesint startHoursBigInteger dHoursBigInteger tempDaysint startDayBigInteger dDaysint maxDayInMonthBigInteger endDaysint monthCarryint intTempint endMonthint quotientBigInteger mdimfBigInteger FOUR;BigInteger HUNDRED;BigInteger FOUR_HUNDRED;BigInteger SIXTY;BigInteger TWENTY_FOUR;BigInteger TWELVE;BigDecimal DECIMAL_ZERO;BigDecimal DECIMAL_ONE;BigDecimal DECIMAL_TWELVE;BigDecimal DECIMAL_TWENTY_FOUR;BigDecimal DECIMAL_SIXTY;...[] daysInMonth;/** <p>Convert <code>this</code> to <code>java.util.GregorianCalendar</code>.</p> ... */GregorianCalendar resultint DEFAULT_TIMEZONE_OFFSETTimeZone tzgetDefaultLocale(...)BigInteger yearsetGregorianChange(...)GregorianCalendar.ADString langString countryString variant/** <p>Convert <code>this</code> along with provided parameters ... */int defaultZoneoffsetBigInteger defaultYearint defaultMonthint defaultDayint defaultHourint defaultMinuteint defaultSecondBigDecimal defaultFractionalSecond/** <p>Returns a <code>java.util.TimeZone</code> for this class.</p> ... */TimeZone resultint zoneoffsetchar signint hourStringBuffer customTimezoneId/** <p>Creates and returns a copy of this object.</p> ... */this.fractionalSecond/** <p>Unset all fields to undefined.</p> ... */XMLGregorianCalendarImpl$ParserString format;int flen;int vlen;int fidx;int vidx;this.formatthis.flenthis.vlen/** <p>Parse a formated <code>String</code> into an <code>XMLGregorianCalendar</code>.</p> ... */char fchchar vchparseAndSetYear(...)int vstartboolean neg/** Prints this object according to the format specification. ... */int bufPtrint fidxprint4Number(...)char[] nprint2Number(...)String fracString zeros/** Prints an int as two digits into the buffer. ... *//** Prints an int as four digits into the buffer. ... *//** <p><code>reset()</code> is designed to allow the reuse of existing ... *//* Copyright (c) 2004, 2018, Oracle and/or its affiliates. All rights reserved. ... *///year//month// day// hour// minute// second// milliseconds// timezone// compute format string for this lexical representation.// current parser needs a format string,// use following heuristics to figure out what xml schema date/time// datatype this lexical string could represent.// Fix 4971612: invalid SCCS macro substitution in data string,//   no %{alpha}% to avoid SCCS maco substitution// found Date Time separater, must be xsd:DateTime// found ":", must be xsd:Time// check for gDay || gMonth || gMonthDay// gDay, ---DD(z?)// --MM// --MMZ// --MMSHH:MM// gMonth, --MM(z?),// per XML Schema Errata, used to be --MM--(z?)// gMonthDay, --MM-DD(z?), (or invalid lexicalRepresentation)// length should be://  7: --MM-DD//  8: --MM-DDZ// 13: --MM-DDSHH:MM// check for Date || GYear | GYearMonth// start at index 1 to skip potential negative sign for year.// found timezone, strip it off for distinguishing// between Date, GYear and GYearMonth so possible// negative sign in timezone is not mistaken as// a separator.// GYear// GYearMonth// Date or invalid lexicalRepresentation// Fix 4971612: invalid SCCS macro substitution in data string// check for validity//"\"" + lexicalRepresentation + "\" is not a valid representation of an XML Gregorian Calendar value."// field initializers already do the correct initialization.// Calendar.MONTH is zero based, XSD Date datatype's month field starts// with JANUARY as 1.// Calendar ZONE_OFFSET and DST_OFFSET fields are in milliseconds.//millisecond//timezone// millisecond// Year// Month// Day//Millisecond// month// year// both are defined// only year is defined// neither are defined// or only eon is defined which is not valid without a year// TODO: Non-optimal solution for now.// Efficient implementation would only store as BigDecimal// when needed and millisecond otherwise.// Treat ZERO as field being undefined.// http://www.w3.org/2001/05/xmlschema-errata#e2-45// while 0-24 is acceptable in the lexical space, 24 is not valid in value space// W3C XML Schema Part 2, Section 3.2.7.1// leap second allows for 60// must test hour after setting seconds// both instances are in same timezone or// both are FIELD_UNDEFINED.// Avoid costly normalization of timezone to 'Z' time.// Both instances have different timezones.// Normalize to UTC time and compare.// C. step 1// C. step 2// C. step 3// Q.getTimezone() != DatatypeConstants.FIELD_UNDEFINED// P has no timezone and Q does.// D. step 1// D. step 2// D. step 3// if timezone was undefined, leave it undefined// if milliseconds was undefined, leave it undefined// normalizing to UTC time negates the timezone offset before// addition.// isPositive//years//months//days//hours// absolute//seconds// set to zulu UTC time.// compare Year.// Eon field is only equal when null.// optimized case for comparing year not requiring eon field.//fields are either equal in value or both undefined.// Step B. 1.1 AND optimized result of performing 1.1-1.4.// Step B. 1.2// Step B. 1.3-4.// optimization. especially when both arguments are null.// Following two dates compare to EQUALS since in different timezones.// 2000-01-15T12:00:00-05:00 == 2000-01-15T13:00:00-04:00// Must ensure both instances generate same hashcode by normalizing// this to UTC timezone.//   no %{alpha}% to avoid SCCS macro substitution// since setters do not allow for invalid values,// (except for exceptional case of year field of zero),// no need to check for anything except for constraints// between fields.//check if days in month is valid. Can be dependent on leap year.// years could not be set// XML Schema 1.0 specification defines year value of zero as// invalid. Allow this class to set year field to zero// since XML Schema 1.0 errata states that lexical zero will// be allowed in next version and treated as 1 B.C.E.// optimize check./* Extracted from ... *//* Years (may be modified additionally below) ... *//* Zone ... *//* Seconds ... */// seconds + fractionalSeconds// Duration seconds is SECONDS + FRACTIONALSECONDS./* Minutes ... *//* Hours ... *//* Days ... */// calculate days in previous month, watch for month roll over// roll over to December of previous year// set fields that where undefined before this addition, back to undefined.// XML Schema months start at 1.// is a leap year./** Use the following instead for JDK7 only: ... */// if year( and eon) are undefined, leave default Calendar values// only set month if it is set// Calendar.MONTH is zero based while XMLGregorianCalendar month field is not.// only set day if it is set// only set hour if it is set// only set minute if it is set// only set second if it is set// only set millisend if it is set// use default if set// zoneoffset is in minutes. Convert to custom timezone id format.// Javadoc for java.util.TimeZone documents max length// for customTimezoneId is 8 when optional ':' is not used.// Format is// "GMT" ('-'|''+') (digit digit?) (digit digit)?//                   hour          minutes// Both this.eon and this.fractionalSecond are instances// of immutable classes, so they do not need to be cloned.// in minutes// not a meta character// seen meta character. we don't do error check against the format// parse seconds.// time zone. missing, 'Z', or [+-]nn:nn// illegal meta character. impossible.// some tokens are left in the input//,vidx);//,vidx-1);// we are expecting more digits// skip leading negative, if it exists// definitely int only. I don't know the exact # of digits that can be in int,// but as long as we can catch (0-9999) range, that should be enough.// not a meta char// optimized path// reallocate the buffer now so that it has enough space// Note: toPlainString() isn't available before Java 1.5// do it the hard way//skip leading zero.//PENDING : Implementation of reset methodimport Validator/** <p>Abstract implementation of Schema for W3C XML Schemas.</p> ... */HashMap<> fFeatures;/** Map containing the initial values of features for ... */HashMap<> fProperties;/** Map containing the initial values of properties for ... *//* @see javax.xml.validation.Schema#newValidator() *//* Schema methods */new ValidatorImpl(...)/* @see javax.xml.validation.Schema#newValidatorHandler() */new ValidatorHandlerImpl(...)/** Returns the initial value of a feature for validators created ... *//* XSGrammarPoolContainer methods *//* Set a feature on the schema *//** Returns the initial value of a property for validators created ... *//* Set a property on the schema */// AbstractXMLSchema/** <p>An extension to XMLDocumentHandler for building DOM structures.</p> ... *//** <p>Sets the <code>DOMResult</code> object which ... *//** A document type declaration. ... */import AttrImplimport ElementNSImplimport PSVIAttrNSImplimport PSVIDocumentImplimport PSVIElementNSImpl/** <p>DOM result augmentor.</p> ... */DOMValidatorHelper fDOMValidatorHelper;Document fDocument;CoreDocumentImpl fDocumentImpl;boolean fStorePSVI;boolean fIgnoreChars;Node targetgetCurrentElement(...)NamedNodeMap attrMapprocessAttributePSVI(...)Node currentElement/** Returns whether the given attribute is an ID type. * */Object type// If it's a Xerces DOM store type information for attributes, set idness, etc..// write type information to this attribute// Add default/fixed attributes// Write type information to this element// DOMResultAugmentorimport DocumentTypeImplimport EntityImplimport NotationImpl/** <p>DOM result builder.</p> ... */Node fTarget;Node fNextSibling;Node fFragmentRoot;ArrayList<> fTargetChildren;/* DOMDocumentHandler methods */NamedNodeMap oldMapNamedNodeMap newMapsetInternalSubset(...)Entity oldEntityEntityImpl newEntityNotation oldNotationNotationImpl newNotation/* XMLDocumentHandler methods *//** Create new DocumentType node for the target. *//** Copy internal subset. *//** Copy entities. *//** Copy notations. *//** Create new Text node for the target. *//** Create new CDATASection node for the target. *//** Create new Comment node for the target. *//** Create new ProcessingInstruction node for the target. */// write type information to this element// adjust current node reference/** Check if this node can be attached to the target. */// DOMResultBuilderimport DocumentBuilderFactoryImpl/** <p>A validator helper for <code>DOMSource</code>s.</p> ... */new DOMNamespaceContext(...)new DOMResultAugmentor(...)new DOMResultBuilder(...)/** Property identifier: namespace context. *//** The namespace context of this document: stores namespaces in scope. * */DOMNamespaceContext fDOMNamespaceContext;/** The namespace context of the DOMSource, includes context from ancestor nodes. * */XMLSchemaValidator fSchemaValidator;/** Schema validator. * *//** Validation manager. * */XMLSchemaValidatorComponentManager fComponentManager;/** Component manager. * */SimpleLocator fXMLLocator;/** Simple Locator. * */DOMDocumentHandler fDOMValidatorHandler;/** DOM document handler. * */DOMResultAugmentor fDOMResultAugmentor;/** DOM result augmentor. * */DOMResultBuilder fDOMResultBuilder;/** DOM result builder. * */NamedNodeMap fEntities;/** Map for tracking unparsed entities. * *//** Root node. * */Node fCurrentElement;/** Current element. * *//** Fields for start element, end element and characters. * *//* ValidatorHelper methods */DOMSource domSourceDOMResult domResultsetupEntityMap(...)setupDOMResultHandler(...)toSAXParseException(...)setDOMResult(...)/** Traverse the DOM and fire events to the schema validator. */beginNode(...)finishNode(...)/** Do processing for the start of a node. */setIgnoringCharacters(...)sendCharactersToValidator(...)cdata(...)/** Do processing for the end of a node. *//** Extracts NamedNodeMap of entities. We need this to validate ... *//** Sets up handler for <code>DOMResult</code>. */Node nodeResultDocumentBuilderFactory factoryString rawNametoFill.uritoFill.rawnametoFill.prefixtoFill.localpartDOMValidatorHelper$DOMNamespaceContext/** NamespaceContext for the DOMSource, includes context for ancestor nodes. */...[] fNamespace;/** Namespace binding information. This array is composed of a ... */int fNamespaceSize;/** The size of the namespace information array. */boolean fDOMContextBuilt;/** Flag indicating whether the namespace context ... */fillNamespaceContext(...)containsPrefix(...)getURI0(...)Node currentNodedeclarePrefix0(...)String[] namespacearray// regardless of what type of node this is, fire start and end document events// Release references to application objects//fCurrentElement = null; -- keep the reference to support current-element-node property// Performs a non-recursive traversal of the DOM. This// will avoid a stack overflow for DOMs with high depth.// start element/** The validator does nothing with processing instructions so bypass it. ... *//** The validator does nothing with comments so bypass it. ... *//** Send the DocumentType node directly to the result builder. */// Ignore other node types.// end element// If there's no DOMResult, unset the validator handler// If the source node and result node are the same use the DOMResultAugmentor.// Otherwise use the DOMResultBuilder.// Is this a DOM level1 document?// REVISIT: Assuming all attributes are of type CDATA. The actual type may not matter. -- mrglavas// REVISIT: Should we be looking at non-namespace attributes// for additional mappings? Should we detect illegal namespace// declarations and exclude them from the context? -- mrglavas// process namespace attribute// resize array, if needed// bind prefix to uri in current context// find prefix in the DOM context// prefix not found// DOMValidatorHelper/** {@link ErrorHandler} that throws all errors and fatal errors. ... *//** <p>Implementation of Schema for W3C XML Schemas ... */...[] ZERO_LENGTH_GRAMMAR_ARRAY;/** Zero length grammar array. *//* XMLGrammarPool methods */// EmptyXMLSchema/** Receives errors through Xerces {@link XMLErrorHandler} ... */boolean hadError;/** set to true if there was any error. *//** returns if there was an error since the last invocation of ... *//** resets the error flag. *//** Implemented by the derived class to return the actual ... */new WrappedSAXException(...)/** <p>Used to format JAXP Validation API error messages using a specified locale.</p> ... *//** <p>Filter {@link XMLGrammarPool} that exposes a ... */XMLGrammarPool core;this.core// noop. don't let caching to happen// noop. cache is read-only.// noop. this pool is always read-only// noop. this pool is always read-only.// ReadOnlyGrammarPool/** <p>Implementation of Schema for W3C XML Schemas which ... */Grammar fGrammar;XMLGrammarDescription fGrammarDescription;// SimpleXMLSchema/** <p>This grammar pool is a memory sensitive cache. The grammars ... */new ReferenceQueue<>(...)int TABLE_SIZE;/** Default size. *//** Grammars. */boolean fPoolIsLocked;/** Flag indicating whether this pool is locked *//** The number of grammars in the pool */ReferenceQueue<> fReferenceQueue;/** Reference queue for cleared grammar references *//** Constructs a grammar pool with a default number of buckets. *//** Constructs a grammar pool with a specified number of buckets. *//* <p> Retrieve the initial known set of grammars. This method is ... */// XMLGrammarPool methodsclean(...)/* <p> Return the final set of grammars that the validator ended up ... */// retrieveInitialGrammarSet (String): Grammar[]/* <p> This method requests that the application retrieve a grammar ... */// cacheGrammars(String, Grammar[]);/** Puts the specified grammar into the grammar pool and associates it to ... */// retrieveGrammar(XMLGrammarDescription):  GrammarXMLGrammarDescription descentry.hashnew SoftGrammarReference(...)/** Returns the grammar associated to the specified grammar description. ... */// putGrammar(Grammar)Grammar tempGrammar/** Removes the grammar associated to the specified grammar description from the ... */// getGrammar(XMLGrammarDescription):Grammar/** Returns true if the grammar pool contains a grammar associated ... */// removeGrammar(XMLGrammarDescription):Grammar/* <p> Sets this grammar pool to a "locked" state--i.e., ... */// containsGrammar(XMLGrammarDescription):boolean/* <p> Sets this grammar pool to an "unlocked" state--i.e., ... */// lockPool()/* <p>This method clears the pool-i.e., removes references ... */// unlockPool()/** This method checks whether two grammars are the same. Currently, we compare ... */XMLSchemaDescription sd1XMLSchemaDescription sd2/** Returns the hash code value for the given grammar description. ... */XMLSchemaDescription sd/** Removes the given entry from the pool ... */entry.preventry.prev.nextentry.bucketentry.next.preventry.grammar.entry/** Removes stale entries from the pool. */Reference<> ref(...).entry/** This class is a grammar pool entry. Each entry acts as a node ... */int bucket;Entry prev;XMLGrammarDescription desc;SoftGrammarReference grammar;this.hashthis.bucketnext.prevthis.desc// since reduces reference count of objects to be destroyed// clear this entry; useful to promote garbage collection/** This class stores a soft reference to a grammar object. It keeps a reference ... */// class EntryEntry entry;// Return no grammars. This allows the garbage collector to sift// out grammars which are not in use when memory demand is high.// It also allows the pool to return the "right" schema grammar// based on schema locations.// create a new entry/** If the soft reference has been cleared, remove this entry from the pool. */// The JAXP 1.3 spec says that the implementation can assume that// if two schema location hints are the same they always resolve// to the same document. In the default grammar pool implementation// we only look at the target namespaces. Here we also compare// location hints.// class SoftGrammarReference// class SoftReferenceGrammarPoolimport TransformerFactoryImpl/** <p>A validator helper for <code>StAXSource</code>s.</p> ... */Transformer identityTransformer1;TransformerHandler identityTransformer2;ValidatorHandlerImpl handler;/** Creates a new instance of StaxValidatorHelper */SAXTransformerFactory tfgetSAXTransformFactory(...)Constants.JDK_ENTITY_COUNT_INFOnew TransformerFactoryConfigurationError(...)// this is impossible, but again better safe than sorry/** <p>A validator helper for <code>StreamSource</code>s.</p> ... *//** Property id: security manager. */SoftReference<> fConfiguration;/** SoftReference to parser configuration. * */TransformerHandler identityTransformerHandlerXMLInputSource input// Gets the parser configuration. We'll create and initialize a new one, if we// haven't created one before or if the previous one was garbage collected.// If settings have changed on the component manager, refresh the error handler and entity resolver.// prepare for parse// StreamValidatorHelper/** <p>Static utility methods for the Validation API implementation.</p> ... *//** Creates a proper {@link XMLInputSource} from a {@link StreamSource}. ... *//** Reconstructs {@link SAXException} from XNIException. */// Utilimport FactoryConfigurationErrorimport ItemPSVIimport Attributes2import EntityResolver2/** <p>Implementation of ValidatorHandler for W3C XML Schemas and ... */new XMLSchemaTypeInfoProvider(...)new ResolutionForwarder(...)/** Flag used to track whether the namespace context needs to be pushed. */AttributesProxy fAttrAdapter;// User Objects/* Constructors */new XMLSchemaValidatorComponentManager(...)/* ValidatorHandler methods */getResourceResolver(...)Status.NOT_ALLOWEDbeginStartElement(...)finishStartElement(...)beginEndElement(...)finishEndElement(...)/* ContentHandler methods */String prefixSymbolString uriSymbolfillXMLAttributes2(...)/* DTDHandler methods */SAXSource saxSourceSAXResult saxResultErrorHandler errorHandlerInputSource isnew FactoryConfigurationError(...)/** Fills in the XMLAttributes object. */fillXMLAttribute(...)isDeclared(...)/** Adds an attribute to the XMLAttributes object. */XMLSchemaTypeInfoProvider fTypeInfoProvider;/** {@link TypeInfoProvider} implementation. ... */ValidatorHandlerImpl$XMLSchemaTypeInfoProviderAugmentations fElementAugs;/** Element augmentations: contains ElementPSVI. * *//** Attributes: augmentations for each attribute contain AttributePSVI. * */boolean fInStartElement;/** In start element. * */boolean fInEndElement;/** In end element. * *//** Initializes the TypeInfoProvider with type information for the current element. * *//** Cleanup at the end of start element. * *//** Cleanup at the end of end element. * *//** Throws a {@link IllegalStateException} if we are not in ... */AttributePSVI psvigetTypeInfoFromPSVI(...)getAttributeTypeInfo(...)ElementPSVI psviXSTypeDefinition t// PSVIProvider supportResolutionForwarder fResolutionForwarder;/** SAX adapter for an LSResourceResolver. */ValidatorHandlerImpl$ResolutionForwarderString XML_TYPE;/** XML 1.0 type constant according to DOM L3 LS REC spec "http://www.w3.org/TR/2004/REC-DOM-Level-3-LS-20040407/" */LSResourceResolver fEntityResolver;/** The DOM entity resolver. *//** Wraps the specified DOM entity resolver. *//** Sets the DOM entity resolver. *//** Returns the DOM entity resolver. */// setEntityResolver(LSResourceResolver)/** Always returns <code>null</code>. An LSResourceResolver has no corresponding method. */// getEntityResolver():LSResourceResolver/** Resolves the given resource and adapts the <code>LSInput</code> ... */LSInput lsInputresolveResource(...)String pubIdString sysIdresolveSystemId(...)/** Delegates to EntityResolver2.resolveEntity(String, String, String, String). *//** Resolves a system identifier against a base URI. *///for now, the identifier can only be (XMLConstants.FEATURE_SECURE_PROCESSING)/** Split empty element event. * */// if the type is union it is possible that we receive// a character call with empty data// cleans up TypeInfoProvider// Fill element QName// Fill XMLAttributes/** Processing instructions do not participate in schema validation, ... */// there seems to be no corresponding method on XMLDocumentFilter.// just pass it down to the output, if any.// create one now// If this is a Xerces SAX parser, set the security manager if there is one// Ignore the exception if the security manager cannot be set.// this is impossible, but better safe than sorry// release the reference to user's handler ASAP// TODO: make sure if this is correct.// TODO: since the number of types in a schema is quite limited,// TypeInfoImpl should be pooled. Even better, it should be a part// of the element decl.// TODO: can t be null?// In the event that resolution failed against the// base URI, just return the system id as is. There's not// much else we can do./** <p>Instances of ValidatorHelper are able to validate ... *//** <p>Implementation of Validator for W3C XML Schemas.</p> ... */Constants.CURRENT_ELEMENT_NODE_PROPERTYValidatorHandlerImpl fSAXValidatorHelper;/** SAX validator helper. * *//** DOM validator helper. * */StreamValidatorHelper fStreamValidatorHelper;/** Stream validator helper. * */StAXValidatorHelper fStaxValidatorHelper;/** StAX validator helper. * */boolean fConfigurationChanged;/** Flag for tracking whether features/properties changed since last reset. */boolean fErrorHandlerChanged;/** Flag for tracking whether the error handler changed since last reset. */boolean fResourceResolverChanged;/** Flag for tracking whether the resource resolver changed since last reset. */String CURRENT_ELEMENT_NODE;/** Support current-element-node property */new DOMValidatorHelper(...)new StreamValidatorHelper(...)new StAXValidatorHelper(...)restoreInitialState(...)// Hand off to SAX validator helper.// Hand off to DOM validator helper.// Hand off to stream validator helper.// Hand off to stax validator helper.// Source parameter cannot be null.// Source parameter must be a SAXSource, DOMSource or StreamSource//Support current-element-node; return current node if DOMSource is used.// avoid resetting features and properties if the state the validator// is currently in, is the same as it will be after reset.// ValidatorImpl/** <p>An implementation of Schema for W3C XML Schemas ... */new WeakReference<>(...)WeakReference<> fGrammarPool;/** Weak reference to grammar pool. */XMLGrammarPool grammarPoolnew SoftReferenceGrammarPool(...)// If there's no grammar pool then either we haven't created one// yet or the garbage collector has already cleaned out the previous one.// WeakReferenceXMLSchema/** Wraps {@link SAXException} and make it an unchecked exception. ... */SAXException exception;/** <p>Implementation of Schema for W3C XML Schemas.</p> ... *//** The grammar pool is immutable *//** <p>Returns the grammar pool contained inside the container.</p> ... *//** <p>Returns whether the schema components contained in this object ... */// XMLSchemaimport SchemaFactory/** {@link SchemaFactory} for XML Schema. ... *//** Feature identifier: schema full checking. *//** Property identifier: XMLSecurityManager. */XMLSchemaLoader fXMLSchemaLoader;/** The XMLSchemaLoader */ErrorHandler fErrorHandler;/** User-specified ErrorHandler; can be null. */LSResourceResolver fLSResourceResolver;/** The LSResrouceResolver */DOMEntityResolverWrapper fDOMEntityResolverWrapper;/** The DOMEntityResolverWrapper */ErrorHandlerWrapper fErrorHandlerWrapper;/** The ErrorHandlerWrapper *//** The SecurityManager. *//** The Security property manager. */XMLGrammarPoolWrapper fXMLGrammarPoolWrapper;/** The container for the real grammar pool. */JdkXmlFeatures fXmlFeatures;new XMLGrammarPoolWrapper(...)/** <p>Is specified schema supported by this <code>SchemaFactory</code>?</p> ... */XMLConstants.W3C_XML_SCHEMA_NS_URIXMLGrammarPoolImplExtension poolnew XMLGrammarPoolImplExtension(...)XMLInputSource[] xmlInputSourcesnew XMLInputSource[]schemas.lengthint grammarCountgetGrammarCount(...)AbstractXMLSchema schemasetGrammarPool(...)new SAXInputSource(...)new DOMInputSource(...)new StAXInputSource(...)SAXParseException senew XMLSchema(...)new ReadOnlyGrammarPool(...)new SimpleXMLSchema(...)new EmptyXMLSchema(...)propagateFeatures(...)propagateProperties(...)new WeakReferenceXMLSchema(...)Constants.ORACLE_FEATURE_SERVICE_MECHANISMString[] propertiesproperties.lengthObject stateXMLSchemaFactory$XMLGrammarPoolImplExtension/** Extension of XMLGrammarPoolImpl which exposes the number of ... *//** Returns the number of grammars contained in this pool. */XMLSchemaFactory$XMLGrammarPoolWrapper/** A grammar pool which wraps another. */// XMLSchemaFactory.XMLGrammarPoolImplExtensionlockPool(...)unlockPool(...)// Enable secure processing feature by default// only W3C XML Schema 1.0 is supported// this will let the loader store parsed Grammars into the pool.// this should have been reported to users already.// this hasn't been reported, so do so now.// and we must throw it.// Clear reference to grammar pool.// Select Schema implementation based on grammar count.// Use a Schema that uses the system id as the equality source./** Check to see if the property is managed by the JdkXmlFeatues * *///in secure mode, let useServicesMechanism be determined by the constructor// XMLSchemaFactory.XMLGrammarPoolWrapper// XMLSchemaFactory/** <p>An implementation of XMLComponentManager for a schema validator.</p> ... *//** Property identifier: security property manager. */HashMap<> fComponents;/** Lookup map for components required for validation. * */// Components/** XML Schema validator. *//** Stores initial feature values for validator reset. */// Configuration/** Stores initial property values for validator reset. */XMLSecurityManager fInitSecurityManager;/** Stores the initial security manager. *//** Stores the initial security property manager. *//** Application's ErrorHandler. * */LSResourceResolver fResourceResolver;/** Application's LSResourceResolver. *//** Locale chosen by the application. *//** Constructs a component manager suitable for Xerces' schema validator. */boolean secureProcessingObject componentsetFeatureDefaults(...)setPropertyDefaults(...)/** Calls reset on each of the components owned by this component manager. * *//** Cleans out configuration, restoring it to its initial state. *//** Sets feature defaults for the given component on this configuration. *//** Sets property defaults for the given component on this configuration. */// setup components// setup other properties// setup grammar pool// add all recognized features and properties and apply their defaults//pass on properties set on SchemaFactory//pre-condition: VALIDATION and SCHEMA_VALIDATION are always true// Mark configuration as fixed.// Remove error resolver and error handler// Set the Locale back to null.// Restore initial security manager// Reset feature and property values to their initial values// XMLSchemaValidatorComponentManager/** <p>A container for grammar pools which only contain schema grammars.</p> ... */import DeferredDocumentImplimport DocumentImplimport ElementDefinitionImplimport EntityReferenceImplimport NodeImplimport TextImplimport LSParserFilter/** This is the base class of all DOM parsers. It implements the XNI ... */Constants.DOCUMENT_CLASS_NAME_PROPERTY/** Feature id: namespace. */// feature idsString CREATE_ENTITY_REF_NODES;/** Feature id: create entity ref nodes. *//** Feature id: include comments. *//** Feature id: create cdata nodes. *//** Feature id: include ignorable whitespace. */String DEFER_NODE_EXPANSION;/** Feature id: defer node expansion. */String DOCUMENT_CLASS_NAME;/** Property id: document class name. */// property ids// Constants.XERCES_PROPERTY_PREFIX + Constants.XMLGRAMMAR_POOL_PROPERTY;// protected static final String GRAMMAR_POOL =String DEFAULT_DOCUMENT_CLASS_NAME;/** Default document class name. */String CORE_DOCUMENT_CLASS_NAME;String PSVI_DOCUMENT_CLASS_NAME;AbstractDOMParser$Abort/** If the user stops the process, this exception will be thrown. */new Abort(...)Abort INSTANCE;boolean DEBUG_BASEURI;boolean fInDTD;/** True if inside DTD. */boolean fCreateEntityRefNodes;/** Create entity reference nodes. */boolean fIncludeIgnorableWhitespace;/** Include ignorable whitespace. */boolean fIncludeComments;/** Include Comments. */boolean fCreateCDATANodes;/** Create cdata nodes. *//** The document. */// dom information/** The default Xerces document implementation, if used. *//** Whether to store PSVI information in DOM tree. */String fDocumentClassName;/** The document class name to use. */DocumentType fDocumentType;/** The document type node. *//** Current node. */CDATASection fCurrentCDATASection;EntityImpl fCurrentEntityDecl;int fDeferredEntityDecl;StringBuilder fStringBuilder;/** Character buffer */StringBuilder fInternalSubset;/** Internal subset buffer. */// internal subsetboolean fDeferNodeExpansion;// deferred expansion databoolean fNamespaceAware;DeferredDocumentImpl fDeferredDocumentImpl;int fDocumentIndex;int fDocumentTypeIndex;int fCurrentNodeIndex;int fCurrentCDATASectionIndex;boolean fInDTDExternalSubset;/** True if inside DTD external subset. *//** Root element node. *//** True if inside CDATA section. *//** True if saw the first chunk of characters */boolean fFilterReject;/** LSParserFilter: specifies that element with given QNAME and all its children ... */Stack<> fBaseURIStack;/** Base uri stack */int fRejectedElementDepth;/** LSParserFilter: tracks the element depth within a rejected subtree. */Stack<> fSkippedElemStack;/** LSParserFilter: store depth of skipped elements */boolean fInEntityRef;/** LSParserFilter: true if inside entity reference */LSParserFilter fDOMFilter;/** This method retrieves the name of current document class. */// <init>(XMLParserConfiguration)/** This method allows the programmer to decide which document ... */Class<> _class// setDocumentClassName(String)/** Drops all references to the last DOM which was built by this parser. */// getDocument():Document/** Resets the parser state. ... */// XMLDocumentParser methods// dropDocumentReferences()setDocumentClassName(...)EntityReference ersetCharacterData(...)EntityReferenceImpl erImplsetInputEncoding(...)int ercreateDeferredEntityReference(...)// startGeneralEntity(String,XMLResourceIdentifier, Augmentations)setEntityInfo(...)getWhatToShow(...)NodeFilter.SHOW_COMMENTshort codeLSParserFilter.FILTER_INTERRUPTAbort.INSTANCELSParserFilter.FILTER_REJECTLSParserFilter.FILTER_SKIPcreateDeferredComment(...)NodeFilter.SHOW_PROCESSING_INSTRUCTIONint picreateDeferredProcessingInstruction(...)setStrictErrorChecking(...)Class<> documentClassClass<> defaultDocClassClass<> psviDocClassnew DeferredDocumentImpl(...)createDeferredDocument(...)// startDocument(String,String)createDeferredDocumentType(...)createElementNode(...)createAttrNode(...)fAttrQName.prefixAttrImpl attrImplboolean isDeclaredint elsetDeferredAttribute(...)removeData(...)int cscreateDeferredCDATASection(...)int txtcreateDeferredTextNode(...)TextImpl textNodeImplNodeFilter.SHOW_ELEMENTNodeList lssetTypeInfo(...)NodeFilter.SHOW_CDATA_SECTIONboolean removeEntityRefNode copyNodeFilter.SHOW_ENTITY_REFERENCEhandleBaseURI(...)int parentIndexint lastChildint siblingsetAsLastChild(...)/** Record baseURI information for the Element (by adding xml:base attribute) ... */// endGeneralEntity(String, Augmentations)getDeferredEntityBaseURI(...)boolean singleQuoteEntityImpl entitycreateDeferredEntity(...)// unparsedEntityDecl(String,XMLResourceIdentifier, String, Augmentations)NamedNodeMap notationsNotationImpl notationcreateDeferredNotation(...)// ignoredCharacters(XMLString, Augmentations)defaultValue.chdefaultValue.offsetint elementDefIndexlookupElementDefinition(...)boolean nsEnabledcreateDeferredElementDefinition(...)NamedNodeMap elementsElementDefinitionImpl elementDefcreateElementDefinition(...)// subclasses can override this method to create element nodes in other ways.// method to create an element node.// subclasses can override this method to create attribute nodes in other ways.// method to create an attribute node.attrQName.uriattrQName.rawnameattrQName.localpart/* When the first characters() call is received, the data is stored in ... */replaceData(...)NodeFilter.SHOW_TEXT// add recognized features// add recognized properties// normalize class name// verify that this class exists and is of the right type//if (!_class.isAssignableFrom(Document.class)) {// set document class name// get feature state// get property// reset dom information// reset string buffer// reset state information// Always create entity reference nodes to be able to recreate// entity as a part of doctype// REVISIT: baseURI/actualEncoding//         remove dependency on our implementation when DOM L3 is REC// set base uri// set actual encoding// we don't need synchronization now, because entity ref will be// expanded anyway. Synch only needed when user creates entityRef node// find corresponding Entity decl// REVISIT: the constant FILTER_REJECT should be changed when new// DOM LS specs gets published// fall through to SKIP since comment has no children.// REVISIT: the constant FILTER_SKIP should be changed when new// make sure we don't loose chars if next event is characters()// accept node// fall through to SKIP since PI has no children.// fFirstChunk must be set to true so that data// won't be lost in the case where the child before PI is// a text node and the next event is characters.// REVISIT: when DOM Level 3 is REC rely on Document.support//          instead of specific class// set DOM error checking off// set documentURI// use specified document class// if subclass of our own class that's cool too// REVISIT: when DOM Level 3 is REC rely on//          Document.support instead of specific class// won't happen we already checked that earlier// REVISIT: strict error checking is not implemented in deferred dom.// NOTE: The specified value MUST be set after you set//       value from the attribute list. -Ac// REVISIT: currently it is possible that someone turns off// namespaces and turns on xml schema validation// To avoid classcast exception in AttrImpl check for namespaces// however the correct solution should probably disallow setting// namespaces to false when schema processing is turned on.// XML Schema// DTD// For DOM Level 3 TypeInfo, the type name must// be null if this attribute has not been declared// in the DTD.// REVISIT: Handle entities in attribute value.// filter nodes// fill value of the root element// make sure that if any char data is available// the fFirstChunk is true, so that if the next event// is characters(), and the last node is text, we will copy// the value already in the text node to fStringBuffer// (not to lose it).// Need to loop in reverse order so that the attributes// are processed in document order when the DOM is expanded.// set type information// if type is union (XML Schema) it is possible that we receive// character call with empty data// collect all the data into the string buffer.// The Text and CDATASection normalization is taken care of within// the DOM in the deferred case.// The Text normalization is taken care of within the DOM in the// deferred case.// REVISIT: Should this happen after we call the filter?// Updating TypeInfo. If the declared type is a union the// [member type definition] will only be available at the// end of an element.// replace children// end-if DOMFilter// Setting TypeInfo. If the declared type is a union the// fall through to SKIP since CDATA section has no children.// set the actual encoding and set DOM error checking back on// set the actual encoding// get current entity declaration//entities.setNamedItem(fCurrentEntityDecl);// Make entity ref node read only// move entity reference children to the list of// siblings of its parent and remove entity reference// get previous sibling of the entity reference// normalize text nodes// length > 0// entity definition exists and it does not have any children//!fCreateEntityRefNodes// move children of entity ref before the entity ref.// remove entity ref.// holds a child of entity ref// REVISIT: remove dependency on our implementation when//          DOM L3 becomes REC// if an element already has xml:base attribute// retrive the baseURI from the entity reference// retrieve baseURI from the entity reference// try baseURI of the entity declaration// internal subset string// NOTE: We only know how to create these nodes for the Xerces//       DOM implementation because DOM Level 2 does not specify//       that functionality. -Ac// create full node// don't add parameter entities!// create deferred node// REVISIT: This code applies to the support of domx/grammar-access// feature in Xerces 1// deferred expansion// get the default value// get element definition// create element definition if not already there// add default attribute// DOM Level 2 wants all namespace declaration attributes// to be bound to "http://www.w3.org/2000/xmlns/"// So as long as the XML parser doesn't do it, it needs to// done here.// REVISIT: set ID type correctly// if deferred// full expansion// get element definition node// REVISIT: Check for uniqueness of element name? -Ac// create attribute and set properties// add default attribute to element definition// if NOT defer-node-expansion// if we are using xerces DOM implementation, call our// own constructor to reuse the strings we have here.// handle character data// if we have data in the buffer we must have created// a text node already.// REVISIT: should this check be performed?// fall through to SKIP since Comment has no children.// accept node -- do nothing// end-if fDOMFilter !=null// end-if child !=null// class AbstractDOMParserimport EntityResolver2Wrapperimport EntityResolverWrapperimport DocumentHandler/** This is the base class of all SAX parsers. It implements both the ... */Constants.ALLOW_DTD_EVENTS_AFTER_ENDDTD_FEATUREConstants.LEXICAL_HANDLER_PROPERTYConstants.DECLARATION_HANDLER_PROPERTYConstants.DOM_NODE_PROPERTY/** Feature id: string interning. */String ALLOW_UE_AND_NOTATION_EVENTS;// if it is already a recognized feature for the pipeline// this is not meant to be a recognized feature, but we need it here to use/** Feature identifier: allow notation and unparsed entity events to be sent out of order. */String LEXICAL_HANDLER;/** Property id: lexical handler. */String DECLARATION_HANDLER;/** Property id: declaration handler. */String DOM_NODE;/** Property id: DOM node. *//** Namespace prefixes. */boolean fLexicalHandlerParameterEntities;/** Lexical handler parameter entities. *//** Standalone document declaration. */boolean fResolveDTDURIs;/** Resolve DTD URIs. */boolean fUseEntityResolver2;/** Use EntityResolver2. */boolean fXMLNSURIs;/** XMLNS URIs: Namespace declarations in the ... *//** Content handler. */// parser handlersDocumentHandler fDocumentHandler;DTDHandler fDTDHandler;DeclHandler fDeclHandler;/** Decl handler. */LexicalHandler fLexicalHandler;/** Lexical handler. */// track the version of the document being parsed// REVISIT: what should be the size of the buffer?// temporary buffer for sending normalized valuesSymbolHash fDeclaredAttrs;// second declaration to any registered DeclHandler// been declared twice, so that we can avoid exposing the// allows us to keep track of whether an attribute has// startDocument(locator,encoding,augs)// startGeneralEntity(String,String,String,String,String)startNamespaceMapping(...)fQName.prefixfQName.rawnameremoveAttributeAt(...)fQName.urifQName.localpartendNamespaceMapping(...)/** This method notifies of the start of parameter entity. The DTD has the ... */// startParameterEntity(String,identifier,String,Augmentation)// elementDecl(String,String, Augmentations)String elemAttr// externalEntityDecl(String,,XMLResourceIdentifier, Augmentations)/** Parses the input source specified by the given system identifier. ... */// Parser and XMLReader methodsnew LocatorImpl(...) { ... }AbstractSAXParser$1// be mislead.// application can do this itself if it wishes to possibly// We *could* consult the LocatorProxy, but the// we cannot return anything meaningful in this context.// since XMLParseExceptions know nothing about encoding,/** parse ... */// parse(String)AbstractSAXParser$2XMLEntityResolver xerEntityResolver2Wrapper er2wnew EntityResolver2Wrapper(...)EntityResolverWrapper erwnew EntityResolverWrapper(...)// setEntityResolver(EntityResolver)XMLEntityResolver xmlEntityResolver// getEntityResolver():EntityResolverXMLErrorHandler xehErrorHandlerWrapper ehw// setErrorHandler(ErrorHandler)XMLErrorHandler xmlErrorHandler// getErrorHandler():ErrorHandler/** Allow an application to register a DTD event handler. ... *//** Allow an application to register a document event handler. ... */// Parser methods// setDTDHandler(DTDHandler)/** Allow an application to register a content event handler. ... */// XMLReader methods// setDocumentHandler(DocumentHandler)/** Return the current content handler. ... */// setContentHandler(ContentHandler)/** Return the current DTD handler. ... */// getContentHandler():ContentHandler/** Set the state of any feature in a SAX2 parser.  The parser ... */// getDTDHandler():DTDHandlerConstants.LEXICAL_HANDLER_PARAMETER_ENTITIES_FEATUREConstants.RESOLVE_DTD_URIS_FEATUREConstants.UNICODE_NORMALIZATION_CHECKING_FEATUREConstants.XMLNS_URIS_FEATUREConstants.USE_ENTITY_RESOLVER2_FEATUREConstants.IS_STANDALONE_FEATUREConstants.USE_ATTRIBUTES2_FEATUREConstants.USE_LOCATOR2_FEATUREConstants.XML_11_FEATURE/** Query the state of a feature. ... *//** Set the value of any property in a SAX2 parser.  The parser ... */setDeclHandler(...)Constants.DOCUMENT_XML_VERSION_PROPERTY/** Query the value of a property. ... *//** Set the DTD declaration event handler. ... */// SAX2 core properties// getProperty(String):Object/** Returns the DTD declaration event handler. ... */// setDeclHandler(DeclHandler)/** Set the lexical event handler. ... */// getDeclHandler():DeclHandler/** Returns the lexical handler. ... */// setLexicalHandler(LexicalHandler)/** Send startPrefixMapping events */// getLexicalHandler():LexicalHandler/** Send endPrefixMapping events *//** XML locator. *//** Constructs an XML locator proxy. *//** Line number. *//** Column number. */// Locator2 methods// class LocatorProxy/** XML attributes. *//** Sets the XML attributes. */// setAttributes(XMLAttributes)// REVISIT: Localize exception messages. -- mrglavas// Attributes2 methods// PSVIProvider methods// class AttributesProxyfAttributesProxy.fAttributes// PSVI// SAX1, SAX2// it wasn't a recognized feature, so we don't worry about it// SAX1// SAX2// the version need only be set once; if// document's XML 1.0|1.1, that's how it'll stay// SAX2 extension// is there a DeclHandler?// Only report startEntity if this entity was actually read.// report skipped entity to content handler// Only report endEntity if this entity was actually read.// REVISIT: should we support schema-normalized-value for SAX1 events// send prefix mapping events// REVISIT: It should not be necessary to iterate over the attribute// list when the set of [namespace attributes] is empty for this// element. This should be computable from the NamespaceContext, but// since we currently don't report the mappings for the xml prefix// we cannot use the declared prefix count for the current context// to skip this section. -- mrglavas// remove namespace declaration attributes// localpart should be empty string as per SAX documentation:// http://www.saxproject.org/?selected=namespaces// REVISIT - I keep running into SAX apps that expect//   null data to be an empty string, which is contrary//   to the comment for this method in the SAX API.// used as a key to detect duplicate attribute definitions.// we aren't permitted to return duplicate attribute definitions// SAX2 extensions// SAX1 and SAX2// help out the GC// parse document// wrap XNI exceptions as SAX exceptions//REVISIT:this methods is not part of SAX2 interfaces, we should throw exception//if any application uses SAX2 and sets locale also. -nb// SAX2 Features// http://xml.org/sax/features/namespaces// http://xml.org/sax/features/namespace-prefixes//   controls the reporting of raw prefixed names and Namespace//   declarations (xmlns* attributes): when this feature is false//   (the default), raw prefixed names may optionally be reported,//   and xmlns* attributes must not be reported.// http://xml.org/sax/features/string-interning//   controls the use of java.lang.String#intern() for strings//   passed to SAX handlers.// http://xml.org/sax/features/lexical-handler/parameter-entities//   controls whether the beginning and end of parameter entities//   will be reported to the LexicalHandler.// http://xml.org/sax/features/resolve-dtd-uris//   controls whether system identifiers will be absolutized relative to//   their base URIs before reporting.// http://xml.org/sax/features/unicode-normalization-checking//   controls whether Unicode normalization checking is performed//   as per Appendix B of the XML 1.1 specification// REVISIT: Allow this feature to be set once Unicode normalization// checking is supported -- mrglavas.// http://xml.org/sax/features/xmlns-uris//   controls whether the parser reports that namespace declaration//   attributes as being in the namespace: http://www.w3.org/2000/xmlns/// http://xml.org/sax/features/use-entity-resolver2//   controls whether the methods of an object implementing//   org.xml.sax.ext.EntityResolver2 will be used by the parser.// Refresh EntityResolver wrapper.// Read only features.// http://xml.org/sax/features/is-standalone//   reports whether the document specified a standalone document declaration.// http://xml.org/sax/features/use-attributes2//   reports whether Attributes objects passed to startElement also implement//   the org.xml.sax.ext.Attributes2 interface.// http://xml.org/sax/features/use-locator2//   reports whether Locator objects passed to setDocumentLocator also implement//   the org.xml.sax.ext.Locator2 interface.// http://xml.org/sax/features/xml-1.1//   reports whether the parser supports both XML 1.1 and XML 1.0.// Default handling/* else if (featureId.startsWith(XERCES_FEATURES_PREFIX)) { ... */// http://xml.org/sax/properties/lexical-handler// Value type: org.xml.sax.ext.LexicalHandler// Access: read/write, pre-parse only//   Set the lexical event handler.// http://xml.org/sax/properties/declaration-handler// Value type: org.xml.sax.ext.DeclHandler//   Set the DTD declaration event handler.// http://xml.org/sax/properties/dom-node// Value type: DOM Node//   Get the DOM node currently being visited, if the SAX parser is//   iterating over a DOM tree.  If the parser recognises and//   supports this property but is not currently visiting a DOM//   node, it should return null (this is a good way to check for//   availability before the parse begins).// http://xml.org/sax/properties/document-xml-version// Value type: java.lang.String//   The literal string describing the actual XML version of the document./* else if (propertyId.startsWith(XERCES_PROPERTIES_PREFIX)) { ... */// Perform default processing// we are not iterating a DOM tree// REVISIT: this hides the fact that internally we use//          null instead of empty string//          SAX requires URI to be a string or an empty string// class AbstractSAXParser/** This is the base class for all XML document parsers. XMLDocumentParser ... *//** Document source *//** DTD source *//** DTD content model source *//** Constructs a document parser using the default symbol table ... *//** This method notifies the start of an entity. ... */// startGeneralEntity(String,XMLResourceIdentifier,String,Augmentations)/** This method notifies the end of an entity. ... */// textDecl(String, String, Augmentations)// endGeneralEntity(String,Augmentations)// comment (XMLString, Augmentations)// processingInstruction(String, XMLString, Augmentations)// startContentModel(String, Augmentations)// any(Augmentations)// empty(Augmentations)// stargGroup(Augmentations)// pcdata(Augmentations)// element(String, Augmentations)// separator(short, Augmentations)// occurence(short, Augmentations)// endGroup(Augmentations)// endContentModel(Augmentations)// set handlers// class AbstractXMLDocumentParser/** A very basic parser configuration. This configuration class can ... */// components (non-configurable)/** The document handler. *//** The DTD handler. *//** The DTD content model handler. */XMLDocumentSource fLastComponent;/** Last component in the document pipeline *//** Adds a component to the parser configuration. This method will ... *//** reset all components before parsing and namespace context */// create a vector to hold all the components in use// REVISIT: Should this be a property?// forward to every component// reset every component// special performance feature: no one by component manager is allowed to set it// class BasicParserConfigurationimport ShadowedSymbolTableimport SynchronizedSymbolTable/** A parser pool that enables caching of grammars. The caching parser ... */boolean DEFAULT_SHADOW_SYMBOL_TABLE;/** Default shadow symbol table (false). */boolean DEFAULT_SHADOW_GRAMMAR_POOL;/** Default shadow grammar pool (false). */SymbolTable fSynchronizedSymbolTable;/** Symbol table. The symbol table that the caching parser pool is ... */XMLGrammarPool fSynchronizedGrammarPool;/** Grammar pool. The grammar pool that the caching parser pool is ... */boolean fShadowSymbolTable;/** Shadow the symbol table for new parser instances. If true, ... */boolean fShadowGrammarPool;/** Shadow the grammar pool for new parser instances. If true, ... *//** Constructs a caching parser pool with the specified symbol table ... */new SynchronizedSymbolTable(...)new SynchronizedGrammarPool(...)/** Returns the grammar pool. *//** Sets whether new parser instance receive shadow copies of the ... */// setters and getters// getXMLGrammarPool():XMLGrammarPool/** Creates a new DOM parser. */// setShadowSymbolTable(boolean)new ShadowedSymbolTable(...)new ShadowedGrammarPool(...)/** Creates a new SAX parser. */// createDOMParser():DOMParserCachingParserPool$SynchronizedGrammarPool/** Synchronized grammar pool. ... */// createSAXParser():SAXParser/** Main grammar pool. *//** Constructs a synchronized grammar pool. */// @return the initial grammar set the validator may place in its "bucket"// @param grammarType type of the grammars to be retrieved.// REVISIT:  does this need to be synchronized since it's just reading?// to work with.// retrieve the initial set of grammars for the validator// GrammarPool methods// <init>(XMLGrammarPool)// @return Grammar corresponding to gDesc, or null if none exists.// @param gDesc description of the grammar to be retrieved// retrieve a particular grammar.// retrieveInitialGrammarSet(String):  Grammar[]//  given to the validator may be included).// @param grammars the Grammars that may be cached (unordered, Grammars previously// @param grammarType The type of the grammars to be cached.// This certainly must be synchronized.// give the grammarPool the option of caching these grammars.// retrieveGrammar(XMLGrammarDesc):  Grammar/** lock the grammar pool *//** clear the grammar pool *//** unlock the grammar pool */CachingParserPool$ShadowedGrammarPool/** Shadowed grammar pool. ... */// class SynchronizedGrammarPool/** Constructs a shadowed grammar pool. *//** Retrieve the initial set of grammars for the validator to work with. ... */// <init>(GrammarPool)/** Retrieve a particular grammar. ... *//** Give the grammarPool the option of caching these grammars. ... *//** Returns the grammar associated to the specified description. ... */// cacheGrammars(grammarType, Grammar[]);containsGrammar(...)/** Puts the specified grammar into the grammar pool. ... *//** **** ... *//** Returns the grammar associated to the specified key. ... *//** ******** ... *//** Removes the grammar associated to the specified key from the ... */// better give both grammars a shot...// class ShadowedGrammarPool// class CachingParserPool/** This is the main Xerces DOM parser class. It uses the abstract DOM ... */String USE_ENTITY_RESOLVER2;/** Feature identifier: EntityResolver2. *//** Property identifier: XML grammar pool. *//** Constructs a DOM parser using the specified parser configuration. *//** Constructs a DOM parser using the dtd/xml schema parser configuration. *//** Constructs a DOM parser using the specified symbol table. *//** Constructs a DOM parser using the specified symbol table and ... */boolean deferred/** Returns this parser's XMLParserConfiguration. *//** this is a direct call to this parser, not a subclass since ... *///fall back to the default configuration to handle the property// getXMLParserConfiguration():XMLParserConfiguration// class DOMParserimport LSException/** This is Xerces DOM Builder class. It uses the abstract DOM ... */// SAX & Xerces feature ids/** Feature id: validation. */String XMLSCHEMA;/** XML Schema validation */String XMLSCHEMA_FULL_CHECKING;/** XML Schema full checking *//** Dynamic validation *//** Feature identifier: disallow docType Decls. */// internal propertiesString PSVI_AUGMENT;boolean fNamespaceDeclarations;/** Include namespace declaration attributes in the document. * *///          LSParser// REVISIT: this value should be null by default and should be set during creation ofboolean fBusy;boolean abortNow;Thread currentThread;Vector<> fSchemaLocations;String fSchemaLocation;AbortHandler abortHandler;/** Constructs a DOM Builder using the standard parser configuration. *//** Constructs a DOM Builder using the specified parser configuration. */String[] domRecognizedFeaturesConstants.DOM_CHARSET_OVERRIDES_XML_ENCODINGConstants.DOM_SUPPORTED_MEDIATYPES_ONLYConstants.DOM_CERTIFIEDConstants.DOM_IGNORE_UNKNOWN_CHARACTER_DENORMALIZATIONS/** Constructs a DOM Builder using the specified symbol table. *//** Constructs a DOM Builder using the specified symbol table and ... */// DOMParser methods/** When the application provides a filter, the parser will call out to ... *//** Set parameters and properties */Constants.DOM_DISALLOW_DOCTYPEString normalizedNamenewTypeMismatchError(...)newFeatureNotFoundError(...)/** Look up the value of a feature or a property. */boolean infosetConstants.DOM_XMLDECL/** Parse an XML document from a location identified by an URI reference. ... */restoreHandlers(...)createLSException(...)LSException.PARSE_ERR/** Parse an XML document from a resource identified by an ... *//** Parse an XML document or fragment from a resource identified by an ... *//** NON-DOM: convert LSInput to XNIInputSource ... */new LSException(...)new AbortHandler(...)DOMParserImpl$AbortHandlerXMLDocumentSource documentSource;XMLDTDContentModelSource dtdContentSource;XMLDTDSource dtdSource;/* Copyright 2000-2005 The Apache Software Foundation. ... *///Schema validation is false by default and hence there is no//need to set it to false here.  Also, schema validation is//not a recognized feature for DTDConfiguration's and so//setting this feature here would result in a Configuration//Exception.// XML Schem validation// turn off deferred DOM// Set values so that the value of the// infoset parameter is true (its default value).// true: namespace-declarations, well-formed,// element-content-whitespace, comments, namespaces// false: validate-if-schema, entities,// datatype-normalization, cdata-sections// set other default values// REVISIT: by default Xerces assumes that input is certified.//          default is different from the one specified in the DOM spec// Xerces datatype-normalization feature is on by default// This is a recognized feature only for XML Schemas. If the// configuration doesn't support this feature, ignore it.// get state of namespace-declarations parameter.// DOM Filter// set features// setting those features to false is no-op// Setting false has no effect.// true: namespaces, namespace-declarations,// comments, element-content-whitespace// setting these features to true is no-op// REVISIT: implement "namespace-declaration" feature// Note: validation and dynamic validation are mutually exclusive//XSModel - turn on PSVI augmentation// Constants.DOM_CHARSET_OVERRIDES_XML_ENCODING feature,// Constants.DOM_SPLIT_CDATA feature,// or any Xerces feature// tokenize location string// turn off schema features// map to JAXP schemaLanguage// turn on schema features// Try to set the property.// If this is a boolean parameter a type mismatch should be thrown.// Parameter is not recognized// REVISIT: This is somewhat expensive to compute// but it's possible that the user has a reference// to the configuration and is changing the values// of these features directly on it.// This could be a recognized feature or property.// This isn't a feature; perhaps it's a property// Recognize Xerces features.// check properties// REVISIT: add Xerces recognized properties/features//If DOMParser insstance is already busy parsing another document when this// method is called, then raise INVALID_STATE_ERR according to DOM L3 LS spec//reset interrupt state// Consume this exception if the user// issued an interrupt or an abort.// REVISIT: need to implement.// all inputs are null// If parse operation is in progress then reset it// If not busy then this is noop// namespace declarations parameter has no effect if namespaces is false.// class DOMParserImplimport XMLDocumentScannerImplimport XMLNamespaceBinderimport XMLDTDProcessor/** This is the DTD-only parser configuration.  It extends the basic ... */Constants.DTD_PROCESSOR_PROPERTYString DTD_PROCESSOR;/** Property identifier: DTD loader. */// components (configurable)XMLDocumentScanner fScanner;XMLDTDProcessor fDTDProcessor;/** DTD Processor . *//** DTD Validator. */XMLNamespaceBinder fNamespaceBinder;/** Namespace binder. */createEntityManager(...)createErrorReporter(...)createDocumentScanner(...)createDTDProcessor(...)createDTDValidator(...)createNamespaceBinder(...)createDatatypeValidatorFactory(...)/** Configures the pipeline. */configureDTDPipeline(...)/** Creates an entity manager. *//** Creates an error reporter. */// createEntityManager():XMLEntityManager/** Create a document scanner. */// createErrorReporter():XMLErrorReporternew XMLDocumentScannerImpl(...)/** Create a DTD scanner. */// createDocumentScanner():XMLDocumentScanner/** Create a DTD loader . */// createDTDScanner():XMLDTDScannernew XMLDTDProcessor(...)/** Create a DTD validator. */// createDTDProcessor():XMLDTDProcessornew XMLDTDValidator(...)/** Create a namespace binder. */// createDTDValidator():XMLDTDValidatornew XMLNamespaceBinder(...)/** Create a datatype validator factory. */// createNamespaceBinder():XMLNamespaceBinder// createDatatypeValidatorFactory():DatatypeValidatorFactory//WARN_ON_DUPLICATE_ATTDEF,     // from XMLDTDScannerImpl//WARN_ON_UNDECLARED_ELEMDEF,   // from XMLDTDScannerImpl//ALLOW_JAVA_ENCODINGS,         // from XMLEntityManager// from XMLDTDScannerImpl//NOTIFY_BUILTIN_REFS,  // from XMLDocumentFragmentScannerImpl//NOTIFY_CHAR_REFS,         // from XMLDocumentFragmentScannerImpl//WARN_ON_DUPLICATE_ENTITYDEF,  // from XMLEntityManager//setFeature(WARN_ON_DUPLICATE_ATTDEF, false);  // from XMLDTDScannerImpl//setFeature(WARN_ON_UNDECLARED_ELEMDEF, false);  // from XMLDTDScannerImpl//setFeature(ALLOW_JAVA_ENCODINGS, false);      // from XMLEntityManager//setFeature(NOTIFY_BUILTIN_REFS, false);   // from XMLDocumentFragmentScannerImpl//setFeature(NOTIFY_CHAR_REFS, false);      // from XMLDocumentFragmentScannerImpl//setFeature(WARN_ON_DUPLICATE_ENTITYDEF, false);   // from XMLEntityManager// configure the pipeline and initialize the components// REVISIT: This should be better designed. In other words, we//          need to figure out what is the best way for people to//          re-use *most* of the standard configuration but do//          things common things such as remove a component (e.g.//          the validator), insert a new component (e.g. XInclude),//          etc... -Ac// filters// class DTDConfiguration/** fDTDScanner *//** getDTDGrammar ... */// getDTDGrammar// comment/** The start of the external subset. ... */// processingInstruction/** The end of the external subset. ... */// startExternalSubset// endExternalSubset// elementDecl// startAttlist// attributeDecl// endAttlist// externalEntityDecl// unparsedEntityDecl// notationDecl// startConditional// endConditional// endDTD/** A referenced element in a mixed content model. If the mixed content ... */// startContentModel/** The start of a children group. ... */// mixedElement/** A referenced element in a children content model. ... */// childrenStartGroup/** The separator between choices or sequences of a children content ... */// childrenElement/** The occurrence count for a child in a children content model. ... */// childrenSeparator/** The end of a children group. ... */// childrenOccurrence// childrenEndGroup// endContentModel// class DTDParserimport XMLNSDTDValidator/** This is configuration uses a scanner that integrates both scanning of the document ... *//** Document scanner that does namespace binding. *///          like DTD/Standard one?// REVISIT: should this configuration depend on the othersXMLDocumentScannerImpl fNonNSScanner;/** Default Xerces implementation of scanner */XMLDTDValidator fNonNSDTDValidator;/** DTD Validator that does not bind namespaces */setDTDValidator(...)/** Create a document scanner: this scanner performs namespace binding *//** Create a DTD validator: this validator performs namespace binding. */new XMLNSDTDValidator(...)// create components// add components// setup DTD pipeline// If schema validator was not in the pipeline insert it.// add schema component// add schema message formatter// class IntegratedParserConfiguration/** This is the non validating parser configuration. It extends the basic ... *///LOAD_EXTERNAL_DTD,    // from XMLDTDScannerImpl//WARN_ON_DUPLICATE_ENTITYDEF   // from XMLEntityManager//setFeature(WARN_ON_UNDECLARED_ELEMDEF, false);    // from XMLDTDScannerImpl//setFeature(LOAD_EXTERNAL_DTD, true);      // from XMLDTDScannerImpl// this configuration delays creation of the scanner// till it is known if namespace processing should be performed// create appropriate scanner// and register it as one of the components.// class NonValidatingConfiguration/** This is the main Xerces SAX parser class. It uses the abstract SAX ... *//** Constructs a SAX parser using the specified parser configuration. *//** Constructs a SAX parser using the dtd/xml schema parser configuration. *//** Constructs a SAX parser using the specified symbol table. *//** Constructs a SAX parser using the specified symbol table and ... */// class SAXParser/** This configuration allows Xerces to behave in a security-conscious manner; that is, ... */// create the SecurityManager property:// class SecurityConfiguration/** This is the "standard" parser configuration. It extends the DTD ... *//** feature identifier: XML Schema validation -- full checking *//** Feature identifier: validate annotations *//** XML Schema Validator. */// NOTE: These shouldn't really be here but since the XML Schema//       validator is constructed dynamically, its recognized//       features might not have been set and it would cause a//       not-recognized exception to be thrown. -Ac//       properties might not have been set and it would cause a// http://apache.org/xml/features/validation/schema//   Lets the user turn Schema validation support on/off.// activate full schema checking// Feature identifier: expose schema normalized value//  http://apache.org/xml/features/validation/schema/normalized-value// Feature identifier: send element default value via characters()// http://apache.org/xml/features/validation/schema/element-default// class StandardParserConfigurationimport XIncludeHandlerimport XIncludeNamespaceSupport/** This class is the configuration used to parse XML 1.0 and XML 1.1 documents ... */Constants.XINCLUDE_FIXUP_BASE_URIS_FEATUREConstants.XINCLUDE_FIXUP_LANGUAGE_FEATUREConstants.XINCLUDE_HANDLER_PROPERTYString XINCLUDE_FIXUP_BASE_URIS;/** Feature identifier: fixup base URIs. */String XINCLUDE_FIXUP_LANGUAGE;/** Feature identifier: fixup language. */String XINCLUDE_HANDLER;XIncludeHandler fXIncludeHandler;/** XInclude handler. */NamespaceSupport fNonXIncludeNSContext;/** Non-XInclude NamespaceContext. */XIncludeNamespaceSupport fXIncludeNSContext;/** XInclude NamespaceContext. */NamespaceContext fCurrentNSContext;/** Current NamespaceContext. */boolean fXIncludeEnabled;/** Flag indicating whether XInclude processsing is enabled. */XMLDocumentSource prevXMLDocumentHandler nextnew XIncludeHandler(...)addCommonComponent(...)new XIncludeNamespaceSupport(...)getFeatureState0(...)// If the XInclude handler was not in the pipeline insert it.// add XInclude component// Setup NamespaceContext//configure DTD pipeline// configure XML document pipeline: insert after DTDValidator and// before XML Schema validator// we don't have to worry about fSchemaValidator being null, since// super.configurePipeline() instantiated it if the feature was set// Otherwise, insert after the last component in the pipeline// configure XML 1.1. DTD pipeline/** This parser configuration includes an <code>XIncludeHandler</code> in the pipeline ... */// <init>(SymbolTable,XMLGrammarPool)}/** <p>An <code>XMLParserConfiguration</code> implements this interface ... */import XML11DocumentScannerImplimport XML11DTDProcessorimport XML11DTDValidatorimport XML11NSDTDValidator/** This class is the configuration used to parse XML 1.0 and XML 1.1 documents. ... */ArrayList<XMLComponent> fComponents;/** XML 1.0 Components. */ArrayList<XMLComponent> fXML11Components;/** XML 1.1. Components. */ArrayList<XMLComponent> fCommonComponents;/** Common components: XMLEntityManager, XMLErrorReporter, XMLSchemaValidator *//** The XML 1.0 Document scanner that does namespace binding. *//** The XML 1.0 Non-namespace implementation of scanner *//** The XML 1.0 DTD Validator: binds namespaces *//** The XML 1.0 DTD Validator that does not bind namespaces *//** The XML 1.0 DTD Processor . *//** The XML 1.1 datatype factory. * *//** The XML 1.1 document scanner that does namespace binding. * */XML11DocumentScannerImpl fXML11DocScanner;/** The XML 1.1 document scanner that does not do namespace binding. * */XML11NSDTDValidator fXML11NSDTDValidator;/** The XML 1.1 DTD validator that does namespace binding. * */XML11DTDValidator fXML11DTDValidator;/** The XML 1.1 DTD validator that does not do namespace binding. * */XML11DTDProcessor fXML11DTDProcessor;/** The XML 1.1 DTD processor. * */// Common componentsnew ArrayList<XMLComponent>(...)/** reset all XML 1.0 components before parsing and namespace context *//** reset all common components before parsing */// resetCommon()/** Configures the XML 1.1 pipeline. ... */new XML11DocumentScannerImpl(...)addXML11Component(...)new XML11DTDValidator(...)/** Adds common component to the parser configuration. This method will ... *//** Adds an XML 1.1 component to the parser configuration. This method will ... */// addCommonComponent(XMLComponent)// addXML11Component(XMLComponent)new XML11DTDProcessor(...)new XML11NSDTDValidator(...)/** Returns the state of a feature. This method calls getFeature() ... */// XML 1.0 specialized components// XML 1.1 specialized components// Common components for XML 1.1. and XML 1.0// forward it to common components// forward it to every common Component// forward it to every XML 1.1 component// ignore it// reset common components// setup XML 1.1 document pipeline// non namespace document pipeline// add XML Schema validator if needed// special performance feature: only component manager is allowed to set it.// class XML11Configuration/** This class is the DTD-only parser configuration ... */ArrayList<> fXML11Components;ArrayList<> fCommonComponents;/** Common components: XMLEntityManager, XMLErrorReporter */// class XML11DTDConfiguration/** This class is the non vlaidating parser configuration ... */// class XML11NonValidatingConfiguration/** This is a concrete vanilla XML parser class. It uses the abstract parser ... *//** Constructs a document parser using the default basic parser ... *//** Constructs a document parser using the specified parser configuration. *//** Constructs a document parser using the specified symbol table. */// <init>(ParserConfiguration)/** Constructs a document parser using the specified symbol table and ... */// class XMLDocumentParserimport XMLDTDLoader/** <p> This configuration provides a generic way of using ... */int BIG_PRIME;// times larger than normal) and see what happens...// potentially man parsers.  Start one as close to 2K (20// among// a larg(ish) prime to use for a symbol table to be sharedSynchronizedSymbolTable fStaticSymbolTable;// the static symbol table to be shared amongst parsersXMLGrammarPoolImpl fStaticGrammarPool;// the Grammar Pool to be shared similarly// schema full checking constant// variables needed for caching schema grammars.XMLDTDLoader fDTDLoader;// the DTD grammar loadernew XMLDTDLoader(...)/* lock the XMLGrammarPoolImpl object so that it does not ... */// <init>(SymbolTable,XMLGrammarPool, XMLComponentManager)/* clear the XMLGrammarPoolImpl object so that it does not ... */// lockGrammarPool()/* unlock the XMLGrammarPoolImpl object so that it ... */// clearGrammarPool()/** Parse a grammar from a location identified by an URI. ... */// unlockGrammarPool()parseGrammar(...)/** Parse a grammar from a location identified by an ... */parseXMLSchema(...)parseDTD(...)/* This method parses an XML Schema document. ... */// package-protected methods// parseGrammar(String, XMLInputSource):  GrammarXMLEntityResolver resolverString propPrefix/* This method parses an external DTD entity. */// parseXMLSchema(XMLInputSource) :  SchemaGrammar// REVISIT:  may need to add some features/properties// specific to this configuration at some point...// create and register missing components// and set up the DTD loader too:// by default, make all XMLGrammarPoolImpl's schema grammars available to fSchemaHandler// don't know this grammar...// Should check whether the grammar with this namespace is already in// the grammar resolver. But since we don't know the target namespace// of the document here, we leave such check to XSDHandler// by default, hand it off to the grammar pool// of the document here, we leave such check to the application...// parseXMLDTD(XMLInputSource) :  DTDGrammar// class XMLGrammarCachingConfiguration/** fDatatypeValidatorFactory *//** Construct an XMLGrammarParser with the specified symbol table ... */// class XMLGrammarParser/** <p> This class provides an easy way for a user to preparse grammars ... */Map<String,String> loaders// feature:  continue-after-fatal-error/** Property identifier: grammar pool . */Map<String,String> KNOWN_LOADERS;// the "built-in" grammar loadersMap<String,XMLGrammarLoader> fLoaders;// Map holding our loaders/** Constructs a preparser using the specified symbol table. ... */new HashMap<String,XMLGrammarLoader>(...)/* Register a type of grammar to make it preparsable.   If ... */String loaderNameXMLGrammarLoader gl// registerPreparser(String, XMLGrammarLoader):  boolean// preparseGrammar(String, XMLInputSource):  Grammar/** Sets the grammar pool. ... *//** Returns the registered grammar pool. */// setGrammarPool(XMLGrammarPool)// some custom work.// it's possible the application may want access to a certain loader to do// getGrammarPool():  XMLGrammarPool// to retrieve that loader and use the loader's setFeature method.// by a grammar loader of a particular type, it will have// an app needs to know if a particular feature is supported// registered loaders; it eats any resulting exceptions.  If// set a feature.  This method tries to set it on all// getLoader(String):  XMLGrammarLoaderEntry<String,XMLGrammarLoader> entryMap<>.Entry<String,XMLGrammarLoader>// in this class to set "standard" properties like error handler etc.</strong>// <p> <strong>An application should use the explicit method// to retrieve that loader and use the loader's setProperty method.// an app needs to know if a particular property is supported// set a property.  This method tries to set it on all//setFeature(String, boolean)// @return the value of the feature.// @param featureId the feature string to query.// @param type type of grammar to look for the feature in.// better make sure the loader exists and knows about this feature.// catches no exceptions--including NPE's--so the application had// get status of feature in a particular loader.  This//setProperty(String, Object)// @return the value of the property.// @param propertyId the property string to query.// @param type type of grammar to look for the property in.// by all loaders--the specific methods should be queried!</strong>// <strong>For standard properties--that will be supported// better make sure the loader exists and knows about this property.// get status of property in a particular loader.  This// getFeature (String, String):  boolean// those are all the basic properties...// none specified!// got one; just instantiate it...// were given one// make sure gl's been set up with all the "basic" properties:// potentially, not all will support this one...// too bad...// eat it up...// since our error reporter is a property we set later,// make sure features it understands are also set.// getProperty(String, String):  Object// class XMLGrammarPreparser/** Base class of all XML-related parsers. ... */XMLParserConfiguration fConfiguration;/** The parser configuration. */XMLSecurityManager securityManager;/** The XML Security Manager. */XMLSecurityPropertyManager securityPropertyManager;/** The XML Security Property Manager. *//** Query the state of a feature. */// parse(XMLInputSource)// save configuration// null indicates that the parser is called directly, initialize themimport XPointerHandler/** This parser configuration includes an <code>XPointerHandler</code> in the pipeline ... */Constants.XPOINTER_HANDLER_PROPERTYXPointerHandler fXPointerHandler;String XPOINTER_HANDLER;new XPointerHandler(...)//if (propertyId.equals(XINCLUDE_HANDLER)) {/** Wraps {@link XMLAttributes} and makes it look like ... *//** Sets the XML attributes to be wrapped. *//* Attributes methods *//* Attributes2 methods *//* AttributeList methods */// This hides the fact that internally we use null instead of empty string// SAX requires the URI to be a string or an empty string/** This class provides an implementation for Augmentations interface. ... */AugmentationsItemsContainer fAugmentationsContainer;/** Add additional information identified by a key to the Augmentations structure. ... */isFull(...)expand(...)/** Get information identified by a key from the Augmentations structure ... *//** Remove additional info from the Augmentations structure ... *//** Returns an enumeration of the keys in the Augmentations structure *//** Remove all objects from the Augmentations structure. */AugmentationsImpl$AugmentationsItemsContainerAugmentationsImpl$SmallContainerint SIZE_LIMIT;...[] fAugmentations;int fNumEntries;new SmallContainerKeyEnumeration(...)LargeContainer expandedContainerAugmentationsImpl$SmallContainer$SmallContainerKeyEnumeration...[] enumArray;enumArray.lengthObject nextValAugmentationsImpl$LargeContainerMap<Object,Object> fAugmentations;enumeration(...)/** This class wraps DOM entity resolver to XNI entity resolver. ... *//** XML 1.0 type constant according to DOM L3 LS CR spec "http://www.w3.org/TR/2003/CR-DOM-Level-3-LS-20031107" */String XSD_TYPE;/** XML Schema constant according to DOM L3 LS CR spec "http://www.w3.org/TR/2003/CR-DOM-Level-3-LS-20031107" */// LSResourceResolver/** Resolves an external parsed entity. If the entity cannot be ... */// XMLEntityResolver methodsLSInput inputSource/** Determines the type of resource being resolved * */// resolveEntity(String,String,String):XMLInputSource// resolve entity using DOM entity resolver// For entity resolution the type of the resource would be  XML TYPE// DOM L3 LS spec mention only the XML 1.0 recommendation right now// unable to resolve entity// getType(XMLResourceIdentifier):String// DOMEntityResolverWrapperimport DOMLocatorImpl//          I think we can avoid this indirection if we modify XMLErrorReporter. --el//          sends one call back to the application//          DOMErrorHandlerWrapper catches calls, copies info from XMLParserException and//          and goes via switch to send errors.//          XMLErrorReport.reportError creates XMLParserException (by wrapping all info)// REVISIT: current implementations wraps error several times:/** This class handles DOM errors . ... */new XMLErrorCode(...)DOMErrorHandler fDomErrorHandler;// It keeps the reference of DOMErrorHandler of applicationboolean eStatus;// Error StatusPrintWriter fOut;// Print writer// @see DOMNormalizer.// some components may set error nodeXMLErrorCode fErrorCode;/** Error code for comparisons. * */DOMErrorImpl fDOMError;// Default constructor //** Sets the DOM error handler. */// DOMErrorHandlerWrapper(DOMErrorHandler domErrorHandler)/** Reports a warning. Warnings are non-fatal and can be safely ignored ... */// XMLErrorHandler methods//getErrorHandler()DOMLocatorImpl locatorfDOMError.fLocatorfDOMError.fSeverityfDOMError.fExceptionfDOMError.fTypefDOMError.fRelatedDatafDOMError.fMessagelocator.fColumnNumberlocator.fLineNumberlocator.fUtf16Offsetlocator.fUri/** Reports an error. Errors are non-fatal and usually signify that the ... */// warning(String,String,XMLParseException)/** Report a fatal error. Fatal errors usually occur when the document ... */// error(String,String,XMLParseException)String domErrorTypegetDOMErrorType(...)// fatalError(String,String,XMLParseException)printError(...)/** Prints the error message. */int severitygetSeverity(...)DOMLocator locatorgetRelatedNode(...)getUri(...)getByteOffset(...)getUtf16Offset(...)DOMErrorHandlerWrapper$DOMErrorTypeMap/** A convenience class for converting between internal ... */// printError(DOMError)Map<XMLErrorCode,String> aDOMErrorTypeTablenew HashMap<XMLErrorCode,String>(...)Map<XMLErrorCode,String> fgDOMErrorTypeTable;/** Map for converting internal error codes to DOM error types. * */// REVISIT: May need to lookup from DOMErrorTypeMap in the future.//REVISIT: Abort processing if fatal error, do we need to??// initialize error type table: internal error codes (represented by domain and key) need to be mapped to a DOM error type.// REVISIT: do well-formedness issues involving XML declaration <?xml ... ?> need to be added to hash table (no XML declaration node in DOM, but Document includes xmlEncoding, xmlStandalone, xmlVersion, etc.// e.g. in Processing Instruction// InvalidCharInXMLDecl omitted because XML declaration is not a DOM Node// considered error in name of node (which follows !DOCTYPE)// considered error in name of node (which follows !ENTITY)// considered error in name of node (which follows !ENTITY %)// considered error in name of node// considered error in name of node, which follows !NOTATION// REVISIT: do EntityNotDeclared, RecursiveReference, RecursiveGeneralReference, RecursivePEReference belong here?// class DOMErrorHandlerWrapper/** <p>An <code>XMLInputSource</code> analogue to <code>javax.xml.transform.dom.DOMSource</code>.</p> */Node fNode;getSystemIdFromNode(...)NoSuchMethodError e// If the DOM implementation is DOM Level 2// then a NoSuchMethodError will be thrown.// Just ignore it.// There was a failure for some other reason// Ignore it as well./** Some useful utility methods. ... *//** Copies the source tree into the specified place in a destination ... */Document factoryboolean domimplNode start/** Finds and returns the first child element node. */// copyInto(Node,Node)/** Finds and returns the first visible child element node. */// getFirstChildElement(Node):Element/** Finds and returns the last child element node. ... *//** Finds and returns the last visible child element node. */// getLastChildElement(Node):Element/** Finds and returns the last visible child element node. ... *//** Finds and returns the next sibling element node. */// get next visible (un-hidden) node.// getNextSiblingElement(Node):Element// get next visible (un-hidden) node, overload previous method for non Xerces node impl// getNextSiblingdElement(Node):Element// set this Node as being hidden// set this Node as being hidden, overloaded method// setHidden(node):void// set this Node as being visible// set this Node as being visible, overloaded method// setVisible(node):void// is this node hidden?getReadOnly(...)// is this node hidden? overloaded method// isHidden(Node):boolean/** Finds and returns the first child node with the given name. *//** Finds and returns the last child node with the given name. */// getFirstChildElement(Node,String):Element/** Finds and returns the next sibling node with the given name. */// getLastChildElement(Node,String):Element/** Finds and returns the first child node with the given qualified name. */// getNextSiblingdElement(Node,String):ElementString childURI/** Finds and returns the last child node with the given qualified name. */// getFirstChildElementNS(Node,String,String):Element/** Finds and returns the next sibling node with the given qualified name. */// getLastChildElementNS(Node,String,String):ElementString siblingURI// getNextSiblingdElementNS(Node,String,String):ElementelemNames.length// getFirstChildElement(Node,String[]):Element// getLastChildElement(Node,String[]):Element// getNextSiblingdElement(Node,String[]):Element// getFirstChildElementNS(Node,String[][]):Element// getLastChildElementNS(Node,String[][]):Element/** Finds and returns the first child node with the given name and ... */// getNextSiblingdElementNS(Node,String[][]):Element/** Finds and returns the last child node with the given name and ... */// getFirstChildElement(Node,String,String,String):Element/** Finds and returns the next sibling node with the given name and ... */// getLastChildElement(Node,String,String,String):Element/** Returns the concatenated child text of the specified node. ... */// getNextSiblingElement(Node,String,String,String):ElementgetChildText(...)// return the name of this element// getChildText(Node):String/** returns local name of this element if not null, otherwise ... */// getLocalName(Element):  String// get the Document of which this Node is a part// getParent(Element):Element// return this Document's root node// getDocument(Node):Document// return the right attribute node// some methods for handling attributes:// getRoot(Document(:  Element// getAttr(Element, String):Attr// get all the attributes for an Element// getAttrNS(Element, String):AttrAttr[] attrArray// get attribute's value// getAttrs(Element):  Attr[]// with the given name// return the value of the attribute of the given element// exist on an element.  Beware!// null!) when the attribute with the specified name does not// work, the next two methods return the empty string (not// It is noteworthy that, because of the way the DOM specs// getValue(Attr):String// return the prefix// getAttrValueNS(Element, String):Attr// return the namespace URI// return annotation// return synthetic annotation/** Creates a DOMException. On J2SE 1.4 and above the cause for the exception will be set. */DOMException deThrowableMethods.fgThrowableMethodsAvailableThrowableMethods.fgThrowableInitCauseMethod/** Creates an LSException. On J2SE 1.4 and above the cause for the exception will be set. */LSException lseDOMUtil$ThrowableMethods/** Holder of methods from java.lang.Throwable. */Method fgThrowableInitCauseMethod;// Method: java.lang.Throwable.initCause(java.lang.Throwable)boolean fgThrowableMethodsAvailable;// Flag indicating whether or not Throwable methods available.// get node factory// placement variables// traverse source tree// copy this node// iterate over children// advance// search for node// concatenate children text// return text value// Something went wrong. There's not much we can do about it.// Attempt to get methods for java.lang.Throwable on class initialization.// ClassNotFoundException, NoSuchMethodException or SecurityException// Whatever the case, we cannot use java.lang.Throwable.initCause(java.lang.Throwable).// class DOMUtil/** <p>Used to format JAXP 1.3 Datatype API error messages using a specified locale.</p> ... */String BASE_NAME;/** Default error handler. ... *//** Print writer. *//** Constructs an error handler that prints error messages to ... *//** Constructs an error handler that prints error messages to the ... *//** Warning. */// ErrorHandler methods// <init>(PrintWriter)/** Error. */// warning(XMLParseException)/** Fatal error. */// error(XMLParseException)// fatalError(XMLParseException)// printError(String,SAXParseException)// class DefaultErrorHandlerErrorHandler theInstance;/** Use this singleton instance. *//** EncodingMap is a convenience class which handles conversions between ... */Map<String,String> aIANA2JavaMapMap<String,String> aJava2IANAMapMap<String,String> fIANA2JavaMap;/** fIANA2JavaMap */Map<String,String> fJava2IANAMap;/** fJava2IANAMap */// <clinit>()/** Returns the Java encoding name for the specified IANA encoding name. ... *//** Returns the IANA encoding name for the specified Java encoding name. ... */// getIANA2JavaMapping(String):String// add IANA to Java encoding mappings.// is this an error???// Add support for Cp1252 and its friends// added since this encoding only differs w.r.t. presentation// support for 1047, as proposed to be added to the// IANA registry in// http://lists.w3.org/Archives/Public/ietf-charset/2002JulSep/0049.html// Adding new aliases as proposed in// http://lists.w3.org/Archives/Public/ietf-charset/2002JulSep/0058.html//   j:CNS11643 -> EUC-TW?//   ISO-2022-CN? ISO-2022-CN-EXT?// add Java to IANA encoding mappings//aJava2IANAMap.put("8859_1",    "US-ASCII"); // ?// proposed addition (see above for details):// getJava2IANAMapping(String):String// class EncodingMapimport ExternalSubsetResolverimport XMLEntityDescription/** <p>This class wraps a SAX entity resolver (EntityResolver2) in an XNI entity resolver.</p> ... */EntityResolver2 fEntityResolver;/** An instance of SAX2 Extensions 1.1's EntityResolver2. *//** <p>Creates a new instance wrapping the given SAX entity resolver.</p> ... *//** <p>Sets the SAX entity resolver wrapped by this object.</p> ... */// <init>(EntityResolver2)/** <p>Returns the SAX entity resolver wrapped by this object.</p> ... */// setEntityResolver(EntityResolver2)// getEntityResolver():EntityResolver2createXMLInputSource(...)// getExternalSubset(XMLDTDDescription):XMLInputSource/** Creates an XMLInputSource from a SAX InputSource. */// Resolve using EntityResolver2// error resolving external subset// unable to resolve external subset// When both pubId and sysId are null, the user's entity resolver// can do nothing about it. We'd better not bother calling it.// This happens when the resourceIdentifier is a GrammarDescription,// which describes a schema grammar of some namespace, but without// any schema location hint. -Sg// error resolving entity// createXMLInputSource(InputSource,String):XMLInputSource// class EntityResolver2Wrapper/** This class wraps a SAX entity resolver in an XNI entity resolver. ... */EntityResolver fEntityResolver;/** The SAX entity resolver. *//** Wraps the specified SAX entity resolver. *//** Sets the SAX entity resolver. */// <init>(EntityResolver)/** Returns the SAX entity resolver. */// resolve entity using SAX entity resolver/** Wraps {@link XMLErrorHandler} and make it look like a SAX {@link ErrorHandler}. ... */XMLErrorHandler eh(...).fErrorHandler// if an XNIException is thrown, just let it go.// REVISIT: is this OK? or should we try to wrap it into SAXException?/** This class wraps a SAX error handler in an XNI error handler. ... *//** The SAX error handler. *//** Wraps the specified SAX error handler. *//** Sets the SAX error handler. */// <init>(ErrorHandler)/** Returns the SAX error handler. */SAXParseException saxExceptioncreateSAXParseException(...)SAXParseException e/** Creates a SAXParseException from an XMLParseException. *//** Creates an XMLParseException from a SAXParseException. */// createSAXParseException(XMLParseException):SAXParseExceptionString fPublicIdString fExpandedSystemIdint fLineNumberint fColumnNumberXMLLocator locationnew XMLLocator(...) { ... }ErrorHandlerWrapper$1/** Creates an XNIException from a SAXException. ... */// createXMLParseException(SAXParseException):XMLParseException// createXNIException(SAXException):XMLParseException// class ErrorHandlerWrappernew FeatureState(...)Status.SETStatus.UNKNOWNStatus.RECOGNIZEDStatus status;boolean state;FeatureState SET_ENABLED;FeatureState SET_DISABLED;FeatureState UNKNOWN;FeatureState RECOGNIZED;FeatureState NOT_SUPPORTED;FeatureState NOT_RECOGNIZED;FeatureState NOT_ALLOWED;this.status/* $Id: FeatureState.java 3024 2011-03-01 03:46:13Z joehw $ *//** This class represents an input source for an XML resource ... */boolean fFollowRedirects;/** Preference for whether HTTP redirects should be followed. * */Map<String,String> fHTTPRequestProperties;/** HTTP request properties. * *//** Constructs an input source from a XMLResourceIdentifier ... */// <init>(XMLResourceIdentifier)// <init>(String,String,String,InputStream,String)/** Returns the preference whether HTTP redirects should ... */// <init>(String,String,String,Reader,String)/** Sets the preference whether HTTP redirects should ... */// getFollowHTTPRedirects():boolean/** Returns the value of the request property ... */// setFollowHTTPRedirects(boolean)/** Returns an iterator for the request properties this ... */// getHTTPRequestProperty(String):String/** Sets the value of the request property ... */// getHTTPRequestProperties():Iterator// setHTTPRequestProperty(String,String)// class HTTPInputSource/** A simple integer based stack. ... *//** Peeks at the top of the stack. *//** Returns the element at the specified depth in the stack. *//** Prints the stack. */// class IntStack/** <p>A read-only XNI wrapper around a JAXP NamespaceContext.</p> ... */List<> fPrefixes;Vector<> fAllPrefixes;int fCurrentContext;/* NamespaceContext methods */new TreeSet<>(...)int[] contextarray// There may be duplicate prefixes in the list so we// first transfer them to a set to ensure uniqueness.// extend the array, if necessary// JAXPNamespaceContextWrapper/** Wraps {@link XMLLocator} and make it look like a SAX {@link Locator}. ... *//** Wraps SAX {@link Locator} into Xerces {@link XMLLocator}. ... *//** <p>Returns the character offset, ... *//** <p>Returns the XML version of the current entity.</p> ... *//** This interface provides a generic message formatting mechanism and ... */// interface MessageFormatter/** Writing a wrapper to re-use most of the namespace functionality ... *//** TODO: Namespace doesn't give information giving multiple prefixes for ... */Vector<> vectorgetPrefixes(...)/** This method supports all functions in the NamespaceContext utility class *//** Namespace support for XML document handlers. This class doesn't ... *//** The top of the namespace information array. *//** Context indexes. This array contains indexes into the namespace ... *///       being at least 1. -Ac// NOTE: The constructor depends on the initial context size/** The current context. */...[] fPrefixes;/** Constructs a namespace context object and initializes it with ... */Enumeration<> prefixes// <init>(NamespaceContext)// reset(SymbolTable)// declarePrefix(String,String):boolean// getURI(String):String// getPrefix(String):String// getDeclaredPrefixCount():int// getDeclaredPrefixAt(int):Stringboolean uniquefPrefixes.lengthString[] prefixesnew IteratorPrefixes(...)//getPrefixesnew Prefixes(...)Vector<> prefixList/** Checks whether a binding or unbinding for ... *//* non-NamespaceContext methods */NamespaceSupport$IteratorPrefixes...[] prefixes;/** Constructor for Prefixes. */this.prefixesNamespaceSupport$Prefixes// copy declaration in the context// reset namespace and context info// bind "xml" prefix to the XML uri// bind "xmlns" prefix to the XMLNS uri//++fCurrentContext;//System.out.println("calling push context, current context = " + fCurrentContext);//System.out.println("Calling popContext, fCurrentContext = " + fCurrentContext);// ignore "xml" and "xmlns" prefixes// see if prefix already exists in current context// REVISIT: [Q] Should the new binding override the//          previously declared binding or should it//          it be ignored? -Ac// NOTE:    The SAX2 "NamespaceSupport" helper allows//          re-bindings with the new binding overwriting//          the previous binding. -Ac// find prefix in current context// find uri in current context// uri not found// resize prefix array// find prefix in context/** This class implements the basic operations for managing parser ... */Set<String> fRecognizedProperties;Map<String,Object> fProperties;/** Properties. */Set<String> fRecognizedFeatures;Map<String,Boolean> fFeatures;/** Features. */XMLComponentManager fParentSettings;/** Parent parser configuration settings. *//** Constructs a parser configuration settings object with a ... *//** Allows a parser to add parser specific features to be recognized ... */// <init>(XMLComponentManager)int featureIdsCount// addRecognizedFeatures(String[])FeatureState checkStatecheckState.status/** Allows a parser to add parser specific properties to be recognized ... */// addRecognizedProperties(String[])PropertyState checkState// XMLComponentManager methodsObject propertyValue/** Check a feature. If feature is known and supported, this method simply ... */FeatureState.NOT_RECOGNIZEDPropertyState.NOT_RECOGNIZED// create storage for recognized features and properties// save parent// check and store// check feature// TODO: reasonable default?// class ParserConfigurationSettingsimport Random/** Fills an array with a random sequence of prime numbers. */...[] PRIMES;Random rnew Random(...)arrayToFill.lengthnextInt(...)PRIMES.lengthnew PropertyState(...)Object state;PropertyState UNKNOWN;PropertyState RECOGNIZED;PropertyState NOT_SUPPORTED;PropertyState NOT_RECOGNIZED;PropertyState NOT_ALLOWED;/* $Id: PropertyState.java 3024 2011-03-01 03:46:13Z joehw $ */import WrappedSAXException/** Receves SAX {@link ContentHandler} events ... */this.fCoreXMLDocumentHandler fCore;NamespaceSupport nsContext;SymbolTable symbolTable;// ContentHandler implementationXMLLocator xmlLocatornew LocatorWrapper(...)WrappedSAXException ee.exceptioncreateQName(...)createAttributes(...)createXMLString(...)/** Creates a QName object. *//** Symbolizes the specified string. */XMLAttributes xa;/** only one instance of XMLAttributes is used. *//** Creates an XMLAttributes object. */// some SAX source doesn't provide a locator,// in which case we assume no line information is available// and use a dummy locator. With this, downstream components// can always assume that they will get a non-null Locator.// if naemspace processing is turned off, local could be "".// in that case, treat everything to be in the no namespace.// XNI uses null whereas SAX uses the empty string// with my patch// return new XMLString(str);// for now/** <p>An <code>XMLInputSource</code> analogue to <code>javax.xml.transform.sax.SAXSource</code>.</p> */XMLReader fXMLReader;InputSource fInputSource;/** Sets the public identifier. ... *//** Sets the system identifier. ... *//** Sets the byte stream. If the byte stream is not already opened ... *//** Sets the character stream. If the character stream is not already ... */// setByteStream(InputStream)/** Sets the encoding of the stream. ... */// setCharacterStream(Reader)/** <p>A light wrapper around a SAX locator. This is useful ... */Locator fLocator;Locator2 fLocator2;/* XMLLocator methods */// SAXLocatorWrapper/** Used to format SAX error messages using a specified locale. ... *//** This class is a container for parser settings that relate to ... */int DEFAULT_ENTITY_EXPANSION_LIMIT;// default value for entity expansion limitint DEFAULT_MAX_OCCUR_NODE_LIMIT;/** Default value of number of nodes created. * */int DEFAULT_ELEMENT_ATTRIBUTE_LIMIT;int entityExpansionLimit;/** Entity expansion limit. * */int maxOccurLimit;/** W3C XML Schema maxOccurs limit. * */int fElementAttributeLimit;/** Default constructor.  Establishes default values ... */// all known security holes.// default constructor.  Establishes default values for/** <p>Sets the number of entity expansions that the ... *//** <p>Returns the number of entity expansions ... *//** <p>Sets the limit of the number of content model nodes ... *//** <p>Returns the limit of the number of content model nodes ... */Constants.ENTITY_EXPANSION_LIMITConstants.MAX_OCCUR_LIMITConstants.ELEMENT_ATTRIBUTE_LIMIT//We are reading system properties only once ,//at the time of creation of this object ,// class SecurityManager/** Shadowed symbol table. ... *//** Main symbol table. *//** Constructs a shadow of the specified symbol table. *//** Adds the specified symbol to the symbol table and returns a ... */// SymbolTable methodscontainsSymbol(...)// addSymbol(String)/** Returns a hashcode value for the specified symbol. The value ... */// addSymbol(char[],int,int):String/** Returns a hashcode value for the specified symbol information. ... */// hash(String):int// hash(char[],int,int):int// class ShadowedSymbolTable/** <p>An <code>XMLInputSource</code> analogue to <code>javax.xml.transform.stax.StAXSource</code>.</p> ... */XMLEventReader fEventReader;boolean fConsumeRemainingContent;getEventReaderSystemId(...)/** <p>A light wrapper around a StAX location. This is useful ... */Location fLocation;// StAXLocationWrappernew Status(...)Status SET;Status UNKNOWN;Status RECOGNIZED;Status NOT_SUPPORTED;Status NOT_RECOGNIZED;Status NOT_ALLOWED;boolean isExceptional;this.isExceptional/* $Id: Status.java 3024 2011-03-01 03:46:13Z joehw $ *//** This class is an unsynchronized hash table primary used for String ... *//** Default table size. */int MAX_HASH_COLLISIONS;/** Maximum hash collisions per bucket. */int MULTIPLIERS_SIZE;int MULTIPLIERS_MASK;int fTableSize;/** Actual table size * */...[] fBuckets;/** Buckets. */int fNum;/** Number of elements. */...[] fHashMultipliers;/** Array of randomly selected hash function multipliers or <code>null</code> ... *//** Constructs a key table with the default size. *//** Constructs a key table with a given size. ... *//** Adds the key/value mapping to the key table. If the key already exists, ... */int collisionCountint bucketentry.keyentry.valuerebalance(...)/** Get the value associated with the given key. ... *//** Get the number of key/value pairs stored in this table. ... *//** Add all values to the given array. The array must have enough entry. ... *//** Return key/value pairs of all entries in the map *//** Make a clone of this object. */SymbolHash newTablenewTable.fNumnewTable.fHashMultipliersnewTable.fBuckets/** Remove all key/value association. This tries to save a bit of GC'ing ... */// clear():  void/** Returns a hashcode value for the specified key. ... */hash0(...)// hash(Object):intint[] multipliers/** Increases the capacity of and internally reorganizes this ... */// hash0(String):intrehashCommon(...)fBuckets.length/** Randomly selects a new hash function and reorganizes this SymbolHash ... */generateSequence(...)Entry[] oldTableEntry[] newTableEntry old/** This class is a key table entry. Each entry acts as a node ... */// key/value/** The next entry. */// search for identical key// replace old value// Rehash the table if the number of entries// would exceed the number of buckets.// Select a new hash function and rehash the table if// MAX_HASH_COLLISIONS is exceeded.// create new entry// entry// class SymbolHash/** This class is a symbol table implementation that guarantees that ... *//** Maximum hash collisions per bucket for a table with load factor == 1. *//** actual table size */int fThreshold;/** The table is rehashed when its size exceeds this threshold.  (The ... */float fLoadFactor;/** The load factor for the SymbolTable. */int fCollisionThreshold;/** A new hash function is selected and the table is rehashed when ... *//** Constructs a new, empty SymbolTable with the specified initial ... *//** Constructs a new, empty SymbolTable with the specified initial capacity ... *//** Constructs a new, empty SymbolTable with a default initial capacity (101) ... */entry.symboladdSymbol0(...)// addSymbol(String):String// addSymbol0(String,int,int):Stringentry.characters.lengthentry.characters// addSymbol0(char[],int,int,int,int):String// hash0(char[],int,int):int/** Randomly selects a new hash function and reorganizes this SymbolTable ... */e.symbol/** Returns true if the symbol table already contains the specified ... */// containsSymbol(String):boolean/** This class is a symbol table entry. Each entry acts as a node ... */// containsSymbol(char[],int,int):booleanString symbol;...[] characters;/** Symbol characters. This information is duplicated here for ... *//** Constructs a new entry from the specified symbol and next entry ... */this.symbolcharacters.length/** Constructs a new entry from the specified symbol information and ... */// search for identical symbol// the collision threshold is exceeded.// add new entry// class SymbolTable/** Synchronized symbol table. ... *//** Constructs a synchronized symbol table. */// construct synchronized symbol table of default size// construct synchronized symbol table of given size// init(int)// class SynchronizedSymbolTable// XMLDocumentHandler implementationURI$MalformedURIException/** ***************************************************************** ... *//** **************************************************************** ... *//** *************************************************************** ... */...[] fgLookupTable;int RESERVED_CHARACTERS;//RFC 2732 added '[' and ']' as reserved characters/** reserved characters ;/?:@&=+$,[] *//** Character Classes */int MARK_CHARACTERS;/** URI punctuation mark characters: -_.!~*'() - these, combined with ... */int SCHEME_CHARACTERS;/** scheme can be composed of alphanumerics and these characters: +-. */int USERINFO_CHARACTERS;/** userinfo can be composed of unreserved, escaped and these ... */int ASCII_ALPHA_CHARACTERS;/** ASCII letter characters */int ASCII_DIGIT_CHARACTERS;/** ASCII digit characters */int ASCII_HEX_CHARACTERS;/** ASCII hex characters */int PATH_CHARACTERS;/** Path characters */int MASK_ALPHA_NUMERIC;/** Mask for alpha-numeric characters */int MASK_UNRESERVED_MASK;/** Mask for unreserved characters */int MASK_URI_CHARACTER;/** Mask for URI allowable characters except for % */int MASK_SCHEME_CHARACTER;/** Mask for scheme characters */int MASK_USERINFO_CHARACTER;/** Mask for userinfo characters */int MASK_PATH_CHARACTER;/** Mask for path characters */String m_scheme;/** Stores the scheme (usually the protocol) for this URI. */String m_userinfo;/** If specified, stores the userinfo for this URI; otherwise null */String m_host;/** If specified, stores the host for this URI; otherwise null */int m_port;/** If specified, stores the port for this URI; otherwise -1 */String m_regAuthority;/** If specified, stores the registry based authority for this URI; otherwise -1 */String m_path;/** If specified, stores the path for this URI; otherwise null */String m_queryString;/** If specified, stores the query string for this URI; otherwise ... */String m_fragment;/** If specified, stores the fragment for this URI; otherwise null *//** Construct a new and uninitialized URI. *//** Construct a new URI from another URI. All fields for this URI are ... *//** Construct a new URI from a URI specification string. If the ... *//** Construct a new URI from a base URI and a URI specification string. ... *//** Construct a new URI that does not follow the generic URI syntax. ... */setScheme(...)setPath(...)/** Construct a new URI that follows the generic URI syntax from its ... */setUserinfo(...)setQueryString(...)setFragment(...)/** Initialize all fields of this URI from another URI. ... */getUserinfo(...)getRegBasedAuthority(...)getQueryString(...)getFragment(...)/** Initializes this URI from a base URI and a URI specification string. ... */String uriSpecint uriSpecLenint colonIdxint searchFromint slashIdxint queryIdxint fragmentIdxinitializeScheme(...)int startPoschar testCharinitializeAuthority(...)initializePath(...)/** Absolutize URI with given base URI. ... */String basePathint segIndexString tempStringint lastSlashconcat(...)/** Initialize the scheme for this URI from a URI string spec. ... */String scheme/** Initialize the authority (either server or registry based) ... */String userinfoboolean hasPortString portStrisValidServerBasedAuthority(...)isValidRegistryBasedAuthority(...)/** Determines whether the components host, port, and user info ... */isWellFormedAddress(...)isHex(...)isUserinfoCharacter(...)/** Determines whether the given string is a registry based authority. ... */isPathCharacter(...)/** Initialize the path for this URI from a URI string spec. ... */isURICharacter(...)/** Get the scheme for this URI. ... *//** Get the scheme-specific part for this URI (everything following the ... */StringBuilder schemespec/** Get the userinfo for this URI. ... *//** Get the host for this URI. ... *//** Get the port for this URI. ... *//** Get the registry based authority for this URI. ... *//** Get the authority for this URI. ... */StringBuilder authority/** Get the path for this URI (optionally with the query string and ... */StringBuilder pathString/** Get the path for this URI. Note that the value returned is the path ... *//** Get the query string for this URI. ... *//** Get the fragment for this URI. ... *//** Set the scheme for this URI. The scheme is converted to lowercase ... */isConformantSchemeName(...)/** Set the userinfo for this URI. If a non-null value is passed in and ... *//** <p>Set the host for this URI. If null is passed in, the userinfo ... *//** Set the port for this URI. -1 is used to indicate that the port is ... *//** <p>Sets the registry based authority for this URI.</p> ... *//** Set the path for this URI. If the supplied path is null, then the ... *//** Append to the end of the path of this URI. If the current path does ... */isURIString(...)/** Set the query string for this URI. A non-null value is valid only ... */isGenericURI(...)/** Set the fragment for this URI. A non-null value is valid only ... *//** Determines if the passed-in Object is equivalent to this URI. ... */URI testURItestURI.m_schemetestURI.m_userinfotestURI.m_hosttestURI.m_porttestURI.m_pathtestURI.m_queryStringtestURI.m_fragmentthis.m_schemethis.m_userinfothis.m_hostthis.m_portthis.m_paththis.m_queryStringthis.m_fragment/** Get the URI as a string specification. See RFC 2396 Section 5.2. ... */StringBuilder uriSpecStringgetSchemeSpecificPart(...)/** Get the indicator as to whether this URI uses the "generic URI" ... *//** Returns whether this URI represents an absolute URI. ... *//** Determine whether a scheme conforms to the rules for a scheme name. ... */int schemeLengthisAlpha(...)isSchemeCharacter(...)/** Determine whether a string is syntactically capable of representing ... */isWellFormedIPv6Reference(...)isWellFormedIPv4Address(...)int labelCharCountisAlphanum(...)/** <p>Determines whether a string is an IPv4 address as defined by ... */int numDotschar second/** <p>Determines whether a string is an IPv6 reference as defined ... */int[] counterint prevCountscanHexSequence(...)/** Helper method for isWellFormedIPv6Reference which scans the ... */int back/** Determine whether a char is a digit. ... *//** Determine whether a character is a hexadecimal character. ... *//** Determine whether a char is an alphabetic character: a-z or A-Z ... *//** Determine whether a char is an alphanumeric: 0-9, a-z or A-Z ... *//** Determine whether a character is a reserved character: ... *//** Determine whether a char is an unreserved character. ... *//** Determine whether a char is a URI character (reserved or ... *//** Determine whether a char is a scheme character. ... *//** Determine whether a char is a userinfo character. ... *//** Determine whether a char is a path character. ... *//** Determine whether a given string contains only URI characters (also ... */// Add ASCII Digits and ASCII Hex Numbers// Add ASCII Letters and ASCII Hex Numbers// Add ASCII Letters// Add Reserved Characters// Add Mark Characters// Add Scheme Characters// Add Userinfo Characters// Add Path Characters// just make a copy of the base if spec is empty// Check for scheme, which must be before '/', '?' or '#'.// search backwards starting from character before ':'.// A standalone base is a valid URI according to spec// Neither 'scheme:' or 'scheme:#fragment' are valid URIs.// Two slashes means we may have authority, but definitely means we're either// matching net_path or abs_path. These two productions are ambiguous in that// every net_path (except those containing an IPv6Reference) is an abs_path.// RFC 2396 resolves this ambiguity by applying a greedy left most matching rule.// Try matching net_path first, and if that fails we don't have authority so// then attempt to match abs_path.// net_path = "//" authority [ abs_path ]// abs_path = "/"  path_segments// Authority will be everything up to path, query or fragment// Attempt to parse authority. If the section is an empty string// this is a valid server based authority, so set the host to this// If we didn't find authority we need to back up. Attempt to// match against abs_path next.// Resolve relative URI to base URI - see RFC 2396 Section 5.2// In some cases, it might make more sense to throw an exception// (when scheme is specified is the string spec and the base URI// is also specified, for example), but we're just following the// RFC specifications//Same as java.net.URI:// DEVIATION: Allow empty authority prior to non-empty// path, query component or fragment identifier// check to see if this is the current doc - RFC 2396 5.2 #2// note that this is slightly different from the RFC spec in that// we don't include the check for query string being null// - this handles cases where the urispec is just a query// string or a fragment (e.g. "?y" or "#s") -// see <http://www.ics.uci.edu/~fielding/url/test1.html> which// identified this as a bug in the RFC// check for scheme - RFC 2396 5.2 #3// if we found a scheme, it means absolute URI, so we're done// check for authority - RFC 2396 5.2 #4// if we found a host, then we've got a network path, so we're done// check for absolute path - RFC 2396 5.2 #5// if we get to this point, we need to resolve relative path// RFC 2396 5.2 #6// 6a - get all but the last segment of the base URI path// 6b - append the relative URI path// 6c - remove all "./" where "." is a complete path segment// 6d - remove "." if path ends with "." as a complete path segment// 6e - remove all "<segment>/../" where "<segment>" is a complete// path segment not equal to ".."// 6f - remove ending "<segment>/.." where "<segment>" is a// complete path segment// userinfo is everything up to @// host is everything up to last ':', or up to// and including ']' if followed by ':'.// port// REVISIT: Remove this code./** for (int i = 0; i < portStr.length(); i++) { ... */// Store port value as string instead of integer.// Note: Registry based authority is being removed from a// new spec for URI which would obsolete RFC 2396. If the// spec is added to XML errata, processing of reg_name// needs to be removed. - mrglavas.// Check if the host is well formed.// Check that port is well formed if it exists.// REVISIT: There's no restriction on port value ranges, but// perform the same check as in setPort to be consistent. Pass// in a string to this method instead of an integer.// Check that userinfo is well formed if it exists.// Userinfo can contain alphanumerics, mark characters, escaped// and ';',':','&','=','+','$',','// check for valid escape sequence// can check against path characters because the set// is the same except for '/' which we've already excluded.// path - everything up to query string or fragment// RFC 2732 only allows '[' and ']' to appear in the opaque part.// Scan path.// rel_path = rel_segment [ abs_path ]// Path segments cannot contain '[' or ']' since pchar// production was not changed by RFC 2732.// Scan opaque part.// opaque_part = uric_no_slash *uric// If the scheme specific part is opaque, it can contain '['// and ']'. uric_no_slash wasn't modified by RFC 2732, which// I've interpreted as an error in the spec, since the// production should be equivalent to (uric - '/'), and uric// contains '[' and ']'. - mrglavas// query - starts with ? and up to fragment or end// fragment - starts with #// Server based authority.// Registry based authority.// userinfo can contain alphanumerics, mark characters, escaped// reg_name = 1*( unreserved | escaped | "$" | "," |//            ";" | ":" | "@" | "&" | "=" | "+" )// presence of the host (whether valid or empty) means// double-slashes which means generic uri// presence of the scheme means absolute uri// Check if the host is a valid IPv6reference.// Cannot start with a '.', '-', or end with a '-'.// rightmost domain label starting with digit indicates IP address// since top level domain label can only start with an alpha// see RFC 2396 Section 3.2.2// hostname      = *( domainlabel "." ) toplabel [ "." ]// domainlabel   = alphanum | alphanum *( alphanum | "-" ) alphanum// toplabel      = alpha | alpha *( alphanum | "-" ) alphanum// RFC 2396 states that hostnames take the form described in// RFC 1034 (Section 3) and RFC 1123 (Section 2.1). According// to RFC 1034, hostnames are limited to 255 characters.// domain labels can contain alphanumerics and '-"// but must start and end with an alphanumeric// RFC 1034: Labels must be 63 characters or less.// make sure that 1) we see only digits and dot separators, 2) that// any dot separator is preceded and followed by a digit and// 3) that we find 3 dots// RFC 2732 amended RFC 2396 by replacing the definition// of IPv4address with the one defined by RFC 2373. - mrglavas// IPv4address = 1*3DIGIT "." 1*3DIGIT "." 1*3DIGIT "." 1*3DIGIT// One to three digits must be in each segment.// Check that that there are no more than three digits// in this segment.// Check that this segment is not greater than 255.// Check if string is a potential match for IPv6reference.// Counter for the number of 16-bit sections read in the address.// Scan hex sequence before possible '::' or IPv4 address.// Address must contain 128-bits of information.// '::' represents at least one 16-bit group of zeros.// Trailing zeros will fill out the rest of the address.// If the second character wasn't ':', in order to be valid,// the remainder of the string must match IPv4Address,// and we must have read exactly 6 16-bit groups.// 3. Scan hex sequence after '::'.// We've either reached the end of the string, the address ends in// an IPv4 address, or it is invalid. scanHexSequence has already// made sure that we have the right number of bits.// Trying to match the following productions:// hexseq = hex4 *( ":" hex4)// hex4   = 1*4HEXDIG// IPv6 addresses are 128-bit, so there can be at most eight sections.// This could be '::'.// This might be invalid or an IPv4address. If it's potentially an IPv4address,// backup to just after the last valid character that matches hexseq.// There can be at most 4 hex digits per group./** This class defines the basic properties of characters in XML 1.1. The data ... */...[] XML11CHARS;/** Character flags for XML 1.1. */int MASK_XML11_VALID;/** XML 1.1 Valid character mask. */int MASK_XML11_SPACE;/** XML 1.1 Space character mask. */int MASK_XML11_NAME_START;/** XML 1.1 Name start character mask. */int MASK_XML11_NAME;/** XML 1.1 Name character mask. */int MASK_XML11_CONTROL;/** XML 1.1 control character mask */int MASK_XML11_CONTENT;/** XML 1.1 content for external entities (valid - "special" chars - control chars) */int MASK_XML11_NCNAME_START;/** XML namespaces 1.1 NCNameStart */int MASK_XML11_NCNAME;/** XML namespaces 1.1 NCName */int MASK_XML11_CONTENT_INTERNAL;/** XML 1.1 content for internal entities (valid - "special" chars) *//** Returns true if the specified character is a space character ... *//** Returns true if the specified character is valid. This method ... */// isXML11Space(int):boolean/** Returns true if the specified character is invalid. ... */// isXML11Valid(int):boolean/** Returns true if the specified character is valid and permitted outside ... */// isXML11Invalid(int):boolean/** Returns true if the specified character can be considered ... */// isXML11ValidLiteral(int):boolean// isXML11Content(int):boolean/** Returns true if the specified character is a valid name start ... */// isXML11InternalEntityContent(int):boolean/** Returns true if the specified character is a valid name ... */// isXML11NameStart(int):boolean/** Returns true if the specified character is a valid NCName start ... */// isXML11Name(int):boolean/** Returns true if the specified character is a valid NCName ... */// isXML11NCNameStart(int):boolean/** Returns whether the given character is a valid ... */// isXML11NCName(int):boolean/** Check to see if a string is a valid Name according to [5] ... *//* [5] Name ::= NameStartChar NameChar* *//** Check to see if a string is a valid NCName according to [4] ... *//* from the namespace 1.1 rec ... */// isXML11ValidName(String):boolean/** Check to see if a string is a valid Nmtoken according to [7] ... *//* [7] Nmtoken ::= (NameChar)+ */// isXML11ValidNCName(String):boolean// Initializing the Character Flag Array// Code generated by: XML11CharGenerator.// Fill 8 of value (byte) 17// Fill 2 of value (byte) 17// Fill 18 of value (byte) 17// Fill 5 of value (byte) 33// Fill 6 of value (byte) 33// Fill 2 of value (byte) -87// Fill 10 of value (byte) -87// Fill 4 of value (byte) 33// Fill 26 of value (byte) -19// Fill 2 of value (byte) 33// Fill 6 of value (byte) 17// Fill 26 of value (byte) 17// Fill 23 of value (byte) 33// Fill 8 of value (byte) 33// Fill 23 of value (byte) -19// Fill 31 of value (byte) -19// Fill 520 of value (byte) -19// Fill 112 of value (byte) -87// Fill 14 of value (byte) -19// Fill 7297 of value (byte) -19// Fill 12 of value (byte) 33// Fill 2 of value (byte) -19// Fill 26 of value (byte) 33// Fill 22 of value (byte) 33// Fill 47 of value (byte) 33// Fill 288 of value (byte) -19// Fill 2672 of value (byte) 33// Fill 1008 of value (byte) -19// Fill 17 of value (byte) 33// Fill 43007 of value (byte) -19// Fill 6400 of value (byte) 33// Fill 1232 of value (byte) -19// Fill 32 of value (byte) 33// Fill 526 of value (byte) -19// class XML11Char/** The XMLAttributesImpl class is an implementation of the XMLAttributes ... *//** Threshold at which an instance is treated ... */int fLargeCount;/** Usage count for the attribute table view. ... *//** Attribute count. */...[] fAttributes;/** Attribute information. */...[] fAttributeTableView;/** Provides an alternate view of the attribute specification. */...[] fAttributeTableViewChainState;/** Tracks whether each chain in the hash table is stale ... */int fTableViewBuckets;/** Actual number of buckets in the table view. */boolean fIsTableViewConsistent;/** Indicates whether the table view contains consistent data. */fAttributes.length/** Sets whether namespace processing is being performed. This state ... *//** Adds an attribute. The attribute's non-normalized value of the ... */// XMLAttributes methods// setNamespaces(boolean)getIndexFast(...)getTableViewBucket(...)prepareAndPopulateTableView(...)...[...].nextAttribute foundfound.name.rawnamefound.namefound.nextrebalanceTableView(...)attribute.nameattribute.typeattribute.valueattribute.xmlValueattribute.nonNormalizedValueattribute.specifiedattribute.augs/** Removes all of the attributes. This method will also remove all ... */// addAttribute(QName,String,XMLString)/** Removes the attribute at the specified index. ... */// removeAllAttributes()Attribute removedAttr/** Sets the name of the attribute at the specified index. ... */// removeAttributeAt(int)/** Sets the fields in the given QName structure with the values ... */// setName(int,QName)/** Sets the type of the attribute at the specified index. ... */// getName(int,QName)/** Sets the value of the attribute at the specified index. This ... */// setType(int,String)/** Sets the non-normalized value of the attribute at the specified ... */// setValue(int,String)...[...].nonNormalizedValue/** Returns the non-normalized value of the attribute at the specified ... */// setNonNormalizedValue(int,String)/** Sets whether an attribute is specified in the instance document ... */// getNonNormalizedValue(int):String...[...].specified/** Returns true if the attribute is specified in the instance document. ... */// setSpecified(int,boolean)/** Return the number of attributes in the list. ... */// AttributeList and Attributes methods// isSpecified(int):boolean/** Look up an attribute's type by index. ... */getReportableType(...)/** Look up an attribute's type by XML 1.0 qualified name. ... */// getType(int):String/** Look up an attribute's value by index. ... */// getType(String):String...[...].xmlValue/** Look up an attribute's value by XML 1.0 qualified name. ... */// getValue(int):String/** Return the name of an attribute in this list (by position). ... */// AttributeList methods// getValue(String):String...[...].name.rawname/** Look up the index of an attribute by XML 1.0 qualified name. ... */// Attributes methods// getName(int):Stringattribute.name.rawname/** Look up the index of an attribute by Namespace name. ... */// getIndex(String):intattribute.name.localpartattribute.name.uri/** Look up the index of an attribute by local name only, ... */// getIndex(String,String):int/** Look up an attribute's local name by index. ... */...[...].name.localpart/** Look up an attribute's XML 1.0 qualified name by index. ... */// getLocalName(int):String// getQName(int):String/** Look up an attribute's type by Namespace name. ... */// getType(String,String):String// getIndexFast(String):int/** Checks for duplicate expanded names (local part and namespace name ... */Attribute att1Attribute att2att1.name.localpartatt2.name.localpartatt1.nameatt2.nameatt1.name.uriatt2.name.uricheckManyDuplicatesNS(...)Attribute[] attributeTableViewint[] attributeTableViewChainStateint largeCountprepareTableView(...)attr.name.localpartattr.name.uriattr.nameattr.nextfound.name.localpartfound.name.urirebalanceTableViewNS(...)/** Returns the value passed in or NMTOKEN if it's an enumerated type. ... */// getIndexFast(String,String):int/** Returns the position in the table view ... */// hash(String,String):int/** Purges all elements from the table view. *//** Increases the capacity of the table view. */int tableViewBuckets/** Prepares the table view of the attributes list for use. */growTableView(...)cleanTableView(...)/** Prepares the table view of the attributes list for use, ... */attr.name.rawname/** Returns the prefix of the attribute at the specified index. ... */...[...].name.prefix/** Look up an attribute's Namespace URI by index. ... */// getPrefix(int):String...[...].name.uri/** Look up an attribute's value by Namespace name and ... */// getURI(int):String/** Look up an augmentations by Namespace name. ... */// getValue(String,String):String...[...].augs/** Look up an augmentation by XML 1.0 qualified name. ... *//** Look up an augmentations by attributes index. ... *//** Sets the uri of the attribute at the specified index. ... */// Implementation methods// getURI(int,QName)...[...].schemaId/** This method will be invoked by XMLEntityReader before ScannedEntities buffer ... *///XMLBufferListener methods/** Randomly selects a new hash function and reorganizes the table view ... */prepareAndPopulateTableViewNS(...)XMLAttributesImpl$Attribute/** Attribute information. ... *//** Name. */// basic info/** Type. */XMLString xmlValue;/** This will point to the ScannedEntities buffer. */String nonNormalizedValue;/** Non-normalized value. */boolean specified;/** Specified. */boolean schemaId;/** Schema ID type. */Augmentations augs;/** Augmentations information for this attribute. ... */Attribute next;/** Pointer to the next attribute in the chain. * */// Additional data for attribute table view/** If attributes were removed from the list after the table ... */// The chain is stale.// This must be a unique attribute.// Update table view.// This chain is active.// We need to check if any of the attributes has the same rawname.// Search the table.// This attribute is unique.// Select a new hash function and rehash the table view// if the collision threshold is exceeded.// The current attribute will be processed in the rehash.// Need to set its name first.// Update table view// Duplicate. We still need to find the index.// set values// clear augmentations// Make the discarded Attribute object available for re-use// by tucking it after the Attributes that are still in use// If the list is small check for duplicates using pairwise comparison.// If the list is large check duplicates using a hash table.// We don't want this table view to be read if someone calls// addAttribute so we invalidate it up front.// We need to check if any of the attributes has the same name.// Overflow. We actually need to visit the chain state array.// Need to populate the hash table with the attributes we've processed so far.// REVISIT: The empty string is not entered in the symbol table!// class Attribute// class XMLAttributesImpl/** Its better to extend the functionality of existing XMLAttributesImpl and also make it of type Iterator. ... */int fCurrent;//pointer to current position.XMLAttributesImpl.Attribute fLastReturnedItem;XMLAttributesImpl.Attribute/** Creates a new instance of XMLAttributesIteratorImpl *///hasNext()//remove//java imports//xerces imports// should this be of type javax.xml.stream.Attribute ?//make sure that only last returned item can be removed.//remove the attribute at current index and lower the current position by 1.//either the next method has been called yet, or the remove method has already been called//after the last call to the next method./** xxx: should we be doing this way ? Attribute event defines so many functions which doesn't make any sense ... *//* class AttributeImpl extends com.sun.org.apache.xerces.internal.util.XMLAttributesImpl.Attribute implements javax.xml.stream.events.Attribute{ ... *///XMLAttributesIteratorImplimport SAXParserFactoryImplimport Catalogimport CatalogManagerimport OASISXMLCatalogReaderimport SAXCatalogReader/** <p>The catalog resolver handles the resolution of external ... */CatalogManager fResolverCatalogManager;/** Internal catalog manager for Apache catalogs. * */Catalog fCatalog;/** Internal catalog structure. * */...[] fCatalogsList;/** An array of catalog URIs. * */boolean fCatalogsChanged;/** Indicates whether the list of catalogs has ... */boolean fPreferPublic;/** Application specified prefer public setting. * */boolean fUseLiteralSystemId;/** Indicates whether the application desires that ... *//** <p>Constructs a catalog resolver with a default configuration.</p> *//** <p>Constructs a catalog resolver with the given ... *//** <p>Returns the initial list of catalog entry files.</p> ... *//** <p>Sets the initial list of catalog entry files. ... *//** <p>Forces the cache of catalog mappings to be cleared.</p> *//** <p>Returns the preference for whether system or public ... *//** <p>Sets the preference for whether system or public ... */setPreferPublic(...)/** <p>Returns the preference for whether the literal system ... *//** <p>Sets the preference for whether the literal system ... *//** <p>Resolves an external entity. If the entity cannot be ... */String resolvedIdresolvePublic(...)resolveSystem(...)getUseLiteralSystemId(...)/** <p>Resolves a resource using the catalog. This method interprets that ... */resolveURI(...)resolveIdentifier(...)/** <p>Resolves an identifier using the catalog. This method interprets that ... *//** <p>Returns the URI mapping in the catalog for the given ... */parseCatalogs(...)/** <p>Returns the URI mapping in the catalog for the given URI ... *//** Initialization. Create a CatalogManager and set all ... */new CatalogManager(...)setAllowOasisXMLCatalogPI(...)setCatalogClassName(...)setCatalogFiles(...)setIgnoreMissingProperties(...)setRelativeCatalogs(...)setUseStaticCatalog(...)setVerbosity(...)/** Instruct the <code>Catalog</code> to parse each of the ... */new Catalog(...)attachReaderToCatalog(...)fCatalogsList.lengthString catalogparseCatalog(...)/** Attaches the reader to the catalog. */SAXParserFactory spfgetSAXFactory(...)getCatalogManager(...)SAXCatalogReader saxReadernew SAXCatalogReader(...)setValidating(...)setCatalogParser(...)OASISXMLCatalogReader.namespaceNameaddReader(...)// Attempt to resolve the system identifier against the base URI.// Ignore the exception. Fallback to the literal system identifier.// The namespace is useful for resolving namespace aware// grammars such as XML schema. Let it take precedence over// the external identifier if one exists.// Resolve against an external identifier if one exists. This// is useful for resolving DTD external subsets and other// external entities. For XML schemas if there was no namespace// mapping we might be able to resolve a system identifier// specified as a location hint.// Ignore IOException. It cannot be thrown from this method./** This class defines the basic XML character properties. The data ... */...[] CHARS;/** Character flags. */int MASK_VALID;/** Valid character mask. */int MASK_SPACE;/** Space character mask. */int MASK_NAME_START;/** Name start character mask. */int MASK_NAME;/** Name character mask. */int MASK_PUBID;/** Pubid character mask. */int MASK_CONTENT;/** Content character mask. Special characters are those that can ... */int MASK_NCNAME_START;/** NCName start character mask. */int MASK_NCNAME;/** NCName character mask. *//** Returns true if the specified character is a supplemental character. ... *//** Returns true the supplemental character corresponding to the given ... *//** Returns the high surrogate of a supplemental character ... *//** Returns the low surrogate of a supplemental character ... *//** Returns whether the given character is a high surrogate ... *//** Returns whether the given character is a low surrogate ... */// isValid(int):boolean/** Returns true if the specified character can be considered content. ... */// isInvalid(int):boolean/** Returns true if the specified character can be considered markup. ... */// isContent(int):boolean// isMarkup(int):boolean// isSpace(int):boolean// isNameStart(int):boolean// isName(int):boolean// isNCNameStart(int):boolean/** Returns true if the specified character is a valid Pubid ... */// isNCName(int):boolean/* [5] Name ::= (Letter | '_' | ':') (NameChar)* */// isPubid(int):boolean/* from the namespace rec ... */// isValidName(String):boolean// isValidNCName(String):boolean/** Returns true if the encoding name is a valid IANA encoding. ... */// encodings/** Returns true if the encoding name is a valid Java encoding. ... */// isValidIANAEncoding(String):boolean/** Trims space characters as defined by production [3] in ... */int lengthMinusOne// Code generated by: XMLCharGenerator.// Fill 3 of value (byte) 49// Fill 6 of value (byte) 49// Fill 2 of value (byte) -71// Fill 10 of value (byte) -71// Fill 2 of value (byte) 49// Fill 26 of value (byte) -3// Fill 60 of value (byte) 33// Fill 58 of value (byte) -19// Fill 11 of value (byte) -19// Fill 8 of value (byte) -19// Fill 53 of value (byte) -19// Fill 68 of value (byte) -19// Fill 9 of value (byte) 33// Fill 36 of value (byte) -19// Fill 3 of value (byte) 33// Fill 30 of value (byte) -19// Fill 56 of value (byte) 33// Fill 89 of value (byte) -19// Fill 18 of value (byte) 33// Fill 7 of value (byte) -19// Fill 14 of value (byte) 33// Fill 46 of value (byte) 33// Fill 70 of value (byte) -87// Fill 36 of value (byte) 33// Fill 3 of value (byte) -19// Fill 20 of value (byte) -19// Fill 44 of value (byte) -19// Fill 18 of value (byte) -19// Fill 13 of value (byte) 33// Fill 12 of value (byte) -19// Fill 66 of value (byte) -19// Fill 4 of value (byte) -87// Fill 28 of value (byte) -19// Fill 55 of value (byte) 33// Fill 38 of value (byte) -19// Fill 7 of value (byte) 33// Fill 10 of value (byte) 33// Fill 17 of value (byte) -87// Fill 23 of value (byte) -87// Fill 3 of value (byte) -87// Fill 11 of value (byte) 33// Fill 27 of value (byte) -19// Fill 10 of value (byte) -19// Fill 8 of value (byte) -87// Fill 71 of value (byte) -19// Fill 5 of value (byte) -19// Fill 15 of value (byte) -19// Fill 4 of value (byte) -19// Fill 15 of value (byte) -87// Fill 519 of value (byte) 33// Fill 16 of value (byte) -87// Fill 22 of value (byte) -19// Fill 7 of value (byte) -87// Fill 16 of value (byte) 33// Fill 6 of value (byte) -19// Fill 5 of value (byte) -87// Fill 12 of value (byte) -87// Fill 6 of value (byte) -87// Fill 15 of value (byte) 33// Fill 9 of value (byte) -87// Fill 16 of value (byte) -19// Fill 145 of value (byte) 33// Fill 46 of value (byte) -19// Fill 39 of value (byte) 33// Fill 62 of value (byte) 33// Fill 33 of value (byte) -19// Fill 20 of value (byte) -87// Fill 21 of value (byte) -87// Fill 230 of value (byte) 33// Fill 39 of value (byte) -19// Fill 41 of value (byte) 33// Fill 40 of value (byte) 33// Fill 3078 of value (byte) 33// Fill 156 of value (byte) -19// Fill 90 of value (byte) -19// Fill 13 of value (byte) -19// Fill 211 of value (byte) 33// Fill 13 of value (byte) -87// Fill 68 of value (byte) 33// Fill 81 of value (byte) 33// Fill 3714 of value (byte) 33// Fill 25 of value (byte) 33// Fill 9 of value (byte) -19// Fill 84 of value (byte) -19// Fill 40 of value (byte) -19// Fill 7379 of value (byte) 33// Fill 20902 of value (byte) -19// Fill 3162 of value (byte) 33// Fill 11172 of value (byte) -19// Fill 92 of value (byte) 33// Fill 8190 of value (byte) 33// trim(String):String// class XMLChar/** Default implementation of {@link XMLDocumentFilter} ... *//** <p>This class is an implementation of the XMLEntityDescription ... *//** Constructs an empty entity description. *//** Constructs an entity description. ... */setDescription(...)/** Constructs a resource identifier. ... */// <init>(String,String,String,String,String)String fEntityName;/** The name of the entity. */// <init>(String,String,String,String,String,String)// setEntityName(String)/** <p>Sets the values of this entity description.</p> ... */// getEntityName():String// setDescription(String,String,String,String,String)/** <p>Clears the values.</p> */// setDescription(String,String,String,String,String,String)/** Returns a hash code for this object. */// hashCode():int// XMLEntityDescriptionImpl/** <p>A structure that represents an error code, characterized by ... *//** message key * *//** <p>Constructs an XMLErrorCode with the given domain and key.</p> ... *//** <p>Convenience method to set the values of an XMLErrorCode.</p> ... *//** <p>Indicates whether some other object is equal to this XMLErrorCode.</p> ... */XMLErrorCode errerr.fDomainerr.fKey/** <p>Returns a hash code value for this XMLErrorCode.</p> ... *//** Stores grammars in a pool associated to a specific key. This grammar pool ... */// whether this pool is locked// the number of grammars in the poolint grammarSizeGrammar[] tempGrammarsGrammar[] toReturne.desce.grammarGrammar tempEntry prevGrammar grammar;//print(temp.getGrammarDescription());//print(desc);/* For DTD build we can't import here XSDDescription. Thus, this method is commented out.. *//* public void print(XMLGrammarDescription description){ ... */// class XMLGrammarPoolImpl/** {@link Source} that represents an {@link XMLInputSource}. ... */XMLInputSource fSource;/** the actual source information. *//** The XMLResourceIdentifierImpl class is an implementation of the ... *//** The public identifier. */String fLiteralSystemId;/** The literal system identifier. *//** The base system identifier. */String fExpandedSystemId;/** The expanded system identifier. *//** The namespace of the resource. *//** Constructs an empty resource identifier. *//** Sets the values of the resource identifier. */// setValues(String,String,String,String)// setValues(String,String,String,String,String)/** Sets the public identifier. *//** Sets the literal system identifier. *//** Sets the base system identifier. */// setLiteralSystemId(String)/** Sets the expanded system identifier. */// setBaseSystemId(String)/** Sets the namespace of the resource. */// setExpandedSystemId(String)// XMLResourceIdentifier methods// setNamespace(String)/** Returns the base URI against which the literal SystemId is to be resolved. *//** Returns the namespace of the resource. */// getNamespace():String// class XMLResourceIdentifierImpl/** XMLString is a structure used to pass character arrays. However, ... *//** Default buffer size (32). *//** Constructs a string buffer from a char. *//** Constructs a string buffer from a String. */// <init>(char)/** Constructs a string buffer from the specified character array. *//** Constructs a string buffer from the specified XMLString. */// <init>(char[],int,int)/** Clears the string buffer. */// <init>(XMLString)/** append ... */this.ch.lengththis.ch// append(char)char[] newch// append(String)// append(char[],int,int)s.chs.offset//making the code more robust as it would handle null or 0 length data,//add the data only when it contains some thing// append(XMLString)// class XMLStringBuffer/** All internalized xml symbols. They can be compared using "==". ... */// public constructor./** The empty string. *///==========================// Commonly used stringsString PREFIX_XML;/** The internalized "xml" prefix. */// Namespace prefixes/urisString PREFIX_XMLNS;/** The internalized "xmlns" prefix. */String fANYSymbol;/** Symbol: "ANY". */// DTD symbolsString fCDATASymbol;/** Symbol: "CDATA". */String fIDSymbol;/** Symbol: "ID". */String fIDREFSymbol;/** Symbol: "IDREF". */String fIDREFSSymbol;/** Symbol: "IDREFS". */String fENTITYSymbol;/** Symbol: "ENTITY". */String fENTITIESSymbol;/** Symbol: "ENTITIES". */String fNMTOKENSymbol;/** Symbol: "NMTOKEN". */String fNMTOKENSSymbol;/** Symbol: "NMTOKENS". */String fNOTATIONSymbol;/** Symbol: "NOTATION". */String fENUMERATIONSymbol;/** Symbol: "ENUMERATION". */String fIMPLIEDSymbol;/** Symbol: "#IMPLIED. */String fREQUIREDSymbol;/** Symbol: "#REQUIRED". */String fFIXEDSymbol;/** Symbol: "#FIXED". */isDebugEnabled(...)/** Returns true if debug has been enabled. */// isDebugEnabled()/** Create an instance of a class using the same classloader for the ObjectFactory by default ... *//** Find a Class using the same classloader for the ObjectFactory by default ... */// Allow simply setting the prop to turn on debug// ClassLoader (always look in system ClassLoader if Xerces//throw security exception if the calling thread is not allowed to access the package//restrict the access to package as speicified in java.security policy//use the bootstrap ClassLoader./** This class is duplicated for each subpackage so keep it in sync. ... *//** Return resource using the same classloader for the ObjectFactory by default ... */new PrivilegedAction<ResourceBundle>(...) { ... }/* Copyright 2002,2004 The Apache Software Foundation. ... */import Formatter/** A helper for analyzing entity expansion limits ... */XMLLimitAnalyzer$NameMapConstants.SP_ENTITY_EXPANSION_LIMITConstants.SP_MAX_OCCUR_LIMITConstants.SP_ELEMENT_ATTRIBUTE_LIMIT/** Max value accumulated for each property *//** Names of the entities corresponding to their max values */...[] totalValue;/** Total value of accumulated entities */...[] caches;/** Maintain values of the top 10 elements in the process of parsing */String entityStart, ...;/** Add the value to the current max count for the specified property ... *//** Add the value to the current count by the index of the property ... */Map<String,Integer> cacheint accumulatedValueLimit.ENTITY_EXPANSION_LIMITLimit.MAX_OCCUR_NODE_LIMITLimit.ELEMENT_ATTRIBUTE_LIMITLimit.PARAMETER_ENTITY_SIZE_LIMIT/** Return the value of the current max count for the specified property ... *//** Return the total value accumulated so far ... *//** Return the current max value (count or length) by the index of a property ... *//** Stop tracking the entity ... *//** Resets the current value of the specified limit. ... */Formatter formatternew Formatter(...)/* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER. ... */import SecurityManager/** This class manages standard and implementation-specific limitations. */Constants.JDK_MAX_OCCUR_LIMITConstants.JDK_ELEMENT_ATTRIBUTE_LIMITConstants.JDK_TOTAL_ENTITY_SIZE_LIMITConstants.SP_TOTAL_ENTITY_SIZE_LIMITConstants.JDK_GENERAL_ENTITY_SIZE_LIMITConstants.SP_GENERAL_ENTITY_SIZE_LIMITConstants.JDK_PARAMETER_ENTITY_SIZE_LIMITConstants.SP_PARAMETER_ENTITY_SIZE_LIMITConstants.JDK_MAX_ELEMENT_DEPTHConstants.SP_MAX_ELEMENT_DEPTHConstants.JDK_XML_NAME_LIMITConstants.SP_XML_NAME_LIMITConstants.JDK_ENTITY_REPLACEMENT_LIMITConstants.SP_ENTITY_REPLACEMENT_LIMITint NO_LIMIT;boolean secureProcessing;/** Flag indicating if secure processing is set */this.secureProcessinglimit.secureValue/** Return the state of secure processing ... */Constants.JDK_YES/** Check if there's no limit defined by the Security Manager ... *//** Check if the size (length or count) of the specified limit property is ... *//** Check if the value (length or count) of the specified limit property is ... *//** Check against cumulated value ... *//** Convert a value set through setProperty to XMLSecurityManager. ... */XMLSecurityManager.classSecurityManager.classSecurityManager origSMState.APIPROPERTYgetMaxOccurNodeLimit(...)getEntityExpansionLimit(...)getElementAttrLimit(...)XMLSecurityPropertyManager$StateProperty ACCESS_EXTERNAL_SCHEMA;Constants.SP_ACCESS_EXTERNAL_DTDConstants.SP_ACCESS_EXTERNAL_SCHEMA/** This implementation of NamespaceContext has the ability to maintain multiple ... */...[] fScope;int fCurrentScope;int scopegetScopeForContext(...)/** Only resets the current scope -- all namespaces defined in lower scopes ... *//** Begins a new scope.  None of the previous namespace bindings will be used, ... */fScope.length/** Pops the current scope.  The namespace bindings from the new current scope ... */// this saves us from having a copy of each of these in fNamespace for each scopegetSystemResourceAsStream(...)/** This class is used for reading resources requested in &lt;include&gt; elements in ... *//** Construct the XIncludeReader using the XMLInputSource and XIncludeHandler. ... *//** Returns true if the specified character is a valid XML character ... */import MalformedByteSequenceExceptionimport HTTPInputSourceimport XPointerProcessornew XIncludeMessageFormatter(...)String XINCLUDE_DEFAULT_CONFIGURATION;String HTTP_ACCEPT;String HTTP_ACCEPT_LANGUAGE;String XPOINTER;String XINCLUDE_NS_URI;String XINCLUDE_INCLUDE;String XINCLUDE_FALLBACK;String XINCLUDE_PARSE_XML;String XINCLUDE_PARSE_TEXT;String XINCLUDE_ATTR_HREF;String XINCLUDE_ATTR_PARSE;String XINCLUDE_ATTR_ENCODING;String XINCLUDE_ATTR_ACCEPT;String XINCLUDE_ATTR_ACCEPT_LANGUAGE;String XINCLUDE_INCLUDED;// Top Level Information Items have [included] property in infosetString CURRENT_BASE_URI;/** The identifier for the Augmentation that contains the current base URI */String XINCLUDE_BASE;// used for adding [base URI] attributesQName XML_BASE_QNAME;String XINCLUDE_LANG;// used for adding [language] attributesQName XML_LANG_QNAME;QName NEW_NS_ATTR_QNAME;int STATE_NORMAL_PROCESSING;// Processing Statesint STATE_IGNORE;// of the include) or after a fallback// we go into this state after a successful include (thus we ignore the childrenint STATE_EXPECT_FALLBACK;// before we reach the end include tag, it's a fatal error// we go into this state after a failed include.  If we don't encounter a fallback/** property identifier: XML security property manager. */// for XMLDocumentFilter// instance variables// for XMLDTDFilterXIncludeHandler fParentXIncludeHandler;// for XIncludeHandler// for buffer size in XIncludeTextReaderString fParentRelativeURI;// It's never going to change in the lifetime of this XIncludeHandler// calculating it can be time consuming, so we cache it.// It "feels wrong" to store this value here.  However,XMLParserConfiguration fChildConfig;// the objects when the parser is re-used// we cache the child parser configuration, so we don't have to re-createXMLParserConfiguration fXIncludeChildConfig;// XInclude or XPointer Handler.  Cache both these// The cached child parser configuration, may contain aXMLParserConfiguration fXPointerChildConfig;XPointerProcessor fXPtrProcessor;// The XPointerProcessorXIncludeMessageFormatter fXIncludeMessageFormatter;XIncludeNamespaceSupport fNamespaceContext;XIncludeTextReader fXInclude10TextReader;// these are needed for text include processingXIncludeTextReader fXInclude11TextReader;XMLResourceIdentifier fCurrentBaseURI;// these are needed for XML Base processingIntStack fBaseURIScope;Stack<> fBaseURI;Stack<> fLiteralSystemID;Stack<> fExpandedSystemID;IntStack fLanguageScope;// these are needed for Language FixupStack<> fLanguageStack;String fCurrentLanguage;ParserConfigurationSettings fSettings;// used for passing features on to child XIncludeHandler objects// The first element is at depth 1.// The current element depth.  We start at depth 0 (before we've reached any elements).int fResultDepth;// The current element depth of the result infoset.// this value must be at least 1...[] fSawInclude;// at that depth was an include element.// An index contains true if the ancestor of the current element which resides// and that include elements are never children of other include elements.// Used to ensure that fallbacks are always children of include elements,...[] fSawFallback;// and it is only reset to false when the end tag of the parent is encountered.// An index contains true if we have seen any fallback elements at that depth,// Ensures that only one fallback element can be at a single depth....[] fState;// The state of the processor at each given depth.ArrayList<> fNotations;// buffering the necessary DTD eventsArrayList<> fUnparsedEntities;boolean fFixupBaseURIs;// flags which control whether base URI or language fixup is performed.boolean fFixupLanguage;boolean fSendUEAndNotationEvents;// Has the value of the ALLOW_UE_AND_NOTATION_EVENTS feature// for SAX compatibility.boolean fIsXML11;// track whether a DTD is being parsed// track whether the root element of the result infoset has been processedboolean fNeedCopyFeatures;// track whether the child config needs its features refreshedisRootDocument(...)getResultDepth(...)fState.lengthfSawFallback.lengthfSawInclude.lengthSymbolTable valueXMLErrorReporter valuesetErrorReporter(...)XMLEntityResolver valueXMLSecurityManager valuecopyFeatures(...)/** Event sent at the start of the document. ... */searchForRecursiveIncludes(...)saveBaseURI(...)saveLanguage(...)modifyAugmentations(...)int lastStateprocessXMLBaseAttributes(...)processXMLLangAttributes(...)isIncludeElement(...)handleIncludeElement(...)isFallbackElement(...)handleFallbackElement(...)hasXIncludeNamespace(...)getSawInclude(...)getSawFallback(...)checkMultipleRootElements(...)setSawFallback(...)setSawInclude(...)restoreBaseURI(...)restoreLanguage(...)checkWhitespace(...)// the rest we just pass on// We are only interested in the notation and unparsed entity declarations,// DTDHandler methodsaddNotation(...)// XIncludeHandler methodsXIncludeMessageFormatter.XINCLUDE_DOMAINsetContextInvalid(...)String parseString xpointerString acceptString acceptLanguageURI hrefURIXMLInputSource includedSourcereportResourceError(...)MalformedURIException excString newHrefescapeHref(...)MalformedURIException exc2isValidInHTTPHeader(...)XMLResourceIdentifier resourceIdentifiercreateInputSource(...)String parserNameXPointerHandler newHandlerXIncludeHandler newHandlerparseXPointer(...)pushScope(...)isXPointerResolved(...)popScope(...)XIncludeTextReader textReadernew XIncludeTextReader(...)new XInclude11TextReader(...)MalformedByteSequenceException exgetArguments(...)CharConversionException e/** Returns true if the element has the namespace "http://www.w3.org/2001/XInclude" ... *//** Checks if the element is an &lt;include&gt; element.  The element must have ... *//** Checks if the element is an &lt;fallback&gt; element.  The element must have ... *//** Returns true if the current [base URI] is the same as the [base URI] that ... */getIncludeParentBaseURI(...)/** Returns true if the current [language] is equivalent to the [language] that ... */String parentLanguagegetIncludeParentLanguage(...)/** Checks if the file indicated by the given XMLLocator has already been included ... */String includedSystemId/** Returns true if the current element is a top level included item.  This means ... */isTopLevelIncludedItemViaInclude(...)isTopLevelIncludedItemViaFallback(...)/** Processes the XMLAttributes object of startElement() calls.  Performs the following tasks: ... */isTopLevelIncludedItem(...)Enumeration<> inscopeNSsameBaseURIAsIncludeParent(...)getRelativeBaseURI(...)sameLanguageAsIncludeParent(...)String parentURIgetURIFromIncludeParent(...)QName nsns.prefixns.localpartns.rawnamecheckUnparsedEntity(...)String entNamecheckNotation(...)/** Returns a URI, relative to the include parent's base URI, of the current ... */int includeParentDepthgetIncludeParentDepth(...)String relativeURIgetRelativeURI(...)String baseSchemeString literalSchemeString baseAuthoritygetAuthority(...)String literalAuthorityString literalPathString literalQueryString literalFragment/** Returns the [base URI] of the include parent. ... *//** Returns the [language] of the include parent. ... *//** Returns the depth of the include parent.  Here, the include parent is ... *//** Returns the current element depth of the result infoset. *//** Modify the augmentations.  Add an [included] infoset item, if the current ... *//** Modify the augmentations.  Add an [included] infoset item, if <code>force</code> ... *//** Records that an &lt;fallback&gt; was encountered at the specified depth, ... */boolean[] newarray/** Returns whether an &lt;fallback&gt; was encountered at the specified depth, ... *//** Records that an &lt;include&gt; was encountered at the specified depth, ... *//** Return whether an &lt;include&gt; was encountered at the specified depth, ... *//** Set the parent of this XIncludeHandler in the tree ... */// used to know whether to pass declarations to the document handler/** Caches an unparsed entity. ... */UnparsedEntity entnew UnparsedEntity(...)ent.nameent.systemIdent.publicIdent.baseURIent.expandedSystemIdent.notationent.augmentations/** Caches a notation. ... */Notation notnew Notation(...)not.namenot.systemIdnot.publicIdnot.baseURInot.expandedSystemIdnot.augmentations/** Checks if an UnparsedEntity with the given name was declared in the DTD of the document ... */checkAndSendUnparsedEntity(...)/** Checks if a Notation with the given name was declared in the DTD of the document ... */checkAndSendNotation(...)/** The purpose of this method is to check if an UnparsedEntity conflicts with a previously ... */XMLResourceIdentifier idUnparsedEntity localEntityisDuplicate(...)/** The purpose of this method is to check if a Notation conflicts with a previously ... */Notation localNotation/** Checks whether the string only contains white space characters. ... *//** Checks whether the root element has already been processed. */getRootElementProcessed(...)setRootElementProcessed(...)/** Sets whether the root element has been processed. *//** Returns whether the root element has been processed. */// setFeature() and addRecognizedFeatures() that the objects have in common.// It would be nice if we didn't have to repeat code like this, but there's no interface that hasEnumeration<> featuresgetXercesFeatures(...)copyFeatures1(...)getSAXFeatures(...)// We're not using XMLNotationDecl because we don't want to lose the augmentations.// This is a storage class to hold information about the notations.String expandedSystemId;Augmentations augmentations;// Useful for searching Vectors for notations with the same name// equals() returns true if two Notations have the same name.// base URI is the same.// resulting from combining the system identifier and the declaration// notations are duplicate through other means. For instance, the URI// to be duplicate. An application may also be able to detect that// [public identifier], and [declaration base URI] are considered// Notation items with the same [name], [system identifier],// from 4.5.2Notation otherother.publicIdother.expandedSystemId// We're not using XMLEntityDecl because we don't want to lose the augmentations.// This is a storage class to hold information about the unparsed entities.// Useful for searching Vectors for entities with the same name// equals() returns true if two UnparsedEntities have the same name.// identifier and the declaration base URI is the same.// means. For instance, the URI resulting from combining the system// be able to detect that unparsed entities are duplicate through other// [notation] are considered to be duplicate. An application may also// [public identifier], [declaration base URI], [notation name], and// Unparsed entity items with the same [name], [system identifier],// from 4.5.1:UnparsedEntity otherother.notation/** Saves the current base URI to the top of the stack. */// The following methods are used for XML Base processing/** Discards the URIs at the top of the stack, and restores the ones beneath it. *//** Saves the given language on the top of the stack. ... */// The following methods are used for language processing/** Discards the language at the top of the stack, and returns the one beneath it. *//** Gets the base URI that was in use at that depth ... */scopeOfBaseURI(...)/** Gets the language that was in use at that depth. ... */scopeOfLanguage(...)/** Returns a relative URI, which when resolved against the base URI at the ... */// second is higher.// such that the first is lower than 'depth' (or equal), and the// We need to find two consecutive elements in the scope stack,/** Search for a xml:base attribute, and if one is found, put the new base URI into ... */String baseURIValueString expandedValue/** Search for a xml:lang attribute, and if one is found, put the new ... *//** Returns <code>true</code> if the given string ... *//** Returns a new <code>XMLInputSource</code> from the given parameters. */HTTPInputSource httpSourcenew HTTPInputSource(...)setHTTPRequestProperty(...)XIncludeHandler.HTTP_ACCEPTXIncludeHandler.HTTP_ACCEPT_LANGUAGE// the Unicode plane 1-14 characters #x10000-#x1FFFD ... #xE0000-#xEFFFD// the Unicode plane 0 characters #xA0 - #xD7FF, #xF900-#xFDCF, #xFDF0-#xFFEF// To convert an IRI reference to a URI reference, the following characters must also be escaped:// the unwise characters { #x7B, } #x7D, | #x7C, \ #x5C, ^ #x5E and ` #x60// the delimiters < #x3C, > #x3E and " #x22// space #x20// To convert the value of the href attribute to an IRI reference, the following characters must be escaped:// Escape an href value according to (4.1.1):/* Copyright 2003-2005 The Apache Software Foundation. ... */// REVISIT: Find a better method for maintaining// the state of the XInclude processor. These arrays// can potentially grow quite large. Cleaning them// out on reset may be very time consuming. -- mrglavas// clear the previous settings from the arrays// if parser settings have not changed return.// parser settings changed. Need to refresh features on child config.// Get symbol table.// Get error reporter.// Get entity resolver.// Get security manager.// Get buffer size.// Reset XML 1.0 text reader.// Reset XML 1.1 text reader.// We don't want a schema validator on the new pipeline,// so if it was enabled, we set the feature to false. If// the validation feature was also enabled we turn on// dynamic validation, so that DTD validation is performed// on the included documents only if they have a DOCTYPE.// This is consistent with the behaviour on the main pipeline.// Don't reset fChildConfig -- we don't want it to share the same components.// It will be reset when it is actually used to parse something.// we do this to ensure that the proper location is reported in errors// otherwise, the locator from the root document would always be used// initialize the current base URI// initialize the current language// we need to change the depth like this so that modifyAugmentations() works// If the last two states were fallback then this must be a descendant of an include// child which isn't a fallback. The specification says we should ignore such elements// we process the xml:base and xml:lang attributes regardless// of what type of element it is.// reset the out of scope stack elements// check if an xml:base has gone out of scope// pop the values from the stack// if we're ending an include element, and we were expecting a fallback// we check to see if the children of this include element contained a fallback// the state would have been set to normal processing if we were expecting the fallback element// now that we're done processing it, we should ignore all the other children of the include element// check if an xml:lang has gone out of scope// pop the language from the stack// this ensures the proper location is displayed in error messages// Either the state is STATE_EXPECT_FALLBACK or it's STATE_IGNORE.// If we're ignoring, we want to stay ignoring. But if we're expecting this fallback element,// we want to signal that we should process the children.// TODO: does Java use IURIs by default?//       [Definition: An internationalized URI reference, or IURI, is a URI reference that directly uses [Unicode] characters.]// TODO: figure out what section 4.1.1 of the XInclude spec is talking about//       has to do with disallowed ASCII character escaping//       this ties in with the above IURI section, but I suspect Java already does it// When parse="xml" and an xpointer is specified treat// all absences of the href attribute as a resource error.// Check whether href is correct and perform escaping as per section 4.1.1 of the XInclude spec.// Report fatal error if the href value contains a fragment identifier or if the value after// escaping is a syntactically invalid URI or IRI.// Verify that if an accept and/or an accept-language attribute exist// that the value(s) don't contain disallowed characters.// setup an HTTPInputSource if either of the content negotation attributes were specified.// Instead of always creating a new configuration, the first one can be reused// use the same symbol table, error reporter, entity resolver, security manager and buffer size.// features must be copied to child configuration// use the same namespace context// If the xpointer attribute is present// If an xpointer attribute is present// Parse the XPointer expression// report the XPointer error as a resource error// set all features on parserConfig to match this parser configuration// necessary to make sure proper location is reported in errors// and it was not resolved// use the fallback// An IOException indicates that we had trouble reading the file, not// that it was an invalid XML file.  So we send a resource error, not a// fatal error.// we only care about encoding for parse="text"// Setup the appropriate text reader.// encoding errors// REVISIT: The namespace of this element should be bound// already. Why are we looking it up from the namespace// context? -- mrglavas// REVISIT: should we use File#sameFile() ?//          I think the benefit of using it is that it resolves host names//          instead of just doing a string comparison.// TODO: [base URI] is still an open issue with the working group.//       They're deciding if xml:base should be added if the [base URI] is different in terms//       of resolving relative references, or if it should be added if they are different at all.//       Revisit this after a final decision has been made.//       The decision also affects whether we output the file name of the URI, or just the path.// Technically, this doesn't check if the parent was a fallback, it also// would return true if any of the parent's sibling elements were fallbacks.// However, this doesn't matter, since we will always be ignoring elements// whose parent's siblings were fallbacks.// Modify attributes to fix the base URI (spec 4.5.5).// We only do it to top level included elements, which have a different// base URI than their include parent.// This causes errors with schema validation, if the schema doesn't// specify that these elements can have an xml:base attribute// this shouldn't ever happen, since by definition, we had to traverse// the same URIs to even get to this place// Modify attributes to perform language-fixup (spec 4.5.6).// [language] than their include parent.// Modify attributes of included items to do namespace-fixup. (spec 4.5.4)// Need to re-declare this prefix in the current context// in order for the SAX parser to report the appropriate// start and end prefix mapping events. -- mrglavas// 4.5.1 - Unparsed Entities// 4.5.2 - Notations/* We actually don't need to do anything for 4.5.3, because at this stage the ... *//** Check whether the scheme components are equal. *//** Check whether the authority components are equal. *//** The scheme and authority components are equal, ... */// We don't start at fDepth, since it is either the top level included item,// or an include element, when this method is called.// This technically might not always return the first non-include/fallback// element that it comes to, since sawFallback() returns true if a fallback// was ever encountered at that depth.  However, if a fallback was encountered// at that depth, and it wasn't the direct descendant of the current element// then we can't be in a situation where we're calling this method (because// we'll always be in STATE_IGNORE)// shouldn't get here, since depth 0 should never have an include element or// a fallback element// we won't worry about when error reporter is null, since there should always be// at least the default error reporter// first check the notation of the unparsed entity// There is no unparsed entity with the same name that we have sent.// Calling unparsedEntityDecl() will add the entity to our local store,// and also send the unparsed entity to the DTDHandler// There is no notation with the same name that we have sent.// componentManager doesn't support this feature,// so we won't worry about it// The literal system id at the location given by "start" is *in focus* at// the given depth. So we need to adjust it to the next scope, so that we// only process out of focus literal system ids// If that is the last system id, then we don't need a relative URI// we should never get here, because 0 was put on the stack in startDocument()// push the new values on the stack// REVISIT: throw error here// for each character in the href// if it's not an ASCII character (excluding 0x7F), break here, and use UTF-8 encoding// abort: href does not allow this character// check if remainder of href contains any illegal characters before proceeding// If escaping happened, create a new string;/** XIncludeMessageFormatter provides error messages for the XInclude 1.0 Candidate Recommendation ... */// TODO: fix error messages in XIncludeMessages.propertiesString XINCLUDE_DOMAIN;/** This is an implementation of NamespaceContext which is intended to be used for ... */...[] fValidContext;/** This stores whether or not the context at the matching depth was valid. */fValidContext.lengthboolean[] contextarray/** This method is used to set a context invalid for XInclude namespace processing. ... *//** This returns the namespace URI which was associated with the given pretext, in ... */int lastValidContext/** This class is used for reading resources requested in &lt;include&gt; elements, ... */Reader fReader;XIncludeHandler fHandler;/** Sets the XMLErrorReporter used for reporting errors while ... *//** Return the Reader for given XMLInputSource. ... */fTempString.ch.lengthfTempString.chURLConnection urlConString rawContentTypeString contentTypeString detectedEncodingIterator<> propIterconsumeBOM(...)MessageFormatter aFormatterLocale aLocale/** XMLEntityManager cares about endian-ness, since it creates its own optimized ... *//** Removes the byte order mark from the stream, if ... *//** REVISIT: This code is taken from com.sun.org.apache.xerces.internal.impl.XMLEntityManager. ... *//** Read the input stream as text, and pass the text on to the XIncludeHandler ... */// getEncodingName(byte[]):Object[]int readSizeint supfTempString.offset/** Sets the input source on this text reader. ... *//** Closes the stream.  Call this after parse(), or when there is no longer any need ... *//** Sets the buffer size property for the reader which decides the chunk sizes that are parsed ... */// Wrap the InputStream so that it is possible to rewind it.// If this is an HTTP connection attach any request properties to the request.// content type will be string like "text/xml; charset=UTF-8" or "text/xml"// text/xml and application/xml offer only one optional parameter// this should be something like "text/xml"// this should be something like "charset=UTF-8", but we want to// strip it down to just "UTF-8"// 8 is the length of "charset="// strip quotes, if present/** The encoding of such a resource is determined by: ... */// see RFC2376 or 3023, section 3.1// see RFC2376 or 3023, section 3.2// else 3 or 4.// eat the Byte Order Mark// If the document is UTF-8 or US-ASCII use// the Xerces readers for these encodings. For// US-ASCII consult the encoding map since// this encoding has many aliases.// Try to use a Java reader.// If the specified encoding wasn't a recognized IANA encoding throw an IOException.// The XIncludeHandler will report this as a ResourceError and then will// attempt to include a fallback if there is one.// this has the potential to throw an exception// it will be fixed when we ensure the stream is rewindable (see note above)// First two bytes are not BOM, so reset.// We could do UTF-32, but since the getEncodingName() doesn't support that// we won't support it here.// To implement UTF-32, look for:  00 00 FE FF for big-endian//                             or  FF FE 00 00 for little-endian// this signals us to use the value from the encoding attribute// retrieve next character// handle rare boundary case// convert surrogates to a supplemental characterConstants.XPOINTER_SCHEMA_PROPERTYString XPOINTER_SCHEMA;XMLGrammarDescription fGrammarDesc;StringBuffer fPointer;//protected String fPointerSchema;int elemCount;// This is used to access the appropriate level of the following stacks.// The current element depth.int fRootDepth;// is an include, and processing goes to the fallback.// This will normally be 1, but it could be larger when the top-level item// The depth of the first element to actually be part of the result infoset.QName foundElement;boolean skip;// START OF IMPLEMENTATION OF XMLComponent methods //////Enumeration<> xercesFeatures//////// START OF  IMPLEMENTATION OF XMLDOCUMENTSOURCE INTERFACE ////////////////// END OF IMPLEMENTATION  OF XMLComponents methods. //////////String fSchemaName;/////////////// Implementation of XPointerSchema Methods /////////////////////////////   END OF IMPLENTATION OF XMLDOCUMENTSOURCE INTERFACE ///////////String fSchemaPointer;boolean fSubResourceIdentified;/** set the Schema Name  eg element , xpointer *//** Return  Schema Name  eg element , xpointer *//** Parent Contenhandler for the this contenthandler. ... *//** return the Parent Contenthandler *//** Content of the XPointer Schema. Xpath to be resolved. *//** Return the XPointer Schema. */Stack<> fPointerToken;//////////// Tokens Playground //////////////////////////////End Implementation of XPointerSchema Methods //////////////////////int fCurrentTokenint;String fCurrentTokenString;int fCurrentTokenType;// 0 Notype; 1 for integer; 2 for string.String tempTokenInteger integerTokenStack<> tempPointerToken//getTokensObject currentTokenConstants.ID_ATTRIBUTEQName cacheQNameQName attrNameString attrTypeAugmentations aaugshasMoreToken(...)addQName(...)/////   START OF IMPLEMTATION OF XMLDocumentHandler methods /////////////////////  END TOKEN PLAYGROUND ///////////////getTokens(...)Stack<> ftempCurrentElement;int fElementCount;int fCurrentToken;boolean includeElement;boolean requiredTokencheckIntegerToken(...)checkStringToken(...)this.fParentXIncludeHandler/* try{ ... */// class XPointerElementhandlerimport XPointerSchema...[] fXPointerSchema;/* Todo's by next integration. ... */...[] fSchemaPointerName;...[] fSchemaPointerURI;String fCurrentSchemaPointer;Stack<> fSchemaNotAvailable;int fCountSchemaName;int schemaLength;XPointerSchema fDefaultXPointerSchema;int fschemalengthfXPointerSchema.lengthgetSchemaNames(...)getDefaultSchema(...)getXpointerSchemaName(...)setXPointerSchemaPointer(...)new XPointerElementHandler(...)int lastindexint schemapointerindexint schemapointerURIindexString tempURIgetEscapedURI(...)//XPointerFramwork/** The Augmentations interface defines a table of additional data that may ... *//** Represents an interface to query namespace information. ... *//** The XML Namespace ("http://www.w3.org/XML/1998/namespace"). This is ... *//** XML Information Set REC ... *//** Start a new Namespace context. ... */// NamespaceContext methods/** Revert to the previous Namespace context. ... *//** Declare a Namespace prefix. ... *//** Look up a prefix and get the currently-mapped Namespace URI. ... *//** Look up a namespace URI and get one of the mapped prefix. ... *//** Return a count of locally declared prefixes, including ... *//** Returns the prefix at the specified index in the current context. *//** Return an enumeration of all prefixes whose declarations are active ... *//** Reset this Namespace support object for reuse. ... */// interface NamespaceContext/** A structure that holds the components of an XML Namespaces qualified ... *//** The qname prefix. For example, the prefix for the qname "a:foo" ... *//** The qname localpart. For example, the localpart for the qname "a:foo" ... *//** The qname rawname. For example, the rawname for the qname "a:foo" ... *//** The URI to which the qname prefix is bound. This binding must be ... *//** Constructs a copy of the specified QName. *//** Convenience method to set the values of the qname components. ... */// setValues(QName)/** Clears the values of the qname components. */// Cloneable methods/** Returns the hashcode for this object. */boolean comma// fall through and return not equal// class QName/** The XMLAttributes interface defines a collection of attributes for ... *//** Returns the number of attributes in the list. ... *///why the above method doens't return QName ?/** Look up an attribute's value by Namespace name. ... *//** Look up an augmentation by attribute's index. ... *//** Look up an augmentation by namespace name. ... */// interface XMLAttributes/** The DTD content model handler interface defines callback methods ... */short SEPARATOR_CHOICE;/** A choice separator for children and mixed content models. This ... */// separatorsshort SEPARATOR_SEQUENCE;/** A sequence separator for children content models. This separator ... */short OCCURS_ZERO_OR_ONE;/** This occurrence count limits the element, choice, or sequence in a ... */// occurrence countsshort OCCURS_ZERO_OR_MORE;short OCCURS_ONE_OR_MORE;// interface XMLDTDContentModelHandler/** The DTD handler interface defines callback methods to report ... */short CONDITIONAL_INCLUDE;/** Conditional section: INCLUDE. ... */short CONDITIONAL_IGNORE;/** Conditional section: IGNORE. ... */// interface XMLDTDHandler/** This handler interface contains methods necessary to receive ... *//** The start of the document fragment. ... *//** The end of the document fragment. ... */// interface XMLDocumentFragmentHandler/** The document handler interface defines callback methods to report ... */// interface XMLDocumentHandler/** Location information. ... */// XMLLocator methods/** Returns the base system identifier. *//** Returns the line number, or <code>-1</code> if no line number is available. *//** Returns the column number, or <code>-1</code> if no column number is available. *//** Returns the character offset, or <code>-1</code> if no character offset is available. */// interface XMLLocator/** <p> This represents the basic physical description of the location of any ... *//** Setsthe base URI against which the literal SystemId is to be ... *//** <p> Returns the base URI against which the literal SystemId is to be ... */// XMLResourceIdentifier/** This class is used as a structure to pass text contained in the underlying ... *//** The character array. *//** The offset into the character array. *//** The length of characters from the offset. *//** Constructs an XMLString structure preset with the specified ... *//** Constructs an XMLString structure with copies of the values in ... *//** Initializes the contents of the XMLString structure with the ... *//** Initializes the contents of the XMLString structure with copies ... */// setValues(char[],int,int)/** Resets all of the values to their defaults. */// setValues(XMLString)/** Returns true if the contents of this XMLString structure and ... */// equals(char[],int,int):boolean// equals(String):boolean// is this faster than call s.toCharArray first and compare the// two arrays directly, which will possibly involve creating a// new char array object.// class XMLString/** This exception is the base exception of all XNI exceptions. It ... *//** The wrapped exception. *//** Constructs an XNI exception with a message. ... *//** Constructs an XNI exception with a wrapped exception. ... *//** Constructs an XNI exception with a message and wrapped exception. ... */// <init>(Exception)/** Returns the wrapped exception. */// <init>(Exception,String)/** A generic grammar for use in validating XML documents. The Grammar ... *//** get the <code>XMLGrammarDescription</code> associated with this ... */// interface Grammar/** Return the root name of this DTD. ... */// interface XMLDTDDescription/** <p> This interface describes basic attributes of XML grammars--their ... */String XML_SCHEMA;/** The grammar type constant for XML Schema grammars. When getGrammarType() ... */// their Grammar objects implement this interface).// certainly use their own constants in place of these (so long as// components which create and/or recognize other types of grammars may// initial set of grammar constants that some configurations will recognize;userString XML_DTD;/** The grammar type constant for DTD grammars. When getGrammarType() ... *//** Return the type of this grammar. ... */// interface XMLGrammarDescription/** The intention of this interface is to provide a generic means ... *//** <p> This interface specifies how the parser and the application ... *//** <p> retrieve the initial known set of grammars. this method is ... */// methods. </p>// grammars, so we have a parameter "grammarType" for each of the// <p>we are trying to make this XMLGrammarPool work for all kinds of/** <p>return the final set of grammars that the validator ended up ... *//** <p> This method requests that the application retrieve a grammar ... *//** Causes the XMLGrammarPool not to store any grammars when ... *//** Allows the XMLGrammarPool to store grammars when its cacheGrammars(String, Grammar[]) ... *//** Removes all grammars from the pool. */// XMLGrammarPool/** Indicate that the current schema document is &lt;include&gt;d by another ... *//** Indicate that the current schema document is &lt;redefine&gt;d by another ... *//** Indicate that the current schema document is &lt;import&gt;ed by another ... *//** If a call is triggered by an attribute or xsi:type, then this method ... *//** Representing a schema grammar. It contains declaratoin/definitions from ... */// interface XSGrammar/** The component interface defines methods that must be implemented ... */// interface XMLComponent/** The component manager manages a parser configuration and the components ... */// interface XMLComponentManager/** An XNI parser configuration exception. This exception class extends ... */Status fType;/** Exception type. */String fIdentifier;/** Identifier. *//** Constructs a configuration exception with the specified type ... *//** Constructs a configuration exception with the specified type, ... */// <init>(short,String)/** Returns the exception type. */// <init>(short,String,String)/** Returns the feature or property identifier. */// getType():short// getIdentifier():String// class XMLConfigurationException/** Defines a DTD content model filter that acts as both a receiver and ... */// interface XMLDTDContentModelFilter/** Defines a DTD content model source. In other words, any object that ... *//** Sets the DTD content model handler. *//** Returns the DTD content model handler. */// interface XMLDTDContentModelSource/** Defines a DTD filter that acts as both a receiver and an emitter ... */// interface XMLDTDFilter/** This interface defines a generic DTD scanner. This interface ... */// interface XMLDTDScanner/** Defines a DTD source. In other words, any object that implements ... *//** Sets the DTD handler. *//** Returns the DTD handler. */// interface XMLDTDSource/** Defines a document filter that acts as both a receiver and an emitter ... */// interface XMLDocumentFilter/** This interface defines a generic document scanner. This interface ... */// interface XMLDocumentScanner/** Defines a document source. In other words, any object that implements ... *//** Sets the document handler. */// interface XMLDocumentSource/** This interface is used to resolve external parsed entities. The ... */// interface XMLEntityResolver/** An interface for handling errors. If the application is interested ... */// interface XMLErrorHandler/** This class represents an input source for an XML document. The ... *//** Base system identifier. *//** Byte stream. *//** Character stream. *//** Encoding. *//** Returns the system identifier. *//** Sets the base system identifier. ... *//** Returns the byte stream. */// setByteStream(InputSource)// getByteStream():InputStream/** Returns the character stream. */// getCharacterStream():Reader/** Returns the encoding of the stream, or null if not known. */// class XMLInputSource/** A parsing exception. This exception is different from the standard ... *//** literal System identifier. *//** expanded System identifier. */int fCharacterOffset;/** Character offset. *//** Constructs a parse exception. */// <init>(XMLLocator,String)// <init>(XMLLocator,String,Exception)/** Returns the row number. */// getRowNumber():int// getCharacterOffset():int// XMLParseException/** Represents a parser configuration. The parser configuration maintains ... */// generic configuration/** Sets the state of a feature. This method is called by the parser ... *//** Sets the value of a property. This method is called by the parser ... *//** Sets the document handler to receive information about the document. ... */// interface XMLParserConfiguration/** Represents a parser configuration that can be used as the ... */// interface XMLPullParserConfigurationString fSchemeName;// The Scheme Name i.e element// FieldsString fSchemeData;// The scheme DataString fShortHandPointerName;// The scheme Data & child sequenceboolean fIsResolveElement;// attempt to resolve relative to the short hand pointer.// current element position. If a ShortHand Pointer is present// Should we attempt to resolve the ChildSequence from theboolean fIsElementFound;// Has the element been foundboolean fWasOnlyEmptyElementFound;// Was only an empty element foundboolean fIsShortHand;// If a shorthand pointer is present and resolvedint fFoundDepth;// The depth at which the element was found...[] fChildSequence;// The XPointer element child sequenceint fCurrentChildPosition;// The current child positionint fCurrentChildDepth;// The current child depth...[] fCurrentChildSequence;// The current element's child sequenceboolean fIsFragmentResolved;// Stores if the Fragment was resolved by the pointerShortHandPointer fShortHandPointer;// The XPointer Error reporter// The XPointer Error Handler// ************************************************************************/** Parses the XPointer expression and tokenizes it into Strings ... */// XPointerPart implementationTokens tokensnew Scanner(...) { ... }ElementSchemePointer$1Tokens.XPTRTOKEN_ELEM_CHILDTokens.XPTRTOKEN_ELEM_NCNAMEint[] tmpChildSequencegetTokenCount(...)new ShortHandPointer(...)setSchemeName(...)/** Returns the scheme name i.e element ... *//** Returns the scheme data ... *//** Sets the scheme name ... *//** Sets the scheme data ... *//** Responsible for resolving the element() scheme XPointer.  If a ShortHand ... */boolean isShortHandPointerResolvedresolveXPointer(...)fChildSequence.lengthmatchChildSequence(...)/** Matches the current element position in the document tree with the ... */fCurrentChildSequence.lengthint[] tmpCurrentChildSequencetmpCurrentChildSequence.lengthXPointerPart.EVENT_ELEMENT_STARTcheckMatch(...)XPointerPart.EVENT_ELEMENT_ENDXPointerPart.EVENT_ELEMENT_EMPTY/** Matches the current position of the element being visited by checking ... *//** Returns true if the node matches or is a child of a matching element() ... *//** Returns true if the XPointer expression resolves to a non-element child ... */isChildFragmentResolved(...)/** Reports an XPointer error */XPointerMessageFormatter.XPOINTER_DOMAIN/** Initializes error handling objects */new XPointerErrorHandler(...)new XPointerMessageFormatter(...)/** Initializes the element scheme processor */initErrorReporter(...)ElementSchemePointer$Tokens/** List of XPointer Framework tokens. ... */// element() Scheme expression scannerint XPTRTOKEN_ELEM_NCNAME;/** XPointer element() scheme ... */int XPTRTOKEN_ELEM_CHILD;// Token names// Token count// Current token positionHashtable<> fTokenNames;/** Constructor ... *//* Returns the token String ... *//** Returns the token String ... *//** Add the specified string as a token ... *//** Add the specified int token ... *//** Returns the number of tokens. */ElementSchemePointer$Scanner/** The XPointer expression scanner.  Scans the XPointer framework expression. ... *//** Constructs an XPath expression scanner. ... *//** Scans the XPointer Expression *//** Scans a NCName. ... */// scan the element() XPointer expression// Initialize a temp arrays to the size of token count which should// be atleast twice the size of child sequence, to hold the ChildSequence.// the element depth// Traverse the scanned tokens// Note:  Only a single ShortHand pointer can be present// The shortHand name// Create a new ShortHandPointer// Initialize the arrays to the number of elements in the ChildSequence.// if a ChildSequence exisits, resolve child elements// if an element name exists// resolve ShortHand Pointer// Added here to skip the ShortHand pointer corresponding to// an element if one exisits and start searching from its child// if only a resolved shorthand pointer exists// need to resize fCurrentChildSequence// Increase the size by a factor of 2 (?)// start// reset the current child position//if (!fSchemeNameFound) {// or empty element found// reset array position of last child// Donot check for empty elements if the empty element is// a child of a found parent element//if (!fIsElementFound) {// If the number of elements in the ChildSequence is greater than the// current child depth, there is not point in checking further// If a shorthand pointer is not present traverse the children// and compare// If a shorthand pointer is present traverse the children// ignoring the first element of the CurrenChildSequence which// contains the ShortHand pointer element and compare// ensure fCurrentChildSequence is large enough// ignore the first element of fCurrentChildSequence// Return true if the Fragment was resolved and the current Node depth// is greater than or equal to the depth at which the element was found// if only a shorthand pointer was present/* fErrorReporter.reportError(XPointerMessageFormatter.XPOINTER_DOMAIN, ... */// invalid XML characters, control characters and 7F// A valid XML character (possibly invalid NCNameChar) that does not fall in one of the other categories// [1]    ElementSchemeData    ::=    (NCName ChildSequence?) | ChildSequence// [2]    ChildSequence    ::=    ('/' [1-9] [0-9]*)+// if last character is '/', break and report an error// ChildSequence    ::=    ('/' [1-9] [0-9]*)+// An invalid child sequence character// Scan the ShortHand Pointer NCName//return false;String fShortHandPointer;// The name of the ShortHand pointer// SymbolTable/** The XPointerProcessor takes care of this.  Simply set the ShortHand Pointer here. ... */int fMatchingChildCount;/** Resolves the XPointer ShortHand pointer based on the rules defined in ... */hasMatchingIdentifier(...)getSchemaDeterminedID(...)getChildrenSchemaDeterminedID(...)getDTDDeterminedID(...)/** Rerturns the DTD determine-ID ... *//** Returns the schema-determined-ID. ... */XSTypeDefinition typeDef/** Not quite sure how this can be correctly implemented. ... *//** Returns the name of the ShortHand pointer ... */// reset fIsFragmentResolved// On startElement or emptyElement, if no matching elements or parent// elements were found, check for a matching idenfitier.// On endElement, decrease the matching child count if the child or// its parent was resolved.// The identifiers of an element are determined by the// ShortHand Pointer as follows:// 1. If an element information item has an attribute information item// among its [attributes] that is a schema-determined ID, then it is// identified by the value of that attribute information item's// [schema normalized value] property;// 2. If an element information item has an element information item among// its [children] that is a schema-determined ID, then it is identified by// the value of that element information item's [schema normalized value] property;// 3. If an element information item has an attribute information item among// its [attributes] that is a DTD-determined ID, then it is identified by the// value of that attribute information item's [normalized value] property.// An attribute information item is a DTD-determined ID if and only if it has// a [type definition] property whose value is equal to ID.// 4. No externally determined ID's// An element or attribute information item is a schema-determined// ID if and only if one of the following is true:]// 1. It has a [member type definition] or [type definition] property// whose value in turn has [name] equal to ID and [target namespace]// equal to http://www.w3.org/2001/XMLSchema;// 2. It has a [base type definition] whose value has that [name] and [target namespace];// 3. It has a [base type definition] whose value has a [base type definition]// whose value has that [name] and [target namespace], and so on following// the [base type definition] property recursively;// 4 & 5 NA// NA/** The Default XPointer error handler used by the XInclude implementation. ... *///throw ex;Vector<> fXPointerParts;// A Vector of XPointerPartsXPointerPart fXPointerPart;// The current XPointerPartboolean fFoundMatchingPtrPart;// Has the fXPointerPart resolved successfullyXMLErrorReporter fXPointerErrorReporter;// XPointerFramework symbol tableString ELEMENT_SCHEME_NAME;// Supported schemesboolean fIsXPointerResolved;// Has the XPointer resolved the subresourceboolean fFixupBase;// Fixup xml:base and xml:lang attributesboolean fFixupLang;/** Parses the XPointer framework expression and delegates scheme specific parsing. ... *///  Implementation of the XPointerProcessor interface.XPointerHandler$1Tokens.XPTRTOKEN_OPEN_PARENTokens.XPTRTOKEN_CLOSE_PARENTokens.XPTRTOKEN_SCHEMENAMETokens.XPTRTOKEN_SCHEMEDATATokens.XPTRTOKEN_SHORTHANDString shortHandPointerNameXPointerPart shortHandPointerString schemeNameint openParenCountint closeParenCountString openParenString schemeDataString closeParenXPointerPart elementSchemePointernew ElementSchemePointer(...)setSchemeData(...)boolean resolved/** Returns true if the Node fragment is resolved. ... */isFragmentResolved(...)/** Returns true if the XPointer successfully found a sub-resource . ... *//** Returns the pointer part used to resolve the document fragment. ... *//** Reports XPointer Errors *//** Reports XPointer Warnings *//** Initializes the XPointer Processor; *//** Returns a Vector of XPointerPart objects ... */XPointerHandler$Tokensint XPTRTOKEN_OPEN_PAREN, ...;/** XPointer Framework tokens ... */String tokenStrintXPointerHandler$Scanner/** Constructs an XPointer Framework expression scanner. ... */int openParenint closeParenint dataOffsetboolean isQNameStringBuffer schemeDataBuff/** Scans the SchemeData. ... *//** If the comment is a child of a matched element, then pass else return. ... *///  Overridden XMLDocumentHandler methods// Overridden XMLComponent methods//fErrorReporter = errorReporter; // The XInclude ErrorReporter// Initialize// scan the XPointer expression// Retreive the local name and prefix to form the scheme name// The next character should be an open parenthesis// can not have more than one ShortHand Pointer// followed by zero or more ( and  the schemeData// followed by the same number of )// check if the number of open parenthesis are equal to the number of close parenthesis// Perform scheme specific parsing of the pointer part// If an exception occurs while parsing the element() scheme expression// ignore it and move on to the next pointer part// Re-throw the XPointer element() scheme syntax error.// ????// The result of the first pointer part whose evaluation identifies// one or more subresources is reported by the XPointer processor as the// result of the pointer as a whole, and evaluation stops.// In our implementation, typically the first xpointer scheme that// matches an element is the document is considered.// If the pointer part resolved then use it, else search for the fragment// using next pointer part from lef-right.// for each element, attempt to resolve it against each pointer part// in the XPointer expression until a matching element is found./* fXPointerErrorReporter.reportError( ... *//* fXPointerErrorReporter.setProperty(Constants.XERCES_PROPERTY_PREFIX ... *///fFixupBase = false;//fFixupLang = false;// not special - one of "#%&;?\`{}~" or DEL// ^// [1]    Pointer      ::=    Shorthand | SchemeBased// [2]    Shorthand    ::=    NCName// [3]    SchemeBased  ::=    PointerPart (S? PointerPart)*// [4]    PointerPart  ::=    SchemeName '(' SchemeData ')'// [5]    SchemeName   ::=    QName// [6]    SchemeData   ::=    EscapedData*// [7]    EscapedData  ::=    NormalChar | '^(' | '^)' | '^^' | '(' SchemeData ')'// [8]    NormalChar   ::=    UnicodeChar - [()^]// [9]    UnicodeChar  ::=    [#x0-#x10FFFF]// [?]    QName        ::=    (NCName ':')? NCName// [?]    NCName       ::=    (Letter | '_') (NCNameChar)*// [?]    NCNameChar   ::=    Letter | Digit | '.' | '-' | '_'  (ascii subset of 'NCNameChar')// [?]    Letter       ::=    [A-Za-z]                              (ascii subset of 'Letter')// [?]    Digit        ::=    [0-9]                                  (ascii subset of 'Digit')// Scanning SchemeName | Shorthand// The name is a QName => a SchemeName// NCName => Shorthand// reset open/close paren for the next pointer part// Scanning SchemeData// ex. schemeName()// Should we throw an exception with a more suitable message instead??//while (currentOffset++ < endOffset) {//schemeData.append(Tokens.XPTRTOKEN_OPEN_PAREN);// xml:base and xml:lang processing// set the context invalid if the element till an element from the result infoset is included// no need to restore restoreBaseURI() for xml:base and xml:lang processing// Error reporter// Error handler// xml:lang// xml:base/** XPointerMessageFormatter provides error messages for the XPointer Framework ... */String XPOINTER_DOMAIN;/** Formats a message with the specified arguments using the given locale ... */int EVENT_ELEMENT_START;// The start element eventint EVENT_ELEMENT_END;// The end element eventint EVENT_ELEMENT_EMPTY;// The empty element event/** Provides scheme specific parsing of a XPointer expression i.e. ... *//** Evaluates an XML resource with respect to an XPointer expressions ... *//** Returns true if the XPointer expression resolves to a resource fragment ... *//** Returns a String containing the scheme name of the PointerPart ... *//** Returns a String containing the scheme data of the PointerPart. ... *//** Sets the scheme name of the PointerPart or the ShortHand Pointer name. ... *//** Sets the scheme data of the PointerPart. ... *//** Parses an XPointer expression.  It performs scheme specific processing ... *//** Returns true if the XPointer expression resolves to the current resource fragment ... *//** Returns true if the XPointer expression resolves any subresource of the ... *//** Represents a PSVI item for one attribute information item. *//** [attribute declaration]: An item isomorphic to the declaration ... *//** Represents a PSVI item for one element information item. *//** [element declaration]: an item isomorphic to the element declaration ... *//** [notation]: the notation declaration. *//** [nil]: true if clause 3.2 of Element Locally Valid (Element) (3.3.4) is ... *//** schema information: the schema information property if it is the ... *//** Represents an abstract PSVI item for an element or an attribute ... */short VALIDITY_NOTKNOWN;/** Validity value indicating that validation has either not been performed ... */short VALIDITY_INVALID;/** Validity value indicating that validation has been strictly assessed ... */short VALIDITY_VALID;/** Validation status indicating that schema validation has been performed ... */short VALIDATION_NONE;short VALIDATION_PARTIAL;short VALIDATION_FULL;/** Validation status indicating that full schema validation has been ... *//** The nearest ancestor element information item with a ... *//** <code>[validity]</code>: determines the validity of the schema item ... *//** <code>[validation attempted]</code>: determines the extent to which ... *//** <code>[schema error code]</code>: a list of error codes generated from ... *//** <code>[schema normalized value]</code>: the normalized value of this ... *//** <code>[schema normalized value]</code>: Binding specific actual value ... *//** The actual value built-in datatype, e.g. ... *//** In the case the actual value represents a list, i.e. the ... *//** <code>[type definition]</code>: an item isomorphic to the type ... *//** <code>[member type definition]</code>: if and only if that type ... *//** <code>[schema default]</code>: the canonical lexical representation of ... *//** <code>[schema specified]</code>: if true, the value was specified in ... *//* Copyright 2003,2004 The Apache Software Foundation. ... *//** The <code>LSInputList</code> interface provides the abstraction of an ... *//** This interface provides access to the post schema validation infoset for an ... *//** Provides the post schema validation item for the current element ... *//** Provides <code>AttributePSVI</code> given the index of an attribute ... *//** Provides <code>AttributePSVI</code> given the namespace name and the ... *//** The <code>ShortList</code> is an immutable ordered collection of ... *//** The number of <code>unsigned short</code>s in the list. The range of ... *//** The <code>StringList</code> is an immutable ordered collection of ... *//** The number of <code>GenericString</code>s in the list. The range of ... *//** This interface represents the Annotation schema component. */short W3C_DOM_ELEMENT;/** The object type is <code>org.w3c.dom.Element</code>. */// TargetTypeshort SAX_CONTENTHANDLER;/** The object type is <code>org.xml.sax.ContentHandler</code>. */short W3C_DOM_DOCUMENT;/** The object type is <code>org.w3c.dom.Document</code>. *//** Write contents of the annotation to the specified object. If the ... *//** A text representation of the annotation. *//** The interface represents the Attribute Declaration schema component. *//** [type definition]: A simple type definition. *//** [scope]. One of <code>SCOPE_GLOBAL</code>, <code>SCOPE_LOCAL</code>, or ... *//** The complex type definition for locally scoped declarations (see ... *//** Value constraint: one of <code>VC_NONE, VC_DEFAULT, VC_FIXED</code>. *//** Value constraint: The constraint value with respect to the [type ... *//** Value Constraint: Binding specific actual constraint value or ... *//** The actual constraint value built-in datatype, e.g. ... *//** In the case the actual constraint value represents a list, i.e. the ... *//** An annotation if it exists, otherwise <code>null</code>. ... *//** A sequence of [annotations] or an empty  <code>XSObjectList</code>. *//** This interface represents the Attribute Group Definition schema component. *//** A set of [attribute uses] if it exists, otherwise an empty ... *//** A [wildcard] if it exists, otherwise <code>null</code>. *//** An annotation if it exists, otherwise <code>null</code>. If not null ... *//** A sequence of [annotations] or an empty <code>XSObjectList</code>. *//** This interface represents the Attribute Use schema component. *//** [required]: determines whether this use of an attribute declaration ... *//** [attribute declaration]: provides the attribute declaration itself, ... *//** Value Constraint: The constraint value, otherwise <code>null</code>. *//** This interface represents the Complex Type Definition schema component. */short CONTENTTYPE_EMPTY;/** Represents an empty content type. A content type with the distinguished ... */// Content Model Typesshort CONTENTTYPE_SIMPLE;/** Represents a simple content type. A content type which is simple ... */short CONTENTTYPE_ELEMENT;/** Represents an element-only content type. An element-only content type ... */short CONTENTTYPE_MIXED;/** Represents a mixed content type. *//** [derivation method]: either <code>DERIVATION_EXTENSION</code>, ... *//** [abstract]: a boolean. Complex types for which <code>abstract</code> is ... *//** A set of attribute uses if it exists, otherwise an empty ... *//** An attribute wildcard if it exists, otherwise <code>null</code>. *//** [content type]: one of empty (<code>CONTENTTYPE_EMPTY</code>), a simple ... *//** A simple type definition corresponding to a simple content model, ... *//** A particle for a mixed or element-only content model, otherwise ... *//** [prohibited substitutions]: a subset of {extension, restriction} ... *//** [prohibited substitutions]: A subset of {extension, restriction} or ... *//** This interface defines constants used by this specification. */short ATTRIBUTE_DECLARATION;/** The object describes an attribute declaration. */// XML Schema Componentsshort ELEMENT_DECLARATION;/** The object describes an element declaration. */short TYPE_DEFINITION;/** The object describes a complex type or simple type definition. */short ATTRIBUTE_USE;/** The object describes an attribute use definition. */short ATTRIBUTE_GROUP;/** The object describes an attribute group definition. */short MODEL_GROUP_DEFINITION;/** The object describes a model group definition. */short MODEL_GROUP;/** A model group. */short PARTICLE;/** The object describes a particle. *//** The object describes a wildcard. */short IDENTITY_CONSTRAINT;/** The object describes an identity constraint definition. */short NOTATION_DECLARATION;/** The object describes a notation declaration. */short ANNOTATION;/** The object describes an annotation. */short FACET;/** The object describes a constraining facet. Note: this object does not ... */short MULTIVALUE_FACET;/** The object describes enumeration and pattern facets. */short DERIVATION_NONE;/** No constraint is available. */// Derivation constantsshort DERIVATION_EXTENSION;/** <code>XSTypeDefinition</code> final set or ... */short DERIVATION_RESTRICTION;short DERIVATION_SUBSTITUTION;/** <code>XSTypeDefinition</code> final set. */short DERIVATION_UNION;short DERIVATION_LIST;short DERIVATION_EXTENSION_RESTRICTION_SUBSTITION;short DERIVATION_ALL;/** The scope of a declaration within named model groups or attribute ... */// Scope/** A scope of <code>global</code> identifies top-level declarations. *//** <code>Locally scoped</code> declarations are available for use only ... */short VC_NONE;/** Indicates that the component does not have any value constraint. */// Value Constraintshort VC_DEFAULT;/** Indicates that there is a default value constraint. */short VC_FIXED;/** Indicates that there is a fixed value constraint for this attribute. */short ANYSIMPLETYPE_DT;/** anySimpleType */// Built-in types: primitive and derivedshort STRING_DT;/** string */short BOOLEAN_DT;/** boolean */short DECIMAL_DT;/** decimal */short FLOAT_DT;/** float */short DOUBLE_DT;/** double */short DURATION_DT;/** duration */short DATETIME_DT;/** dateTime */short TIME_DT;/** time */short DATE_DT;/** date */short GYEARMONTH_DT;/** gYearMonth */short GYEAR_DT;/** gYear */short GMONTHDAY_DT;/** gMonthDay */short GDAY_DT;/** gDay */short GMONTH_DT;/** gMonth */short HEXBINARY_DT;/** hexBinary */short BASE64BINARY_DT;/** base64Binary */short ANYURI_DT;/** anyURI */short QNAME_DT;/** QName */short NOTATION_DT;/** NOTATION */short NORMALIZEDSTRING_DT;/** normalizedString */short TOKEN_DT;/** token */short LANGUAGE_DT;/** language */short NMTOKEN_DT;/** NMTOKEN */short NAME_DT;/** Name */short NCNAME_DT;/** NCName */short ID_DT;/** ID */short IDREF_DT;/** IDREF */short ENTITY_DT;/** ENTITY */short INTEGER_DT;/** integer */short NONPOSITIVEINTEGER_DT;/** nonPositiveInteger */short NEGATIVEINTEGER_DT;/** negativeInteger */short LONG_DT;/** long */short INT_DT;/** int */short SHORT_DT;/** short */short BYTE_DT;/** byte */short NONNEGATIVEINTEGER_DT;/** nonNegativeInteger */short UNSIGNEDLONG_DT;/** unsignedLong */short UNSIGNEDINT_DT;/** unsignedInt */short UNSIGNEDSHORT_DT;/** unsignedShort */short UNSIGNEDBYTE_DT;/** unsignedByte */short POSITIVEINTEGER_DT;/** positiveInteger */short LISTOFUNION_DT;/** The type represents a list type definition whose item type (itemType) ... */short LIST_DT;/** The type represents a list type definition. */short UNAVAILABLE_DT;/** The built-in type category is not available. *//** The interface represents the Element Declaration schema component. *//** [type definition]: either a simple type definition or a complex type ... *//** [Value constraint]: one of <code>VC_NONE, VC_DEFAULT, VC_FIXED</code>. *//** [Value constraint]: the constraint value with respect to the [type ... *//** If nillable is true, then an element may also be valid if it carries ... *//** identity-constraint definitions: a set of constraint definitions if it ... *//** [substitution group affiliation]: a top-level element definition if it ... *//** Convenience method that checks if <code>exclusion</code> is a ... *//** [substitution group exclusions]: the returned value is a bit ... *//** Convenience method that checks if <code>disallowed</code> is a ... *//** [disallowed substitutions]: the returned value is a bit combination of ... *//** The XML Schema API operations only raise exceptions in "exceptional" ... */short code;short NOT_SUPPORTED_ERR;/** If the implementation does not support the requested type of object or ... */// ExceptionCodeshort INDEX_SIZE_ERR;/** If index or size is negative, or greater than the allowed value *//** Describes a constraining facet. Enumeration and pattern facets are exposed ... *//** The name of the facet, e.g. <code>FACET_LENGTH, FACET_TOTALDIGITS</code> ... *//** A value of this facet. *//** [Facets]: check whether a facet is fixed. *//** This interface represents the Identity-constraint Definition schema ... */short IC_KEY;/** See the definition of <code>key</code> in the identity-constraint ... */// Identity Constraintsshort IC_KEYREF;/** See the definition of <code>keyref</code> in the identity-constraint ... */short IC_UNIQUE;/** See the definition of <code>unique</code> in the identity-constraint ... *//** [identity-constraint category]: one of key, keyref or unique. *//** [selector]: a restricted XPath 1.0 expression. *//** [fields]: a non-empty list of restricted  XPath 1.0 expressions. *//** [referenced key]: required if [identity-constraint category] is keyref, ... *//** This interface allows one to retrieve an instance of <code>XSLoader</code>. ... *//** A list containing the versions of XML Schema documents recognized by ... *//** Creates a new XSLoader. The newly constructed loader may then be ... *//** An interface that provides a method to load XML Schema documents. This ... *//** This interface represents an XML Schema. *//** This interface represents the Model Group schema component. */short COMPOSITOR_SEQUENCE;/** This constant value signifies a sequence operator. */// Content model compositorsshort COMPOSITOR_CHOICE;/** This constant value signifies a choice operator. */short COMPOSITOR_ALL;/** This content model represents a simplified version of the SGML ... *//** [compositor]: one of all, choice or sequence. The valid constant values ... *//** A list of [particles] if it exists, otherwise an empty ... *//** This interface represents the Model Group Definition schema component. *//** Describes a multi-value constraining facets: pattern and enumeration. *//** The name of the facet, i.e. <code>FACET_ENUMERATION</code> and ... *//** Values of this facet. *//** Objects implementing the <code>XSNamedMap</code> interface are used to ... *//** The interface represents the namespace schema information information item. ... *//** [schema namespace]: A namespace name or <code>null</code> if absent. *//** [document location] - a list of location URIs for the documents that ... *//** The <code>XSNamesaceItemList</code> interface provides the abstraction of ... *//** This interface represents the Notation Declaration schema component. *//** The URI reference representing the system identifier for the notation ... *//** The string representing the public identifier for this notation ... *//** The <code>XSObject</code> is a base object for the XML Schema component ... *//** The name of type <code>NCName</code>, as defined in XML Namespaces, of ... *//** The <code>XSObjectList</code> interface provides the abstraction of an ... *//** This interface represents the Particle schema component. *//** [min occurs]: determines the minimum number of terms that can occur. *//** [max occurs]: determines the maximum number of terms that can occur. ... *//** [max occurs]: whether the maxOccurs value is unbounded. *//** [term]: one of a model group, a wildcard, or an element declaration. *//** This interface represents the Simple Type Definition schema component. This ... */short VARIETY_ABSENT;/** The variety is absent for the anySimpleType definition. */// Variety definitionsshort VARIETY_ATOMIC;/** <code>Atomic</code> type. */short VARIETY_LIST;/** <code>List</code> type. */short VARIETY_UNION;/** <code>Union</code> type. */short FACET_NONE;/** No facets defined. */// Facetsshort FACET_LENGTH;/** 4.3.1 Length */short FACET_MINLENGTH;/** 4.3.2 minLength. */short FACET_MAXLENGTH;/** 4.3.3 maxLength. */short FACET_PATTERN;/** 4.3.4 pattern. */short FACET_WHITESPACE;/** 4.3.5 whitespace. */short FACET_MAXINCLUSIVE;/** 4.3.7 maxInclusive. */short FACET_MAXEXCLUSIVE;/** 4.3.9 maxExclusive. */short FACET_MINEXCLUSIVE;/** 4.3.9 minExclusive. */short FACET_MININCLUSIVE;/** 4.3.10 minInclusive. */short FACET_TOTALDIGITS;/** 4.3.11 totalDigits . */short FACET_FRACTIONDIGITS;/** 4.3.12 fractionDigits. */short FACET_ENUMERATION;/** 4.3.5 enumeration. */short ORDERED_FALSE;/** A constant defined for the 'ordered' fundamental facet: not ordered. */short ORDERED_PARTIAL;/** A constant defined for the 'ordered' fundamental facet: partially ... */short ORDERED_TOTAL;/** A constant defined for the 'ordered' fundamental facet: total ordered. *//** [variety]: one of {atomic, list, union} or absent. *//** Describes a term that can be one of a model group, a wildcard, or an ... *//** This interface represents a complex or simple type definition. */short COMPLEX_TYPE;/** The object describes a complex type. */short SIMPLE_TYPE;/** The object describes a simple type. *//** Return whether this type definition is a simple type or complex type. *//** {base type definition}: either a simple type definition or a complex ... *//** {final}. For a complex type definition it is a subset of {extension, ... *//** For complex types the returned value is a bit combination of the subset ... *//** Convenience attribute. A boolean that specifies if the type definition ... *//** Convenience method which checks if this type is derived from the given ... *//** This interface represents the Wildcard schema component. */short NSCONSTRAINT_ANY;/** Namespace Constraint: any namespace is allowed. */// Namespace Constraintshort NSCONSTRAINT_NOT;/** Namespace Constraint: namespaces in the list are not allowed. */short NSCONSTRAINT_LIST;/** Namespace Constraint: namespaces in the list are allowed. */short PC_STRICT;/** There must be a top-level declaration for the item available, or the ... */// Process contentsshort PC_SKIP;/** No constraints at all: the item must simply be well-formed XML. */short PC_LAX;/** If the item, or any items among its [children] is an element ... *//** Namespace constraint: For <code>constraintType</code> ... *//** [process contents]: one of skip, lax or strict. Valid constants values ... *//** <p>The <code>ByteList</code> is an immutable ordered collection of ... *//* Copyright 2004,2005 The Apache Software Foundation. ... *//** <p>The <code>ObjectList</code> is an immutable ordered collection of ... *//** The number of <code>Object</code>s in the list. The range of ... *//** Checks if the <code>Object</code> <code>item</code> is a ... *//** <p>Interface to expose the values for all date-time related types. The following ... *//** <p>Interface to expose the value of 'decimal' and related datatypes.</p> ... *//** <p>Interface to expose the value of the 'double' datatype.</p> ... *//** <p>Interface to expose value of the float datatype.</p> ... *//** Interface to expose QName actual values ... *//** Specifies values related to XPath Axes. ... *//** The ancestor axis contains the ancestors of the context node; ... *//** the ancestor-or-self axis contains the context node and the ancestors of ... *//** the attribute axis contains the attributes of the context node; the axis ... *//** The child axis contains the children of the context node. *//** The descendant axis contains the descendants of the context node; ... *//** The descendant-or-self axis contains the context node and the ... *//** the following axis contains all nodes in the same document as the ... *//** The following-sibling axis contains all the following siblings of the ... */int NAMESPACEDECLS;/** The namespace axis contains the namespace nodes of the context node; the ... *//** The parent axis contains the parent of the context node, ... *//** The preceding axis contains all nodes in the same document as the context ... *//** The preceding-sibling axis contains all the preceding siblings of the ... *//** The self axis contains just the context node itself. */int ALLFROMNODE;/** A non-xpath axis, traversing the subtree including the subtree ... */int PRECEDINGANDANCESTOR;/** A non-xpath axis, traversing the the preceding and the ancestor nodes, ... */int ALL;/** A non-xpath axis, returns all nodes in the tree from and including the ... */// All axis past this are absolute.// ===========================================int DESCENDANTSFROMROOT;/** A non-xpath axis, returns all nodes that aren't namespaces or attributes, ... */int DESCENDANTSORSELFFROMROOT;/** A non-xpath axis, returns root only. */int FILTEREDLIST;/** A non-xpath axis, for functions. */...[] isReverse;/** A table to identify whether an axis is a reverse axis; *//** The names of the axes for diagnostic purposes. */// ancestor// ancestor-or-self// child// descendant// descendant-or-self// following// following-sibling// namespace// namespace-declarations// parent (one node, has no order)// preceding// preceding-sibling// self (one node, has no order)// 5// 6// 7// 8// 9// 10// 11// 12// 13// 14// 15// 16// 17// 18// 19// 20/** <code>DTM</code> is an XML document model expressed as a table ... *//** Null node handles are represented by this value. */short ROOT_NODE;/** The node is a <code>Root</code>. */// eg. org.w3c.dom.Document.ELEMENT_NODE?// %REVIEW% Should we actually define these as initialized to,// used by the DOM, for convenient mapping// These nodeType mnemonics and values are deliberately the same as thoseshort ELEMENT_NODE;/** The node is an <code>Element</code>. */short ATTRIBUTE_NODE;/** The node is an <code>Attr</code>. */short TEXT_NODE;/** The node is a <code>Text</code> node. */short CDATA_SECTION_NODE;/** The node is a <code>CDATASection</code>. */short ENTITY_REFERENCE_NODE;/** The node is an <code>EntityReference</code>. */short ENTITY_NODE;/** The node is an <code>Entity</code>. */short PROCESSING_INSTRUCTION_NODE;/** The node is a <code>ProcessingInstruction</code>. */short COMMENT_NODE;/** The node is a <code>Comment</code>. */short DOCUMENT_NODE;/** The node is a <code>Document</code>. */short DOCUMENT_TYPE_NODE;/** The node is a <code>DocumentType</code>. */short DOCUMENT_FRAGMENT_NODE;/** The node is a <code>DocumentFragment</code>. */short NOTATION_NODE;/** The node is a <code>Notation</code>. */short NAMESPACE_NODE;/** The node is a <code>namespace node</code>. Note that this is not ... */short NTYPES;/** The number of valid nodetypes. *//** Set an implementation dependent feature. ... */// public void setParseBlockSize(int blockSizeSuggestion);// %TBD% RETIRED -- do via setFeature if needed. Remove from impls.// ========= DTM Implementation Control Functions. ==============/** Set a run time property for this DTM instance. ... *//** This returns a stateless "traverser", that can navigate over an ... */// ========= Document Navigation Functions =========/** This is a shortcut to the iterators that implement ... *//** Get an iterator that can navigate over an XPath Axis, predicated by ... *//** Given a node handle, test if it has child nodes. ... *//** Given a node handle, get the handle of the node's first child. ... *//** Given a node handle, get the handle of the node's last child. ... *//** Retrieves an attribute node by local name and namespace URI ... *//** Given a node handle, get the index of the node's first attribute. ... *//** Given a node handle, get the index of the node's first namespace node. ... *//** Given a node handle, advance to its next sibling. ... *//** Given a node handle, find its preceeding sibling. ... *//** Given a node handle, advance to the next attribute. If an ... *//** Given a namespace handle, advance to the next namespace in the same scope ... *//** Given a node handle, find its parent node. ... *//** Given a DTM which contains only a single document, ... *//** Given a node handle, find the owning document node. This version mimics ... *//** Given a node handle, find the owning document node. ... *//** Get the string-value of a node as a String object ... *//** Get number of character array chunks in ... *//** Get a character array chunk in the string-value of a node. ... *//** Given a node handle, return an ID that represents the node's expanded name. ... *//** Given an expanded name, return an ID.  If the expanded-name does not ... *//** Given an expanded-name ID, return the local name part. ... *//** Given an expanded-name ID, return the namespace URI part. ... *//** Given a node handle, return its DOM-style node name. This will ... *//** Given a node handle, return the XPath node name.  This should be ... *//** Given a node handle, return its DOM-style localname. ... *//** Given a namespace handle, return the prefix that the namespace decl is ... *//** Given a node handle, return its DOM-style namespace URI ... *//** Given a node handle, return its node value. This is mostly ... *//** Given a node handle, return its DOM-style node type. ... *//** Get the depth level of this node in the tree (equals 1 for ... *//** Tests whether DTM DOM implementation implements a specific feature and ... */// ============== Document query functions ==============/** Return the base URI of the document entity. If it is not known ... *//** Set the base URI of the document entity. ... *//** Return the system identifier of the document entity. If ... *//** Return the name of the character encoding scheme ... *//** Return an indication of the standalone status of the document, ... *//** Return a string representing the XML version of the document. This ... *//** Return an indication of ... *//** A document type declaration information item has the following properties: ... *//** Return the public identifier of the external subset, ... *//** Returns the <code>Element</code> whose <code>ID</code> is given by ... *//** Return true if the xsl:strip-space or xsl:preserve-space was processed ... */// ============== Boolean methods ================/** Figure out whether nodeHandle2 should be considered as being later ... *//** 2. [element content whitespace] A boolean indicating whether a ... *//** 10. [all declarations processed] This property is not strictly speaking ... *//** 5. [specified] A flag indicating whether this attribute was actually ... *//** Directly call the ... */// ========== Direct SAX Dispatch, for optimization purposes ========/** Directly create SAX parser events representing the XML content of ... *//** Return an DOM node for the given node. ... */// %REVIEW% What response occurs if not supported?// ==== Construction methods (may not be supported by some implementations!) =====/** Return this DTM's content handler, if it has one. ... */// make that distinction explicit?// listener interfaces?  Should it be a separate interface to// current DTMDocumentImpl draft), or should we just support SAX// wider set of methods (like the "append" methods in the// %REVIEW% Do these appends make any sense, should we support a/** Return this DTM's lexical handler, if it has one. ... *//** Return this DTM's EntityResolver, if it has one. ... *//** Return this DTM's DTDHandler, if it has one. ... *//** Return this DTM's ErrorHandler, if it has one. ... *//** Return this DTM's DeclHandler, if it has one. ... *//** Append a child to "the end of the document". Please note that ... *//** Append a text node child that will be constructed from a string, ... *//** Get the location of a node in the source document. ... *//** As the DTM is registered with the DTMManager, this method ... *//** As documents are released from the DTMManager, the DTM implementation ... *//** This class iterates over a single XPath Axis, and returns node handles. *//** Specifies the end of the iteration, and is the same as DTM.NULL. *//** Get start to END should 'close' the iterator, ... *//** Set if restartable. *//** A class that implements traverses DTMAxisTraverser interface can traverse ... *//** By the nature of the stateless traversal, the context node can not be ... *//** Traverse to the next node after the current node. ... *//** Traverse to the next node after the current node that is matched ... *//** Simple implementation of DOMException. ... *//** Constructs a DOM/DTM exception. ... *//** Constructor DTMDOMException ... *//** This class specifies an exceptional condition that occurred ... *//** Create a new DTMException. ... *//** Create a new DTMException wrapping an existing exception. ... *//** Wrap an existing exception in a DTMException. ... *//** Simple filter for doing node tests.  Note the semantics of this are ... */int SHOW_ALL;/** Show all <code>Nodes</code>. */// the DTMIterator.// be traversed. These values may be ORed together before being passed to// Constants for whatToShow.  These are used to set the node type that willint SHOW_ELEMENT;/** Show <code>Element</code> nodes. */int SHOW_ATTRIBUTE;/** Show <code>Attr</code> nodes. This is meaningful only when creating an ... */int SHOW_TEXT;/** Show <code>Text</code> nodes. */int SHOW_CDATA_SECTION;/** Show <code>CDATASection</code> nodes. */int SHOW_ENTITY_REFERENCE;/** Show <code>EntityReference</code> nodes. Note that if Entity References ... */int SHOW_ENTITY;/** Show <code>Entity</code> nodes. This is meaningful only when creating ... */int SHOW_PROCESSING_INSTRUCTION;/** Show <code>ProcessingInstruction</code> nodes. */int SHOW_COMMENT;/** Show <code>Comment</code> nodes. */int SHOW_DOCUMENT;/** Show <code>Document</code> nodes. (Of course, as with Attributes ... */int SHOW_DOCUMENT_TYPE;/** Show <code>DocumentType</code> nodes. */int SHOW_DOCUMENT_FRAGMENT;/** Show <code>DocumentFragment</code> nodes. (Of course, as with ... */int SHOW_NOTATION;/** Show <code>Notation</code> nodes. This is meaningful only when creating ... */int SHOW_NAMESPACE;/** This bit instructs the iterator to show namespace nodes, which ... */int SHOW_BYFUNCTION;/** Special bit for filters implementing match patterns starting with ... *//** Test whether a specified node is visible in the logical view of a ... *//** <code>DTMIterators</code> are used to step through a (possibly ... */short FILTER_ACCEPT;/** Accept the node. */// org.w3c.dom.traversal.NodeFilter.FILTER_ACCEPT?// %REVIEW% Should we explicitly initialize them from, eg,// Constants returned by acceptNode, borrowed from the DOM Traversal chaptershort FILTER_REJECT;/** Reject the node. Same behavior as FILTER_SKIP. (In the DOM these ... */short FILTER_SKIP;/** Skip this single node. *//** Get an instance of a DTM that "owns" a node handle.  Since a node ... *//** Get an instance of the DTMManager.  Since a node ... *//** The root node of the <code>DTMIterator</code>, as specified when it ... *//** Reset the root node of the <code>DTMIterator</code>, overriding ... *//** Reset the iterator to the start. After resetting, the next node returned ... *//** This attribute determines which node types are presented via the ... *//** <p>The value of this flag determines whether the children of entity ... *//** Returns the next node in the set and advances the position of the ... *//** Returns the previous node in the set and moves the position of the ... *//** Detaches the <code>DTMIterator</code> from the set which it iterated ... *//** Specify if it's OK for detach to release the iterator for reuse. ... *//** Get the current node in the iterator. Note that this differs from ... *//** Tells if this NodeSetDTM is "fresh", in other words, if ... *//** If setShouldCacheNodes(true) is called, then nodes will ... *///========= Random Access ==========/** Tells if this iterator can have nodes added to it or set via ... *//** Get the current position within the cached list, which is one ... *//** If an index is requested, NodeSetDTM will call this method ... *//** Set the current position in the node set. ... *//** Returns the <code>node handle</code> of an item in the collection. If ... *//** Sets the node at the specified index of this vector to be the ... *//** The number of nodes in the list. The range of valid child node indices ... *//** Get a cloned Iterator that is reset to the start of the iteration. ... *///=========== Cloning operations. ============/** Get a clone of this iterator, but don't reset the iteration in the ... *//** Returns true if all the nodes in the iteration well be returned in document ... *//** Returns the axis being iterated, if it is known. ... */import PrefixResolver/** A DTMManager instance can be used to create DTM and ... */XMLStringFactory m_xsf;/** Factory for creating XMLString objects. ... *//** Default constructor is protected on purpose. *//** Get the XMLStringFactory used for the DTMs. ... *//** Set the XMLStringFactory used for the DTMs. ... */DTMManager factoryImplnew DTMManagerDefault(...)setXMLStringFactory(...)/** Get the instance of DTM that "owns" a node handle. ... *//** Given a W3C DOM node, try and return a DTM handle. ... *//** Creates a DTM representing an empty <code>DocumentFragment</code> object. ... *//** Release a DTM either to a lru pool, or completely remove reference. ... *//** Create a new <code>DTMIterator</code> based on an XPath ... *//** Create a new <code>DTMIterator</code> based only on a whatToShow ... *//** Create a new <code>DTMIterator</code> that holds exactly one node. ... */boolean m_incremental;/* Flag indicating whether an incremental transform is desired */boolean m_source_location;/* Flag set by FEATURE_SOURCE_LOCATION. ... *//** Get a flag indicating whether an incremental transform is desired ... *//** Set a flag indicating whether an incremental transform is desired ... *//** Get a flag indicating whether the transformation phase should ... *//** Set a flag indicating whether the transformation phase should ... */int IDENT_DTM_NODE_BITS;/** This value, set at compile time, controls how many bits of the ... */// -------------------- private methods --------------------int IDENT_NODE_DEFAULT;/** When this bitmask is ANDed with a DTM node handle number, the result ... */int IDENT_DTM_DEFAULT;int IDENT_MAX_DTMS;/** This is the maximum number of DTMs available.  The highest DTM is ... *//** %TBD% Doc ... *//** This interface is meant to be implemented by a client of the DTM, and allows ... */short NOTSTRIP;/** Do not strip whitespace child nodes of this element. */short STRIP;/** Strip whitespace child nodes of this element. */short INHERIT;/** Inherit whitespace stripping behavior of the parent node. *//** <code>ChunkedIntArray</code> is an extensible array of blocks of integers. ... */new ChunksVector(...)int slotsize;int lowbits;// way to pound on the array addressing code.// Debugging tip: Cranking lowbits down to 4 or so is a good// Locked, MUST be power of two in current codeint chunkalloc;// How many bits address within chunksint lowmask;ChunksVector chunks;...[] fastArray;int lastUsed;/** Create a new CIA with specified record size. Currently record size MUST ... */this.slotsizeXMLErrorResources.ER_CHUNKEDINTARRAY_NOT_SUPPORTED/** Append a 4-integer record to the CIA, starting with record 1. (Since ... */int slotsizeint newoffsetint chunkposint slotposint[] chunk/** Retrieve an integer from the CIA by record number and column within ... */XMLErrorResources.ER_OFFSET_BIGGER_THAN_SLOT// This test supports DTM.getNextPreceding.// Special case: The Document node (position==0) is acceptable.// RETURN -1. If position is NOT an ancestor, return position.// of the node at index "startPos". IF IT IS, DO NOT ACCEPT IT AND// Check that the node at index "position" is not an ancestor/** Disard the highest-numbered record. This is used in the string-buffer ... *//** Overwrite the integer found at a specific record and column. ... *//** Overwrite an entire (4-integer) record at the specified index. ... *//** Retrieve the contents of a record into a user-supplied buffer array. ... */ChunkedIntArray$ChunksVectorint BLOCKSIZE;...[] m_map;int m_mapSize;int orgMapSizeint[][] newMap//"ChunkedIntArray("+slotsize+") not currently supported");/* try ... */// Grow if needed// System.out.println("Using slow read (1)");//"Offset bigger than slot");// We have to look all the way up the ancestor chain// to make sure we don't have an ancestor.// Get the node whose index == ancestor// Get that node's parent (Note that this assumes w[1]// is the parent node index. That's really a DTM feature// rather than a ChunkedIntArray feature.)// ATOMIC!// System.out.println("Using slow read (2): "+position);// For now, just do a simple append.  A sorted insert only// makes sense if we're doing an binary search or some such./** <p>Support the coroutine design pattern.</p> ... */BitSet m_activeIDs;/** "Is this coroutine ID number already in use" lookup table. ... */int m_unreasonableId;/** Limit on the coroutine ID numbers accepted. I didn't want the ... */Object m_yield;/** Internal field used to hold the data being explicitly passed ... */int NOBODY;// Expose???int ANYBODY;int m_nextCoroutine;/** Internal field used to confirm that the coroutine now waking up is ... *//** <p>Each coroutine in the set managed by a single ... *//** In the standard coroutine architecture, coroutines are ... *//** Transfer control to another coroutine which has already been started and ... */XMLErrorResources.ER_COROUTINE_NOT_AVAILco_exit(...)XMLErrorResources.ER_COROUTINE_CO_EXIT/** Terminate this entire set of coroutines. The others will be ... *//** Make the ID available for reuse and terminate this coroutine, ... */// What I want is "Find first clear bit". That doesn't exist.// JDK1.2 added "find last set bit", but that doesn't help now.// %TBD% -- Declare? Encapsulate? Ignore? Or// dance widdershins about the instruction cache?//"Coroutine not available, id="+toCoroutine);// We expect these values to be overwritten during the notify()/wait()// periods, as other coroutines in this set get their opportunity to run.// System.out.println("waiting...");// dance deasil about the program counter?// Pass it along// And inform this coroutine that its partners are Going Away// %REVIEW% Should this throw/return something more useful?//"CoroutineManager recieved co_exit() request");// %REVIEW%/** <p>CoroutineParser is an API for parser threads that operate as ... *//** Register a SAX-style content handler for us to output to *//** Register a SAX-style lexical handler for us to output to ... *//** doParse() is a simple API which tells the coroutine parser ... *//* The run() method is required in CoroutineParsers that run as ... *//** doMore() is a simple API which tells the coroutine parser ... *//** doTerminate() is a simple API which tells the coroutine ... *//** Initialize the coroutine parser. Same parameters could be passed ... */// class CoroutineParser/** CustomStringPool is an example of an application-provided data structure for a ... */Map<String,Integer> m_stringToInt;Integer iobj/* $Id: CustomStringPool.java,v 1.2.4.1 2005/09/15 08:14:59 suresh_emailid Exp $ */import IntVector/** <code>DTMAxisNodeList</code> gives us an implementation of the DOM's ... */DTM m_dtm;DTMAxisIterator m_iter;IntVector m_cachedNodes;int m_last;// Methods unique to this class/** Public constructor: Wrap a DTMNodeList around an existing ... *//** Access the wrapped DTMIterator. I'm not sure whether anyone will ... *//** Returns the <code>index</code>th item in the collection. If ... */// org.w3c.dom.NodeList API follows/** This class serves as a default base for implementations of mutable ... *//** The position of the last node within the iteration, as defined by XPath. ... *//** The position of the current node within the iteration, as defined by XPath. ... *//** The position of the marked node within the iteration; ... *//** The handle to the start, or root, of the iteration. ... *//** True if the start node should be considered part of the iteration. ... *//** True if this iteration can be restarted. False otherwise (eg, if ... *//** Set the flag to include the start node in the iteration. ... *//** Returns the position of the last node within the iteration, as ... *//** Returns a deep copy of this iterator. Cloned iterators may not be ... */DTMAxisIteratorBase clone/** Do any final cleanup that is required before returning the node that was ... *//** Reset the position to zero. NOTE that this does not change the iteration ... */// Not previously established// Note that we're doing both setMark() -- which saves _currentChild// -- and explicitly saving our position counter (number of nodes// yielded so far).// %REVIEW% Should position also be saved by setMark()?// (It wasn't in the XSLTC version, but I don't understand why not.)// Save state// Count the nodes found by this iterator// Restore saved state// return clone.reset();/** <code>DTMNodeList</code> gives us an implementation of the DOM's ... */int m_firstChild;DTM m_parentDTM;/** Public constructor: Create a NodeList to support ... */import com.sun.org.apache.xml.internal.dtm.*import BoolStack/** The <code>DTMDefaultBase</code> class serves as a helper base for DTMs. ... */// for dumpDTMboolean JJK_DEBUG;int ROOTNODE;/** The identity of the root node. */// node of a DTM.// getDocument() method instead of ROOTNODE to get at the root// This constant is likely to be removed in the future. Use the/** The number of nodes, which is also used to determine the next ... */SuballocatedIntVector m_exptype;/** The expanded names, one array element for each node. */SuballocatedIntVector m_firstch;/** First child values, one array element for each node. */SuballocatedIntVector m_nextsib;/** Next sibling values, one array element for each node. */SuballocatedIntVector m_prevsib;/** Previous sibling values, one array element for each node. */SuballocatedIntVector m_parent;Vector<> m_namespaceDeclSets;/** Vector of SuballocatedIntVectors of NS decl sets */SuballocatedIntVector m_namespaceDeclSetElements;/** SuballocatedIntVector  of elements at which corresponding ... */...[] m_elemIndexes;/** These hold indexes to elements based on namespace and local name. ... */int DEFAULT_BLOCKSIZE;/** The default block size of the node arrays */int DEFAULT_NUMBLOCKS;/** The number of blocks for the node arrays */// favor small docs.int DEFAULT_NUMBLOCKS_SMALL;/** The number of blocks used for small documents & RTFs */int NOTPROCESSED;/** The value to use when the information has not been built yet. *///protected final int m_blocksize;/** The block size of the node arrays */DTMManager m_mgr;/** The DTM manager who "owns" this DTM. */DTMManagerDefault m_mgrDefault;/** m_mgr cast to DTMManagerDefault, or null if it isn't an instance ... */SuballocatedIntVector m_dtmIdent;/** The document identity number(s). If we have overflowed the addressing ... */String m_documentBaseURI;/** The base URI for this document. *///protected final static int m_mask = DTMManager.IDENT_NODE_DEFAULT;/** The mask for the identity. ... */DTMWSFilter m_wsfilter;/** The whitespace filter that enables elements to strip whitespace or not. */boolean m_shouldStripWS;/** Flag indicating whether to strip whitespace nodes */BoolStack m_shouldStripWhitespaceStack;/** Stack of flags indicating whether to strip whitespace nodes */XMLStringFactory m_xstrf;/** The XMLString factory for creating XMLStrings. */ExpandedNameTable m_expandedNameTable;/** The table for exandedNameID lookups.  This may or may not be the same ... */boolean m_indexing;/** true if indexing is turned on. *//** Construct a DTMDefaultBase object using the default block size. ... *//** Construct a DTMDefaultBase object from a DOM node. ... */int numblocksnew SuballocatedIntVector(...)new ExpandedNameTable(...)getExpandedNameTable(...)new BoolStack(...)pushShouldStripWhitespace(...)/** Ensure that the size of the element indexes can hold the information. ... */int[][] localNameIndexint[] elemHandlesm_elemIndexes.lengthint[][][] indexesindexes.lengthlocalNameIndex.lengthint[][] indexeselemHandles.lengthint[] indexes/** Add a node to the element indexes. The node will not be added unless ... */ExpandedNameTable entint namespaceIDgetNamespaceID(...)int localNameIDgetLocalNameID(...)int[] indexensureSizeOfIndex(...)/** Find the first index that occurs in the list that is greater than or ... *//** Find the first matching element from the index at or after the ... */int[][] lnIndexslnIndexs.lengthint[] elemsfindGTE(...)/** Get the next node identity value in the list, and call the iterator ... *//** This method should try and build one or more nodes in the table. ... *//** Get the number of nodes that have been added. ... */...[] m_traversers;/** Stateless axis traversers, lazely built. *//** Get the simple type ID for the given node identity. ... *///        // We've cut over to Suballocated*Vector, which are self-sizing.//    protected void ensureSize(int index)//     * at least index+1.//     * @param index On exit from this function, the information arrays sizes must be//     * at the given index.//     * Ensure that the size of the information arrays can hold another entryint info_exptype(...)/** Get the expanded type ID for the given node identity. ... *//** Get the level in the tree for the given node identity. ... */boolean isMore_parent(...)/** Get the first child for the given node identity. ... *//** Get the next sibling for the given node identity. ... *//** Get the previous sibling for the given node identity. ... *//** Get the parent for the given node identity. ... *//** Diagnostics function to dump the DTM. */PrintStream psint nRecordsint exTypeIDString typestringint firstChildint nextSibling_level(...)int prevSibling_prevsib(...)/** Diagnostics function to dump a single node. ... */int identity/** Given a node identity, return a node handle. If extended addressing ... */DTMManager.IDENT_NODE_DEFAULT/** Given a node handle, return a node identity. If extended addressing ... */int whichDTMidDTMManager.IDENT_DTM_DEFAULTint whichDTMindexm_mgrDefault.m_dtmsm_mgrDefault.m_dtm_offsets/** Given a node handle, advance to its last child. ... *//** Retrieves an attribute node by by qualified name and namespace URI. ... */getFirstAttributeIdentity(...)/** Given a node identity, get the index of the node's first attribute. ... */getNextNodeIdentity(...)/** Given a node handle and an expanded type ID, get the index of the node's ... *//** Given a node handle, advance to the next attribute. ... */getNextAttributeIdentity(...)/** Given a node identity for an attribute, advance to the next attribute. ... */Vector<> m_namespaceLists;/** Lazily created namespace lists. *//** Build table of namespace declaration ... */// on demandSuballocatedIntVector nsListint newETypeSuballocatedIntVector inheritedfindNamespaceContext(...)int isize/** Retrieve list of namespace declaration locations ... */int wouldBeAtfindInSortedSuballocatedIntVector(...)int candidateint rootIDint uppermostNSCandidateID/** Subroutine: Locate the specified node within ... *//** Given a node handle, get the index of the node's first child. ... */SuballocatedIntVector nsContext/** Given a namespace handle, advance to the next namespace. ... *//** Find the Document node handle for the document currently under construction. ... *//** Given a node handle, find the owning document node.  This has the exact ... *//** Given a node handle, find the owning document node.  Unlike the DOM, ... */XMLErrorResources.ER_METHOD_NOT_SUPPORTED/** Returns the namespace type of a specific node ... */int expandedNameID/** Given a node handle, return its XPath-style localname. ... *//** Get the identity of this node in the tree ... *//** Get the handle of this node in the tree ... *//** 2. [element content whitespace] A boolean indicating whether the ... *//** Directly create SAX parser events from a subtree. ... *//** Append a child to the end of the document. Please note that the node ... *//** Simple error for asserts and the like. ... *//** Find out whether or not to strip whispace nodes. ... *//** Set whether to strip whitespaces and push in current value of ... *//** Set whether to strip whitespaces at this point by popping out ... */popAndTop(...)/** Set whether to strip whitespaces and set the top of the stack to ... */setTop(...)/** A dummy routine to satisify the abstract interface. If the DTM ... *//** Query which DTMManager this DTM is currently being handled by. ... *//** Query which DTMIDs this DTM is currently using within the DTMManager. ... */// Use smaller sizes for the internal node arrays if the block size// is small.// Only create the m_prevsib array if the usePrevsib flag is true.// Some DTM implementations (e.g. SAXImpl) do not need this array.// We can save the time to build it in those cases.// Note that this fails if we aren't talking to an instance of// DTMManagerDefault// Reorganized test and loop into single flow// Tiny performance improvement, saves a few bytes of code, clearer.// %OPT% Other internal getters could be treated simliarly// Boiler-plate code for each of the _xxx functions, except for the array.// Check to see if the information requested has been processed, and,// if not, advance the iterator until we the information has been// processed.// Optimization: use the DTMManagerDefault's fast DTMID-to-offsets// table.  I'm not wild about this solution but this operation// needs need extreme speed.// %REVIEW% Wish I didn't have to perform the pre-test, but// someone is apparently asking DTMs whether they contain nodes// which really don't belong to them. That's probably a bug// which should be fixed, but until it is:// Assume that attributes and namespaces immediately follow the element.// Assume this can not be null.//_type(node) != nodeType));// If the previous sibling array is not built, we get at// the previous sibling using the parent, firstch and// nextsib arrays.// Assume that attributes and namespace nodes immediately follow the element// First// Most recent. May be -1 (none) if DTM was pruned.// %OPT% Is there a lastElement() method? Should there be?// %OPT% Count-down might be faster, but debuggability may// be better this way, and if we ever decide we want to// keep this ordered by expanded-type...// Base the size of a new namespace list on the// size of the inherited list - but within reason!// Handle overwriting inherited.// %OPT% Keep sorted? (By expanded-name rather than by doc order...)// Downside: Would require insertElementAt if not found,// which has recopying costs. But these are generally short lists...// %OPT% Is binary-search really saving us a lot versus linear?// (... It may be, in large docs with many NS decls.)// Found it// -1-wouldbeat == 0// Not after anything; definitely not found// Not found, but we know where it should have been.// Search back until we find an ancestor or run out.// Decrement wouldBeAt to find last possible ancestor// Special case: if the candidate is before the given node, and// is in the earliest possible position in the document, it// must have the namespace declarations we're interested in.// Found ancestor in list// Too deep in tree// Too late in list// No namespaces known at this node// looked too late// looked ot early// Clean up at loop end// Assume that attributes and namespaces immediately// follow the element.// %OPT% Would things be faster if all NS nodes were built// before all Attr nodes? Some costs at build time for 2nd// pass...//Since we've been given the base, try direct lookup//(could look from nodeHandle but this is at least one//comparison/get-parent faster)//SuballocatedIntVector nsContext=findNamespaceContext(nodeHandle & m_mask);// Assume that attributes and namespace nodes immediately follow the element.// makeNodeHandle(0)// %TBD%//("getStringValueChunkCount not yet supported!");//"getStringValueChunk not yet supported!");// %REVIEW% This _should_ only be null if someone asked the wrong DTM about the node...// which one would hope would never happen.../** @todo: *///"Not yet supported!");// Apparently, the axis walker stuff requires levels to count from 1./* if (nodeHandle != DTM.NULL) ... *//* if (nodeId != DTM.NULL) ... */// %REVIEW%  OK? -sb// %REVIEW%  OK??  -sb// %REVIEW% OK?// These return NULL if the node doesn't belong to this document.//"appendChild not yet supported!");//"appendTextChild not yet supported!");import NodeCounter/** This class implements the traversers for DTMDefaultBase. *//** Construct a DTMDefaultBaseTraversers object from a DOM node. ... */XMLErrorResources.ER_TYPED_ITERATOR_AXIS_NOT_IMPLEMENTEDXMLErrorResources.ER_ITERATOR_AXIS_NOT_IMPLEMENTED/** Abstract superclass defining behaviors shared by all DTMDefault's ... *//** Current iteration location. Usually this is the last location ... */// support multiple inheritance. <sigh/>// those are often based on the untyped versions and Java doesn't// that we can't create a TypedInternalAxisIteratorBase because// these, and wants them to have as few fields as possible. Note// But Scott's worried about the overhead involved in cloning// well, and simply ignore them in iterators which don't use them.// %REVIEW% We could opt to share _nodeType and setNodeType() as/** Remembers the current node for the next call to gotoMark(). ... *//** Restores the current node remembered by setMark(). ... *//** Iterator that returns all immediate children of a given node */// end of InternalAxisIteratorBase/** Setting start to END should 'close' the iterator, ... */DTMDefaultBaseIterators$ParentIterator/** Iterator that returns the parent of a given node. Note that ... */// end of ChildrenIterator/** The extended type ID that was requested. *//** Set the node type of the parent that we're looking for. ... *//** Get the next node in the iteration. In this case, we return ... */DTMDefaultBaseIterators$TypedChildrenIterator/** Iterator that returns children of a given type for a given node. ... */// end of ParentIteratorDTMDefaultBaseIterators$NamespaceChildrenIterator// end of TypedChildrenIterator/** Iterator that returns the namespace nodes as defined by the XPath data model ... *//** Constructor NamespaceAttributeIterator */DTMDefaultBaseIterators$TypedNamespaceIterator// end of NamespaceIterator/** Constructor TypedNamespaceIterator ... *//** Iterator that returns the the root node as defined by the XPath data model ... *//** Constructor RootIterator */DTMDefaultBaseIterators$TypedRootIterator// end of RootIterator/** Constructor TypedRootIterator ... */DTMDefaultBaseIterators$NamespaceAttributeIterator// end of TypedRootIterator/** Iterator that returns all siblings of a given node. */DTMDefaultBaseIterators$TypedFollowingSiblingIterator/** Iterator that returns all following siblings of a given node. */// end of FollowingSiblingIterator/** Constructor TypedFollowingSiblingIterator ... *//** Iterator that returns attribute nodes (of what nodes?) */// end of TypedFollowingSiblingIterator// assumes caller will pass element nodesDTMDefaultBaseIterators$TypedAttributeIterator/** Iterator that returns attribute nodes of a given type */// end of AttributeIterator/** Constructor TypedAttributeIterator ... */getTypedAttribute(...)/** Iterator that returns preceding siblings of a given node */// end of TypedAttributeIteratorint _startNodeID;/** The node identity of _startNode for this iterator */ExpandedNameTable.ATTRIBUTEExpandedNameTable.NAMESPACEDTMDefaultBaseIterators$TypedPrecedingSiblingIterator/** Iterator that returns preceding siblings of a given type for ... */// end of PrecedingSiblingIterator/** Constructor TypedPrecedingSiblingIterator ... */int startIDDTMDefaultBaseIterators$PrecedingIterator/** Iterator that returns preceding nodes of a given node. ... */// end of TypedPrecedingSiblingIteratorint _maxAncestors;/** The max ancestors, but it can grow... */...[] _stack;/** The stack of start node + ancestors up to the root of the tree, ... */int _sp, ...;/** (not sure yet... -sb) */int _markedsp, ...;/* _currentNode precedes candidates.  This is the identity, not the handle! *//** Returns a deep copy of this iterator.   The cloned iterator is not reset. ... */PrecedingIterator cloneint[] stackCopy_stack.lengthclone._stackXMLErrorResources.ER_ITERATOR_CLONE_NOT_SUPPORTEDint[] stack// redefine DTMAxisIteratorBase's resetDTMDefaultBaseIterators$TypedPrecedingIterator/** Iterator that returns preceding nodes of agiven type for a ... */// end of PrecedingIterator/** Constructor TypedPrecedingIterator ... */DTMDefaultBaseIterators$FollowingIterator/** Iterator that returns following nodes of for a given node. */// end of TypedPrecedingIteratorDTMAxisTraverser m_traverser;// easier for nowfirst(...)DTMDefaultBaseIterators$TypedFollowingIterator/** Iterator that returns following nodes of a given type for a given node. */// end of FollowingIterator/** Constructor TypedFollowingIterator ... */DTMDefaultBaseIterators$AncestorIterator/** Iterator that returns the ancestors of a given node in document ... */// end of TypedFollowingIteratornew NodeVector(...)NodeVector m_ancestors;int m_ancestorsPos;int m_markedPos;int m_realStartNode;/** The real start node for this axes, since _startNode will be adjusted. *//** Returns a deep copy of this iterator.  The cloned iterator is not reset. ... */AncestorIterator cloneclone._startNodeDTMDefaultBaseIterators$TypedAncestorIterator/** Typed iterator that returns the ancestors of a given node. */// end of AncestorIterator/** Constructor TypedAncestorIterator ... *//** Iterator that returns the descendants of a given node. */// end of TypedAncestorIterator/** Tell if this node identity is a descendant.  Assumes that ... */isDescendant(...)/** Reset. */DTMDefaultBaseIterators$TypedDescendantIterator/** Typed iterator that returns the descendants of a given node. */// end of DescendantIterator/** Constructor TypedDescendantIterator ... */DTMDefaultBaseIterators$NthDescendantIterator/** Iterator that returns the descendants of a given node. ... */// end of TypedDescendantIterator/** The current nth position. *//** Constructor NthDescendantIterator ... */DTMDefaultBaseIterators$SingletonIterator/** Class SingletonIterator. */// end of NthDescendantIterator/** (not sure yet what this is.  -sb)  (sc & sb remove final to compile in JDK 1.1.8) *//** Constructor SingletonIterator *//** Constructor SingletonIterator ... */DTMDefaultBaseIterators$TypedSingletonIterator/** Iterator that returns a given node only if it is of a given type. */// end of SingletonIterator/** Constructor TypedSingletonIterator ... *//* This causes an error when using patterns for elements that ... *///        if (type == NO_TYPE) {//            return(EMPTYITERATOR);//        else if (type == ELEMENT) {//            iterator = new FilterIterator(getAxisIterator(axis),//                                          getElementFilter());//        else//"Error: typed iterator for axis "//+ Axis.names[axis] + "not implemented");//"Error: iterator for axis '" + Axis.names[axis]//+ "' not implemented");// singleton iterator, since there can only be one attribute of// a given type.// Be careful to handle the Document node properly//"Iterator clone not supported.");// Pop actual root node (if not start) back off the stack// Last parent before root node// Bugzilla 8324: We were forgetting to skip Attrs and NS nodes.// Also recoded the loop controls for clarity and to flatten out// the tail-recursion.// ?? -sb// find rightmost descendant (or self)// int current;// while ((node = getLastChild(current = node)) != NULL){}// _currentNode = current;// _currentNode precedes possible following(node) nodes// must set to false for any clone// | m_dtmIdent);// make handle.// I'm not exactly clear yet what this is doing... -sb//final int result = super.next();// end of TypedSingletonIterator/** This class implements the traversers for DTMDefaultBase. ... *//** This returns a stateless "traverser", that can navigate ... */DTMAxisTraverser traversernew DTMAxisTraverser[]getNamesLength(...)new AncestorTraverser(...)new AncestorOrSelfTraverser(...)new AttributeTraverser(...)new ChildTraverser(...)new DescendantTraverser(...)new DescendantOrSelfTraverser(...)new FollowingTraverser(...)new FollowingSiblingTraverser(...)new NamespaceTraverser(...)Axis.NAMESPACEDECLSnew NamespaceDeclsTraverser(...)new ParentTraverser(...)new PrecedingTraverser(...)new PrecedingSiblingTraverser(...)new SelfTraverser(...)Axis.ALLnew AllFromRootTraverser(...)Axis.ALLFROMNODEnew AllFromNodeTraverser(...)Axis.PRECEDINGANDANCESTORnew PrecedingAndAncestorTraverser(...)Axis.DESCENDANTSFROMROOTnew DescendantFromRootTraverser(...)Axis.DESCENDANTSORSELFFROMROOTnew DescendantOrSelfFromRootTraverser(...)new RootTraverser(...)Axis.FILTEREDLISTXMLErrorResources.ER_UNKNOWN_AXIS_TYPEXMLErrorResources.ER_AXIS_TRAVERSER_NOT_SUPPORTEDDTMDefaultBaseTraversers$AncestorTraverser/** Implements traversal of the Ancestor access, in reverse document order. */DTMDefaultBaseTraversers$AncestorOrSelfTraverserDTMDefaultBaseTraversers$AttributeTraverser/** Implements traversal of the Attribute access */DTMDefaultBaseTraversers$ChildTraverser/** Get the next indexed node that matches the expanded type ID.  Before ... */int nsIndexint lnIndexint nextIDfindElementFromIndex(...)int parentIDint firstMatchgetNextIndexed(...)DTMDefaultBaseTraversers$IndexedDTMAxisTraverser/** Super class for derived classes that want a convenient way to access ... *//** Tell if the indexing is on and the given expanded type ID matches ... */ExpandedNameTable.ELEMENT/** Tell if a node is outside the axis being traversed.  This method must be ... *//** Tell if the axis has been fully processed to tell if a the wait for ... */isAfterAxis(...)axisHasBeenProcessed(...)DTMDefaultBaseTraversers$DescendantTraverser/** Get the first potential identity that can be returned.  This should ... *//** Get the subtree root identity from the handle that was passed in by ... */isIndexed(...)getSubtreeRoot(...)int firstPotentialgetFirstPotential(...)int subtreeRootIdentDTMDefaultBaseTraversers$DescendantOrSelfTraverser/** Get the first potential identity that can be returned, which is the ... */DTMDefaultBaseTraversers$AllFromNodeTraverser/** Implements traversal of the entire subtree, including the root node. */DTMDefaultBaseTraversers$FollowingTraverser/** Implements traversal of the following access, in document order. *//** Get the first of the following. ... */int etypeDTMDefaultBaseTraversers$FollowingSiblingTraverserDTMDefaultBaseTraversers$NamespaceDeclsTraverserDTMDefaultBaseTraversers$NamespaceTraverserDTMDefaultBaseTraversers$ParentTraverserDTMDefaultBaseTraversers$PrecedingTraverser/** Tell if the current identity is an ancestor of the context identity. ... */isAncestor(...)DTMDefaultBaseTraversers$PrecedingAndAncestorTraverser/** Implements traversal of the Ancestor and the Preceding axis, ... */DTMDefaultBaseTraversers$PrecedingSiblingTraverserDTMDefaultBaseTraversers$SelfTraverser/** Implements traversal of the Self axis. */DTMDefaultBaseTraversers$AllFromRootTraverser/** Return the root. ... *//** Return the root if it matches the expanded type ID. ... */DTMDefaultBaseTraversers$RootTraverser/** Return the root if it matches the expanded type ID, ... */DTMDefaultBaseTraversers$DescendantOrSelfFromRootTraverser/** Get the first potential identity that can be returned, which is the axis ... *//** Get the first potential identity that can be returned. ... */DTMDefaultBaseTraversers$DescendantFromRootTraverser// Cache of stateless traversers for this DTM// Share/reuse existing traverser// Generate new traverser// Don't want to throw an exception for this one.//"Unknown axis traversal type: "+axis);// "Axis traverser not supported: "//                       + Axis.names[axis]);// Process using identities// Is it a child?// If the parent occured before the subtree root, then// we know it is past the child axis.// Otherwise, it could be a descendant below the subtree root// children, or it could be after the subtree root.  So we have// to climb up until the parent is less than the subtree root, in// which case we return NULL, or until it is equal to the subtree// root, in which case we continue to look.// System.out.println("Found node via index: "+first);// %REVIEW% Dead code. Eliminate?// Process in Identifier space// %REVIEW% Is there *any* cheaper way to do this?// Yes. In ID space, compare to axisRoot's successor// (next-sib or ancestor's-next-sib). Probably shallower search.// may call nextNode()// Trickological code: _exptype() has the side-effect of// running nextNode until the specified node has been loaded,// and thus can be used to ensure that incremental construction of// the DTM has gotten this far. Using it just for that side-effect// is quite a kluge...// make sure it's here.// Compute in ID space// %REVIEW% This looks like it might want shift into identity space// to avoid repeated conversion in the individual functions// Compute in identity space// Only works on IDs, not handles.// %REVIEW% Are we using handles or indexes?// %REVIEW% See comments in IsAfterAxis; using the "successor" of// contextIdent is probably more efficient.// compute in ID space// Kluge test: Just make sure +1 yielded a real node// %REVIEW% Shouldn't this always be 0?import FastStringBuffer/** This is the implementation of the DTM document interface.  It receives ... */new ChunkedIntArray(...)new FastStringBuffer(...)new DTMStringPool(...)byte DOCHANDLE_SHIFT;// Number of lower bits used to represent node index.int NODEHANDLE_MASK;// Same as {@link DTMConstructor.IDENT_NODE_DEFAULT}// Masks the lower order of node handle.int DOCHANDLE_MASK;// Same as {@link DTMConstructor.IDENT_DOC_DEFAULT}// Masks the higher order Document handleint m_docHandle;int m_docElement;// masked document handle for this dtm documentint currentParent;// Context for parse-and-append operations// nodeHandle to the root of the actual dtm doc contentint previousSibling;// current parent - default is document rootint m_currentNode;// previous sibling - no previous siblingboolean previousSiblingWasParent;//protected Stack m_elemStack = new Stack();     // element stack// the element stack, so m_elemStack isn't needed.// The tree under construction can itself be used as// current node...[] gotslot;// Local cache for record-at-a-time fetchboolean done;// endDocument recieved?boolean m_isError;/** The document base URI. */IncrementalSAXSource m_incrSAXSource;/** If we're building the model incrementally on demand, we need to ... */ChunkedIntArray nodes;// ({@link DOCHANDLE_SHIFT} bits).// Assumes indices are not larger than {@link NODEHANDLE_MASK}// each reference slot is addressed by a nodeHandle index value.// nodes array: integer array blocks to hold the first level reference of the nodes,// ========= DTM data structure declarations. ==============FastStringBuffer m_char;// each of which is addressed by the absolute offset and length in the buffer// text/comment table: string buffer to hold the text string values of the document,int m_char_current_start;// needed because the string may be appended in several chunks.// Start of string currently being accumulated into m_char;DTMStringPool m_localNames;// probably not the right default.// pools across multiple documents, so setting them here is// passed in from outside? Scott want to be able to share// -- Should we really be creating these, or should they be// %TBD% INITIALIZATION/STARTUP ISSUESDTMStringPool m_nsNames;DTMStringPool m_prefixNames;ExpandedNameTable m_expandedNames;// an interface _implemented_ by this class... which might be simplest!// retrieve them each time. Or this needs to be// startup. Or it needs to attach to this document and// means it needs to attach to them AFTER we've resolved their// needs to be bound to the NS and local name pools. Which// %TBD% If we use the current ExpandedNameTable mapper, it/** Construct a DTM. ... */initDocument(...)/** Bind a IncrementalSAXSource to this DTM. If we discover we need nodes ... *//** Wrapper for ChunkedIntArray.append, to automatically update the ... */int slotnumberappendSlot(...)writeEntry(...)/** Set a reference pointer to the element name symbol table. ... *//** Get a reference pointer to the element name symbol table. ... *//** Set a reference pointer to the namespace URI symbol table. ... *//** Get a reference pointer to the namespace URI symbol table. ... *//** Set a reference pointer to the prefix name symbol table. ... *//** Get a reference pointer to the prefix name symbol table. ... *//** Set a reference pointer to the content-text repository ... *//** Get a reference pointer to the content-text repository ... *//** getContentHandler returns "our SAX builder" -- the thing that ... *//** Return this DTM's lexical handler. ... *//** Return this DTM's EntityResolver. ... *//** Return this DTM's DTDHandler. ... *//** Return this DTM's ErrorHandler. ... *//** Return this DTM's DeclHandler. ... */// Replaces the deprecated DocumentHandler interface.// Accept SAX events, use them to build/extend the DTM tree.// ========= SAX2 ContentHandler methods =========// Flush string accumulation into a text nodeappendEndDocument(...)processAccumulatedText(...)appendEndElement(...)appendStartDocument(...)int nAttsstringToIndex(...)appendStartElement(...)appendNSDeclaration(...)int contentEndappendAttribute(...)/** /System.out.println("Prefix="+prefix+" index="+m_prefixNames.stringToIndex(prefix)); ... */// %TBD% Where do we pool expandedName, or is it just the union, or...appendComment(...)writeSlot(...)//      int charStringStart=0,charStringLength=0;//      // of appendAccumulatedText for the next set of characters receives//      // appendAccumulatedText starts, and reset to the end of the table and 0 at the end//      // offset of the string in the table and charStringLength the acccumulated length when//      // to the text/comment string table: charStringStart should point to the starting//      // Counters to keep track of the current text string being accumulated with respect//              return (m_docHandle | ourslot);//              charStringLength = 0;//              charStringStart=m_char.length();//              previousSibling = ourslot;//              int ourslot = appendNode(w0, w1, w2, w3);//              int w3 = length;//              // W3: Length of the full string//              int w2 = charStringStart;//              // W2: Start position within m_char//              int w1 = currentParent;//              // W1: Parent//              int w0 = COMMENT_NODE;//              // %TBD% may be possible to combine with appendNode()to replace the next chunk of code//              // create a Comment Node//              m_char.append(ch, start, length);               // store the comment string to the text/comment string table//      {//      throws DTMException//      public int createComment(char ch[], int start, int length)//       *///       * @see DTMException//       * @param length The number of characters to use from the array.//       * @param start The starting position in the array.//       * @param ch An array holding the characters in the comment.//       *//       * received.  %TBD% It can be rechained later via the optional DTM writable interface.//       * The node created will be chained according to its natural order of request//       * Factory method; creates a Comment node in this document.//      /**//              return createComment(text.toCharArray(), 0, text.length());//              // wraps around the index value based createTextNode method//      public int createComment(String text)//       * @return int DTM node-number of the text node created//       * @param text String The characters text string from the XML document.//              int w0 = TEXT_NODE;//              // create a Text Node//              m_char.append(ch, start, length);               // store the chunk to the text/comment string table//      public int createTextNode(char ch[], int start, int length)//       * @param length The number of characters to read from the array.//       * @param start The start position in the array.//       * @param ch The characters from the XML document.//       * is called.//       * insist that all adjacent text must be merged before this method//       * %REVIEW% for text normalization issues, unless we are willing to//       * Factory method; creates a Text node in this document.//              return createTextNode(text.toCharArray(), 0, text.length());//      public int createTextNode(String text)//              previousSiblingWasParent = true;//              // Attrs are Parents//              //previousSibling = ourslot;//              appendNode(w0, w1, w2, w3);//              w3 = m_char.length() - w2;//              // W3: Length//              m_char.append(value);//              w2 = m_char.length();//              // W2: Start Position within buffer//              w1 = ourslot;//              w0 = TEXT_NODE;//              // W0: Node Type//              previousSibling = ourslot;      // Should attributes be previous siblings//              // Add node//              int w3 = m_localNames.stringToIndex(attName);//              // W3:  Tag name//              int w2 = 0;//              // W2:  Next (not yet resolved)//              // W1:  Parent//                      w0 = ATTRIBUTE_NODE;//              } else {//                      }//                              //w0 = ATTRIBUTE_NODE |//                      } else {//                              //      (com.sun.org.apache.xalan.internal.templates.Constants.S_XMLNAMESPACEURI << 16);//                      if (prefix.equals("xml")) {//                      String prefix = qname.substring(0, colonpos);//              if (colonpos > 0) {//              int w0 = 0;//              String attName = qname.substring(colonpos+1);//              int colonpos = qname.indexOf(":");//      public int createAttribute(String qname, String value) {//       * @return Handle of node//       * @param value Value of the attribute//       * @param qname Qualified Name of the attribute//       * Appends an attribute to the document.//                      createAttribute(atts.getQName(i), atts.getValue(i));//                      String qname = atts.getQName(i);//              for (int i=0; i < atLength; i++) {//              int atLength = (null == atts) ? 0 : atts.getLength();//      void setAttributes(Attributes atts) {//       * @param atts Attributes to be created.//       * Creates attributes for the current node.//              // namespaceTable.removeLastElem();//              // Pop a level of namespace table//              // the previous sibling for the next operation//              // The element just being finished will be//              currentParent = gotslot[1] & 0xFFFF;//              nodes.readSlot(currentParent, gotslot);//              previousSibling = currentParent;//              // Pop parentage//                      nodes.writeEntry(previousSibling, 2, NULL);//              if (previousSiblingWasParent)//              ////              // pop up the stacks//      public void endElement(String ns, String name)//       * @param name The element name//       * @param ns the namespace of the element//               *//       * coordinated access to the DTMDStringPool based symbol tables.</p>//       * <p>%tbd% The following interface may need to be modified to match a//       * element and parent and patch up parent and sibling pointers if necessary//       * element in the XML document to give hint its time to pop up the current//       * <p>The XML content handler will invoke this method at the end of every//       * Receive an indication for the end of an element.//              return createElement(nsIndex, nameIndex, atts);//              int prefixIndex = m_prefixNames.stringToIndex(name.substring(0, prefixSep));//              int prefixSep = name.indexOf(":");//              // The prefixIndex is not needed by the indexed interface of the createElement method//              int nameIndex = m_localNames.stringToIndex(name);//              int nsIndex = m_nsNames.stringToIndex(ns);//              // method.//              // onverted to index values modified to match a//              // method will then use the index values returned to invoke the other createElement()//              // The raw string values are stored into the current DTM name symbol tables.  The method//              // This method wraps around the index valued interface of the createElement interface.//      public int createElementNS(String ns, String name, Attributes atts)//       * @see org.xml.sax.Attributes//       * @see #endElement//       * @param atts The attributes attached to the element, if any.//       * @param name String the element name, including the prefix if any.//       * @param ns String the namespace of the node//       * symbols used in an Element node.</p>//       * <p>The following parameters for createElementNS contains raw string values for name//       * to prepare and patch up parent and sibling node pointers.</p>//       * of the element's content are processed in order to give DTM the indication//       * <p>The XML content handler or application will invoke endElement() method after all//       * Factory method; creates an Element node associated with a given name space in this document.//      // using String value parameters passed in from a content handler or application//      // Factory method to create an Element node associated with a given name space//              // with a name space//              // note - there should be no prefix separator in the name because it is not associated//              int nsIndex = NULL;//      public int createElement(String name, Attributes atts)//       * <p>The following parameters for createElement contains raw string values for name//       * Factory method; creates an Element node not associated with a given name space in this document.//      // Factory method to create an Element node not associated with a given name space//                      m_docElement = ourslot;//              if (m_docElement == NULL)//              // set the root element pointer when creating the first element node//              setAttributes(atts);//              previousSibling = 0;//              currentParent = ourslot;//              //int ourslot = nodes.appendSlot(w0, w1, w2, w3);//              int w3 = nameIndex;//              // W3: Tagname//              // W2: Next  (initialized as 0)//              int w0 = (nsIndex << 16) | ELEMENT_NODE;//              // W0  High:  Namespace  Low:  Node Type//              // element used//              // name indexes to the nodes array, keep track of the current node and parent//              // this element and its attributes, store the element, namespace, and attritute//              // do document root node creation here on the first element, create nodes for//      public int createElement(int nsIndex, int nameIndex, Attributes atts)//       * @return nodeHandle int of the element created//       * @param nameIndex The element name.//       * @param nsIndex The namespace of the node//       * to the symbol entry in the DTMDStringPool based symbol tables.</p>//       * <p>The following interface for createElement will use an index value corresponds//       * <p>The XML content handler will invoke endElement() method after all//       * Factory method; creates an Element node in this document.//              initDocument(0);//              m_docElement = NULL;     // reset nodeHandle to the root of the actual dtm doc content//              //       the next initDocument().//              // %TBD% reset slot 0 to indicate ChunkedIntArray reuse or wait for//      public void reset()//       * other methods in this interface.</p>//       * <p>The SAX parser will invoke this method only once, before any//       * Receive notification of the beginning of a document.//              // residual data from provious use of this DTM//              // %TBD% may need to notice the last slot number and slot count to avoid//              done = true;//      public void documentEnd()//       * input.</p>//       * (because of an unrecoverable error) or reached the end of//       * not invoke this method until it has either abandoned parsing//       * be the last method invoked during the parse.  The handler shall not//       * <p>The content handler will invoke this method only once, and it will//       * Receive hint of the end of a document.readSlot(...)int kidint nextkidreadEntry(...)int thisParentint nextSib/** Given a node handle, advance to its next descendant. ... */slotsUsed(...)int nextParentPos/** Given a node handle, advance to the next node on the following axis. ... *//** Given a node handle, advance to the next node on the preceding axis. ... */specialFind(...)/** Returns the root element of the document. ... *//** Given a node handle, find the owning document node.  This has the DTM ... */int nodetypenewstr(...)//###zaj - tbdindexToString(...)String expandedNameString nsName...[] fixednames;/** fixednames */// Notation/** /System.out.println("got i="+i+" "+(i>>16)+"/"+(i&0xffff)); ... */short count/** Append a child to the end of the child list of the current node. Please note that the node ... */// issues.// they need to deal with current-insertion-location and end-element// %REVIEW% jjk: These probably aren't the right API. At the very leastboolean sameDoc/** Append a text child at the current insertion point. Assumes that the ... */// both SAX1 and SAX2 and share this logic between them.// %TBD% jjk: SHOULD PROBABLY BE INLINED, unless we want to support// ==== BUILDER methods ====int w0int w1int w2int w3int ourslotappendNode(...)/** Append a comment child at the current insertion point. Assumes that the ... *//** Append an Element child at the current insertion point. This ... *//** /System.out.println("set w3="+w3+" "+(w3>>16)+"/"+(w3&0xffff)); ... */int namespaceForNamespaces/** Append an Attribute child at the current insertion ... *//** Terminate the element currently acting as an insertion point. Subsequent ... *//** Starting a new document. Perform any resets/initialization ... *//** All appends to this document have finished; do whatever final ... *//** For the moment all the run time properties are ignored by this ... *//** Source information is not handled yet, so return ... */// clear nodes and document handle// Establish SAX-stream link so we can receive the requested data// Are the following really needed? IncrementalSAXSource doesn't yet// support them, and they're mostly no-ops here...//source.setErrorHandler(this);//source.setDTDHandler(this);//source.setDeclHandler(this);// A decent compiler may inline this.// Set the default; endElement overrides// Actually creating the text node is handled by// processAccumulatedText(); here we just accumulate the// characters into the buffer.// The FastStringBuffer has been previously agreed upon// May need to tell the low-level builder code to pop up a level.// There _should't_ be any significant pending text at this point.// No args but we do need to tell the low-level builder code to// pop up a level.// %TBD% I believe ignorable text isn't part of the DTM model...?// %TBD% Which pools do target and data go into?// No-op for DTM//%TBD%// %TBD% Split prefix off qname// save masked DTM document handle// Initialize the doc -- no parent, no next-sib// wait for the first startElement to create the doc root node// ###shs worry about tracing/debug later// Read node into variable// type is the last half of first slot// Check to see if Element or Document node// In case when Document root is given//      if (nodeHandle == 0) nodeHandle = 1;// %TBD% Probably was a mistake.// If someone explicitly asks for first child// of Document, I would expect them to want// that and only that.// points to next sibling// Return NULL if node has only attributes// If parent slot matches given parent, return kid// No child found// ###shs put trace/debug later// do not need to test node type since getFirstChild does that// If nodeHandle points to element next slot would be first attribute// Iterate through Attribute Nodes// Goto next sibling// %REVIEW% jjk: Just a quick observation: If you're going to// call readEntry repeatedly on the same node, it may be// more efficiently to do a readSlot to get the data locally,// reducing the addressing and call-and-return overhead.// Should we check if handle is element (do we want sanity checks?)// First Attribute (if any) should be at next position in table// Document root has no next sibling// ###shs should cycle/wait if nextSib is 0? Working on threading next// Next Sibling is in the next position if it shares the same parent// Document root has no previous sibling//%REVIEW% Why are we using short here? There's no storage//reduction for an automatic variable, especially one used//so briefly, and it typically costs more cycles to process//than an int would.// ###shs need to work on namespace// Document root [Document Node? -- jjk] - no next-sib// Document done and node out of bounds// Add wait logic here// Probably should throw error here like original instead of returning//###shs still working on// ###shs copied from Xalan 1, what is this suppose to do?// if nodeHandle is _not_ an ancestor of// axisContextHandle, specialFind will return it.// If it _is_ an ancestor, specialFind will return -1// %REVIEW% unconditional return defeats the// purpose of the while loop -- does this// logic make any sense?// Should check to see within range?// Document Root should not have to be handled differently// Assumption that Document Node is always in 0 slot// ###zaj - researching//###zaj    return value// Remove prefix from qName// %TBD% jjk This is assuming the elementName is the qName.// Get NS// Create expanded name// %TBD% jjk Expanded name is bitfield-encoded as// typeID[6]nsuriID[10]localID[16]. Switch to that form, and to// accessing the ns/local via their tables rather than confusing// nsnames and expandednames.// Get expanded name// Remove prefix from expanded name// Remove local name from expanded name// nothing, Element// Attr, Text// CDATA, EntityReference// Entity, PI// Comment, Document// Doctype, DocumentFragment// ###zaj use mask to get node type// ###zaj todo - document nodetypes//###zaj// ###shs Think more about how this differs from createTextNode// create a Text Node// %TBD% may be possible to combine with appendNode()to replace the next chunk of code// W2: Start position within m_char// W3: Length of the full string// create a Comment Node// do document root node creation here on the first element, create nodes for// this element and its attributes, store the element, namespace, and attritute// name indexes to the nodes array, keep track of the current node and parent// element used// W0  High:  Namespace  Low:  Node Type// W2: Next  (initialized as 0)// W3: Tagname high: prefix Low: local name// %REVIEW% I'm assigning this node the "namespace for namespaces"// which the DOM defined. It is expected that the Namespace spec will// adopt this as official. It isn't strictly needed since it's implied// by the nodetype, but for now...// %REVIEW% Prefix need not be recorded; it's implied too. But// recording it might simplify the design.// %TBD% isID is not currently honored.// W1:  Parent// W2:  CURRENTLY UNUSED -- It's next-sib in attrs, but we have no kids.// W3:  namespace name// Should attributes be previous siblings//(m_docHandle | ourslot);// W2:  Next (not yet resolved)// W3:  Tagname high: prefix Low: local name// pop up the stacks// Pop parentage// The element just being finished will be// the previous sibling for the next operation// Pop a level of namespace table// namespaceTable.removeLastElem();// %TBD% reset slot 0 to indicate ChunkedIntArray reuse or wait for//       the next initDocument().// reset nodeHandle to the root of the actual dtm doc content// %TBD% may need to notice the last slot number and slot count to avoid// residual data from provious use of this DTMimport DOM2DTMimport SAX2DTMimport SAX2RTFDTM/** The default implementation for the DTMManager. ... */new DTM[]/** Set this to true if you want a dump of the DTM after creation. *///static final boolean JKESS_XNI_EXPERIMENT=true;/** Set this to true if you want a basic diagnostics. */...[] m_dtms;/** Map from DTM identifier numbers to DTM objects that this manager manages. ... */...[] m_dtm_offsets;/** Map from DTM identifier numbers to offsets. For small DTMs with a ... */XMLReaderManager m_readerManager;/** The cache for XMLReader objects to be used if the user did not ... */DefaultHandler m_defaultHandler;/** The default implementation of ContentHandler, DTDHandler and ErrorHandler. *//** Add a DTM to the DTM table. This convenience call adds it as the ... *//** Add a DTM to the DTM table. ... */int oldlenm_dtms.lengthXMLErrorResources.ER_NO_DTMIDS_AVAILDTM[] new_m_dtmsint[] new_m_dtm_offsets/** Get the first free DTM ID available. %OPT% Linear search is inefficient! *//** The default table for exandedNameID lookups. */XMLStringFactory xstringFactoryDOM2DTM dtmnew DOM2DTM(...)SAX2DTM dtmboolean haveXercesParsernew SAX2RTFDTM(...)new SAX2DTM(...)IncrementalSAXSource coParsernew IncrementalSAXSource_Filter(...)IncrementalSAXSource_Filter filtersetIncrementalSAXSource(...)startParse(...)clearCoRoutine(...)XMLErrorResources.ER_NODE_NON_NULLDTM thisDTMgetHandleOfNode(...)XMLErrorResources.ER_COULD_NOT_RESOLVE_NODE/** This method returns the SAX2 parser to use with the InputSource ... *//** Indicates that the XMLReader object is no longer in use for the transform. ... *//** Return the DTM object containing a representation of this node. ... *//** Given a DTM, find the ID number in the DTM tables which addresses ... */DTM tdtm/** Release the DTMManager's reference(s) to a DTM, making it unmanaged. ... */getDTMIdentity(...)/** Method createDocumentFragment ... */DocumentBuilder dbNode df/** NEEDSDOC Method createDTMIterator ... *//** return the expanded name table. ... */// TODO: %REVIEW% Not really the right error message.//"No more DTM IDs are available!");// We used to just allocate the array size to IDENT_MAX_DTMS.// But we expect to increase that to 16 bits, and I'm not willing// to allocate that much space unless needed. We could use one of our// handy-dandy Fast*Vectors, but this will do for now.// Various growth strategies are possible. I think we don't want// to over-allocate excessively, and I'm willing to reallocate// more often to get that. See also Fast*Vector classes.// %REVIEW% Should throw a more diagnostic error if we go over the max...// The DTM should have been told who its manager was when we created it.// Do we need to allow for adopting DTMs _not_ created by this manager?// count on addDTM() to throw exception if out of range//      if (DUMPTREE)//        dtm.dumpDTM();// Special case to support RTF construction into shared DTM.// It should actually still work for other uses,// but may be slightly deoptimized relative to the base// to allow it to deal with carrying multiple documents.// %REVIEW% This is a sloppy way to request this mode;// we need to consider architectural improvements.// No matter what.  %REVIEW%// If the reader is null, but they still requested an incremental// build, then we still want to set up the IncrementalSAXSource stuff./* || ((null == reader) && incremental) */// IncrementalSAXSource_Xerces to avoid threading.// Create a IncrementalSAXSource to run on the secondary thread.// Have the DTM set itself up as IncrementalSAXSource's listener.// Launch parsing coroutine.  Launches a second thread,// if we're using IncrementalSAXSource.filter().// not incremental// Reset the ContentHandler, DTDHandler, ErrorHandler to the DefaultHandler// after creating the DTM.// Reset the LexicalHandler to null after creating the DTM.//"Not supported: " + source);//"node must be non-null for getDTMHandleFromNode!");// Find the DOM2DTMs wrapped around this Document (if any)// and check whether they contain the Node in question.// NOTE that since a DOM2DTM may represent a subtree rather// than a full document, we have to be prepared to check more// than one -- and there is no guarantee that we will find// one that contains ancestors or siblings of the node we're// seeking.// %REVIEW% We could search for the one which contains this// node at the deepest level, and thus covers the widest// subtree, but that's going to entail additional work// checking more DTMs... and getHandleOfNode is not a// cheap operation in most implementations.// TODO: %REVIEW% If overflow addressing, we may recheck a DTM// already examined. Ouch. But with the increased number of DTMs,// scanning back to check this is painful.// POSSIBLE SOLUTIONS://   Generate a list of _unique_ DTM objects?//   Have each DTM cache last DOM node search?// Not found; generate a new DTM.// %REVIEW% Is this really desirable, or should we return null// and make folks explicitly instantiate from a DOMSource? The// latter is more work but gives the caller the opportunity to// explicitly add the DTM to a DTMManager... and thus to know when// it can be discarded again, which is something we need to pay much// more attention to. (Especially since only DTMs which are assigned// to a manager can use the overflow addressing scheme.)// %BUG% If the source node was a DOM2DTM$defaultNamespaceDeclarationNode// and the DTM wasn't registered with this DTMManager, we will create// a new DTM and _still_ not be able to find the node (since it will// be resynthesized). Another reason to push hard on making all DTMs// be managed DTMs.// Since the real root of our tree may be a DocumentFragment, we need to// use getParent to find the root, instead of getOwnerDocument.  Otherwise// DOM2DTM#getHandleOfNode will be very unhappy.// Can't return the same node since it's unique to a specific DTM,// but can return the equivalent node -- find the corresponding// Document Element, then ask it for the xml: namespace decl.//"Could not resolve the node to a handle!");// If user did not supply a reader, ask for one from the reader manager// Performance critical function.// Accept as a special case.// Programming error; want to know about it.// Shortcut using DTMDefaultBase's extension hooks// %REVIEW% Should the lookup be part of the basic DTM API?// Following shouldn't need a nodeHandle, but does...// and doesn't seem to report the intended value// Multiple DTM IDs may be assigned to a single DTM.// The Right Answer is to ask which (if it supports// extension, the DTM will need a list anyway). The// Wrong Answer, applied if the DTM can't help us,// is to linearly search them all; this may be very// painful.// %REVIEW% Should the lookup move up into the basic DTM API?/** DTMNamedNodeMap is a quickie (as opposed to quick) implementation of the DOM's ... */DTM dtm;/** The DTM for this node. */int element;/** The DTM element handle. */short m_count;/** The number of nodes in this map. *//** Create a getAttributes NamedNodeMap for a given DTM element node ... */this.dtm/** Return the number of Attributes on this Element ... *//** Retrieves a node specified by name. ... *//** Returns the <code>index</code>th item in the map. If <code>index</code> ... *//** Adds a node using its <code>nodeName</code> attribute. If a node with ... */DTMException.NO_MODIFICATION_ALLOWED_ERR/** Removes a node specified by name. When this map contains the attributes ... *//** Retrieves a node specified by local name and namespace URI. HTML-only ... */Node retNode/** Adds a node using its <code>namespaceURI</code> and ... *//** Removes a node specified by local name and namespace URI. A removed ... */DTMNamedNodeMap$DTMException/** Constructor DTMException ... */import DTMDOMException/** <code>DTMNodeIterator</code> gives us an implementation of the ... */DTMIterator dtm_iter;/** Public constructor: Wrap a DTMNodeIterator around an existing ... */CloneNotSupportedException cnse/** Detaches the NodeIterator from the set which it iterated over, ... */// org.w3c.dom.traversal.NodeFilter API follows/** The value of this flag determines whether the children ... *//** Return a handle to the filter used to screen nodes. ... */new DTMDOMException(...)/** Return a mask describing which node types are presented via the ... */// Theoretically, we could release dtm_iter at this point. But// some of the operations may still want to consult it even though// navigation is now invalid.DTMIterator m_iter;getCurrentPos(...)cloneWithReset(...)runTo(...)setCurrentPos(...)/** <code>DTMNodeProxy</code> presents a DOM Node API front-end to the DTM model. ... */new DTMNodeProxyImplementation(...)/** The DTM node handle. *//** The return value as Empty String. */DOMImplementation implementation;/** The DOMImplementation object *//** Create a DTMNodeProxy Node representing a specific Node in a DTM ... */this.node/** NON-DOM: Return the DTM model ... *//** NON-DOM: Return the DTM node number ... *//** Test for equality based on node number. ... */DTMNodeProxy dtmpdtmp.nodedtmp.dtm/** FUTURE DOM: Test node identity, in lieu of Node==Node ... */DTMNodeProxy thatthat.dtmthat.node/** Ask whether we support a given DOM feature. ... */int newnodenew DTMChildIterNodeList(...)// DTMNamedNodeMap m_attrs;new DTMNamedNodeMap(...)/** Method hasAttribute ... *//** Method hasAttributeNS ... *//** This is a bit of a problem in DTM, since a DTM may be a Document ... */int dochandleint elementhandleint kidhandleVector<> listVectorNodeSet nodeSetboolean isTagNameWildCardNodeList nodeListtraverseChildren(...)boolean isNamespaceURIWildCardboolean isLocalNameWildCardNodeList nlDTMNamedNodeMap mapAttr retAttr/** Get the owner element of an attribute. ... *//** NEEDSDOC Method adoptNode ... *//** <p>EXPERIMENTAL! Based on the <a ... */DTMNodeProxy$DTMNodeProxyImplementation/** Inner class to support getDOMImplementation. *//** This method returns a specialized object which implements the ... *///RAMESH : Pending proper implementation of DOM Level 3/** DOM Level 3 feature: documentURI *//** DOM Level 3 feature: Document actualEncoding */this.xmlEncodingboolean xmlStandalone;this.xmlStandalonethis.xmlVersion/* $Id: DTMNodeProxy.java,v */// return (dtmp.node == this.node);// Patch attributed to Gary L Peskin <garyp@firstech.com>// DTMNodeProxy dtmp = (DTMNodeProxy)node;//throw new DTMDOMException(DOMException.NOT_SUPPORTED_ERR);// throw new DTMDOMException(DOMException.NOT_SUPPORTED_ERR);// Annoyingly, AxisIterators do not currently implement DTMIterator, so// we can't just wap DTMNodeList around an Axis.CHILD iterator.// Instead, we've created a special-case operating mode for that object.// Attr's Next is defined at DTM level, but not at DOM level.// Note that this uses the DOM-compatable version of the call// More than one; ill-formed.// End loop// These are harmless; document is still wellformed// ill-formed// %OPT% This should do something smarter?// We really don't know which attributes might have come from the// source document versus from the DTD. Treat them all as having// been provided by the user.// %REVIEW% if/when we become aware of DTDs/schemae.// In XPath and DTM data models, unlike DOM, an Attr's parent is its// owner element.// Could create a DTM... but why, when it'd have to be permanantly empty?//return hasFeature(feature, version) ? this : null;//PENDING/* if (getBaseURI() == null) { ... *//* NodeImpl ancestor = (NodeImpl)getElementAncestor(this); ... *//* case Node.DOCUMENT_NODE : { ... *//* // REVISIT: remove casts when DOM L3 becomes REC. ... *//* case Node.ELEMENT_NODE: { ... *//* if (needsSyncData()) { ... *///Pending/** <p>Like DTMStringPool, but threadsafe. It's been proposed that DTMs ... *//** Command-line unit test driver. This test relies on the fact that ... */String[] wordDTMStringPool poolnew DTMSafeStringPool(...)int password.lengthString w// end pass loop// DTMSafeStringPool/** <p>DTMStringPool is an "interning" mechanism for strings. It will ... */Vector<> m_intToString;int HASHPRIME;...[] m_hashStart;IntVector m_hashChain;/** Create a DTMStringPool using the given chain size ... */int hashslotint hashlastint hashcandidate// -sb Add this to force empty strings to be index 0.// Is it one we already know?// New value. Add to tables.// Initialize to no-following-same-hash// First for this hash// Link from previous with same hashimport NodeConsumer/** This class does a pre-order walk of the DTM tree, calling a ContentHandler ... */ContentHandler m_contentHandler;/** Local reference to a ContentHandler *//** DomHelper for this TreeWalker *//** Set the DTM to be traversed. ... *//** Get the ContentHandler used for the tree walk. ... *//** Set the ContentHandler used for the tree walk. ... */this.m_contentHandler/** Perform a non-recursive pre-order/post-order traversal, ... */int topstartNode(...)endNode(...)boolean nextIsRaw;/** Flag indicating whether following text to be processed is raw text *//** Optimized dispatch of characters. *//** Start processing given node ... */DTM dtmXMLString dataLexicalHandler lhdispatchAsComment(...)int nsnboolean isLexHdispatachChars(...)Result.PI_DISABLE_OUTPUT_ESCAPINGResult.PI_ENABLE_OUTPUT_ESCAPING/** End processing of given node ... */// %REVIEW% Why isn't this just traverse(pos,pos)?// Remember the root of this subtree// %REVIEW% This condition isn't tested in traverse(pos,top)// -- bug?// %OPT% Can we simplify the loop conditionals by adding://          if(top==DTM.NULL) top=0// -- or by simply ignoring this case and relying on the fact that// pos will never equal DTM.NULL until we're ready to exit?//      ((NodeConsumer) m_contentHandler).setOriginatingNode(node);// ??;// String prefix = dtm.getPrefix(nsn);// System.out.println("m_dh.getNamespaceOfNode(node): "+m_dh.getNamespaceOfNode(node));// System.out.println("m_dh.getLocalNameOfNode(node): "+m_dh.getLocalNameOfNode(node));// %OPT% !!// String data = pi.getData();// warning("Can not output entity to a pure SAX ContentHandler");// String prefix = m_dtm.getPrefix(nsn);//TreeWalker/** DTM Empty Axis Iterator. The class is immutable */new EmptyIterator(...)EmptyIterator INSTANCE;/** This is a default implementation of a table that manages mappings from ... */new ExtendedType(...)new ExtendedType[]...[] m_extendedTypes;/** Array of extended types for this document */int m_initialSize;/** The initial size of the m_extendedTypes array */int m_nextType;// to the length of m_extendedTypes, do we need this?// %REVIEW% Since this is (should be) always equal/** Next available extended type */// These are all the types prerotated, for caller convenience.int CDATA_SECTION;int ENTITY_REFERENCE;int ENTITY;int DOCUMENT;int DOCUMENT_TYPE;int DOCUMENT_FRAGMENT;int NOTATION;ExtendedType hashET;/** Workspace for lookup. NOT THREAD SAFE! */...[] m_defaultExtendedTypes;/** The array to store the default extended types. */float m_loadFactor;/** The default load factor of the Hashtable. ... */int m_initialCapacity;/** The initial capacity of the hash table. Use a bigger number ... */int m_capacity;/** The capacity of the hash table, i.e. the size of the ... */int m_threshold;/** The threshold of the hash table, which is equal to capacity * loadFactor. ... */...[] m_table;/** The internal array to store the hash entries. ... *//** Create an expanded name table. */new HashEntry[]initExtendedTypes(...)/** Initialize the vector of extended types with the ... */new HashEntry(...)/** Given an expanded name represented by namespace, local name and node type, ... */ExtendedType newETHashEntry entryredefine(...)HashEntry em_extendedTypes.lengthExtendedType[] newArray/** Increases the capacity of and internally reorganizes the hashtable, ... */HashEntry[] oldTableHashEntry old/** Given a type, return an expanded name ID.Any additional nodes that are ... *//** Given an expanded-name ID, return the local name ID. ... *//** Given an expanded-name ID, return the namespace URI ID. ... *//** Return the size of the ExpandedNameTable ... *//** Return the array of extended types ... */ExpandedNameTable$HashEntry/** Inner class which represents a hash table entry. ... */ExtendedType key;HashEntry next;/** Init default values */// Calculate the hash code// Redefine the hashET object to represent the new expanded name.// Calculate the index into the HashEntry table.// Look up the expanded name in the hash table. Return the id if// the expanded name is already in the hash table.// Expand the internal HashEntry array if necessary.// Create a new ExtendedType object// Expand the m_extendedTypes array if necessary.// Create a new hash entry for the new ExtendedType and put it into// the table.// ExtendedType etype = m_extendedTypes[ExpandedNameID];//ExtendedType etype = m_extendedTypes[ExpandedNameID];/** The class ExtendedType represents an extended type object used by ... */int nodetype;String namespace;/** Create an ExtendedType object from node type, namespace and local name. ... */this.nodetypethis.namespace/** Create an ExtendedType object from node type, namespace, local name ... *//** Redefine this ExtendedType object to represent a different extended type. ... *//** Override the hashCode() method in the Object class *//** Test if this ExtendedType object is equal to the given ExtendedType. ... */other.nodetypeother.localNameother.namespace/** Return the node type *//** Return the local name *//** Return the namespace *//** <p>IncrementalSAXSource is an API that delivers a small number of ... */// SAX Output API/** Register a SAX-style lexical handler for us to output to *//** Register a SAX-style DTD handler for us to output to *//** deliverMoreNodes() is a simple API which tells the thread in which the ... */// Command Input API/** Launch an XMLReader's parsing operation, feeding events to this ... */// Parse Thread Convenience API// class IncrementalSAXSourceimport ThreadControllerWrapper/** <p>IncrementalSAXSource_Filter implements IncrementalSAXSource, using a ... */CoroutineManager fCoroutineManager;//Internal status reportint fControllerCoroutineID;int fSourceCoroutineID;ContentHandler clientContentHandler;LexicalHandler clientLexicalHandler;// %REVIEW% support multiple?DTDHandler clientDTDHandler;ErrorHandler clientErrorHandler;int eventcounter;int frequency;boolean fNoMoreEvents;// the user requested an early stop via deliverMoreNodes(false).// because input stream ran to completion (endDocument), or because// Flag indicating that no more events should be delivered -- either// Support for startParse()InputSource fXMLReaderInputSource;new CoroutineManager(...)/** Create a IncrementalSAXSource_Filter which is not yet bound to a specific ... */co_joinCoroutineSet(...)XMLErrorResources.ER_COJOINROUTINESET_FAILED/** Bind our input streams to an XMLReader. ... */// Register a content handler for us to output to// Register a DTD handler for us to output to// NOTE NAME -- subclassing issue in the Xerces version// ??? Should we register directly on the filter?// Not all filters support this...// Register a lexical handler for us to output to// Register an error handler for us to output to// Immediately resets number of events before _next_ resume as well.// Set the number of events between resumes of our coroutine// possibility of a large base-64 block in a SOAP stream.)// text causing greater than usual readahead. (Unlikely? Consider the// concatenated before they're processed... but that risks huge blocks of// stop after characters, since in our application these wind up being// and characters may be sufficient. I actually may not want to// %REVIEW% Glenn suggests that pausing after endElement, endDocument,// the additional layer of data flow.// compilers to realize that these are tail-calls, reducing the expense of// BEFORE passing the call along. I'm hoping that this will encourage JIT// Note that for everything except endDocument and fatalError, we do the count-and-yield// is reset.// and resume our coroutine each time that counter hits zero and// but they also count the number of events passing through,// These  pass the data to our client ContentHandler...// ContentHandler methodsco_yield(...)co_entry_pause(...)// But I want 'em here for now, to remind us to recheck this assertion!// actually want to use them to register directly with the filter.// pause after them. As such, it may make more sense for folks who// that they're rare enough that it makes little or no sense to// %REVIEW% These do NOT currently affect the eventcounter; I'm asserting// LexicalHandler support. Not all SAX2 filters support these events// DTDHandler support.// of the normal SAX ErrorHandler stream, that's fine; Not Our Problem.// us in the exception handling code because it won't be delivered as part// abends before endDocument is delivered. If that means explicitly calling// event source make sure this method is invoked if the event stream// %REVIEW% Current solution: In filtering mode, it is REQUIRED that// or a SAX design flaw.// as our event source.  It's unclear whether this is a Xerces bug// handling this properly when running in filtering mode with Xerces// exceptions thrown by the ContentHandler, which prevents us from// PROBLEM: Xerces is apparently _not_ calling the ErrorHandler for// ErrorHandler support.// coroutine support/** <p>In the SAX delegation code, I've inlined the count-down in ... *//** co_entry_pause is called in startDocument() before anything else ... *//** Co_Yield handles coroutine interactions while a parse is in progress. ... */co_resume(...)new StopException(...)co_exit_to(...)/** Launch a thread that will run an XMLReader's parse() operation within ... */// Convenience: Run an XMLReader in a threadXMLErrorResources.ER_INCRSAXSRCFILTER_NOT_RESTARTABLEXMLErrorResources.ER_XMLRDR_NOT_BEFORE_STARTPARSErunThread(...)/* Thread logic to support startParseThread() */StopException exIncrementalSAXSource_Filter$StopException/** Used to quickly terminate parse when running under a ... *//** deliverMoreNodes() is a simple API which tells the coroutine ... *///"co_joinCoroutineSet() failed");// to report fatal errors in filtering mode// Not supported by all SAX2 filters:// Nothing we can do about it// Should we also bind as other varieties of handler?// (DTDHandler and so on)// EXCEPTION: In this case we need to run the event BEFORE we yield.// This can cause a hang.  -sb// co_yield(true);// Otherwise, begin normal event delivery// EXCEPTION: In this case we need to run the event BEFORE we yield --// just as with endDocument, this terminates the event stream.// Nobody called init()? Do it now...// Coroutine system says we haven't registered. That's an// application coding error, and is unrecoverable.// Horrendous kluge to run filter to completion. See below.// Coroutine manager might throw no-such.// Yield control, resume parsing when done// If we're at end of document or were told to stop early// Running under startParseThread()// We'll co_exit from there.// Yield control. We do NOT expect anyone to ever ask us again.// Shouldn't happen unless we've miscoded our coroutine logic// "Shut down the garbage smashers on the detention level!"//"IncrmentalSAXSource_Filter not currently restartable.");//"XMLReader not before startParse request");// Xalan thread pooling...// com.sun.org.apache.xalan.internal.transformer.TransformerImpl.runTransformThread(this);// Guard against direct invocation of start().// Initially assume we'll run successfully.// For the duration of this operation, all coroutine handshaking// will occur in the co_yield method. That's the nice thing about// coroutines; they give us a way to hand off control from the// middle of a synchronous method.// Expected and harmless// Unexpected malfunction// end parse// Mark as no longer running in thread.// Mark as done and yield control to the controller coroutine// "CPO, shut down the garbage smashers on the detention level!"// If parsing is already done, we can immediately say so// SHOULD NEVER OCCUR, since the coroutine number and coroutine manager// are those previously established for this IncrementalSAXSource_Filter...// So I'm just going to return it as a parsing exception, for now./** Simple unit test. Attempt coroutine parsing of document indicated ... *//* public static void _main(String args[]) ... */// class IncrementalSAXSource_Filter/** <p>IncrementalSAXSource_Xerces takes advantage of the fact that Xerces1 ... */Method fParseSomeSetup;// to make it a prerequisite, we will rely upon relection.// references to those APIs. So until Xerces2 is pervasive and we're willing// require very different methods and objects, we need to avoid static// Reflection. To allow this to compile with both Xerces1 and Xerces2, whichMethod fParseSome;// Xerces1 methodObject fPullParserConfig;Method fConfigSetInput;// Xerces2 pull control objectMethod fConfigParse;// Xerces2 methodMethod fSetInputSource;Constructor<> fConfigInputSourceCtor;// Xerces2 pull control methodMethod fConfigSetByteStream;// Xerces2 initialization methodMethod fConfigSetCharStream;Method fConfigSetEncoding;Method fReset;SAXParser fIncrementalParser;// Both Xerces1 and Xerces2, but diff. signatures/** Create a IncrementalSAXSource_Xerces, and create a SAXParser ... */Class<> xniConfigClassClass<>[] args1Constructor<> ctorSAXParser.classClass<> xniStdConfigClassObject[] args2Class<> fXniInputSourceClassClass<>[] args3Class<>[] args4Class<>[] args5Class<>[] args6Reader.classClass<>[] args7Class<>[] argsbClass<>[] noargsIncrementalSAXSource_Xerces dummynew IncrementalSAXSource_Xerces(...)this.fParseSomeSetupdummy.fParseSomeSetupthis.fParseSomedummy.fParseSomethis.fIncrementalParserdummy.fIncrementalParser/** Create a IncrementalSAXSource_Xerces wrapped around ... */Class<> meClass<>[] parmsIncrementalSAXSource_Filter iss// Register handler directly with the incremental parser/** startParse() is a simple API which tells the IncrementalSAXSource ... */XMLErrorResources.ER_STARTPARSE_NEEDS_SAXPARSERXMLErrorResources.ER_STARTPARSE_WHILE_PARSINGparseSomeSetup(...)XMLErrorResources.ER_COULD_NOT_INIT_PARSERboolean keepgoingparseSome(...)// Private methods -- conveniences to hide the reflection detailsObject[] parms1Object xmlsourceObject[] parmsaObject[] noparmsObject[] parmObject ret...[] noparms;//  Would null work???...[] parmsfalse;CoroutineManager coint appCoroutineIDIncrementalSAXSource parsercreateIncrementalSAXSource(...)XMLSerializer tracenew XMLSerializer(...)int argdeliverMoreNodes(...)// Xerces-2 incremental parsing support (as of Beta 3)// ContentHandlers still get set on fIncrementalParser (to get// conversion from XNI events to SAX events), but// _control_ for incremental parsing must be exercised via the config.// At this time there's no way to read the existing config, only// to assert a new one... and only when creating a brand-new parser.// Reflection is used to allow us to continue to compile against// Xerces1. If/when we can abandon the older versions of the parser,// this will simplify significantly.// If we can't get the magic constructor, no need to look further.// Build the parser configuration object. StandardParserConfiguration// happens to implement XMLPullParserConfiguration, which is the API// we're going to want to use.// Preload all the needed the configuration methods... I want to know they're// all here before we commit to trying to use them, just in case the// API changes again.// Fallback if this fails (implemented in createIncrementalSAXSource) is// to attempt Xerces-1 incremental setup. Can't do tail-call in// constructor, so create new, copy Xerces-1 initialization,// then throw it away... Ugh.// Reflection is used to allow us to compile against// Xerces2. If/when we can abandon the older versions of the parser,// this constructor will simply have to fail until/unless the// Xerces2 incremental support is made available on previously// constructed SAXParser instances.// to use IncrementalSAXSource_Filter rather than Xerces-specific code.// Xerces version mismatch; neither Xerces1 nor Xerces2 succeeded.// Fall back on filtering solution.// Typecast required in Xerces2; SAXParser doesn't inheret XMLReader// %OPT% Cast at asignment?// Not supported by all SAX2 parsers but should work in Xerces://"startParse needs a non-null SAXParser.");//"startParse may not be called while parsing.");//"could not initialize parser with");// Obtain input from SAX inputSource object, construct XNI version of// that object. Logic adapted from Xerces2.// Bugzilla5272 patch suggested by Sandy Gao.// Has to be reflection to run with Xerces2// after compilation against Xerces1. or vice// versa, due to return type mismatches.// %REVIEW% Do first pull. Should we instead just return true?// Take next parsing step, return false iff parsing complete:// Tell coroutine to begin parsing, run while parsing is in progress//          System.out.println("\nParser threw exception:");//          ((Exception)result).printStackTrace();// class IncrementalSAXSource_Xerces/** <code>NodeLocator</code> maintains information on an XML source ... */String m_publicId;String m_systemId;int m_lineNumber;int m_columnNumber;/** Creates a new <code>NodeLocator</code> instance. ... */this.m_publicIdthis.m_systemIdthis.m_lineNumberthis.m_columnNumber/** <code>getPublicId</code> returns the public ID of the node. ... *//** <code>getSystemId</code> returns the system ID of the node. ... *//** <code>getLineNumber</code> returns the line number of the node. ... *//** <code>getColumnNumber</code> returns the column number of the ... *//** <code>toString</code> returns a string representation of this ... */import DTMDefaultBaseIteratorsimport ExpandedNameTableimport IncrementalSAXSourceimport StringBufferPoolimport XMLCharacterRecognizer/** The <code>DOM2DTM</code> class serves up a DOM's contents via the ... */new TreeWalker(...)boolean JJK_NEWCODE;String NAMESPACE_DECL_NS;/** Manefest constant */Node m_pos;/** The current position in the DOM tree. Last node examined for ... */int m_last_parent;/** The current position in the DTM tree. Who children get appended to. */int m_last_kid;/** The current position in the DTM tree. Who children reference as their ... */Node m_root;/** The top of the subtree. ... */boolean m_processedFirstElement;/** True iff the first element has been processed. This is used to control ... */boolean m_nodesAreProcessed;/** true if ALL the nodes in the m_root subtree have been processed; ... */Vector<> m_nodes;/** The node objects.  The instance part of the handle indexes ... *//** Construct a DOM2DTM object from a DOM node. ... */int attrsize/** Construct the node map from the node. ... */ExpandedNameTable exntDTMManagerDefault mgrDindexNode(...)declareNamespaceInContext(...)/** Get the number of nodes that have been added. *//** This method iterates to the next node that will be added to the table. ... */Node posint nexttypeboolean suppressNodeNode lastTextNodeshort wsvgetShouldStripSpace(...)boolean shouldStripDTMWSFilter.INHERITDTMWSFilter.STRIPpopShouldStripWhitespace(...)logicalNextDOMTextNode(...)int nextindexnew DOM2DTMdefaultNamespaceDeclarationNode(...)/** Get a Node from an identity index. ... *//** Get the handle from a Node. ... *//** Get the handle from a Node. This is a more robust version of ... */Node cursorgetHandleFromNode(...)lookupNode(...)String nodeuriString nodelocalnameFastStringBuffer buffree(...)/** Determine if the string-value of a node is whitespace ... */boolean b/** Retrieve the text content of a DOM subtree, appending it into a ... */String newnameString nsuri/** Utility function: Given a DOM Text node, determine whether it is ... */DocumentType dtdNode elemint elemHandle/** Bind an IncrementalSAXSource to this DTM. NOT RELEVANT for DOM2DTM, since ... *//** Returns whether the specified <var>ch</var> conforms to the XML 1.0 definition ... */fixWhiteSpace(...)dispatchNodeData(...)TreeWalker m_walker;TreeWalker treeWalkerContentHandler prevCHtraverseFragment(...)/** No source information is available for DOM2DTM, so return ... */// Initialize DOM navigation// Initialize DTM navigation// Apparently the domSource root may not actually be the// Document node. If it's an Element node, we need to immediately// add its attributes. Adapted from nextNode().// %REVIEW% Move this logic into addNode and recurse? Cleaner!// (If it's an EntityReference node, we're probably scrod. For now// I'm just hoping nobody is ever quite that foolish... %REVIEW%)// %ISSUE% What about inherited namespaces in this case?// Do we need to special-case initialize them into the DTM model?// start with no previous sib// No need to force nodetype in this case;// addNode() will take care of switching it from// Attr to Namespace if necessary.// Terminate list of attrs, and make sure they aren't// considered children of the element// IMPORTANT: This does NOT change m_last_parent or m_last_kid!// if attrs exist//if(ELEMENT_NODE)// Initialize DTM-completed status// Have we overflowed a DTM Identity's addressing range?// Handle as Extended Addressing// %REVIEW% Wrong error message, but I've been told we're trying// not to add messages right not for I18N reasons.// %REVIEW% Should this be a Fatal Error?//"No more DTM IDs are available";// ensureSize(nodeIndex);// %REVIEW% The Namespace Spec currently says that Namespaces are// processed in a non-namespace-aware manner, by matching the// QName, even though there is in fact a namespace assigned to// these nodes in the DOM. If and when that changes, we will have// to consider whether we check the namespace-for-namespaces// rather than the node name.// %TBD% Note that the DOM does not necessarily explicitly declare// all the namespaces it uses. DOM Level 3 will introduce a// namespace-normalization operation which reconciles that, and we// can request that users invoke it or otherwise ensure that the// tree is namespace-well-formed before passing the DOM to Xalan.// But if they don't, what should we do about it? We probably// don't want to alter the source DOM (and may not be able to do// so if it's read-only). The best available answer might be to// synthesize additional DTM Namespace Nodes that don't correspond// to DOM Attr Nodes.// If the DTM parent had no children, this becomes its first child.// Deal with the difference between Namespace spec and XSLT// definitions of local name. (The former says PIs don't have// localnames; the latter says they do.)// Hack to make DOM1 sort of work...// -sb// %TBD% Nodes created with the old non-namespace-aware DOM// calls createElement() and createAttribute() will never have a// localname. That will cause their expandedNameID to be just the// nodeType... which will keep them from being matched// successfully by name. Since the DOM makes no promise that// those will participate in namespace processing, this is// officially accepted as Not Our Fault. But it might be nice to// issue a diagnostic message!// warning("DOM 'level 1' node "+node.getNodeName()+" won't be mapped properly in DOM2DTM.");// This should be done after m_exptype has been set, and probably should// always be the last thing we do// Non-recursive one-fetch-at-a-time depth-first traversal with// attribute/namespace nodes and white-space stripping.// Navigating the DOM is simple, navigating the DTM is simple;// keeping track of both at once is a trifle baroque but at least// we've avoided most of the special cases.// %REVIEW% Is this local copy Really Useful from a performance// point of view?  Or is this a false microoptimization?// Navigate DOM tree// %REVIEW% There's probably a more elegant way to skip// the doctype. (Just let it go and Suppress it?// Push DTM context -- except for children of Entity References,// which have no DTM equivalent and cause no DTM navigation.// Whitespace-handler context stacking// if(m_wsfilter)// If that fails, look up and right (but not past root!)// Last node posted at this level had no more children// If it has _no_ children, we need to record that.// %REVIEW% There's probably a more elegant way to// skip the doctype. (Just let it go and Suppress it?// Found it!// No next-sibling found. Pop the DOM.// %TBD% Should never arise, but I want to be sure of that...// Freeze right here!// The only parents in the DTM are Elements.  However,// the DOM could contain EntityReferences.  If we// encounter one, pop it _without_ popping DTM.// Nothing needs doing// Fix and pop DTM// Popping from an element// Popping from anything else// If it's an entity ref, advance past it.// %REVIEW% Should we let this out the door and just suppress it?// More work, but simpler code, more likely to be correct, and// it doesn't happen very often. We'd get rid of the loop too.// Did we run out of the tree?// Text needs some special handling:// DTM may skip whitespace. This is handled by the suppressNode flag, which// when true will keep the DTM node from being created.// DTM only directly records the first DOM node of any logically-contiguous// sequence. The lastTextNode value will be set to the last node in the// contiguous sequence, and -- AFTER the DTM addNode -- can be used to// advance next over this whole block. Should be simpler than special-casing// the above loop for "Was the logically-preceeding sibling a text node".// Finally, a DTM node should be considered a CDATASection only if all the// contiguous text it covers is CDATASections. The first Text should// force DTM to Text.// nexttype=pos.getNodeType();// If filtering, initially assume we're going to suppress the node// Scan logically contiguous text (siblings, plus "flattening"// of entity reference boundaries).// Any Text node means DTM considers it all Text// Any non-whitespace in this sequence blocks whitespace// suppression// Special handling for PIs: Some DOMs represent the XML// Declaration as a PI. This is officially incorrect, per the DOM// spec, but is considered a "wrong but tolerable" temporary// workaround pending proper handling of these fields in DOM Level// 3. We want to recognize and reject that case.// Inserting next. NOTE that we force the node type; for// coalesced Text, this records CDATASections adjacent to// ordinary Text as Text.// Process attributes _now_, rather than waiting.// Simpler control flow, makes NS cache available immediately.// If the xml: prefix is explicitly declared// we don't need to synthesize one.// NOTE that XML Namespaces were not originally// defined as being namespace-aware (grrr), and// while the W3C is planning to fix this it's// safer for now to test the QName and trust the// parsers to prevent anyone from redefining the// reserved xmlns: prefix// The DOM might not have an explicit declaration for the// implicit "xml:" prefix, but the XPath data model// requires that this appear as a Namespace Node so we// have to synthesize one. You can think of this as// being a default attribute defined by the XML// Namespaces spec rather than by the DTD.// (if !suppressNode)// Text postprocessing: Act on values stored above// %TBD% If nexttype was forced to TEXT, patch the DTM node// Advance the DOM cursor over contiguous text// Remember where we left off.// Is Node actually within the same document? If not, don't search!// This would be easier if m_root was always the Document node, but// we decided to allow wrapping a DTM around a subtree.// If node _is_ in m_root's tree, find its handle// %OPT% This check may be improved significantly when DOM// Level 3 nodeKey and relative-order tests become// available!// We know this node; find its handle.// for ancestors of node// if node and m_root in same Document// if node!=null// %OPT% This is probably slower than it needs to be.// Assume that attributes immediately follow the element.// Should namespace nodes be retrievable DOM-style as attrs?// If not we need a separate function... which may be desirable// architecturally, but which is ugly from a code point of view.// (If we REALLY insist on it, this code should become a subroutine// of both -- retrieve the node, then test if the type matches// what you're looking for.)// if (DTM.NAMESPACE_NODE != type)// %TBD% If an element only has one text node, we should just use it// If this is a DTM text node, it may be made of multiple DOM text// nodes -- including navigating into Entity References. DOM2DTM// records the first node in the sequence and requires that we// pick up the others when we retrieve the DTM node's value.// %REVIEW% DOM Level 3 is expected to add a "whole text"// retrieval method which performs this function for us.// Never a child but might be our starting node// warning(XPATHErrorResources.WG_PARSING_AND_PREPARING);// Assume non-null.// assume not null.// XSLT treats PIs, and possibly other things, as having QNames.//  Match old default for this function// This conversion may or may not be necessary// %TBD% Handle DOM1?// Walk out of any EntityReferenceNodes that ended with text// Walk into any EntityReferenceNodes that start with text// Found a logical next sibling. Is it text?// The _type(nodeHandle) call was taking the lion's share of our// time, and was wrong anyway since it wasn't coverting handle to// identity. Inlined it.// then it's unparsed// The draft says: "The XSLT processor may use the public// identifier to generate a URI for the entity instead of the URI// specified in the system identifier. If the XSLT processor does// not use the public identifier to generate the URI, it must use// the system identifier; if the system identifier is a relative// URI, it must be resolved into an absolute URI using the URI of// the resource containing the entity declaration as the base// URI [RFC2396]."// So I'm falling a bit short here.// This should be resolved to an absolute URL, but that's hard// to do from here.// Take the easy way out for now.// Text coalition -- a DTM text node may represent multiple// DOM nodes.// NOTE: Because this operation works in the DOM space, it does _not_ attempt// to perform Text Coalition. That should only be done in DTM space.//    /* case Node.PROCESSING_INSTRUCTION_NODE ://      // warning(XPATHErrorResources.WG_PARSING_AND_PREPARING);//      break; *//** This is a kluge to let us shove a declaration for xml: into the ... */String NOT_SUPPORTED_ERR;Element pseudoparent;String prefix, ...;int handle;this.pseudoparentthis.handlethis.nodename/** Non-DOM method, part of the temporary kluge ... *///RAMESH: PENDING=> Add proper implementation for the below DOM L3 additionsimport DTMStringPoolimport DTMTreeWalkerimport NodeLocatorimport StringVectorimport WrappedRuntimeException/** This class implements a DTM that tends to be optimized more for speed than ... */new DTMTreeWalker(...)/** Set true to monitor SAX events and similar diagnostic info. */IncrementalSAXSource m_incrementalSAXSource;FastStringBuffer m_chars;//private FastStringBuffer m_chars = new FastStringBuffer(13, 13);/** All the character content, including attribute values, are stored in ... */SuballocatedIntVector m_data;/** This vector holds offset and length data. */IntStack m_parents;/** The parent stack, needed only for construction. ... */int m_previous;/** The current previous node, needed only for construction time. ... */Vector<> m_prefixMappings;/** Namespace support, only relevent at construction time. ... */IntStack m_contextIndexes;int m_textType;/** Type of next characters() event within text block in prgress. */int m_coalescedTextType;/** Type of coalesced text block. See logic in the characters() ... */Locator m_locator;/** The SAX Document locator *//** The SAX Document system-id */boolean m_insideDTD;/** We are inside the DTD.  This is used for ignoring comments. */DTMTreeWalker m_walker;/** Tree Walker for dispatchToEvents. */DTMStringPool m_valuesOrPrefixes;/** pool of string values that come as strings. */boolean m_endDocumentOccured;/** End document has been reached. ... */SuballocatedIntVector m_dataOrQName;/** Data or qualified name values, one array element for each node. */Map<String,Integer> m_idAttributes;/** This table holds the ID string to node associations, for ... */...[] m_fixednames;/** fixed dom-style names. */Vector<> m_entities;/** Vector of entities.  Each record is composed of four Strings: ... */int ENTITY_FIELD_PUBLICID;/** m_entities public ID offset. */int ENTITY_FIELD_SYSTEMID;/** m_entities system ID offset. */int ENTITY_FIELD_NOTATIONNAME;/** m_entities notation name offset. */int ENTITY_FIELD_NAME;/** m_entities name offset. */int ENTITY_FIELDS_PER;/** Number of entries per record for m_entities. */int m_textPendingStart;/** The starting offset within m_chars for the text or ... */boolean m_useSourceLocationProperty;/** Describes whether information about document source location ... */StringVector m_sourceSystemId;/** Made protected for access by SAX2RTFDTM. */IntVector m_sourceLine;IntVector m_sourceColumn;/** Construct a SAX2DTM object using the default block size. ... *//** Construct a SAX2DTM object ready to be constructed from SAX2 ... */getSource_location(...)new StringVector(...)/** Set whether information about document source location ... *//** Get the data or qualified name for the given node identity. ... *//** Ask the CoRoutine parser to doTerminate and clear the reference. *//** Ask the CoRoutine parser to doTerminate and clear the reference. If ... */isTextType(...)sendNormalizedSAXcharacters(...)sendSAXcharacters(...)int startNode_dataOrQName(...)int expandedTypeIDint qnameIndexDTMTreeWalker treeWalkergetcontentHandler(...)setcontentHandler(...)setDTM(...)Object gotMore/** Bottleneck determination of text type. ... *///        super.ensureSize(index);//          // But DTMDefaultBase may need fixup.//          // dataOrQName is an SuballocatedIntVector and hence self-sizing.//     * NEEDSDOC @param index//     * @param on exit from this function, the information arrays sizes must beaddNewDTMID(...)setSourceLocation(...)/** Get a new DTM ID beginning at the specified node index. ... */int numDTMsint dtmId/** Store the source location of the current node.  This method must be called ... */String enameString nnameint prefixIndexint attrHString attrNSboolean nsMatchemptystr(...)Integer intObj/** Get a prefix either from the qname or from the uri mapping, or just make ... */int uriIndexint indexOfNSSep/** Get a prefix either from the uri mapping, or just make ... *//** Set an ID string to node association in the ID table. ... *//** Check whether accumulated text should be stripped; if not, ... */boolean doStripint exName/** Resolve an external entity. ... */// Implementation of the EntityResolver interface./** Receive notification of a notation declaration. ... */// Implementation of DTDHandler interface./** Receive notification of an unparsed entity declaration. ... *//** Receive a Locator object for document events. ... */// Implementation of ContentHandler interface./** Receive notification of the beginning of the document. ... */int doc/** Receive notification of the end of the document. ... */charactersFlush(...)/** Receive notification of the start of a Namespace mapping. ... *//** Receive notification of the end of a Namespace mapping. ... *//** Check if a declaration has already been made for a given prefix. ... */int startDeclsVector<> prefixMappingsString prefixDeclboolean m_pastFirstElement;/** Receive notification of the start of an element. ... */int elemNodeboolean DEBUG_ATTRSString declURLString attrUriString valStringString attrLocalNamedeclAlreadyDeclared(...)setIDAttribute(...)/** Receive notification of the end of an element. ... */int topContextIndexint lastNodequickPop(...)/** Receive notification of character data inside an element. ... *//** Receive notification of ignorable whitespace in element content. ... *//** Receive notification of a processing instruction. ... *//** Receive notification of a skipped entity. ... *//** Receive notification of a parser warning. ... */// Implementation of the ErrorHandler interface./** Receive notification of a recoverable parser error. ... *//** Report a fatal XML parsing error. ... *//** Report an element type declaration. ... */// Implementation of the DeclHandler interface./** Report an attribute type declaration. ... *//** Report an internal entity declaration. ... *//** Report a parsed external entity declaration. ... *//** Report the start of DTD declarations, if any. ... */// Implementation of the LexicalHandler interface./** Report the end of DTD declarations. ... *//** Report the beginning of an entity in content. ... *//** Report the end of an entity. ... *//** Report the start of a CDATA section. ... *//** Report the end of a CDATA section. ... *//** Report an XML comment anywhere in the document. ... *//** Retrieve the SourceLocator associated with a specific node. ... */new NodeLocator(...)/* $Id: SAX2DTM.java,v 1.2.4.1 2005/09/15 08:15:11 suresh_emailid Exp $ */// %OPT% Use smaller sizes for all internal storage units when// the blocksize is small. This reduces the cost of creating an RTF.// %REVIEW%  Initial size pushed way down to reduce weight of RTFs// (I'm not entirely sure 0 would work, so I'm playing it safe for now.)//m_data = new SuballocatedIntVector(doIndexing ? (1024*2) : 512, 1024);//m_data = new SuballocatedIntVector(blocksize);// Need placeholder in case index into here must be <0.//m_dataOrQName = new SuballocatedIntVector(blocksize);// m_useSourceLocationProperty=com.sun.org.apache.xalan.internal.processor.TransformerFactoryImpl.m_source_location;// Establish coroutine link so we can request more data// Note: It's possible that some versions of IncrementalSAXSource may// not actually use a CoroutineManager, and hence may not require// that we obtain an Application Coroutine ID. (This relies on the// coroutine transaction details having been encapsulated in the// IncrementalSAXSource.do...() methods.)// Are the following really needed? incrementalSAXSource doesn't yet//incrementalSAXSource.setErrorHandler(this);//incrementalSAXSource.setDeclHandler(this);// If just testing nonzero, no need to shift...// Don't retrieve name until/unless needed// String name = m_expandedNameTable.getLocalName(expandedTypeID);// I'm not sure if I want to do anything with this...// ??// gotMore may be a Boolean (TRUE if still parsing, FALSE if// EOF) or an exception if IncrementalSAXSource malfunctioned// (code error rather than user error).// %REVIEW% Currently the ErrorHandlers sketched herein are// no-ops, so I'm going to initially leave this also as a// no-op.// for now...// EOF reached without satisfying the request// Drop connection, stop trying// %TBD% deregister as its listener?// Common to all nodes:// Note that nextSibling is not processed until charactersFlush()// is called, to handle successive characters() events.// Special handling by type: Declare namespaces, attach first child// We have to reset the information in m_dtmIdent and// register the DTM with the new manager.//%REVIEW% %BUG% Prevent this from arising in the first place// by not allowing the enabling conditions to change after we start// building the document.// %OPT% We should cache this, I guess.// Separate lines because I wanted to breakpoint it// -1 indicates no-text-in-progress// Discard accumulated text// Guard against characters/ignorableWhitespace events that// contained no characters.  They should not result in a node.// Reset for next text block//  private static final int ENTITY_FIELD_PUBLICID = 0;//  private static final int ENTITY_FIELD_SYSTEMID = 1;//  private static final int ENTITY_FIELD_NOTATIONNAME = 2;//  private static final int ENTITY_FIELD_NAME = 3;// for the next element.// Bugzilla 4858: throw away m_locator. we cache m_systemId// JDK 1.1.x compat -sc// SPECIAL CASE: Implied declaration at root element// go to the next attribute.// Bit of a hack... if somehow valString is null, stringToIndex will// return -1, which will make things very unhappy.//String attrLocalName = attributes.getLocalName(i);// for the children.// If no one noticed, startPrefixMapping is a drag.// Pop the context for the last child (the one pushed by startElement)// Do it again for this one (the one pushed by the last endElement).// If lastNode is still DTM.NULL, this element had no children// First one in this block// Type logic: If all adjacent text is CDATASections, the// concatentated text is treated as a single CDATASection (see// initialization above).  If any were ordinary Text, the whole// thing is treated as Text. This may be worth %REVIEW%ing.// %OPT% We can probably take advantage of the fact that we know this// is whitespace.// %REVIEW% What should be done here?// %REVIEW% Is there anyway to get the JAXP error listener here?// ignore comments if we're inside the DTD// For now, treat comments as strings...  I guess we should do a// seperate FSB buffer instead.import com.sun.org.apache.xml.internal.dtm.ref.*import org.xml.sax.*/** SAX2DTM2 is an optimized version of SAX2DTM which is used in non-incremental situation. ... *//** ************************************************************** ... */SAX2DTM2$ParentIterator_parent2(...)_type2(...)SAX2DTM2$TypedChildrenIterator/** Return the node at the given position. */SAX2DTM2$TypedRootIteratorSAX2DTM2$TypedFollowingSiblingIteratorSAX2DTM2$TypedAttributeIteratorSAX2DTM2$TypedPrecedingSiblingIteratorint startNodeID/** Return the index of the last node in this iterator. */SAX2DTM2$PrecedingIteratorSAX2DTM2$TypedPrecedingIterator//DTMAxisTraverser m_traverser; // easier for nowSAX2DTM2$TypedFollowingIteratorint currentNodeIDSAX2DTM2$AncestorIteratorint m_blocksize;// The initial size of the ancestor array...[] m_ancestors;// The array for ancestor nodes. This array will grow dynamically.// Number of ancestor nodes in the arraym_ancestors.lengthint[] newAncestorsSAX2DTM2$TypedAncestorIteratorSAX2DTM2$TypedDescendantIteratorSAX2DTM2$TypedSingletonIterator...[] m_exptype_map0;// SuballocatedIntVector.elementAt().// of indirection and results in better performance than just calling// SuballocatedIntVectors. Using the cached arrays reduces the level// %OPT% Array references which are used to cache the map0 arrays in...[] m_nextsib_map0;...[] m_firstch_map0;...[] m_parent_map0;...[] m_exptype_map;// Double array references to the map arrays in SuballocatedIntVectors....[] m_nextsib_map;...[] m_firstch_map;...[] m_parent_map;// %OPT% Cache the array of extended types in this classVector<> m_values;// %REVISIT% Do we need a custom class (e.g. StringVector) here?// DTMStringPool because we can save the cost for hash calculation.// them in a plain Vector is more efficient than storing in the// %OPT% These values are unlikely to be equal. Storing// comment and PI nodes.// A Vector which is used to store the values of attribute, namespace,int m_valueIndex;// The current index into the m_values Vector.int m_maxNodeIndex;// The maximum value of the current node index.int m_SHIFT;// Cache the shift and mask values for the SuballocatedIntVectors.int m_MASK;int TEXT_LENGTH_BITS;// The number of bits for the length of a Text node./** %OPT% If the offset and length of a Text node are within certain limits, ... */int TEXT_OFFSET_BITS;// The number of bits for the offset of a Text node.int TEXT_LENGTH_MAX;// The maximum length valueint TEXT_OFFSET_MAX;// The maximum offset valueboolean m_buildIdIndex;// True if we want to build the ID index table.XMLString EMPTY_XML_STR;// Constant for empty XMLString/** Construct a SAX2DTM2 object using the default block size. *//** Construct a SAX2DTM2 object using the given block size. */getMap0(...)/** Override DTMDefaultBase._exptype() by dropping the incremental code. ... *//** The optimized version of DTMDefaultBase._exptype(). ... *//** The optimized version of DTMDefaultBase._nextsib(). ... *//** The optimized version of DTMDefaultBase._firstch(). ... *//** The optimized version of DTMDefaultBase._parent(). ... *//** The optimized version of DTMDefaultBase._type(). ... *//** The optimized version of DTMDefaultBase.getExpandedTypeID(int). ... *//** Return the node type from the expanded type *//** Override SAX2DTM.startElement() ... */getExtendedTypes(...)getMap(...)/** Override the processingInstruction() interface in SAX2DTM2. ... *//** The optimized version of DTMDefaultBase.getFirstAttribute(). ... *//** The optimized version of DTMDefaultBase.getFirstAttributeIdentity(int). ... *//** The optimized version of DTMDefaultBase.getNextAttributeIdentity(int). ... *//** The optimized version of DTMDefaultBase.getTypedAttribute(int, int). ... *//** Override SAX2DTM.getLocalName() in SAX2DTM2. ... *//** The optimized version of SAX2DTM.getNodeNameX(). ... */ExtendedType extType/** The optimized version of SAX2DTM.getNodeName(). ... */getFixedNames(...)/** Override SAX2DTM.getStringValue(int) ... *//** The optimized version of SAX2DTM.getStringValue(int). ... *//** Returns the string value of the entire tree *//** The optimized version of SAX2DTM.dispatchCharactersEvents(int, ContentHandler, boolean). ... *//** Copy the String value of a Text node to a SerializationHandler *//** Copy an Element node to a SerializationHandler. ... *//** Copy  namespace nodes. ... */int nextNSNodegetNextNamespaceNode2(...)String nodeValue/** Return the next namespace node following the given base node. ... *//** Copy  attribute nodes from an element . ... *//** Copy an Attribute node to a SerializationHandler ... */int valueIndex/* $Id: SAX2DTM2.java,v 1.2.4.1 2005/09/15 08:15:12 suresh_emailid Exp $ */// %OPT% The most common case is handled first.// %OPT% If the nodeType is element (matching child::*), we only// need to compare the expType with DTM.NTYPES. A child node of// an element can be either an element, text, comment or// processing instruction node. Only element node has an extended// type greater than or equal to DTM.NTYPES.//m_traverser = getAxisTraverser(Axis.FOLLOWING);//_currentNode = m_traverser.first(node);//_currentNode = m_traverser.next(_startNode, _currentNode);// Start from the current node's parent if// _includeSelf is false.//m_ancestors.addElement(node);// %OPT% If the startNode is the root node, do not need// to do the isDescendant() check.// %OPT% If the start node is root (e.g. in the case of //node),// we can save the isDescendant() check, because all nodes are// descendants of root.// Initialize the values of m_SHIFT and m_MASK.// Some documents do not have attribute nodes. That is why// we set the initial size of this Vector to be small and set// the increment to a bigger number.// Set the map0 values in the constructor.//return m_exptype.elementAt(identity);//return m_nextsib.elementAt(identity);//return m_firstch.elementAt(identity);//return m_parent.elementAt(identity);//int eType = _exptype2(identity);//return (nodeID != NULL) ? _exptype2(nodeID) : NULL;// %OPT% Saving the comment string in a Vector has a lower cost than// saving it in DTMStringPool.// Add a NULL entry to the end of the node arrays as// the end indication.// Set the cached references after the document is built.//if(m_dtmIdent.size() == (nodeIndex>>>DTMManager.IDENT_DTM_NODE_BITS))// If the offset and length do not exceed the given limits// (offset < 2^21 and length < 2^10), then save both the offset// and length in a bitwise encoded value.// Store offset and length in the m_data array if one exceeds// the given limits. Use a negative dataIndex as an indication.// optimization: only create StringBuffer if > 1 child// %OPT% Optimization for documents which does not have any explicit// namespace nodes. For these documents, there is an implicit// namespace node (xmlns:xml="http://www.w3.org/XML/1998/namespace")// declared on the root element node. In this case, there is no// need to do namespace copying. We can safely return without// doing anything.// Find the first namespace node// Retrieve the name of the namespace node// Retrieve the node value of the namespace node/* final String uri = getNamespaceName(node); ... *//** This is a subclass of SAX2DTM which has been modified to meet the needs of ... */int m_currentDocumentNode;/** Most recently started Document, or null if the DTM is empty. */IntStack mark_size;/** Tail-pruning mark: Number of nodes in use */IntStack mark_data_size;/** Tail-pruning mark: Number of data items in use */IntStack mark_char_size;/** Tail-pruning mark: Number of size-of-data fields in use */IntStack mark_doq_size;/** Tail-pruning mark: Number of dataOrQName slots in use */IntStack mark_nsdeclset_size;/** Tail-pruning mark: Number of namespace declaration sets in use ... */IntStack mark_nsdeclelem_size;/** Tail-pruning mark: Number of naespace declaration elements in use ... */int m_emptyNodeCount;/** Tail-pruning mark:  initial number of nodes in use */int m_emptyNSDeclSetCount;/** Tail-pruning mark:  initial number of namespace declaration sets */int m_emptyNSDeclSetElemsCount;/** Tail-pruning mark:  initial number of namespace declaration elements */int m_emptyDataCount;/** Tail-pruning mark:  initial number of data items in use */int m_emptyCharsCount;/** Tail-pruning mark:  initial number of characters in use */int m_emptyDataQNCount;/** Tail-pruning mark:  default initial number of dataOrQName slots in use *//** Given a DTM, find the owning document node. In the case of ... *//** Given a node handle, find the owning document node, using DTM semantics ... *//** Given a node identifier, find the owning document node.  Unlike the DOM, ... *//** Receive notification of the beginning of a new RTF document. ... *//** "Tail-pruning" support for RTFs. ... */boolean topint dsint ds1// NEVER track source locators for RTFs; they aren't meaningful. I think.// (If we did track them, we'd need to tail-prune these too.)//com.sun.org.apache.xalan.internal.processor.TransformerFactoryImpl.m_source_location;// Record initial sizes of fields that are pushed and restored// for RTF tail-pruning.  More entries can be popped than pushed, so// we need this to mark the primordial state of the DTM.// Safety net; should never happen// Re-initialize the tree append process// no longer open// Values from DTMDefaultBase// %REVIEW% Can the namespace stack sizes ever differ? If not, save space!// Values from SAX2DTM// Values from SAX2DTM - m_data always has a reserved entry// Return true iff DTM now emptyint MAX_CODE;/** Maximum error messages, this is needed to keep track of the number of messages. *//** Maximum warnings, this is needed to keep track of the number of warnings. */int MAX_OTHERS;/** Maximum misc strings. */int MAX_MESSAGES;/** Maximum total warnings and error messages. *//* Message keys */String ER_CANNOT_OVERWRITE_CAUSE;String ER_NO_DEFAULT_IMPL;String ER_CHUNKEDINTARRAY_NOT_SUPPORTED;String ER_OFFSET_BIGGER_THAN_SLOT;String ER_COROUTINE_NOT_AVAIL;String ER_COROUTINE_CO_EXIT;String ER_COJOINROUTINESET_FAILED;String ER_COROUTINE_PARAM;String ER_PARSER_DOTERMINATE_ANSWERS;String ER_NO_PARSE_CALL_WHILE_PARSING;String ER_TYPED_ITERATOR_AXIS_NOT_IMPLEMENTED;String ER_ITERATOR_AXIS_NOT_IMPLEMENTED;String ER_ITERATOR_CLONE_NOT_SUPPORTED;String ER_UNKNOWN_AXIS_TYPE;String ER_AXIS_NOT_SUPPORTED;String ER_NO_DTMIDS_AVAIL;String ER_NODE_NON_NULL;String ER_COULD_NOT_RESOLVE_NODE;String ER_STARTPARSE_WHILE_PARSING;String ER_STARTPARSE_NEEDS_SAXPARSER;String ER_COULD_NOT_INIT_PARSER;String ER_EXCEPTION_CREATING_POOL;String ER_PATH_CONTAINS_INVALID_ESCAPE_SEQUENCE;String ER_SCHEME_REQUIRED;String ER_NO_SCHEME_IN_URI;String ER_NO_SCHEME_INURI;String ER_PATH_INVALID_CHAR;String ER_SCHEME_FROM_NULL_STRING;String ER_SCHEME_NOT_CONFORMANT;String ER_HOST_ADDRESS_NOT_WELLFORMED;String ER_PORT_WHEN_HOST_NULL;String ER_INVALID_PORT;String ER_FRAG_FOR_GENERIC_URI;String ER_FRAG_WHEN_PATH_NULL;String ER_FRAG_INVALID_CHAR;String ER_PARSER_IN_USE;String ER_CANNOT_CHANGE_WHILE_PARSING;String ER_SELF_CAUSATION_NOT_PERMITTED;String ER_NO_USERINFO_IF_NO_HOST;String ER_NO_PORT_IF_NO_HOST;String ER_NO_QUERY_STRING_IN_PATH;String ER_NO_FRAGMENT_STRING_IN_PATH;String ER_CANNOT_INIT_URI_EMPTY_PARMS;String ER_METHOD_NOT_SUPPORTED;String ER_INCRSAXSRCFILTER_NOT_RESTARTABLE;String ER_XMLRDR_NOT_BEFORE_STARTPARSE;String ER_AXIS_TRAVERSER_NOT_SUPPORTED;String ER_ERRORHANDLER_CREATED_WITH_NULL_PRINTWRITER;String ER_SYSTEMID_UNKNOWN;String ER_LOCATION_UNKNOWN;String ER_CREATEDOCUMENT_NOT_SUPPORTED;String ER_CHILD_HAS_NO_OWNER_DOCUMENT;String ER_CHILD_HAS_NO_OWNER_DOCUMENT_ELEMENT;String ER_CANT_OUTPUT_TEXT_BEFORE_DOC;String ER_CANT_HAVE_MORE_THAN_ONE_ROOT;String ER_ARG_LOCALNAME_NULL;String ER_ARG_LOCALNAME_INVALID;String ER_ARG_PREFIX_INVALID;String ER_NAME_CANT_START_WITH_COLON;// Message keys used by the serializerString ER_OIERROR;String ER_NAMESPACE_PREFIX;String ER_STRAY_ATTRIBUTE;String ER_STRAY_NAMESPACE;String ER_COULD_NOT_LOAD_METHOD_PROPERTY;String ER_SERIALIZER_NOT_CONTENTHANDLER;String ER_ILLEGAL_ATTRIBUTE_POSITION;String ER_ILLEGAL_CHARACTER;...[] contents;/** The lookup table for error messages. *//** Get the association list. ... */// Note to translators:  A QNAME has the syntactic form [NCName:]NCName// The localname is the portion after the optional colon; the message indicates// that there is a problem with that part of the QNAME.// The prefix is the portion before the optional colon; the message indicates...[] _contents;/** Get the lookup table for error messages ... *//** Default implementation of XPATHErrorResources.  This is just ... *//** A utility class for issuing XML error messages. ... *//** The local object to use. */ListResourceBundle XMLBundle;/** The language specific resource object for XML messages. */String XML_ERROR_RESOURCES;/** The class name of the XML error message string table. *//** String to use if a bad message code is used. *//** String to use if the message format operation failed. *//** Set the Locale object to use. ... *//** Get the Locale object that is being used. ... *//** Creates a message from the specified key and replacement ... */String fmsgboolean throwex// Do this to keep format from crying.// This is better than making a bunch of conditional// code all over the place.import FileURLimport PublicIdimport CatalogReaderimport TR9401CatalogReader/** Represents OASIS Open Catalog files. ... */getStaticManager(...)addEntryType(...)int BASE;/** The BASE Catalog Entry type. */int CATALOG;/** The CATALOG Catalog Entry type. *//** The DOCUMENT Catalog Entry type. */int OVERRIDE;/** The OVERRIDE Catalog Entry type. */int SGMLDECL;/** The SGMLDECL Catalog Entry type. */int DELEGATE_PUBLIC;/** The DELEGATE_PUBLIC Catalog Entry type. */int DELEGATE_SYSTEM;/** The DELEGATE_SYSTEM Catalog Entry type. */int DELEGATE_URI;/** The DELEGATE_URI Catalog Entry type. */int DOCTYPE;/** The DOCTYPE Catalog Entry type. */int DTDDECL;/** The DTDDECL Catalog Entry type. *//** The ENTITY Catalog Entry type. */int LINKTYPE;/** The LINKTYPE Catalog Entry type. *//** The NOTATION Catalog Entry type. */int PUBLIC;/** The PUBLIC Catalog Entry type. */int SYSTEM;/** The SYSTEM Catalog Entry type. */int URI;/** The URI Catalog Entry type. */int REWRITE_SYSTEM;/** The REWRITE_SYSTEM Catalog Entry type. */int REWRITE_URI;/** The REWRITE_URI Catalog Entry type. */int SYSTEM_SUFFIX;/** The SYSTEM_SUFFIX Catalog Entry type. */int URI_SUFFIX;/** The URI_SUFFIX Catalog Entry type. */URL base;/** The base URI for relative system identifiers in the catalog. ... */URL catalogCwd;/** The base URI of the Catalog file currently being parsed. */Vector<> catalogEntries;/** The catalog entries currently known to the system. */boolean default_override;/** The default initial override setting. */CatalogManager catalogManager;/** The catalog manager in use for this instance. */Vector<> catalogFiles;/** A vector of catalog files to be loaded. ... */Vector<> localCatalogFiles;/** A vector of catalog files constructed during processing of ... */Vector<> catalogs;/** A vector of Catalogs. ... */Vector<> localDelegate;/** A vector of DELEGATE* Catalog entries constructed during ... */Map<String,Integer> readerMap;/** A hash of CatalogReaders. ... */Vector<> readerArr;/** A vector of CatalogReaders. ... *//** Constructs an empty Catalog. ... *//** Constructs an empty Catalog with a specific CatalogManager. ... *//** Return the CatalogManager used by this catalog. *//** Establish the CatalogManager used by this catalog. *//** Setup readers. */TR9401CatalogReader textReadernew TR9401CatalogReader(...)/** Add a new CatalogReader to the Catalog. ... *//** Copies the reader list from the current Catalog to a new Catalog. ... */Vector<> mapArrString mimeType/** Create a new Catalog object. ... */String catalogClassCatalog csetCatalogManager(...)copyReaders(...)message(...)catalogManager.debug/** Returns the current base URI. *//** Returns the default override setting associated with this ... *//** Load the system catalog files. ... */Vector<> catalogsgetCatalogFiles(...)String catfile/** Parse a catalog file, augmenting internal data structures. ... */getPreferPublic(...)parsePendingCatalogs(...)CatalogReader readerint arrayPosnew CatalogException(...)CatalogException.UNPARSEABLEreadCatalog(...)/** Parse a catalog document, augmenting internal data structures. ... */DataInputStream inStreamboolean parsedFileNotFoundException fnfeCatalogException cegetExceptionType(...)CatalogException.PARSE_FAILED/** Parse all of the pending catalogs. ... */Vector<> newQueueEnumeration<> qint curCatparseCatalogFile(...)/** Parse a single catalog file, augmenting internal data structures. ... */CatalogEntry entryboolean notFoundmakeURL(...)fixSlashes(...)MalformedURLException e2/** Cleanup and process a Catalog entry. ... */getEntryType(...)getEntryArg(...)URL newbaseString fsimakeAbsolute(...)String publicidString systemidnormalizeURI(...)setEntryArg(...)String altURIString ppiaddDelegate(...)String psiString puiString rpxString upxString fpi/** Handle unknown CatalogEntry types. ... *//** Parse all subordinate catalogs. ... */Enumeration<> enint catPosnewCatalog(...)parseAllCatalogs(...)CatalogEntry eCatalog dcat/** Return the applicable DOCTYPE system identifier. ... */String resolvedboolean overdecodeURN(...)resolveLocalSystem(...)resolveLocalPublic(...)resolveSubordinateCatalogs(...)/** Return the applicable DOCUMENT entry. ... *//** Return the applicable ENTITY system identifier. ... *//** Return the applicable NOTATION system identifier. ... *//** Return the applicable PUBLIC or SYSTEM identifier. ... */Vector<> delCatsString pEnumeration<> enCatsString delegatedCatalog/** Return the applicable SYSTEM system identifier. ... *//** Return the applicable SYSTEM system identifier in this ... */boolean windowsString startStringString suffixStringString suffixURI/** Return the applicable URI. ... */resolveLocalURI(...)/** Return the applicable URI in this catalog. ... *//** Search the subordinate catalogs, in order, looking for a match. ... */resolveDoctype(...)resolveNotation(...)/** Replace backslashes with forward slashes. (URLs always use ... */// -----------------------------------------------------------------/** Construct an absolute URI from a relative one, using the current ... */URL local/** Perform character normalization on a URI reference. ... */StringBuilder newRefUnsupportedEncodingException ueeencodedByte(...)/** Perform %-encoding on a single byte. ... *//** Add to the current list of delegated catalogs. ... */String partialEnumeration<> localCatalogEntry dpeString dp// Catalog.java - Represents OASIS Open Catalog files.// nop;// Have to copy the readers in the right order...convert hash to arr// Pad the mapArr out to the right length// This is a little odd. The parseCatalog() method expects// a filename, but it adds that name to the end of the// catalogFiles vector, and then processes that vector.// This allows the system to handle CATALOG entries// In this init case, we take the last element off the// catalogFiles vector and pass it to parseCatalog. This// will "do the right thing" in the init case, and allow// parseCatalog() to do the right thing in the non-init// case. Honest.// Put the file into the list of catalogs to process...// In all cases except the case when initCatalog() is the// caller, this will be the only catalog initially in the list...// Now process all the pending catalogs...// No catalog; give up!// give up!// try again!//nop// Move all the localCatalogFiles into the front of// the catalogFiles queue// Put the rest of the catalogs on the end of the new list// Suppose there are no catalog files to process, but the// single catalog already parsed included some delegate// entries? Make sure they don't get lost.// Now process all the files on the catalogFiles vector. This// vector can grow during processing if CATALOG entries are// encountered in the catalog// We haven't parsed any catalogs yet, let this// catalog be the first...// This is a subordinate catalog. We save its name,// but don't bother to load it unless it's necessary.// We've parsed them all, reinit the vector...// The base-base is the cwd. If the catalog file is specified// with a relative path, this assures that it gets resolved// properly...// tack on a basename because URLs point to files not dirs// The initial base URI is the location of the catalog file// meaningless in XML// Parse all the subordinate catalogs// Parse all the DELEGATE catalogs// If there's a SYSTEM entry in this catalog, use it// If there's a PUBLIC entry in this catalog, use it// If there's a DOCTYPE entry in this catalog, use it// Otherwise, look in the subordinate catalogs// If there's a DOCUMENT entry, return it// If there's a ENTITY entry in this catalog, use it// If there's a NOTATION entry in this catalog, use it// Always normalize the public identifier before attempting a match// If there's a DELEGATE_PUBLIC entry in this catalog, use it// delegate this match to the other catalog// Nada!// If there's a REWRITE_SYSTEM entry in this catalog, use it// Is this the longest prefix?// return the systemId with the new prefix// If there's a SYSTEM_SUFFIX entry in this catalog, use it// return the systemId for the suffix// If there's a DELEGATE_SYSTEM entry in this catalog, use it// If there's a URI entry in this catalog, use it// If there's a REWRITE_URI entry in this catalog, use it// return the uri with the new prefix// If there's a URI_SUFFIX entry in this catalog, use it// return the uri for the suffix// If there's a DELEGATE_URI entry in this catalog, use it// Ok, now what are we supposed to call here?// this can't happen// ctrl// high ascii// "// <// >// \// `// |// we already have this prefix// now insert partial into the vector at [pos]/** Represents a Catalog entry. ... */new ConcurrentHashMap<String,Integer>(...)AtomicInteger nextEntry;/** The nextEntry is the ordinal number of the next entry type. */Map<String,Integer> entryTypes;/** The entryTypes vector maps catalog entry names ... */Vector<> entryArgs;/** The entryTypes vector maps catalog entry types to the ... *//** Adds a new catalog entry type. ... *//** Lookup an entry type ... */Integer iTypeCatalogException.INVALID_ENTRY_TYPE/** Find out how many arguments an entry is required to have. ... */getEntryArgCount(...)Integer iArgsint entryType;/** The entry type of this entry */Vector<> args;/** The arguments associated with this entry *//** Null constructor; something for subclasses to call. *//** Construct a catalog entry of the specified type. ... */CatalogException.INVALID_ENTRY/** Get the entry type. ... *//** Get an entry argument. ... *//** Set an entry argument. ... */// CatalogEntry.java - Represents Catalog entries/** Signal Catalog exception. ... */int WRAPPER;/** A wrapper around another exception */int INVALID_ENTRY;/** An invalid entry */int INVALID_ENTRY_TYPE;/** An invalid entry type */int NO_XML_PARSER;/** Could not instantiate an XML parser */int UNKNOWN_FORMAT;/** Unknown XML format */int UNPARSEABLE;/** Unparseable XML catalog (not XML) */int PARSE_FAILED;/** XML but parse failed */int UNENDED_COMMENT;/** Text catalog ended in mid-comment *//** The embedded exception if tunnelling, or null. */int exceptionType;/** Create a new CatalogException. ... */this.exceptionType/** Create a new CatalogException wrapping an existing exception. ... *//** Create a new CatalogException from an existing exception. ... *//** Return a detail message for this exception. ... *//** Return the embedded exception, if any. ... *//** Return the exception type ... *//** Override toString to pick up any embedded exception. ... */// CatalogException.java - Catalog exception/* Copyright 2001-2004 The Apache Software Foundation or its licensors, ... */import BootstrapResolverimport Debug/** CatalogManager provides an interface to the catalog properties. ... */new BootstrapResolver(...)String pFiles;String pVerbosity;String pPrefer;String pStatic;String pAllowPI;String pClassname;String pIgnoreMissing;CatalogManager staticManager;/** A static CatalogManager instance for sharing */BootstrapResolver bResolver;/** The bootstrap resolver to use when loading XML Catalogs. */boolean ignoreMissingProperties;/** Flag to ignore missing property files and/or properties *//** Holds the resources after they are loaded from the file. */String propertyFile;/** The name of the CatalogManager properties file. */URL propertyFileURI;/** The location of the propertyFile */String defaultCatalogFiles;/** Default catalog files list. */String catalogFiles;/** Current catalog files list. */boolean fromPropertiesFile;/** Did the catalogFiles come from the properties file? */int defaultVerbosity;/** Default verbosity level if there is no property setting for it. */Integer verbosity;/** Current verbosity level. */boolean defaultPreferPublic;/** Default preference setting. */Boolean preferPublic;/** Current preference setting. */boolean defaultUseStaticCatalog;/** Default setting of the static catalog flag. */Boolean useStaticCatalog;/** Current setting of the static catalog flag. */Catalog staticCatalog;/** The static catalog used by this manager. */boolean defaultOasisXMLCatalogPI;/** Default setting of the oasisXMLCatalogPI flag. */Boolean oasisXMLCatalogPI;/** Current setting of the oasisXMLCatalogPI flag. */boolean defaultRelativeCatalogs;/** Default setting of the relativeCatalogs flag. */Boolean relativeCatalogs;/** Current setting of the relativeCatalogs flag. */String catalogClassName;/** Current catalog class name. */boolean overrideDefaultParser;/** Indicates whether implementation parts should use ... */Debug debug;/** The manager's debug object. Used for printing debugging messages. ... *//** Constructor that specifies an explicit property file. */this.propertyFilenew Debug(...)/** Set the bootstrap resolver. *//** Get the bootstrap resolver. *//** Load the properties from the propertyFile and build the ... */CatalogManager.classString verbStrint verb/** Allow access to the static CatalogManager *//** How are missing properties handled? ... *//** How should missing properties be handled? ... *//** Obtain the verbosity setting from the properties. ... */String defaultVerbStrreadProperties(...)/** What is the current verbosity? */queryVerbosity(...)/** Set the current verbosity. */this.verbosity/** What is the current verbosity? ... */getVerbosity(...)/** Obtain the relativeCatalogs setting from the properties. ... */String allow/** Get the relativeCatalogs setting. ... */queryRelativeCatalogs(...)/** Set the relativeCatalogs setting. ... */getRelativeCatalogs(...)/** Obtain the list of catalog files from the properties. ... */String catalogList/** Return the current list of catalog files. ... */StringTokenizer filesqueryCatalogFiles(...)String catalogFileURL absURIrelativeCatalogs(...)/** Set the list of catalog files. *//** Obtain the preferPublic setting from the properties. ... */String prefer/** Return the current prefer public setting. ... */queryPreferPublic(...)/** Set the prefer public setting. */this.preferPublic/** Obtain the static-catalog setting from the properties. ... */String staticCatalog/** Get the current use static catalog setting. */queryUseStaticCatalog(...)/** Set the use static catalog setting. *//** Get the current use static catalog setting. ... */getUseStaticCatalog(...)/** Get a new catalog instance. ... */Catalog catalogString catalogClassNamegetCatalogClassName(...)ClassCastException cnfesetupReaders(...)loadSystemCatalogs(...)/** Get a catalog instance. ... */getPrivateCatalog(...)/** <p>Obtain the oasisXMLCatalogPI setting from the properties.</p> ... *//** Get the current XML Catalog PI setting. */queryAllowOasisXMLCatalogPI(...)/** Set the XML Catalog PI setting *//** Get the current XML Catalog PI setting. ... */getAllowOasisXMLCatalogPI(...)/** Obtain the Catalog class name setting from the properties. *//** Get the current Catalog class name. */queryCatalogClassName(...)/** Set the Catalog class name. *//** Get the current Catalog class name. ... */// CatalogManager.java - Access CatalogManager.properties// Note that we don't setDebug() here; we do that lazily. Either the// user will set it explicitly, or we'll do it automagically if they// read from the propertyFile for some other reason. That way, there's// no attempt to read from the file before the caller has had a chance// to avoid it.// there's no reason to give this warning more than once// This is a bit of a hack. After we've successfully read the properties,// use them to set the default debug level, if the user hasn't already set// the default debug level.// nop// This is a bit of a hack. After we've successfully got the verbosity,// we have to use it to set the default debug level,// if the user hasn't already set the default debug level./** An extension to OASIS Open Catalog files, this class supports ... */int URISUFFIX;/** The URISUFFIX Catalog Entry type. ... */int SYSTEMSUFFIX;/** The SYSTEMSUFFIX Catalog Entry type. ... */int RESOLVER;/** The RESOLVER Catalog Entry type. ... */int SYSTEMREVERSE;/** The SYSTEMREVERSE Catalog Entry type. ... */resolveExternalSystem(...)Catalog.URI/** Return the applicable SYSTEM system identifier, resorting ... */Catalog.SYSTEM/** Return the applicable PUBLIC or SYSTEM identifier, resorting ... */resolveExternalPublic(...)Catalog.PUBLIC/** Query an external RFC2483 resolver for a system identifier. ... */Resolver rqueryResolver(...)/** Query an external RFC2483 resolver for a public identifier. ... *//** Query an external RFC2483 resolver. ... */InputStream iStreamString RFC2483String lineString cTypesetUseCaches(...)CatalogException cexCatalogException.UNKNOWN_FORMAT/** Append two vectors, returning the result. ... *//** Find the URNs for a given system identifier in all catalogs. ... */Vector<> resolvedVector<> subResolvedresolveAllSubordinateCatalogs(...)Vector<> localResolvedresolveLocalSystemReverse(...)appendVector(...)/** Find the URN for a given system identifier. ... */resolveAllSystemReverse(...)/** Return the applicable SYSTEM system identifiers. ... */Vector<> resolutionsVector<> subResolutionsVector<> localResolutionsresolveAllLocalSystem(...)/** Return all applicable SYSTEM system identifiers in this ... */Vector<> map/** Find the URNs for a given system identifier in the current catalog. ... *//** Search the subordinate catalogs, in order, looking for all ... */Resolver cresolveAllSystem(...)// Resolver.java - Represents an extension of OASIS Open Catalog files.// I don't care about the character set or subtype// If there are SYSTEM entries in this catalog, start with them// Then look in the subordinate catalogs// Only find one DOCTYPE resolution// Only find one DOCUMENT resolution// Only find one ENTITY resolution// Only find one NOTATION resolution// Only find one PUBLIC resolution/** A simple bootstrapping resolver. ... */String xmlCatalogXSD;/** URI of the W3C XML Schema for OASIS XML Catalog files. */String xmlCatalogRNG;/** URI of the RELAX NG Grammar for OASIS XML Catalog files. */String xmlCatalogPubId;/** Public identifier for OASIS XML Catalog files. */String xmlCatalogSysId;/** System identifier for OASIS XML Catalog files. */Map<String,String> publicMap;/** Private hash used for public identifiers. */Map<String,String> systemMap;/** Private hash used for system identifiers. */Map<String,String> uriMap;/** Private hash used for URIs. *//** SAX resolveEntity API. */InputSource iSource/** Transformer resolve API. */String fragmentint hashPosSAXSource sourceURL baseURLString absBase/** Attempt to construct an absolute URI */URL fileURLMalformedURLException mue2// BootstrapResolver.java - Resolve entities and URIs internally// Ideally this method would not attempt to open the// InputStream, but there is a bug (in Xerces, at least)// that causes the parser to mistakenly open the wrong// system identifier if the returned InputSource does// not have a byteStream.// It could be argued that we still shouldn't do this here,// but since the purpose of calling the entityResolver is// almost certainly to open the input stream, it seems to// do little harm.// FIXME: silently fail?// try to make an absolute URI from the current base// don't bother if the absBase isn't different!// bail/** Static debugging/messaging class for Catalogs. ... */int debug;/** The internal debug level. *//** Set the debug level for future messages. *//** Get the current debug level. *//** Print debug message (if the debug level is high enough). ... */// Debug.java - Print debug messages/** Static method for dealing with file: URLs. ... *//** Construct a file: URL for a path name. ... */// FileURL.java - Construct a file: scheme URL/* if (pathname.startsWith("/")) { ... *//** Static Namespace query methods. ... *//** Returns the "prefix" part of a QName or the empty string (not ... *//** Returns the "localname" part of a QName, which is the whole ... *//** Returns the namespace URI for the specified prefix at the ... */String nsattr/** Returns the namespace URI for the namespace to which the ... */// Namespaces.java - Analyze namespace nodes in a DOM tree/** Static methods for dealing with public identifiers. ... *//** Normalize a public identifier. ... */String normal/** Encode a public identifier as a "publicid" URN. ... */String urnstringReplace(...)/** Decode a "publicid" URN into a public identifier. ... *//** Replace one string with another. */// PublicId.java - Information about public identifiers//    System.out.println(str + ": " + oldStr + " => " + newStr);//      System.out.println(str + " (" + pos + ")");import CatalogException/** The CatalogReader interface. ... *//** Read a catalog from a file. ... *//** Read a catalog from an input stream. ... */// CatalogReader.java - An interface for reading catalog files/** The DOMCatalogParser interface. ... *//** Parse a DOM node as a catalog entry. ... */// DOMCatalogParser.java - An interface for reading catalog filesimport Namespaces/** A DOM-based CatalogReader. ... */Map<String,String> namespaceMap;/** Mapping table from QNames to CatalogParser classes. ... *//** Add a new parser to the reader. ... *//** Get the name of the parser class for a given catalog type. ... */String domParserClassgetCatalogParser(...)DOMCatalogParser domParsergetCatalogManager(...).debugparseCatalogEntry(...)/** Read the catalog behind the specified URL. ... */// DOMCatalogReader.java - Read XML Catalog filesimport CatalogEntry/** Parse Extended OASIS Entity Resolution Technical Committee ... */String extendedNamespaceName;/** The namespace name of extended catalog elements *//** The SAX <code>startElement</code> method recognizes elements ... */boolean inExtensioninExtensionNamespace(...)int entryTypeVector<> entryArgsCatalog.BASECatalogEntry cenew CatalogEntry(...)Resolver.URISUFFIXResolver.SYSTEMSUFFIX/** The SAX <code>endElement</code> method does nothing. */String popURIcatalog.BASE// ExtendedXMLCatalogReader.java - Read XML Catalog files// Check before calling the super because super will report our// namespace as an extension namespace, but that doesn't count// for this element.// This is an Extended XML Catalog entry// This is equivalent to an invalid catalog entry type// Check after popping the stack so we don't erroneously think we// are our own extension namespace.../** Parse OASIS Entity Resolution Technical Committee ... */Catalog catalog;/** The catalog object needs to be stored by the object so that ... */String namespaceName;/** The namespace name of OASIS ERTC catalogs */String tr9401NamespaceName;/** The namespace name of OASIS ERTC TR9401 catalog extension */Stack<> baseURIStack;Stack<> overrideStack;Stack<> namespaceStack;/** Set the current catalog. */this.catalog/** Get the current catalog. *//** Are we in an extension namespace? ... */Enumeration<> elements/** The SAX <code>setDocumentLocator</code> method does nothing. */// Implement the SAX ContentHandler interface/** The SAX <code>startDocument</code> method does nothing. */getCurrentBase(...)getDefaultOverride(...)/** The SAX <code>endDocument</code> method does nothing. */String overrideCatalog.OVERRIDECatalog.DELEGATE_PUBLICCatalog.DELEGATE_SYSTEMCatalog.DELEGATE_URICatalog.REWRITE_SYSTEMCatalog.SYSTEM_SUFFIXCatalog.REWRITE_URICatalog.URI_SUFFIXCatalog.CATALOGcatalog.DOCTYPEcatalog.DOCUMENTcatalog.DTDDECLCatalog.ENTITYCatalog.LINKTYPECatalog.NOTATIONCatalog.SGMLDECLString popOverridecatalog.OVERRIDE/** The SAX <code>characters</code> method does nothing. *//** The SAX <code>ignorableWhitespace</code> method does nothing. *//** The SAX <code>processingInstruction</code> method does nothing. *//** The SAX <code>skippedEntity</code> method does nothing. *//** The SAX <code>startPrefixMapping</code> method does nothing. *//** The SAX <code>endPrefixMapping</code> method does nothing. */// OASISXMLCatalogReader.java - Read XML Catalog files// This is an XML Catalog entry// nop, start of catalog// nop, a group// This is a TR9401 Catalog entry/** The SAXCatalogParser interface. ... *//** Set the Catalog for which parsing is being performed. */// SAXCatalogParser.java - An interface for reading catalog files/** A SAX-based CatalogReader. ... */getStaticManager(...).debugSAXParserFactory parserFactory;/** The SAX Parser Factory */String parserClass;/** The SAX Parser Class */SAXCatalogParser saxParser;/** The parser in use for the current catalog. */boolean abandonHope;/** Set if something goes horribly wrong. It allows the class to ... *//** The Catalog that we're working for. *//** Set the XML SAX Parser Factory. */this.parserFactory/** Set the XML SAX Parser Class */this.parserClass/** Get the parser factory currently in use. *//** Get the parser class currently in use. *//** The debug class to use for this reader. ... *//** The constructor *//** Set the SAXCatalogParser class for the given namespace/root ... *//** Get the SAXCatalogParser class for the given namespace/root ... *//** Parse an XML Catalog file. ... *//** Parse an XML Catalog stream. ... */EntityResolver bResolvergetBootstrapResolver(...)SAXParserHandler spHandlernew SAXParserHandler(...)UnknownHostException uhenew UnknownHostException(...)/** The SAX <code>setDocumentLocator</code> method. Does nothing. *//** The SAX <code>startDocument</code> method. Does nothing. *//** The SAX <code>endDocument</code> method. Does nothing. *//** The SAX <code>startElement</code> method. ... */String saxParserClasssetCatalog(...)/** The SAX2 <code>startElement</code> method. ... *//** The SAX <code>endElement</code> method. Does nothing. *//** The SAX2 <code>endElement</code> method. Does nothing. *//** The SAX <code>characters</code> method. Does nothing. *//** The SAX <code>ignorableWhitespace</code> method. Does nothing. *//** The SAX <code>processingInstruction</code> method. Does nothing. *//** The SAX <code>startPrefixMapping</code> method. Does nothing. *//** The SAX <code>endPrefixMapping</code> method. Does nothing. *//** The SAX <code>skippedentity</code> method. Does nothing. */// SAXCatalogReader.java - Read XML Catalog files// Create an instance of the parser// FIXME: there must be a better wayimport org.xml.sax.helpers.*/** An entity-resolving DefaultHandler. ... */EntityResolver er;ContentHandler ch;this.er// Entity Resolver// Content Handler// SAXParserHandler.java - An entity-resolving DefaultHandler/** Parses OASIS Open Catalog files. ... *//** Start parsing an OASIS TR9401 Open Catalog file. The file is ... */Vector<> unknownEntryString entryTokenunknownEntry(...)int numArgsVector<> argsCatalogException.UNENDED_COMMENTCatalogException cex2// TR9401CatalogReader.java - Read OASIS Catalog files/** Parses plain text Catalog files. ... */InputStream catfile;/** The input stream used to read the catalog */...[] stack;/** Character lookahead stack. Reading a catalog sometimes requires ... */Stack<> tokenStack;/** Token stack. Recognizing an unexpected catalog entry requires ... *//** The current position on the lookahead stack */boolean caseSensitive;/** Are keywords in the catalog case sensitive? *//** Construct a CatalogReader object. *//** Start parsing a text catalog file. The file is ... */URL catURL/** The destructor. ... *//** Return the next token in the catalog file. ... */int nextchnextChar(...)char[] chararr/** Return the next logical character from the input stream. ... */// TextCatalogReader.java - Read text/plain Catalog files// whatever...// Skip over leading whitespace and comments// all ctrls are whitespace// now 'ch' is the current char from the file// we've found a comment, skip it...// Ok, we've found the end of the comment,// loop back to the top and start again...// return the next whitespace or comment delimited/** Parse "xcatalog" XML Catalog files, this is the XML Catalog format ... */// Implement the SAX DocumentHandler interfacecatalog.DELEGATE_PUBLICcatalog.CATALOGcatalog.PUBLICcatalog.SYSTEM// XCatalogReader.java - Read XML Catalog files/** A SAX EntityResolver/JAXP URIResolver that uses catalogs. ... */boolean namespaceAware;/** Make the parser Namespace aware? */boolean validating;/** Make the parser validating? *//** The underlying catalog *//** The catalog manager */initializeCatalogs(...)/** Initialize catalog */getCatalog(...)/** Return the underlying catalog *//** Implements the guts of the <code>resolveEntity</code> method ... *//** Implements the <code>resolveEntity</code> method ... */getResolvedEntity(...)/** JAXP URIResolver API *//** <p>Establish an entityResolver for newly resolved URIs.</p> ... */// CatalogResolver.java - A SAX EntityResolver/JAXP URI Resolver/** A SAX Parser that performs catalog-based entity resolution. ... */boolean suppressExplanation;/** Suppress explanatory message? ... */SAXParser saxParser;/** The underlying parser. *//** The underlying reader. */DocumentHandler documentHandler;/** The underlying DocumentHandler. */DTDHandler dtdHandler;/** The underlying DTDHandler. *//** The manager for the underlying resolver. */CatalogResolver catalogResolver;/** The underlying catalog resolver. */CatalogResolver piCatalogResolver;/** A separate resolver for oasis-xml-pi catalogs. */boolean allowXMLCatalogPI;/** Are we in the prolog? Is an oasis-xml-catalog PI valid now? */boolean oasisXMLCatalogPI;/** Has an oasis-xml-catalog PI been seen? */URL baseURL;/** The base URI of the input document, if known. */initParser(...)/** Initialize the parser. */new CatalogResolver(...)/** Return the Catalog being used. *//** SAX Parser API. ... */setupParse(...)explain(...)/** SAX Parser API. *//** SAX DocumentHandler API. */URL catalogString quote/** SAX DTDHandler API. *//** Setup for parsing. */URL cwd/** Provide one possible explanation for an InternalError. */// ResolvingParser.java - An interface for reading catalog files// nevermind// give up/** A SAX XMLFilter that performs catalog-based entity resolution. ... *//** Construct an empty XML Filter with no parent. *//** Construct an XML filter with the specified parent. *//** Provide accessto the underlying Catalog. *//** SAX XMLReader API. ... */setupBaseURI(...)/** SAX DTDHandler API. ... *//** SAX ContentHandler API. ... *//** Save the base URI of the document being parsed. */// ResolvingXMLFilter.java - An XMLFilter that performs catalog resolutionimport com.sun.org.apache.xml.internal.resolver.*/** A SAX XMLReader that performs catalog-based entity resolution. ... *//** Construct a new reader from the JAXP factory. ... */// ResolvingXMLReader.java - An XMLReader that performs catalog resolutionimport JCEMapperimport SignatureAlgorithmimport Canonicalizerimport XMLSecurityExceptionimport KeyResolverimport Transformimport ElementProxyimport I18nimport XMLUtilsimport ResourceResolver/** This class does the configuration of the library. This includes creating ... */Init.classString CONF_NS;/** The namespace for CONF file * */Logger LOG;boolean alreadyInitialized;/** Field alreadyInitialized *//** Method isInitialized ... */Init.alreadyInitialized/** Method init */...->...String cfiledynamicInit(...)fileInit(...)/** Dynamically initialise the library by registering the default algorithms/implementations */Init$1registerDefaultPrefixes(...)registerDefaultAlgorithms(...)registerDefaultResolvers(...)PrivilegedActionException exXMLSecurityException xse/** Initialise the library from a configuration file */createDocumentBuilder(...)Node configNode elString tagElement resourceAttr langAttrAttr countryAttrString languageCodeString countryCodeElement[] listselectNodes(...)String javaClassObject[] exArgsElement[] tranElemNoClassDefFoundError exwarn(...)Node algorithmsNodeElement[] algorithmsnew Algorithm(...)JCEMapper.AlgorithmElement[] sigElemsElement sigElemElement[] resolverElemList<String> classNamesresolverElem.lengthregisterClassNames(...)Element[] nlsetDefaultPrefix(...)/** Licensed to the Apache Software Foundation (ASF) under one ... */// Load the Resource Bundle - the default is the English resource bundle.// To load another resource bundle, call I18n.init(...) before calling this// Bind the default prefixes// Set the default Transforms// Set the default signature algorithms// Set the default JCE algorithms// Set the default c14n algorithms// Register the default resolvers// Register the default key resolvers/* read library configuration file *//* configure internationalization *//** $todo$ handle registering */import SignatureElementProxy/** The Algorithm class which stores the Algorithm URI as a string. */setAlgorithmURI(...)/** Constructor Algorithm ... *//** Method getAlgorithmURI ... */getLocalAttribute(...)Constants._ATT_ALGORITHM/** Sets the algorithm's URI as used in the signature. ... */setLocalAttribute(...)// changes to utils.ClassLoaderUtils to this file.// modifiers changed to package-private. Make sure to integrate any future// NOTE! This is a duplicate of utils.ClassLoaderUtils with publicClassLoaderUtils.class/** Load a class with a given name. <p></p> It will try to load the class in the ... */loadClass2(...)//ignoreimport XMLSignatureimport JavaUtils/** This class maps algorithm identifier URIs to JAVA JCE class names. */JCEMapper.classnew ConcurrentHashMap<String,Algorithm>(...)Map<String,Algorithm> algorithmsMap;String providerName;/** Method register ... */checkRegisterPermission(...)/** This method registers the default algorithms. */MessageDigestAlgorithm.ALGO_ID_DIGEST_NOT_RECOMMENDED_MD5MessageDigestAlgorithm.ALGO_ID_DIGEST_RIPEMD160MessageDigestAlgorithm.ALGO_ID_DIGEST_SHA1MessageDigestAlgorithm.ALGO_ID_DIGEST_SHA224MessageDigestAlgorithm.ALGO_ID_DIGEST_SHA256MessageDigestAlgorithm.ALGO_ID_DIGEST_SHA384MessageDigestAlgorithm.ALGO_ID_DIGEST_SHA512MessageDigestAlgorithm.ALGO_ID_DIGEST_WHIRLPOOLMessageDigestAlgorithm.ALGO_ID_DIGEST_SHA3_224MessageDigestAlgorithm.ALGO_ID_DIGEST_SHA3_256MessageDigestAlgorithm.ALGO_ID_DIGEST_SHA3_384MessageDigestAlgorithm.ALGO_ID_DIGEST_SHA3_512XMLSignature.ALGO_ID_SIGNATURE_DSAXMLSignature.ALGO_ID_SIGNATURE_DSA_SHA256XMLSignature.ALGO_ID_SIGNATURE_NOT_RECOMMENDED_RSA_MD5XMLSignature.ALGO_ID_SIGNATURE_RSA_RIPEMD160XMLSignature.ALGO_ID_SIGNATURE_RSA_SHA1XMLSignature.ALGO_ID_SIGNATURE_RSA_SHA224XMLSignature.ALGO_ID_SIGNATURE_RSA_SHA256XMLSignature.ALGO_ID_SIGNATURE_RSA_SHA384XMLSignature.ALGO_ID_SIGNATURE_RSA_SHA512XMLSignature.ALGO_ID_SIGNATURE_RSA_SHA1_MGF1XMLSignature.ALGO_ID_SIGNATURE_RSA_SHA224_MGF1XMLSignature.ALGO_ID_SIGNATURE_RSA_SHA256_MGF1XMLSignature.ALGO_ID_SIGNATURE_RSA_SHA384_MGF1XMLSignature.ALGO_ID_SIGNATURE_RSA_SHA512_MGF1XMLSignature.ALGO_ID_SIGNATURE_RSA_SHA3_224_MGF1XMLSignature.ALGO_ID_SIGNATURE_RSA_SHA3_256_MGF1XMLSignature.ALGO_ID_SIGNATURE_RSA_SHA3_384_MGF1XMLSignature.ALGO_ID_SIGNATURE_RSA_SHA3_512_MGF1XMLSignature.ALGO_ID_SIGNATURE_ECDSA_SHA1XMLSignature.ALGO_ID_SIGNATURE_ECDSA_SHA224XMLSignature.ALGO_ID_SIGNATURE_ECDSA_SHA256XMLSignature.ALGO_ID_SIGNATURE_ECDSA_SHA384XMLSignature.ALGO_ID_SIGNATURE_ECDSA_SHA512XMLSignature.ALGO_ID_SIGNATURE_ECDSA_RIPEMD160XMLSignature.ALGO_ID_MAC_HMAC_NOT_RECOMMENDED_MD5XMLSignature.ALGO_ID_MAC_HMAC_RIPEMD160XMLSignature.ALGO_ID_MAC_HMAC_SHA1XMLSignature.ALGO_ID_MAC_HMAC_SHA224XMLSignature.ALGO_ID_MAC_HMAC_SHA256XMLSignature.ALGO_ID_MAC_HMAC_SHA384XMLSignature.ALGO_ID_MAC_HMAC_SHA512/** Method translateURItoJCEID ... */Algorithm algorithmgetAlgorithm(...)algorithm.jceName/** Method getAlgorithmClassFromURI ... */algorithm.algorithmClass/** Returns the keylength in bits for a particular algorithm. ... */algorithm.keyLengthalgorithm.ivLength/** Method getJCEKeyAlgorithmFromURI ... */algorithm.requiredKey/** Method getJCEProviderFromURI ... */algorithm.jceProvider/** Method getAlgorithm ... *//** Gets the default Provider for obtaining the security algorithms ... *//** Sets the default Provider for obtaining the security algorithms ... */JCEMapper$Algorithm/** Represents the Algorithm xml element */String requiredKey;String jceName;String algorithmClass;int keyLength;int ivLength;String jceProvider;/** Gets data from element ... */this.requiredKeythis.jceNamethis.algorithmClassthis.keyLengththis.ivLengththis.jceProvider// Digest algorithms// Signature algorithmsimport NoSuchProviderExceptionimport XMLSignatureExceptionimport EncryptionConstants/** Digest Message wrapper and selector class. ... */Constants.MoreAlgorithmsSpecNSConstants.SignatureSpecNSEncryptionConstants.EncryptionSpecNSConstants.XML_DSIG_NS_MORE_07_05String ALGO_ID_DIGEST_NOT_RECOMMENDED_MD5;/** Message Digest - NOT RECOMMENDED MD5 */String ALGO_ID_DIGEST_SHA1;/** Digest - Required SHA1 */String ALGO_ID_DIGEST_SHA224;/** Message Digest - OPTIONAL SHA224 */String ALGO_ID_DIGEST_SHA256;/** Message Digest - RECOMMENDED SHA256 */String ALGO_ID_DIGEST_SHA384;/** Message Digest - OPTIONAL SHA384 */String ALGO_ID_DIGEST_SHA512;/** Message Digest - OPTIONAL SHA512 */String ALGO_ID_DIGEST_RIPEMD160;/** Message Digest - OPTIONAL RIPEMD-160 */String ALGO_ID_DIGEST_WHIRLPOOL;// Newer digest algorithms...all optionalString ALGO_ID_DIGEST_SHA3_224;String ALGO_ID_DIGEST_SHA3_256;String ALGO_ID_DIGEST_SHA3_384;String ALGO_ID_DIGEST_SHA3_512;MessageDigest algorithm;/** Field algorithm stores the actual {@link java.security.MessageDigest} *//** Constructor for the brave who pass their own message digest algorithms and the ... */getDigestInstance(...)/** Factory method for constructing a message digest algorithm by name. ... */new MessageDigestAlgorithm(...)String algorithmIDtranslateURItoJCEID(...)String providergetProviderId(...)new XMLSignatureException(...)NoSuchAlgorithmException exNoSuchProviderException ex/** Returns the actual {@link java.security.MessageDigest} algorithm object ... *//** Proxy method for {@link java.security.MessageDigest#isEqual} ... *//** Proxy method for {@link java.security.MessageDigest#digest()} ... *//** Proxy method for {@link java.security.MessageDigest#digest(byte[])} ... *//** Proxy method for {@link java.security.MessageDigest#digest(byte[], int, int)} ... *//** Proxy method for {@link java.security.MessageDigest#getAlgorithm} ... *//** Proxy method for {@link java.security.MessageDigest#getProvider} ... */getProvider(...)/** Proxy method for {@link java.security.MessageDigest#getDigestLength} ... */getDigestLength(...)/** Proxy method for {@link java.security.MessageDigest#reset} ... *//** Proxy method for {@link java.security.MessageDigest#update(byte[])} ... *//** Proxy method for {@link java.security.MessageDigest#update(byte)} ... *//** Proxy method for {@link java.security.MessageDigest#update(byte[], int, int)} ... */Constants._TAG_DIGESTMETHODimport Keyimport SecureRandomimport AlgorithmParameterSpecimport IntegrityHmacimport SignatureBaseRSAimport SignatureDSAimport SignatureECDSAimport AlgorithmAlreadyRegisteredException/** Allows selection of digital signature's algorithm, private keys, other ... */SignatureAlgorithm.classnew ConcurrentHashMap<String,Class<? extends SignatureAlgorithmSpi>>(...)Map<String,Class<? extends SignatureAlgorithmSpi>> algorithmHash;/** All available algorithm classes are registered here */SignatureAlgorithmSpi signatureAlgorithm;/** Field signatureAlgorithm */String algorithmURI;/** Constructor SignatureAlgorithm ... */this.algorithmURIgetSignatureAlgorithmSpi(...)engineGetContextFromElement(...)engineSetHMACOutputLength(...)engineAddContextToElement(...)new XMLSecurityException(...)/** Get a SignatureAlgorithmSpi object corresponding to the algorithmURI argument */Class<? extends SignatureAlgorithmSpi> implementingClassSignatureAlgorithmSpi tmp/** Proxy method for {@link java.security.Signature#sign()} ... */engineSign(...)/** Proxy method for {@link java.security.Signature#getAlgorithm} ... */engineGetJCEAlgorithmString(...)/** Method getJCEProviderName ... */engineGetJCEProviderName(...)/** Proxy method for {@link java.security.Signature#update(byte[])} ... */engineUpdate(...)/** Proxy method for {@link java.security.Signature#update(byte)} ... *//** Proxy method for {@link java.security.Signature#update(byte[], int, int)} ... *//** Proxy method for {@link java.security.Signature#initSign(java.security.PrivateKey)} ... */engineInitSign(...)/** Proxy method for {@link java.security.Signature#initSign(java.security.PrivateKey, ... *//** Proxy method for {@link java.security.Signature#setParameter( ... */engineSetParameter(...)/** Proxy method for {@link java.security.Signature#initVerify(java.security.PublicKey)} ... */engineInitVerify(...)/** Proxy method for {@link java.security.Signature#verify(byte[])} ... */engineVerify(...)/** Returns the URI representation of Transformation algorithm ... *//** Registers implementing class of the SignatureAlgorithm with algorithmURI ... */Class<? extends SignatureAlgorithmSpi> registeredClassnew AlgorithmAlreadyRegisteredException(...)Class<? extends SignatureAlgorithmSpi> clazzNullPointerException exSignatureDSA.classSignatureDSA.SHA256.classSignatureDSA.SHA256SignatureBaseRSA.SignatureRSASHA1.classSignatureBaseRSA.SignatureRSASHA1IntegrityHmac.IntegrityHmacSHA1.classIntegrityHmac.IntegrityHmacSHA1SignatureBaseRSA.SignatureRSAMD5.classSignatureBaseRSA.SignatureRSAMD5SignatureBaseRSA.SignatureRSARIPEMD160.classSignatureBaseRSA.SignatureRSARIPEMD160SignatureBaseRSA.SignatureRSASHA224.classSignatureBaseRSA.SignatureRSASHA224SignatureBaseRSA.SignatureRSASHA256.classSignatureBaseRSA.SignatureRSASHA256SignatureBaseRSA.SignatureRSASHA384.classSignatureBaseRSA.SignatureRSASHA384SignatureBaseRSA.SignatureRSASHA512.classSignatureBaseRSA.SignatureRSASHA512SignatureBaseRSA.SignatureRSASHA1MGF1.classSignatureBaseRSA.SignatureRSASHA1MGF1SignatureBaseRSA.SignatureRSASHA224MGF1.classSignatureBaseRSA.SignatureRSASHA224MGF1SignatureBaseRSA.SignatureRSASHA256MGF1.classSignatureBaseRSA.SignatureRSASHA256MGF1SignatureBaseRSA.SignatureRSASHA384MGF1.classSignatureBaseRSA.SignatureRSASHA384MGF1SignatureBaseRSA.SignatureRSASHA512MGF1.classSignatureBaseRSA.SignatureRSASHA512MGF1SignatureBaseRSA.SignatureRSASHA3_224MGF1.classSignatureBaseRSA.SignatureRSASHA3_224MGF1SignatureBaseRSA.SignatureRSASHA3_256MGF1.classSignatureBaseRSA.SignatureRSASHA3_256MGF1SignatureBaseRSA.SignatureRSASHA3_384MGF1.classSignatureBaseRSA.SignatureRSASHA3_384MGF1SignatureBaseRSA.SignatureRSASHA3_512MGF1.classSignatureBaseRSA.SignatureRSASHA3_512MGF1SignatureECDSA.SignatureECDSASHA1.classSignatureECDSA.SignatureECDSASHA1SignatureECDSA.SignatureECDSASHA224.classSignatureECDSA.SignatureECDSASHA224SignatureECDSA.SignatureECDSASHA256.classSignatureECDSA.SignatureECDSASHA256SignatureECDSA.SignatureECDSASHA384.classSignatureECDSA.SignatureECDSASHA384SignatureECDSA.SignatureECDSASHA512.classSignatureECDSA.SignatureECDSASHA512SignatureECDSA.SignatureECDSARIPEMD160.classSignatureECDSA.SignatureECDSARIPEMD160IntegrityHmac.IntegrityHmacMD5.classIntegrityHmac.IntegrityHmacMD5IntegrityHmac.IntegrityHmacRIPEMD160.classIntegrityHmac.IntegrityHmacRIPEMD160IntegrityHmac.IntegrityHmacSHA224.classIntegrityHmac.IntegrityHmacSHA224IntegrityHmac.IntegrityHmacSHA256.classIntegrityHmac.IntegrityHmacSHA256IntegrityHmac.IntegrityHmacSHA384.classIntegrityHmac.IntegrityHmacSHA384IntegrityHmac.IntegrityHmacSHA512.classIntegrityHmac.IntegrityHmacSHA512/** Method getBaseNamespace ... *//** Method getBaseLocalName ... */Constants._TAG_SIGNATUREMETHOD// are we already registered?/** Returns the URI representation of {@code Transformation algorithm} ... *//** Method engineGetJCEProviderName ... *//** Proxy method for {@link javax.crypto.Mac} ... *//** Method engineInitVerify ... *//** Method engineGetContextFromElement ... *//** Method engineSetHMACOutputLength ... */import ECPublicKeyimport java.security.spec.*new ArrayList<ECCurveDefinition>(...)new ECCurveDefinition(...)/** Converts an ASN.1 ECDSA value to a XML Signature ECDSA Value. ... */byte rLengthbyte sLengthint rawLenbyte[] xmldsigBytesasn1Bytes.length/** Converts a XML Signature ECDSA Value to an ASN.1 DSA value. ... */xmldsigBytes.lengthbyte[] asn1BytesList<ECCurveDefinition> ecCurveDefinitions;ECParameterSpec ecParameterSpecBigInteger ordergetOrder(...)BigInteger affineXgetAffineX(...)getGenerator(...)BigInteger affineYgetAffineY(...)BigInteger agetA(...)getCurve(...)BigInteger bgetB(...)getCofactor(...)ECField ecFieldBigInteger fieldIterator<ECCurveDefinition> ecCurveDefinitionIteratorECFieldFp ecFieldFpgetP(...)ECFieldF2m ecFieldF2mgetReductionPolynomial(...)ECCurveDefinition ecCurveDefinitionString oidECDSAUtils$ECCurveDefinitionString field;String a;String b;String x;String y;String n;int h;/** returns the ec oid if parameter are equal to this definition */byte[] affineXBytesstripLeadingZeros(...)byte[] affineYBytesbyte[] encodedBytesaffineXBytes.lengthaffineYBytes.lengthencodedBytes.lengthnew ECPoint(...)byte[] strippedstripped.length// complete//NOPMD//uncompressedimport InvalidAlgorithmParameterExceptionimport InvalidKeyExceptionimport Macimport SecretKeyimport MessageDigestAlgorithmimport SignatureAlgorithmSpiIntegrityHmac.classMac macAlgorithm;/** Field macAlgorithm */int HMACOutputLength;/** Field HMACOutputLength */boolean HMACOutputLengthSet;/** Method engineGetURI ... *//** Returns the output length of the hash/digest. *//** Method IntegrityHmac ... */engineGetURI(...)this.macAlgorithmthis.HMACOutputLengthSetthis.HMACOutputLengthbyte[] completeResultdoFinal(...)IllegalStateException exString suppliedString neededSecretKey.classInvalidKeyException exMac mac/** Method engineInitSign ... */InvalidAlgorithmParameterException ex/** Method engineGetJCEAlgorithmString ... */selectDsNode(...)Constants._TAG_HMACOUTPUTLENGTHString hmacLengthgetFullTextChildrenFromNode(...)/** Method engineAddContextToElement ... */Element HMElemcreateElementInSignatureSpace(...)Text HMTextaddReturnToElement(...)IntegrityHmac$IntegrityHmacSHA1/** Class IntegrityHmacSHA1 *//** Constructor IntegrityHmacSHA1 ... */IntegrityHmac$IntegrityHmacSHA224/** Class IntegrityHmacSHA224 *//** Constructor IntegrityHmacSHA224 ... */IntegrityHmac$IntegrityHmacSHA256/** Class IntegrityHmacSHA256 *//** Constructor IntegrityHmacSHA256 ... */IntegrityHmac$IntegrityHmacSHA384/** Class IntegrityHmacSHA384 *//** Constructor IntegrityHmacSHA384 ... */IntegrityHmac$IntegrityHmacSHA512/** Class IntegrityHmacSHA512 *//** Constructor IntegrityHmacSHA512 ... */IntegrityHmac$IntegrityHmacRIPEMD160/** Class IntegrityHmacRIPEMD160 *//** Constructor IntegrityHmacRIPEMD160 ... */IntegrityHmac$IntegrityHmacMD5/** Class IntegrityHmacMD5 *//** Constructor IntegrityHmacMD5 ... */// reinstantiate Mac object to work around bug in JDK// see: http://bugs.java.com/view_bug.do?bug_id=4953555// this shouldn't occur, but if it does, restore previous Macimport PrivateKeyimport PublicKeyimport Signatureimport SignatureExceptionSignatureBaseRSA.classSignature signatureAlgorithm;/** Field algorithm *//** Constructor SignatureRSA ... */this.signatureAlgorithmSignatureException exPublicKey.classinitVerify(...)Signature sigsign(...)PrivateKey.classinitSign(...)/** Class SignatureRSASHA1 *//** Constructor SignatureRSASHA1 ... *//** Class SignatureRSASHA224 *//** Constructor SignatureRSASHA224 ... *//** Class SignatureRSASHA256 *//** Constructor SignatureRSASHA256 ... *//** Class SignatureRSASHA384 *//** Constructor SignatureRSASHA384 ... *//** Class SignatureRSASHA512 *//** Constructor SignatureRSASHA512 ... *//** Class SignatureRSARIPEMD160 *//** Constructor SignatureRSARIPEMD160 ... *//** Class SignatureRSAMD5 *//** Constructor SignatureRSAMD5 ... *//** Class SignatureRSASHA1MGF1 *//** Constructor SignatureRSASHA1MGF1 ... *//** Class SignatureRSASHA224MGF1 *//** Constructor SignatureRSASHA224MGF1 ... *//** Class SignatureRSASHA256MGF1 *//** Constructor SignatureRSASHA256MGF1 ... *//** Class SignatureRSASHA384MGF1 *//** Constructor SignatureRSASHA384MGF1 ... *//** Class SignatureRSASHA512MGF1 *//** Constructor SignatureRSASHA512MGF1 ... *//** Class SignatureRSA3_SHA224MGF1 *//** Constructor SignatureRSASHA3_224MGF1 ... *//** Class SignatureRSA3_SHA256MGF1 *//** Constructor SignatureRSASHA3_256MGF1 ... *//** Class SignatureRSA3_SHA384MGF1 *//** Constructor SignatureRSASHA3_384MGF1 ... *//** Class SignatureRSASHA3_512MGF1 *//** Constructor SignatureRSASHA3_512MGF1 ... */// reinstantiate Signature object to work around bug in JDK// this shouldn't occur, but if it does, restore previousimport DSAKeyString URI;/** size of Q *//** Constructor SignatureDSA ... */byte[] jcebytesconvertDsaXMLDSIGtoASN1(...)encodeToString(...)bitLength(...)getQ(...)convertDsaASN1toXMLDSIG(...)SignatureECDSA.classconvertASN1toXMLDSIG(...)convertXMLDSIGtoASN1(...)/** Class SignatureECDSASHA1 *//** Constructor SignatureECDSASHA1 ... *//** Class SignatureECDSASHA224 *//** Constructor SignatureECDSASHA224 ... *//** Class SignatureECDSASHA256 *//** Constructor SignatureECDSASHA256 ... *//** Class SignatureECDSASHA384 *//** Constructor SignatureECDSASHA384 ... *//** Class SignatureECDSASHA512 *//** Constructor SignatureECDSASHA512 ... *//** Class SignatureECDSARIPEMD160 *//** Constructor SignatureECDSARIPEMD160 ... *//** Class CanonicalizationException *//** Constructor CanonicalizationException *//** Constructor CanonicalizationException ... */import StandardCharsetsimport Canonicalizer11_OmitCommentsimport Canonicalizer11_WithCommentsimport Canonicalizer20010315ExclOmitCommentsimport Canonicalizer20010315ExclWithCommentsimport Canonicalizer20010315OmitCommentsimport Canonicalizer20010315WithCommentsimport CanonicalizerPhysicalStandardCharsets.UTF_8new ConcurrentHashMap<String,Class<? extends CanonicalizerSpi>>(...)/** The output encoding of canonicalized data */String XPATH_C14N_WITH_COMMENTS_SINGLE_NODE;/** XPath Expression for selecting every node and continuous comments joined ... */String ALGO_ID_C14N_OMIT_COMMENTS;/** The URL defined in XML-SEC Rec for inclusive c14n <b>without</b> comments. */String ALGO_ID_C14N_WITH_COMMENTS;/** The URL defined in XML-SEC Rec for inclusive c14n <b>with</b> comments. */String ALGO_ID_C14N_EXCL_OMIT_COMMENTS;/** The URL defined in XML-SEC Rec for exclusive c14n <b>without</b> comments. */String ALGO_ID_C14N_EXCL_WITH_COMMENTS;/** The URL defined in XML-SEC Rec for exclusive c14n <b>with</b> comments. */String ALGO_ID_C14N11_OMIT_COMMENTS;/** The URI for inclusive c14n 1.1 <b>without</b> comments. */String ALGO_ID_C14N11_WITH_COMMENTS;/** The URI for inclusive c14n 1.1 <b>with</b> comments. */String ALGO_ID_C14N_PHYSICAL;/** Non-standard algorithm to serialize the physical representation for XML Encryption */Map<String,Class<? extends CanonicalizerSpi>> canonicalizerHash;CanonicalizerSpi canonicalizerSpi;boolean secureValidation;/** Constructor Canonicalizer ... */Class<? extends CanonicalizerSpi> implementingClassCanonicalizerSpi tmpcanonicalizerSpi.resetnew InvalidCanonicalizerException(...)/** Method getInstance ... */new Canonicalizer(...)Class<? extends CanonicalizerSpi> registeredClassCanonicalizer.classCanonicalizer.ALGO_ID_C14N_OMIT_COMMENTSCanonicalizer20010315OmitComments.classCanonicalizer.ALGO_ID_C14N_WITH_COMMENTSCanonicalizer20010315WithComments.classCanonicalizer.ALGO_ID_C14N_EXCL_OMIT_COMMENTSCanonicalizer20010315ExclOmitComments.classCanonicalizer.ALGO_ID_C14N_EXCL_WITH_COMMENTSCanonicalizer20010315ExclWithComments.classCanonicalizer.ALGO_ID_C14N11_OMIT_COMMENTSCanonicalizer11_OmitComments.classCanonicalizer.ALGO_ID_C14N11_WITH_COMMENTSCanonicalizer11_WithComments.classCanonicalizer.ALGO_ID_C14N_PHYSICALCanonicalizerPhysical.class/** Method getURI ... *//** Method getIncludeComments ... */engineGetIncludeComments(...)/** This method tries to canonicalize the given bytes. It's possible to even ... */Document documentInputSource innew IgnoreAllErrorHandler(...)canonicalizeSubtree(...)/** Canonicalizes the subtree rooted by {@code node}. ... */canonicalizerSpi.secureValidationengineCanonicalizeSubTree(...)/** Canonicalizes an XPath node set. The {@code xpathNodeSet} is treated ... */engineCanonicalizeXPathNodeSet(...)/** Canonicalizes an XPath node set. ... *//** Sets the writer where the canonicalization ends.  ByteArrayOutputStream ... *//** Returns the name of the implementing {@link CanonicalizerSpi} class ... *//** Set the canonicalizer behaviour to not reset. */this.secureValidation// check whether URI is already registered// needs to validate for ID attribute normalization/* for some of the test vectors from the specification, ... *//** Base class which all Canonicalization algorithms extend. */boolean reset;/** Reset the writer after a c14n *//** Method canonicalize ... *//** Method engineCanonicalizeXPathNodeSet ... */convertNodelistToSet(...)/** Returns the URI of this engine. ... *//** Returns true if comments are included ... *//** C14n a nodeset ... *//** C14n a node tree. ... *//** Sets the writer where the canonicalization ends. ByteArrayOutputStream if ... *//** Constructor InvalidCanonicalizerException *//** Constructor InvalidCanonicalizerException ... *//** Compares two attributes based on the C14n specification. ... */Constants.NamespaceSpecNSint ATTR0_BEFORE_ATTR1;int ATTR1_BEFORE_ATTR0;String XMLNS;String namespaceURI0String namespaceURI1boolean isNamespaceAttr0boolean isNamespaceAttr1String localname0String localname1String name0// both are namespaces// attr0 is a namespace, attr1 is not// attr1 is a namespace, attr0 is not// none is a namespaceimport CanonicalizationException/** Temporary swapped static functions from the normalizer Section *//** Constructor C14nHelper *//** Method namespaceIsRelative ... */namespaceIsAbsolute(...)/** Method namespaceIsAbsolute ... *//** This method throws an exception if the Attribute value contains ... */String nodeAttrNameboolean definesDefaultNSboolean definesNonDefaultNSnamespaceIsRelative(...)String parentNamenew CanonicalizationException(...)/** This method throws a CanonicalizationException if the supplied Document ... *//** This method throws a CanonicalizationException if the supplied Element ... */assertNotRelativeNS(...)// don't allow instantiation// assume empty namespaces are absoluteimport C14nHelperimport XMLSignatureInput/** Implements <A HREF="http://www.w3.org/TR/2001/REC-xml-c14n-20010315">Canonical ... */boolean firstCall;XmlAttrStack xmlattrStack;boolean c14n11;/** Constructor Canonicalizer20010315 ... */new XmlAttrStack(...)this.c14n11/** Always throws a CanonicalizationException because this is inclusive c14n. ... *//** Output the Attr[]s for the given element. ... */SortedSet<Attr> resultnew TreeSet<Attr>(...)OutputStream writerint attrsLengthAttr attributeString NUriString NNameString NValueaddMappingAndRender(...)getUnrenderedNodes(...)getXmlnsAttr(...)outputAttrToWriter(...)boolean isRealVisibleisVisibleDO(...)addXmlnsAttr(...)removeMappingIfRender(...)removeMapping(...)addMapping(...)Attr xmlnsgetNullNode(...)isNeedsToBeExpanded(...)getSubNode(...)getNodeSet(...)circumventBug2650(...)String NameAttr n/** $todo$ well, should we throw UnsupportedOperationException ? */// result will contain the attrs which have to be output//It's not a namespace attr node. Add to the result and continue.//The default mapping for xml must not be output.//Render the ns definition//It is the first node of the subtree//Obtain all the namespaces defined in the parents, and added to the output.//output the attributes in the xml namespace.//we output all Attrs which are available//A non namespace definition node.// treat xml:id like any other attribute// (emit it, but don't inherit it)//The node is visible add the attribute to the list of output attributes./* except omit namespace node with local name xml, which defines ... *///add the prefix binding to the ns symb table.//The xpath select this node output it if needed.//The element is visible, handle the xmlns definition//No xmlns def just get the already defined.//There is a definition but the xmlns is not selected by the xpath.//then xmlns=""//output the xmlns def if needed.//Float all xml:* attributes of the unselected parent elements to this one.import InclusiveNamespaces/** Implements &quot; <A ... */SortedSet<String> inclusiveNSSet;/** This Set contains the names (Strings like "xmlns" or "xmlns:foo") of ... */boolean propagateDefaultNamespace;/** Constructor Canonicalizer20010315Excl ... *//** Method engineCanonicalizeSubTree ... */this.propagateDefaultNamespaceprefixStr2Set(...)engineCanonicalize(...)SortedSet<String> visiblyUtilizedString NNodeValuegetMappingWithoutRendered(...)Attr keySet<String> visiblyUtilizedboolean isOutputElementremoveMappingIfNotRender(...)// The prefix visibly utilized (in the attribute or in the name) in// the element// Not a namespace definition.// The Element is output element, add the prefix (if used) to// visiblyUtilized// Add to the result.// The default mapping for xml must not be output.// New definition check if it is relative.// It's the output selected.// The Element is output element, add the prefix (if used)// to visibyUtilized// New definition check if it is relative// The element is visible, handle the xmlns definition// There is a definition but the xmlns is not selected by the// xpath. then xmlns=""/** Class Canonicalizer20010315ExclWithComments *//** Constructor Canonicalizer20010315ExclWithComments *//** Constructor Canonicalizer20010315WithXPathOmitComments *//** Constructor Canonicalizer20010315WithXPathWithComments */import CanonicalizerSpiimport AttrCompareimport UnsyncByteArrayOutputStream/** Abstract base class for canonicalization algorithms. ... */Constants.XML_LANG_SPACE_SpecNSnew AttrCompare(...)String XML;String XML_LANG_URI;AttrCompare COMPARE;...[] END_PI;// potentially untrusted objects such as OutputStreams.// Make sure you clone the following mutable arrays before passing to...[] BEGIN_PI;...[] END_COMM;...[] BEGIN_COMM;...[] XA;...[] X9;...[] QUOT;...[] XD;...[] GT;...[] LT;...[] END_TAG;...[] AMP;...[] EQUALS_STR;int NODE_BEFORE_DOCUMENT_ELEMENT;int NODE_NOT_BEFORE_OR_AFTER_DOCUMENT_ELEMENT;int NODE_AFTER_DOCUMENT_ELEMENT;List<NodeFilter> nodeFilter;boolean includeComments;Set<Node> xpathNodeSet;Node excludeNode;/** The node to be skipped/excluded from the DOM tree ... */OutputStream writer;Attr nullNode;/** The null xmlns definition. *//** Constructor CanonicalizerBase ... */this.includeCommentsthis.xpathNodeSetengineCanonicalizeXPathNodeSetInternal(...)/** Canonicalizes a Subtree node. ... */isExcludeComments(...)isOctetStream(...)getExcludeNode(...)isNodeSet(...)getNodeFilters(...)circumventBugIfNeeded(...)this.excludeNodeNameSpaceSymbTable nsnew NameSpaceSymbTable(...)int nodeLevelgetParentNameSpaces(...)canonicalizeSubTree(...)UnsupportedEncodingException ex/** Method canonicalizeSubTree, this function is a recursive one. ... */Node excludeNodeboolean includeCommentsMap<String,byte[]> cachenew HashMap<String,byte[]>(...)isVisibleInt(...)outputNodePush(...)outputCommentToWriter(...)outputPItoWriter(...)outputTextToWriter(...)outputAttributesSubtree(...)writeStringToUtf8(...)outputNodePop(...)canonicalizeXPathNodeSet(...)byte[] sol/** Canonicalizes all the nodes included in the currentNode and contained in the ... */boolean currentNodeIsVisibleint documentLeveloutputAttributes(...)Iterator<NodeFilter> itisNodeIncludeDO(...)isNodeInclude(...)/** Adds to ns the definitions from the parent elements of el ... */List<Element> parentsnew ArrayList<Element>(...)ListIterator<Element> itAttr nsprefixElement elehandleParent(...)/** Output the attributes for this node in XPathNodeSet c14n. ... *//** Output the attributes for this node in a Subtree c14n. ... *//** Outputs an Attribute to the internal Writer. ... */byte[] toWritewriteCodePointToUtf8(...)/** Outputs a PI to the internal Writer. ... *//** Method outputCommentToWriter ... *//** Outputs a Text of CDATA section to the internal Writer. ... */// The null xmlns definition.//Fills the nssymbtable with the definitions of the parent of the root subnode// illegal node type during traversal//Add a level to the nssymbtable. So latter can be pop-back.//We finished with this level, pop to the previous definitions.//Obtain all the parents of the element//Visit them in reverse order.// '\t'// '\n'// '\r'/** Serializes the physical representation of the subtree. All the attributes ... *//** Constructor Canonicalizer20010315 *//** Always throws a CanonicalizationException. ... */// result will contain all the attrs declared directly on that element// Processing Instructions before or after the document element are not treated specially// Comments before or after the document element are not treated specially/** A stack based Symbol Table. ... */new SymbMap(...)NameSpaceSymbEntry nenew NameSpaceSymbEntry(...)ne.lastrenderedSymbMap initialMap;SymbMap symb;/** The map betwen prefix-> entry table. */List<SymbMap> level;/** The stacks for removing the definitions when doing pop. */boolean cloned;/** Default constractor */new ArrayList<SymbMap>(...)/** Get all the unrendered nodes in the name space. ... */Iterator<NameSpaceSymbEntry> itNameSpaceSymbEntry nn.renderedn.nneedsClone(...)n.prefixn.lastrenderedn.uri/** Push a frame for visible namespace. ... *//** Pop a frame for visible namespace. *//** Push a frame for a node. ... *//** Pop a frame. ... *//** Gets the attribute node that defines the binding for the prefix. ... */NameSpaceSymbEntry entryentry.renderedentry.lastrenderedentry.urientry.n/** Gets a definition without mark it as render. ... *//** Adds the mapping for a prefix. ... */NameSpaceSymbEntry obob.uriob.lastrenderedne.rendered/** Adds a definition and mark it as render. ... */ob.renderedob.nne.n/** The internal structure of NameSpaceSymbTable. *//** The URI that the prefix defines */String lastrendered;/** The last output in the URI for this prefix (This for speed reason). */boolean rendered;/** This prefix-URI has been already render or not. */Attr n;/** The attribute to include. */this.renderedint free;new NameSpaceSymbEntry[]index(...)Object oldKeyList<NameSpaceSymbEntry> anew ArrayList<NameSpaceSymbEntry>(...)Object[] setObject cur/** rehashes the map to the new capacity. ... */String[] oldKeysNameSpaceSymbEntry[] oldValsString oSymbMap copycopy.entriescopy.keys//Insert the default binding for xmlns.//put them rendered?//Put the number of namespace definitions in the stack.//There is no definition for the prefix(a bug?).//No need to render an entry already rendered.// Mark this entry as render.// Return the node for outputing.//If we have it previously defined. Don't keep working.//Creates and entry in the table for this new definition.//We have a previous definition store it for the pop.//Check if a previous definition(not the inmidiatly one) has been rendered.//Yes it is. Mark as rendered.//abs of indexboolean OLD_UTF8;/** Revert to the old behavior (version 2 or before), i.e. surrogate pairs characters becomes ... */getStringInUtf8(...)byte extraBytebyte writeisValidCodePoint(...)Character.MIN_SUPPLEMENTARY_CODE_POINTint biasint writeboolean expandedbyte[] newResult// valid code point: c >= 0x0000 && c <= 0x10FFFF// version 2 or before output 2 question mark characters for 32 bit chars// 0x00000000 - 0x0000007F// 0xxxxxxx// 0x00000080 - 0x000007FF// 110xxxxx 10xxxxxx// 0x00000800 - 0x0000FFFF// 1110xxxx 10xxxxxx 10xxxxxx// 0x00010000 - 0x001FFFFF// 11110xxx 10xxxxx 10xxxxxx 10xxxxxx// 0x00200000 - 0x03FFFFFF// 111110xx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx// already outside valid Character range, just for completeness// 0x04000000 - 0x7FFFFFFF// 1111110x 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx// 0x80000000 - 0xFFFFFFFF// case not possible as java has no unsigned int//No Surrogates in sun java/** An XmlAttrStack that is shared between the Canonical XML 1.0 and 1.1 implementations. */new ArrayList<XmlsStackElement>(...)XmlAttrStack.classXmlAttrStack$XmlsStackElementnew ArrayList<Attr>(...)List<Attr> nodes;int currentLevel;int lastlevel;XmlsStackElement cur;List<XmlsStackElement> levels;get(...).levelnew XmlsStackElement(...)cur.levelcur.nodesboolean parentRenderedXmlsStackElement eMap<String,Attr> loanew HashMap<String,Attr>(...)e.renderede.levelcur.renderedList<Attr> baseAttrsboolean successiveOmittedIterator<Attr> ite.nodesAttr baseAttrjoinURI(...)URISyntaxException ueString bschemeString bauthorityString bpathString bqueryURI rString rschemeString rauthorityString rpathString rquerygetQuery(...)String tschemeString tauthorityString tpathString tqueryremoveDotSegments(...)String inputStringBuilder outputprintStep(...)String segment// pre-parse the baseURI// 1. The input buffer is initialized with the now-appended path// components then replace occurrences of "//" in the input buffer// with "/" until no more occurrences of "//" are in the input buffer.// Initialize the output buffer with the empty string.// If the input buffer starts with a root slash "/" then move this// character to the output buffer.// While the input buffer is not empty, loop as follows// 2A. If the input buffer begins with a prefix of "./",// then remove that prefix from the input buffer// else if the input buffer begins with a prefix of "../", then// if also the output does not contain the root slash "/" only,// then move this prefix to the end of the output buffer else// remove that prefix// 2B. if the input buffer begins with a prefix of "/./" or "/.",// where "." is a complete path segment, then replace that prefix// with "/" in the input buffer; otherwise,// FIXME: what is complete path segment?// 2C. if the input buffer begins with a prefix of "/../" or "/..",// where ".." is a complete path segment, then replace that prefix// with "/" in the input buffer and if also the output buffer is// empty, last segment in the output buffer equals "../" or "..",// where ".." is a complete path segment, then append ".." or "/.."// for the latter case respectively to the output buffer else// remove the last segment and its preceding "/" (if any) from the// output buffer and if hereby the first character in the output// buffer was removed and it was not the root slash then delete a// leading slash from the input buffer; otherwise,// 2D. if the input buffer consists only of ".", then remove// that from the input buffer else if the input buffer consists// only of ".." and if the output buffer does not contain only// the root slash "/", then move the ".." to the output buffer// else delte it.; otherwise,// 2E. move the first path segment (if any) in the input buffer// to the end of the output buffer, including the initial "/"// character (if any) and any subsequent characters up to, but not// including, the next "/" character or the end of the input buffer.// 3. Finally, if the only or last segment of the output buffer is// "..", where ".." is a complete path segment not followed by a slash// then append a slash "/". The output buffer is returned as the result// of remove_dot_segments/** Constructor AlgorithmAlreadyRegisteredException *//** Constructor AlgorithmAlreadyRegisteredException ... *//** This Exception is thrown if decoding of Base64 data fails. *//** Constructor Base64DecodingException *//** Constructor Base64DecodingException ... *//** The mother of all Exceptions in this bundle. It allows exceptions to have ... */String msgID;/** Field msgID *//** Constructor XMLSecurityException */this.msgID/** Constructor XMLSecurityException ... */getExceptionMessage(...)/** Method getMsgID ... *//** Method printStackTrace *//** Method getOriginalException ... *//** The mother of all runtime Exceptions in this bundle. It allows exceptions to have ... *//** Constructor XMLSecurityRuntimeException *//** Constructor XMLSecurityRuntimeException ... */Constants.exceptionMessagesResourceBundleBase/** Constructor ContentHandlerAlreadyRegisteredException *//** Constructor ContentHandlerAlreadyRegisteredException ... */import X509Certificateimport DEREncodedKeyValueimport KeyInfoReferenceimport KeyNameimport KeyValueimport MgmtDataimport PGPDataimport RetrievalMethodimport SPKIDataimport X509Dataimport DSAKeyValueimport RSAKeyValueimport KeyResolverExceptionimport KeyResolverSpiimport StorageResolverimport Transforms/** This class stand for KeyInfo Element that may contain keys, names, ... */new ArrayList<KeyResolverSpi>(...)KeyInfo.classList<StorageResolver> listnew ArrayList<StorageResolver>(...)List<X509Data> x509Datas;// The default StorageResolver is null.// the KeyResolvers would not be called.// We need at least one StorageResolver otherwiseList<StorageResolver> nullList;List<StorageResolver> storageResolvers;/** Field storageResolvers */List<KeyResolverSpi> internalKeyResolvers;/** Stores the individual (per-KeyInfo) {@link KeyResolverSpi}s *//** Constructor KeyInfo ... */getDefaultPrefix(...)getBaseNamespace(...)addReturnToSelf(...)/** Set whether secure processing is enabled or not. The default is false. *//** Sets the {@code Id} attribute ... */setLocalIdAttribute(...)Constants._ATT_ID/** Returns the {@code Id} attribute ... *//** Method addKeyName ... */new KeyName(...)/** Method add ... */appendSelf(...)/** Method addKeyValue ... */new KeyValue(...)/** Method addMgmtData ... */new MgmtData(...)/** Method addPGPData ... *//** Method addRetrievalMethod ... */new RetrievalMethod(...)/** Method addX509Data ... */new ArrayList<X509Data>(...)/** Method addDEREncodedKeyValue ... */new DEREncodedKeyValue(...)/** Method addKeyInfoReference ... */new KeyInfoReference(...)/** Method addUnknownElement ... *//** Method lengthKeyName ... */Constants._TAG_KEYNAME/** Method lengthKeyValue ... */Constants._TAG_KEYVALUE/** Method lengthMgmtData ... */Constants._TAG_MGMTDATA/** Method lengthPGPData ... */Constants._TAG_PGPDATA/** Method lengthRetrievalMethod ... */Constants._TAG_RETRIEVALMETHOD/** Method lengthSPKIData ... */Constants._TAG_SPKIDATA/** Method lengthX509Data ... */Constants._TAG_X509DATA/** Method lengthDEREncodedKeyValue ... */Constants.SignatureSpec11NSConstants._TAG_DERENCODEDKEYVALUE/** Method lengthKeyInfoReference ... */Constants._TAG_KEYINFOREFERENCE/** Method lengthUnknownElement ... *//** Method itemKeyName ... */this.baseURI/** Method itemKeyValue ... *//** Method itemMgmtData ... *//** Method itemPGPData ... */new PGPData(...)/** Method itemRetrievalMethod ... *//** Method itemSPKIData ... */new SPKIData(...)/** Method itemX509Data ... */new X509Data(...)/** Method itemDEREncodedKeyValue ... */selectDs11Node(...)/** Method itemKeyInfoReference ... *//** Method itemUnknownElement ... *//** Method isEmpty ... *//** Method containsKeyName ... */lengthKeyName(...)/** Method containsKeyValue ... */lengthKeyValue(...)/** Method containsMgmtData ... */lengthMgmtData(...)/** Method containsPGPData ... */lengthPGPData(...)/** Method containsRetrievalMethod ... */lengthRetrievalMethod(...)/** Method containsSPKIData ... */lengthSPKIData(...)/** Method containsUnknownElement ... */lengthUnknownElement(...)/** Method containsX509Data ... */lengthX509Data(...)/** Method containsDEREncodedKeyValue ... */lengthDEREncodedKeyValue(...)/** Method containsKeyInfoReference ... */lengthKeyInfoReference(...)/** This method returns the public key. ... */PublicKey pkgetPublicKeyFromInternalResolvers(...)getPublicKeyFromStaticResolvers(...)/** Searches the library wide KeyResolvers for public keys ... */Iterator<KeyResolverSpi> itKeyResolverSpi keyResolverNode currentChildsetSecureValidation(...)StorageResolver storageengineLookupAndResolvePublicKey(...)/** Searches the per-KeyInfo KeyResolvers for public keys ... *//** Method getX509Certificate ... */X509Certificate certgetX509CertificateFromInternalResolvers(...)getX509CertificateFromStaticResolvers(...)/** This method uses each System-wide {@link KeyResolver} to search the ... */applyCurrentResolver(...)engineLookupResolveX509Certificate(...)/** Method getX509CertificateFromInternalResolvers ... */lengthInternalKeyResolver(...)/** This method returns a secret (symmetric) key. This is for XML Encryption. ... */SecretKey skgetSecretKeyFromInternalResolvers(...)getSecretKeyFromStaticResolvers(...)/** Searches the library wide KeyResolvers for Secret keys ... */engineLookupAndResolveSecretKey(...)/** Searches the per-KeyInfo KeyResolvers for secret keys ... *//** This method returns a private key. This is for Key Transport in XML Encryption. ... */PrivateKey pkgetPrivateKeyFromInternalResolvers(...)getPrivateKeyFromStaticResolvers(...)/** Searches the library wide KeyResolvers for Private keys ... */engineLookupAndResolvePrivateKey(...)/** Searches the per-KeyInfo KeyResolvers for private keys ... *//** This method is used to add a custom {@link KeyResolverSpi} to a KeyInfo ... */this.internalKeyResolvers/** Method lengthInternalKeyResolver ... *//** Method itemInternalKeyResolver ... *//** Method addStorageResolver ... */this.storageResolversConstants._TAG_KEYINFO/** $todo$ using this method, we don't see unknown Elements ... */// First search using the individual resolvers from the user// Then use the system-wide Resolvers// not using StorageResolvers at the moment// since they cannot return private keys// Replace the default null StorageResolver/** Utility class for {@code com.sun.org.apache.xml.internal.security.keys} package. *//** Method prinoutKeyInfo ... */KeyName xitemKeyName(...)getKeyName(...)KeyValue xitemKeyValue(...)getPublicKey(...)MgmtData xitemMgmtData(...)getMgmtData(...)X509Data xitemX509Data(...)containsCertificate(...)containsIssuerSerial(...)// no instantiationimport KeyFactoryimport InvalidKeySpecExceptionimport X509EncodedKeySpecimport Signature11ElementProxy/** Provides content model support for the {@code dsig11:DEREncodedKeyvalue} element. */...[] supportedKeyTypes;/** JCA algorithm key types supported by this implementation. *//** Constructor DEREncodedKeyValue ... */addBase64Text(...)getEncodedDER(...)/** Method getPublicKey ... */byte[] encodedKeygetBytesFromTextChild(...)String keyTypeKeyFactory keyFactoryX509EncodedKeySpec keySpecnew X509EncodedKeySpec(...)PublicKey publicKeygeneratePublic(...)NoSuchAlgorithmException eInvalidKeySpecException e/** Method getEncodedDER ... */getKeySpec(...)X509EncodedKeySpec.classgetEncoded(...)getFormat(...)// Iterate over the supported key types until one produces a public key.// Do nothing, try the next type/** Empty interface just to identify Elements that can be children of ds:KeyInfo. *//** Provides content model support for the {@code dsig11:KeyInfoReference} element. *//** Constructor RetrievalMethod ... */Constants._ATT_URI/** Method getURIAttr ... */getURIAttr(...)/** Constructor KeyName ... */addText(...)/** Method getKeyName ... */getTextFromTextChild(...)import ECKeyValue/** The KeyValue element contains a single public key that may be useful in ... *//** Constructor KeyValue ... */DSAKeyValue dsanew DSAKeyValue(...)RSAKeyValue rsanew RSAKeyValue(...)ECKeyValue ecnew ECKeyValue(...)Element rsaConstants._TAG_RSAKEYVALUEElement dsaConstants._TAG_DSAKEYVALUERSAKeyValue kvDSAKeyValue kv/** Constructor MgmtData ... *//** Method getMgmtData ... *//** $todo$ Implement *//** Constructor PGPData ... */String TYPE_DSA;/** DSA retrieval */String TYPE_RSA;/** RSA retrieval */String TYPE_PGP;/** PGP retrieval */String TYPE_SPKI;/** SPKI retrieval */String TYPE_MGMT;/** MGMT retrieval */String TYPE_X509;/** X509 retrieval */String TYPE_RAWX509;/** RAWX509 retrieval */Constants._ATT_TYPE/** Method getTransforms ... */Element transformsElemConstants._TAG_TRANSFORMSnew Transforms(...)XMLSignatureException ex/** $todo$ implement *//** Constructor SPKIData ... */import XMLX509CRLimport XMLX509Certificateimport XMLX509Digestimport XMLX509IssuerSerialimport XMLX509SKIimport XMLX509SubjectNameX509Data.class/** Constructor X509Data ... *//** Method addIssuerSerial ... */new XMLX509IssuerSerial(...)/** Method addSKI ... */new XMLX509SKI(...)/** Method addSubjectName ... */new XMLX509SubjectName(...)/** Method addCertificate ... */new XMLX509Certificate(...)/** Method addCRL ... */new XMLX509CRL(...)/** Method addDigest ... */new XMLX509Digest(...)/** Method lengthIssuerSerial ... */Constants._TAG_X509ISSUERSERIAL/** Method lengthSKI ... */Constants._TAG_X509SKI/** Method lengthSubjectName ... */Constants._TAG_X509SUBJECTNAME/** Method lengthCertificate ... */Constants._TAG_X509CERTIFICATE/** Method lengthCRL ... */Constants._TAG_X509CRL/** Method lengthDigest ... */Constants._TAG_X509DIGEST/** Method itemIssuerSerial ... *//** Method itemSKI ... *//** Method itemSubjectName ... *//** Method itemCertificate ... *//** Method itemCRL ... *//** Method itemDigest ... *//** Method containsIssuerSerial ... */lengthIssuerSerial(...)/** Method containsSKI ... */lengthSKI(...)/** Method containsSubjectName ... */lengthSubjectName(...)/** Method containsCertificate ... */lengthCertificate(...)/** Method containsDigest ... */lengthDigest(...)/** Method containsCRL ... */lengthCRL(...)/* No Elements found */import DSAParamsimport DSAPublicKeyimport DSAPublicKeySpec/** Constructor DSAKeyValue ... */addBigIntegerElement(...)Constants._TAG_PConstants._TAG_QConstants._TAG_GConstants._TAG_YDSAParams paramsgetG(...)DSAPublicKeySpec pkspecnew DSAPublicKeySpec(...)getBigIntegerFromChildElement(...)KeyFactory dsaFactoryInvalidKeySpecException eximport ECFieldimport ECFieldFpimport ECParameterSpecimport ECPointimport ECPublicKeySpecimport EllipticCurveinitializeCurve(...)Curve SECP256R1;/* Supported curve, secp256r1 */Curve SECP384R1;/* Supported curve secp384r1 */Curve SECP521R1;/* Supported curve secp521r1 */BigInteger pbigInt(...)ECField fieldnew ECFieldFp(...)EllipticCurve curvenew EllipticCurve(...)ECPoint gnew Curve(...)ECParameterSpec ecParamsgetCurveOid(...)Element namedCurveElementcreateElementInSignature11Space(...)ECPoint ecPointgetW(...)byte[] secPublicKeyencodePoint(...)Element publicKeyElementConstants._TAG_ECKEYVALUEElement curElemECPublicKeySpec specnew ECPublicKeySpec(...)hasAttributeNS(...)getECParameterSpec(...)decodePoint(...)MarshalException exverifyElement(...)Curve matchmatchCurve(...)int fieldSizebyte[] xbcopyOfRange(...)byte[] ybtrimZeroes(...)xb.lengthyb.lengthECKeyValue$Curve// NamedCurve// PublicKey// strip off "urn:oid"// Check that the params represent one of the supported// curves. If there is a match, return the object identifier// of the curve.// Per ANSI X9.62, an encoded point is a 1 byte type followed by// ceiling(LOG base 2 field-size / 8) bytes of x and the same of y.// get field size in bytes (rounding up)// uncompressedimport RSAPublicKeyimport RSAPublicKeySpec/** Constructor RSAKeyValue ... */Constants._TAG_MODULUSConstants._TAG_EXPONENTgetModulus(...)getPublicExponent(...)KeyFactory rsaFactoryRSAPublicKeySpec rsaKeyspecnew RSAPublicKeySpec(...)/** Constructor XMLX509CRL ... *//** Constructor X509CRL ... *//** Method getCRLBytes ... */import CertificateExceptionimport CertificateFactoryString JCA_CERT_ID;/** Field JCA_CERT_ID *//** Constructor X509Certificate ... *//** Constructor XMLX509Certificate ... */CertificateEncodingException ex/** Method getCertificateBytes ... */byte[] certbytesgetCertificateBytes(...)CertificateFactory certFactXMLX509Certificate.JCA_CERT_IDgenerateCertificate(...)getX509Certificate(...)XMLX509Certificate otherXMLSecurityException exXMLSecurityException e/** Just used for tagging contents that are allowed inside a ds:X509Data Element. *//** Provides content model support for the {@code dsig11:X509Digest} element. *//** Constructor XMLX509Digest ... */getDigestBytesFromCert(...)/** Method getAlgorithmAttr ... */getAlgorithmAttr(...)/** Method getDigestBytes ... *//** Method getDigestBytesFromCert ... */String jcaDigestAlgorithmimport RFC2253ParserXMLX509IssuerSerial.class/** Constructor XMLX509IssuerSerial ... */addTextElement(...)Constants._TAG_X509ISSUERNAMEConstants._TAG_X509SERIALNUMBERgetIssuerX500Principal(...)getSerialNumber(...)/** Method getSerialNumber ... */getTextFromChildElement(...)/** Method getSerialNumberInteger ... *//** Method getIssuerName ... */XMLX509IssuerSerial othergetIssuerName(...)/** Handles SubjectKeyIdentifier (SKI) for X.509v3. ... */XMLX509SKI.classString SKI_OID;/** {@code SubjectKeyIdentifier (id-ce-subjectKeyIdentifier) (2.5.29.14)}: ... *//** Constructor X509SKI ... *//** Constructor XMLX509SKI ... */getSKIBytesFromCert(...)/** Method getSKIBytes ... *//** Method getSKIBytesFromCert ... */byte[] extensionValuegetExtensionValue(...)XMLX509SKI.SKI_OIDbyte[] skidValueextensionValue.lengthskidValue.lengthXMLX509SKI othergetSKIBytes(...)/* Gets the DER-encoded OCTET string for the extension value ... *//** Strip away first four bytes from the extensionValue ... *//** Constructor X509SubjectName ... *//** Constructor XMLX509SubjectName ... */getSubjectX500Principal(...)/** Method getSubjectName ... */XMLX509SubjectName otherString otherSubjectgetSubjectName(...)String thisSubject/** Constructor InvalidKeyResolverException *//** Constructor InvalidKeyResolverException ... */import DEREncodedKeyValueResolverimport DSAKeyValueResolverimport ECKeyValueResolverimport KeyInfoReferenceResolverimport RSAKeyValueResolverimport RetrievalMethodResolverimport X509CertificateResolverimport X509DigestResolverimport X509IssuerSerialResolverimport X509SKIResolverimport X509SubjectNameResolver/** KeyResolver is factory class for subclass of KeyResolverSpi that ... */KeyResolver.classnew CopyOnWriteArrayList<KeyResolver>(...)List<KeyResolver> resolverVector;/** Field resolverVector */KeyResolverSpi resolverSpi;/** Field resolverSpi *//** Method length ... */KeyResolver resolverresolveX509Certificate(...)new KeyResolverException(...)PublicKey certresolvePublicKey(...)/** This method is used for registering {@link KeyResolverSpi}s which are ... */KeyResolverSpi keyResolverSpisetGlobalResolver(...)KeyResolverSpi tmpnew KeyResolver(...)List<KeyResolver> keyResolverListnew ArrayList<KeyResolver>(...)/** This method registers the default resolvers. */new RSAKeyValueResolver(...)new DSAKeyValueResolver(...)new X509CertificateResolver(...)new X509SKIResolver(...)new RetrievalMethodResolver(...)new X509SubjectNameResolver(...)new X509IssuerSerialResolver(...)new DEREncodedKeyValueResolver(...)new KeyInfoReferenceResolver(...)new X509DigestResolver(...)new ECKeyValueResolver(...)/** Method resolvePublicKey ... *//** Method resolveX509Certificate ... *//** Method setProperty ... */engineSetProperty(...)/** Method getProperty ... */engineGetProperty(...)/** Method understandsProperty ... */understandsProperty(...)/** Method resolverClassName ... */KeyResolver$ResolverIterator/** Iterate over the KeyResolverSpi instances */List<KeyResolver> res;Iterator<KeyResolver> it;resolver.resolverSpinew ResolverIterator(...)/** Constructor KeyResolverException *//** Constructor KeyResolverException ... *//** This class is an abstract class for a child KeyInfo Element. ... */Map<String,String> properties;/** Field properties */boolean globalResolver;/** Set whether secure validation is enabled or not. The default is false. *//** This method returns whether the KeyResolverSpi is able to perform the requested action. ... *//** Method engineResolvePublicKey ... *//** Method engineLookupAndResolvePublicKey ... */cloneIfNeeded(...)engineCanResolve(...)engineResolvePublicKey(...)/** Method engineResolveCertificate ... *//** Method engineLookupResolveX509Certificate ... */engineResolveX509Certificate(...)/** Method engineResolveSecretKey ... *//** Method engineLookupAndResolveSecretKey ... */engineResolveSecretKey(...)/** Method engineLookupAndResolvePrivateKey ... *//** Method engineSetProperty ... *//** Method engineGetProperty ... */this.globalResolver/** Parses a byte array and returns the parsed Element. ... */// This method was added later, it has no equivalent// engineResolvePrivateKey() in the old API.// We cannot throw UnsupportedOperationException because// KeyResolverSpi implementations who don't know about// this method would stop the search too early./** KeyResolverSpi implementation which resolves public keys from a ... */DEREncodedKeyValueResolver.class/** {{@inheritDoc}}. */elementIsInSignature11Space(...)DEREncodedKeyValue derKeyValueDSAKeyValueResolver.classElement dsaKeyElementboolean isKeyValueelementIsInSignatureSpace(...)DSAKeyValue dsaKeyValue// this trick is needed to allow the RetrievalMethodResolver to eat a// ds:DSAKeyValue directly (without KeyValue)//do nothingECKeyValueResolver.classElement ecKeyElementECKeyValue ecKeyValue// ds:ECKeyValue directly (without KeyValue)import KeyInfo/** KeyResolverSpi implementation which resolves public keys, private keys, secret keys, and X.509 certificates from a ... */KeyInfoReferenceResolver.classKeyInfo referentresolveReferentKeyInfo(...)getSecretKey(...)getPrivateKey(...)/** Resolve the KeyInfoReference Element's URI attribute into a KeyInfo instance. ... */KeyInfoReference referenceAttr uriAttrXMLSignatureInput resourceresolveInput(...)Element referentElementnew KeyInfo(...)obtainReferenceElement(...)validateReference(...)addStorageResolver(...)/** Validate the Element referred to by the KeyInfoReference. ... */containsKeyInfoReference(...)/** Resolve the XML signature input represented by the specified URI. ... */ResourceResolver resRes/** Resolve the Element effectively represented by the XML signature input source. ... */byte[] inputBytesgetDocFromBytes(...)// Don't support chains of references at this time. If do support in the future, this is where the code// would go to validate that don't have a cycle, resulting in an infinite loop. This may be unrealistic// to implement, and/or very expensive given remote URI references.// Retrieved resource is a byte streamimport KeyStoreimport KeyStoreExceptionimport Certificateimport CertificateEncodingException/** Resolves a PrivateKey within a KeyStore based on the KeyInfo hints. ... */PrivateKeyResolver.classKeyStore keyStore;this.keyStorethis.password/** Method engineResolveX509Certificate ... *//** Method engineResolvePrivateKey ... */PrivateKey privKeyresolveX509Data(...)String keyNameX509Data x509DataXMLX509SKI x509SKIitemSKI(...)resolveX509SKI(...)XMLX509IssuerSerial x509SerialitemIssuerSerial(...)resolveX509IssuerSerial(...)XMLX509SubjectName x509SubjectNameitemSubjectName(...)resolveX509SubjectName(...)XMLX509Certificate x509CertitemCertificate(...)KeyStoreException e/* Search for a private key entry in the KeyStore with the same Subject Key Identifier */Enumeration<String> aliasesaliases(...)String aliasisKeyEntry(...)Certificate certgetCertificate(...)XMLX509SKI certSKI/* Search for a private key entry in the KeyStore with the same Issuer/Serial Number pair. */XMLX509IssuerSerial certSerial/* Search for a private key entry in the KeyStore with the same Subject Name. */XMLX509SubjectName certSN/* Search for a private key entry in the KeyStore with the same Certificate. */byte[] x509CertBytesbyte[] certBytesCertificateEncodingException e1// Keep searchingRSAKeyValueResolver.classElement rsaKeyElementRSAKeyValue rsaKeyValue// ds:RSAKeyValue directly (without KeyValue)/** The RetrievalMethodResolver can retrieve public keys and certificates from ... */RetrievalMethodResolver.classRetrievalMethod rmRetrievalMethod.TYPE_RAWX509getRawCertificate(...)RetrievalMethod rm2XMLSignatureInput resource2Element e2resolveKey(...)CertificateException exresolveCertificate(...)/** Retrieves a x509Certificate from the given information ... *//** Retrieves a PublicKey from the given information ... */inputBytes.length/** Resolves the input from the given retrieval method ... */Attr uriTransforms transformsgetTransforms(...)performTransforms(...)Iterator<Node> itList<Node> parentsListIterator<Node> it2// Create a retrieval method over the given element// a raw certificate, direct parsing is done!// Check to make sure that the reference is not to another RetrievalMethod// which points to this element// An element has been provided// Retrieved resource is a nodeSet// Retrieved resource is an inputStream// otherwise, we parse the resource, create an Element and delegate// if the resource stores a raw certificate, we have to handle it// Apply the transforms// Obtain all the parents of the elemnt// Visit them in reverse order./** Resolves a SecretKey within a KeyStore based on the KeyName. ... */SecretKeyResolver.class/** Resolves a single Key based on the KeyName. */SingleKeyResolver.classString keyName;PublicKey publicKey;PrivateKey privateKey;SecretKey secretKey;this.keyNamethis.publicKeythis.privateKeythis.secretKey/** Resolves Certificates which are directly contained inside a ... */X509CertificateResolver.classElement[] elsselectDsNodes(...)els.lengthXMLX509Certificate xmlCert// populate Object array/** KeyResolverSpi implementation which resolves public keys and X.509 certificates from a ... */X509DigestResolver.classcontainsDigest(...)/** Resolves from the storage resolver the actual certificate represented by the digest. ... */XMLX509Digest[] x509DigestsElement[] x509childNodesselectDs11Nodes(...)x509childNodes.lengthIterator<Certificate> storageIteratorcheckStorage(...)new XMLX509Digest[]x509Digests.lengthXMLX509Digest keyInfoDigestbyte[] certDigestBytesgetDigestBytes(...)/** Method checkSrorage ... */KeyResolverException exX509IssuerSerialResolver.classX509Data x509dataint noOfISSXMLX509IssuerSerial xmlissX509SKIResolver.classXMLX509SKI[] x509childObjectnew XMLX509SKI[]x509childObject.length/** Field _x509childObject[] */X509SubjectNameResolver.classXMLX509SubjectName[] x509childObjectnew XMLX509SubjectName[]import KeyStoreResolverimport SingleCertificateResolver/** This class collects customized resolvers for Certificates. */StorageResolver.classList<StorageResolverSpi> storageResolvers;/** Constructor StorageResolver *//** Constructor StorageResolver ... *//** Method addResolver ... */new ArrayList<StorageResolverSpi>(...)/** Method addKeyStore ... */new KeyStoreResolver(...)StorageResolverException exnew SingleCertificateResolver(...)/** Method getIterator ... */new StorageResolverIterator(...)StorageResolver$StorageResolverIterator/** Class StorageResolverIterator ... */Iterator<StorageResolverSpi> resolvers;/** Field resolvers */Iterator<Certificate> currentResolver;/** Field currentResolver *//** Constructor StorageResolverIterator ... */this.resolversfindNextResolver(...)/** Method remove */// Find the next storage with at least one element and return its IteratorStorageResolverSpi resolverSpiIterator<Certificate> iter/** Constructor StorageResolverException *//** Constructor StorageResolverException ... */import Filesimport CertificateExpiredExceptionimport CertificateNotYetValidExceptionimport StorageResolverExceptionimport StorageResolverSpi/** This {@link StorageResolverSpi} makes all raw (binary) {@link X509Certificate}s ... */new ArrayList<X509Certificate>(...)CertsInFilesystemDirectoryResolver.classString merlinsCertificatesDir;/** Field merlinsCertificatesDir */List<X509Certificate> certs;/** Field certs */this.merlinsCertificatesDirreadCertsFromHarddrive(...)/** Method readCertsFromHarddrive ... */File certDirList<String> alCertificateFactory cfString currentFileNamenew StorageResolverException(...)boolean addedString dncheckValidity(...)this.certsCertificateNotYetValidException exCertificateExpiredException exnew FilesystemIterator(...)CertsInFilesystemDirectoryResolver$FilesystemIterator/** Class FilesystemIterator *//** Field i *//** Constructor FilesystemIterator ... *//** Method main ... */CertsInFilesystemDirectoryResolver krsnew CertsInFilesystemDirectoryResolver(...)Iterator<Certificate> ibyte[] ski//add to ArrayList/** Makes the Certificates from a JAVA {@link KeyStore} object available to the ... *//** Field keyStore *//** Constructor KeyStoreResolver ... */KeyStoreException exnew KeyStoreIterator(...)KeyStoreResolver$KeyStoreIterator/** Class KeyStoreIterator */Enumeration<String> aliases;/** Field aliases */Certificate nextCert;/** Field nextCert *//** Constructor KeyStoreIterator ... */this.aliasesnew Enumeration<String>(...) { ... }KeyStoreResolver$KeyStoreIterator$1findNextCert(...)Certificate ret// In particular, this skips over entries containing symmetric keys.// Find the next entry that contains a certificate and return it.// Do a quick check on the keystore// empty Enumeration// maybe caller did not call hasNext()/** This {@link StorageResolverSpi} makes a single {@link X509Certificate} ... */X509Certificate certificate;/** Field certificate */this.certificatenew InternalIterator(...)SingleCertificateResolver$InternalIterator/** Class InternalIterator */boolean alreadyReturned;/** Field alreadyReturned *//** Constructor InternalIterator ... */this.alreadyReturned/** Raised when the computed hash value doesn't match the given <i>DigestValue</i>. ... *//** Constructor InvalidDigestValueException *//** Constructor InvalidDigestValueException ... *//** Raised if testing the signature value over <i>DigestValue</i> fails because of invalid signature. ... *//** Constructor InvalidSignatureValueException *//** Constructor InvalidSignatureValueException ... */import InvalidCanonicalizerExceptionimport ResourceResolverSpi/** Handles {@code &lt;ds:Manifest&gt;} elements. ... */Manifest.classnew PrivilegedAction<Integer>(...) { ... }int MAXIMUM_REFERENCE_COUNT;/** The default maximum number of references per Manifest, if secure validation is enabled. */Integer referenceCount;List<Reference> references;/** Field references */...[] referencesEl;List<VerifiedReference> verificationResults;/** Field verificationResults[] */Map<String,String> resolverProperties;/** Field resolverProperties */List<ResourceResolver> perManifestResolvers;/** Field perManifestResolvers *//** Constructs {@link Manifest} ... */new ArrayList<Reference>(...)/** Constructor Manifest ... */int lethis.referencesEl.lengththis.referencesElConstants._TAG_REFERENCEConstants._TAG_MANIFESTElement refElemAttr refAttr/** This {@code addDocument} method is used to add a new resource to the ... */Reference refnew Reference(...)/** The calculation of the DigestValues in the References must be after the ... */Reference currentRefgenerateDigestValue(...)/** Return the nonnegative number of added references. ... *//** Return the <i>i</i><sup>th</sup> reference. Valid {@code i} ... *//** Used to do a <A HREF="http://www.w3.org/TR/xmldsig-core/#def-ValidationReference">reference ... */verifyReferences(...)boolean verifyreferencesEl.lengththis.verificationResultsnew ArrayList<VerifiedReference>(...)boolean currentRefVerifiedList<VerifiedReference> manifestReferencesemptyList(...)typeIsReferenceToManifest(...)XMLSignatureInput signedManifestNodesdereferenceURIandPerformTransforms(...)Set<Node> nlManifest referencedManifestIterator<Node> nlIteratorboolean referencedManifestValidgetSourceURI(...)new MissingResourceFailureException(...)referencedManifest.perManifestResolversthis.perManifestResolversreferencedManifest.resolverPropertiesthis.resolverPropertiesgetVerificationResults(...)new ReferenceNotInitializedException(...)new VerifiedReference(...)ReferenceNotInitializedException ex/** After verifying a {@link Manifest} or a {@link SignedInfo} using the ... *//** Get the list of verification result objects *//** Adds Resource Resolver for retrieving resources at specified {@code URI} attribute ... */new ArrayList<ResourceResolver>(...)new ResourceResolver(...)/** Get the Per-Manifest Resolver List ... *//** Get the resolver property map ... *//** Used to pass parameters like proxy servers etc to the ResourceResolver ... *//** Returns the value at specified key ... *//** Method getSignedContentItem ... */getReferencedContentAfterTransformsItem(...)CanonicalizationException exInvalidCanonicalizerException ex/** Method getReferencedContentPriorTransformsItem ... */getContentsBeforeTransformation(...)/** Method getReferencedContentAfterTransformsItem ... */getContentsAfterTransformation(...)/** Method getSignedContentLength ... */// check out Reference children// At least one Reference must be present. Bad.// create List// the this.doc is handed implicitly by the this.getOwnerDocument()// add Reference object to our cache vector// add the Element of the Reference object to the Manifest/SignedInfo// update the cached Reference object, the Element content is automatically updated// not yet constructed, so _we_ have to// if only one item does not verify, the whole verification fails// was verification successful till now and do we want to verify the Manifest?// Hm, seems not to be a ds:Manifest// The Reference stated that it points to a ds:Manifest// but we did not find a ds:Manifest in the signed area/** Thrown by {@link com.sun.org.apache.xml.internal.security.signature.SignedInfo#verify()} when ... */Reference uninitializedReference;/** Field uninitializedReference *//** MissingKeyResourceFailureException constructor. ... */this.uninitializedReference/** Constructor MissingResourceFailureException ... *//** used to set the uninitialized {@link com.sun.org.apache.xml.internal.security.signature.Reference} ... *//** used to get the uninitialized {@link com.sun.org.apache.xml.internal.security.signature.Reference} ... *//** An interface to tell to the c14n if a node is included or not in the output *//** Tells if a node must be output in c14n. ... *//** Tells if a node must be output in a c14n. ... *//** Handles {@code &lt;ds:Object&gt;} elements ... *//** Constructs {@link ObjectContainer} ... *//** Constructs {@link ObjectContainer} from {@link Element} ... *//** Sets the {@code MimeType} attribute ... */Constants._ATT_MIMETYPE/** Returns the {@code MimeType} attribute ... *//** Sets the {@code Encoding} attribute ... */Constants._ATT_ENCODING/** Returns the {@code Encoding} attribute ... *//** Adds child Node ... */Constants._TAG_OBJECTimport Algorithmimport ReferenceDataimport ReferenceNodeSetDataimport ReferenceOctetStreamDataimport ReferenceSubTreeDataimport InvalidTransformExceptionimport TransformationExceptionimport DigesterOutputStreamimport UnsyncBufferedOutputStreamimport ResourceResolverException/** Handles {@code &lt;ds:Reference&gt;} elements. ... */Reference.classString OBJECT_URI;/** Field OBJECT_URI */String MANIFEST_URI;/** Field MANIFEST_URI */int MAXIMUM_TRANSFORM_COUNT;/** The maximum number of transforms per reference, if secure validation is enabled. */boolean useC14N11;/** Look up useC14N11 system property. If true, an explicit C14N11 transform ... */Manifest manifest;XMLSignatureInput transformsOutput;Transforms transforms;Element digestMethodElem;Element digestValueElement;ReferenceData referenceData;/** Constructor Reference ... */Algorithm digestAlgorithmnew Algorithm(...) { ... }Reference$1this.manifestthis.transformsConstants._TAG_DIGESTVALUE/** Build a {@link Reference} from an {@link Element} ... *//** Returns {@link MessageDigestAlgorithm} ... *//** Sets the {@code URI} of this {@code Reference} element ... *//** Returns the {@code URI} of this {@code Reference} element ... *//** Sets the {@code Id} attribute of this {@code Reference} element ... *//** Returns the {@code Id} attribute of this {@code Reference} element ... *//** Sets the {@code type} atttibute of the Reference indicate whether an ... *//** Return the {@code type} atttibute of the Reference indicate whether an ... *//** Method isReferenceToObject ... */Reference.OBJECT_URI/** Method isReferenceToManifest ... */Reference.MANIFEST_URI/** Method setDigestValueElement ... */String base64codedValueText tcreateText(...)/** Method generateDigestValue ... */setDigestValueElement(...)calculateDigest(...)/** Returns the XMLSignatureInput which is created by de-referencing the URI attribute. ... */ResourceResolver resolvergetPerManifestResolvers(...)addProperties(...)getResolverProperties(...)ResourceResolverException exXMLSignatureInput outputthis.transformsOutputTransformationException ex/** Returns the XMLSignatureInput which is the result of the Transforms. ... */XMLSignatureInput inputcacheDereferencedElement(...)/** This method returns the XMLSignatureInput which represents the node set before ... */Transform tTransforms.TRANSFORM_C14N_EXCL_OMIT_COMMENTSTransforms.TRANSFORM_C14N_EXCL_WITH_COMMENTSTransforms.TRANSFORM_C14N_OMIT_COMMENTSTransforms.TRANSFORM_C14N_WITH_COMMENTSTransforms.TRANSFORM_C14N11_OMIT_COMMENTSTransforms.TRANSFORM_C14N11_WITH_COMMENTSperformTransform(...)setSourceURI(...)/** Method getHTMLRepresentation ... */XMLSignatureInput nodesgetNodesetBeforeFirstCanonicalization(...)Transform c14nTransformSet<String> inclusiveNamespacesInclusiveNamespaces.ExclusiveCanonicalizationNamespaceInclusiveNamespaces._TAG_EC_INCLUSIVENAMESPACESInclusiveNamespaces innew InclusiveNamespaces(...)getInclusiveNamespaces(...)getHTMLRepresentation(...)InvalidTransformException ex/** This method only works after a call to verify. ... *//** Get the ReferenceData that corresponds to the cached representation of the dereferenced ... *//** This method returns the {@link XMLSignatureInput} which is referenced by the ... *//** Store the dereferenced Element(s) so that it/they can be retrieved later. */Set<Node> snew ReferenceNodeSetData(...) { ... }Reference$2new Iterator<Node>(...) { ... }Reference$2$1Iterator<Node> sIterator;new ReferenceSubTreeData(...)isByteArray(...)new ReferenceOctetStreamData(...)getOctetStream(...)getMIMEType(...)/** Method getReferencedBytes ... *//** Method calculateDigest ... */MessageDigestAlgorithm mdagetMessageDigestAlgorithm(...)isPreCalculatedDigest(...)getPreCalculatedDigest(...)DigesterOutputStream diOsnew DigesterOutputStream(...)new UnsyncBufferedOutputStream(...)Reference.useC14N11isOutputStreamSet(...)addTransform(...)updateOutputStream(...)getOctetStreamReal(...)getDigestValue(...)/** Get the pre-calculated digest value from the XMLSignatureInput. ... */String preCalculatedDigest/** Returns the digest value. ... *//** Tests reference validation is success or false ... */byte[] elemDigbyte[] calcDigboolean equal// important: The ds:Reference must be added to the associated ds:Manifest//            or ds:SignedInfo _before_ the this.resolverResult() is called.// this.manifest.appendChild(this.constructionElement);// this.manifest.appendChild(this.doc.createTextNode("\n"));// Create DigestMethod Element without actually instantiating a MessageDigest Object//new XMLSignatureInput(output.getBytes());//this.transformsOutput.setSourceURI(output.getSourceURI());// there is one InclusiveNamespaces element// LOG a warning// if signing and c14n11 property == true explicitly add// C14N11 transform if needed//this.getReferencedBytes(diOs);//mda.update(data);// The required element is not in the XML!/** Raised if verifying a {@link com.sun.org.apache.xml.internal.security.signature.Reference} fails ... *//** Constructor ReferenceNotInitializedException *//** Constructor ReferenceNotInitializedException ... *//** Handles {@code &lt;ds:SignatureProperties&gt;} elements ... *//** Constructor SignatureProperties ... *//** Constructs {@link SignatureProperties} from {@link Element} ... */Element propertyElemConstants._TAG_SIGNATUREPROPERTYAttr propertyAttr/** Return the nonnegative number of added SignatureProperty elements. ... */Element[] propertyElemspropertyElems.length/** Return the <i>i</i><sup>th</sup> SignatureProperty. Valid {@code i} ... */new SignatureProperty(...)/** Method addSignatureProperty ... */Constants._TAG_SIGNATUREPROPERTIES/** Handles {@code &lt;ds:SignatureProperty&gt;} elements ... *//** Constructs{@link SignatureProperty} using specified {@code target} attribute ... *//** Constructs {@link SignatureProperty} using sepcified {@code target} attribute and ... *//** Constructs a {@link SignatureProperty} from an {@link Element} ... *//** Sets the {@code id} attribute ... *//** Returns the {@code id} attribute ... *//** Sets the {@code target} attribute ... */Constants._ATT_TARGET/** Returns the {@code target} attribute ... *//** Method appendChild ... */import SecretKeySpec/** Handles {@code &lt;ds:SignedInfo&gt;} elements ... */SignatureAlgorithm signatureAlgorithm;...[] c14nizedBytes;/** Field c14nizedBytes */Element c14nMethod;Element signatureMethod;/** Overwrites {@link Manifest#addDocument} because it creates another ... *//** Constructs {@link SignedInfo} using given Canonicalization algorithm and ... *//** Constructor SignedInfo ... */Constants._TAG_CANONICALIZATIONMETHODnew SignatureAlgorithm(...)this.c14nMethod/** Build a {@link SignedInfo} from an {@link Element} ... */reparseSignedInfoElem(...)Element c14nMethodString c14nMethodURICanonicalizer c14nizerbyte[] c14nizedBytesDocument newdocNode imported/** Tests core validation process ... *//** Returns getCanonicalizedOctetStream ... */this.c14nizedBytesgetCanonicalizationMethodURI(...)String inclusiveNamespacesisSecureValidation(...)/** Output the C14n stream to the given OutputStream. ... *//** Returns the Canonicalization method URI ... *//** Returns the Signature method URI ... */Element signatureElementgetSignatureMethodElement(...)/** Method getSignatureMethodElement ... *//** Creates a SecretKey for the appropriate Mac algorithm based on a ... */new SecretKeySpec(...)getJCEAlgorithmString(...)Constants._TAG_SIGNEDINFOElement inclusiveElement// Check this?// Parse the Reference children and Id attribute in the Manifest/* If a custom canonicalizationMethod is used, canonicalize ... */// the c14n is not a secure one and can rewrite the URIs or like// so reparse the SignedInfo to be sure// make defensive copy/** Holds the result of a Reference validation. */List<VerifiedReference> manifestReferences;this.manifestReferencesimport SignerOutputStream/** Handles {@code &lt;ds:Signature&gt;} elements. ... */XMLSignature.classString ALGO_ID_MAC_HMAC_SHA1;/** MAC - Required HMAC-SHA1 */String ALGO_ID_SIGNATURE_DSA;/** Signature - Required DSAwithSHA1 (DSS) */String ALGO_ID_SIGNATURE_DSA_SHA256;/** Signature - Optional DSAwithSHA256 */String ALGO_ID_SIGNATURE_RSA;/** Signature - Recommended RSAwithSHA1 */String ALGO_ID_SIGNATURE_RSA_SHA1;String ALGO_ID_SIGNATURE_NOT_RECOMMENDED_RSA_MD5;/** Signature - NOT Recommended RSAwithMD5 */String ALGO_ID_SIGNATURE_RSA_RIPEMD160;/** Signature - Optional RSAwithRIPEMD160 */String ALGO_ID_SIGNATURE_RSA_SHA224;/** Signature - Optional RSAwithSHA224 */String ALGO_ID_SIGNATURE_RSA_SHA256;/** Signature - Optional RSAwithSHA256 */String ALGO_ID_SIGNATURE_RSA_SHA384;/** Signature - Optional RSAwithSHA384 */String ALGO_ID_SIGNATURE_RSA_SHA512;/** Signature - Optional RSAwithSHA512 */String ALGO_ID_SIGNATURE_RSA_SHA1_MGF1;/** Signature - Optional RSAwithSHA1andMGF1 */String ALGO_ID_SIGNATURE_RSA_SHA224_MGF1;/** Signature - Optional RSAwithSHA224andMGF1 */String ALGO_ID_SIGNATURE_RSA_SHA256_MGF1;/** Signature - Optional RSAwithSHA256andMGF1 */String ALGO_ID_SIGNATURE_RSA_SHA384_MGF1;/** Signature - Optional RSAwithSHA384andMGF1 */String ALGO_ID_SIGNATURE_RSA_SHA512_MGF1;/** Signature - Optional RSAwithSHA512andMGF1 */String ALGO_ID_SIGNATURE_RSA_SHA3_224_MGF1;/** Signature - Optional RSAwithSHA3_224andMGF1 */String ALGO_ID_SIGNATURE_RSA_SHA3_256_MGF1;/** Signature - Optional RSAwithSHA3_256andMGF1 */String ALGO_ID_SIGNATURE_RSA_SHA3_384_MGF1;/** Signature - Optional RSAwithSHA3_384andMGF1 */String ALGO_ID_SIGNATURE_RSA_SHA3_512_MGF1;/** Signature - Optional RSAwithSHA3_512andMGF1 */String ALGO_ID_MAC_HMAC_NOT_RECOMMENDED_MD5;/** HMAC - NOT Recommended HMAC-MD5 */String ALGO_ID_MAC_HMAC_RIPEMD160;/** HMAC - Optional HMAC-RIPEMD160 */String ALGO_ID_MAC_HMAC_SHA224;/** HMAC - Optional HMAC-SHA2224 */String ALGO_ID_MAC_HMAC_SHA256;/** HMAC - Optional HMAC-SHA256 */String ALGO_ID_MAC_HMAC_SHA384;/** HMAC - Optional HMAC-SHA284 */String ALGO_ID_MAC_HMAC_SHA512;/** HMAC - Optional HMAC-SHA512 */String ALGO_ID_SIGNATURE_ECDSA_SHA1;/** Signature - Optional ECDSAwithSHA1 */String ALGO_ID_SIGNATURE_ECDSA_SHA224;/** Signature - Optional ECDSAwithSHA224 */String ALGO_ID_SIGNATURE_ECDSA_SHA256;/** Signature - Optional ECDSAwithSHA256 */String ALGO_ID_SIGNATURE_ECDSA_SHA384;/** Signature - Optional ECDSAwithSHA384 */String ALGO_ID_SIGNATURE_ECDSA_SHA512;/** Signature - Optional ECDSAwithSHA512 */String ALGO_ID_SIGNATURE_ECDSA_RIPEMD160;/** Signature - Optional ECDSAwithRIPEMD160 */SignedInfo signedInfo;/** ds:Signature.ds:SignedInfo element */KeyInfo keyInfo;/** ds:Signature.ds:KeyInfo */boolean followManifestsDuringValidation;/** Checking the digests in References in a Signature are mandatory, but for ... */Element signatureValueElement;int MODE_SIGN;int MODE_VERIFY;/** This creates a new {@code ds:Signature} Element and adds an empty ... *//** Constructor XMLSignature ... */String xmlnsDsPrefixthis.signedInfonew SignedInfo(...)Constants._TAG_SIGNATUREVALUE/** Creates a XMLSignature in a Document ... *//** This will parse the element and construct the Java Objects. ... */Element signedInfoElemAttr signatureValueAttrElement keyInfoElemElement objectElemthis.signatureValueElementthis.keyInfoAttr objectAttrElement childElemnew SignatureProperties(...)/** Returns the completely parsed {@code SignedInfo} object. ... *//** Returns the octet value of the SignatureValue element. ... *//** Base64 encodes and sets the bytes as the content of the SignatureValue ... */ignoreLineBreaks(...)/** Returns the KeyInfo child. If we are in signing mode and the KeyInfo ... */Element keyInfoElementElement firstObjectaddReturnBeforeChild(...)/** Appends an Object (not a {@code java.lang.Object} but an Object ... *//** Returns the {@code i}th {@code ds:Object} child of the signature ... */Element objElemnew ObjectContainer(...)/** Returns the number of all {@code ds:Object} elements. ... *//** Digests all References in the SignedInfo, calculates the signature value ... */SignedInfo sigetSignedInfo(...)SignatureAlgorithm sagetSignatureAlgorithm(...)SignerOutputStream outputnew SignerOutputStream(...)OutputStream sogenerateDigestValues(...)signInOctetStream(...)setSignatureValueElement(...)/** Adds a {@link ResourceResolver} to enable the retrieval of resources. ... */addResourceResolver(...)/** Adds a {@link ResourceResolverSpi} to enable the retrieval of resources. ... *//** Extracts the public key from the certificate and verifies if the signature ... */checkSignatureValue(...)/** Verifies if the signature is valid by redigesting all References, ... */byte[] sigBytesgetAlgorithmURI(...)getJCEProviderName(...)SignerOutputStream soOutputStream bosgetSignatureValue(...)this.followManifestsDuringValidation/** Add a Reference with full parameters to this Signature ... *//** This method is a proxy method for the {@link Manifest#addDocument} method. ... *//** Adds a Reference with just the URI and the transforms. This used the ... */Constants.ALGO_ID_DIGEST_SHA1/** Add a Reference with just this URI. It uses SHA1 by default as the digest ... *//** Add an X509 Certificate to the KeyInfo. This will include the whole cert ... */addCertificate(...)getKeyInfo(...)/** Add this public key to the KeyInfo. This will include the complete key in ... *//** Proxy method for {@link SignedInfo#createSecretKey(byte[])}. If you want ... */createSecretKey(...)/** Signal whether Manifest should be automatically validated. ... *//** Get the local name of this element ... */// create an empty SignatureValue; this is filled by setSignatureValueElement// check out SignedInfo child// check to see if it is there// create a SignedInfo object from that element// get signedInfoElem again in case it has changed// check out SignatureValue child// check to see if it exists// <element ref="ds:KeyInfo" minOccurs="0"/>// If it exists use it, but it's not mandatory// <element ref="ds:Object" minOccurs="0" maxOccurs="unbounded"/>// Register Ids of the Object child elements// check to see if we are signing and if we have to create a keyinfo// create the KeyInfo// get the Element from KeyInfo// add it before the object// add it as the last element to the signature//try {//if (this.state != MODE_SIGN) {// throw new XMLSignatureException(//  "signature.operationOnlyBeforeSign");//} catch (XMLSecurityException ex) {// throw new XMLSignatureException(ex);//Create a SignatureAlgorithm object// generate digest values for all References in this SignedInfo// initialize SignatureAlgorithm for signing// get the canonicalized bytes from SignedInfo// set them on the SignatureValue element// see if cert is null// check the values with the public key from the cert//COMMENT: pk suggests it can only be a public key?//check to see if the key is not null// all references inside the signedinfo need to be dereferenced and// digested again to see if the outcome matches the stored value in the// SignedInfo.// If followManifestsDuringValidation is true it will do the same for// References inside a Manifest.//create a SignatureAlgorithms from the SignatureMethod inside//SignedInfo. This is used to validate the signature.// Get the canonicalized (normalized) SignedInfo// retrieve the byte[] from the stored signature// Impossible...// have SignatureAlgorithm sign the input bytes and compare them to// the bytes that were stored in the signature./** All XML Signature related exceptions inherit herefrom. ... *//** Constructor XMLSignatureException *//** Constructor XMLSignatureException ... */import LinkedHashSetimport CanonicalizerBaseimport XMLSecurityRuntimeException/** Class XMLSignatureInput ... */new ArrayList<NodeFilter>(...)InputStream inputOctetStreamProxy;/** Some InputStreams do not support the {@link java.io.InputStream#reset} ... *//* The XMLSignature Input can be either: ... */Set<Node> inputNodeSet;/** The original NodeSet for this XMLSignatureInput */Node subNode;/** The original Element *//** Exclude Node *for enveloped transformations* */boolean excludeComments;boolean isNodeSet;/** A cached bytes */String mimeType;/** Some Transforms may require explicit MIME type, charset (IANA registered ... */String sourceURI;/** Field sourceURI */List<NodeFilter> nodeFilters;/** Node Filter list. */boolean needsToBeExpanded;OutputStream outputStream;String preCalculatedDigest;/** Pre-calculated digest value of the object in base64. *//** Construct a XMLSignatureInput from an octet array. ... *//** Constructs a {@code XMLSignatureInput} from an octet stream. The ... */this.inputOctetStreamProxy/** Construct a XMLSignatureInput from a subtree rooted by rootNode. This ... */this.subNode/** Constructor XMLSignatureInput ... */this.inputNodeSet/** Construct a {@code XMLSignatureInput} from a known digest value in Base64. ... */this.preCalculatedDigest/** Check if the structure needs to be expanded. ... *//** Set if the structure needs to be expanded. ... */this.needsToBeExpanded/** Returns the node set from input which was specified as the parameter of ... *//** Get the Input NodeSet. ... */new LinkedHashSet<Node>(...)getSet(...)Set<Node> resultconvertToNodes(...)/** Returns the Octet stream(byte Stream) from input which was specified as ... *//** Returns the byte array from input which was specified as the parameter of ... */getBytesFromInputStream(...)Canonicalizer20010315OmitComments c14nizernew Canonicalizer20010315OmitComments(...)/** Determines if the object has been set up with a Node set ... *//** Determines if the object has been set up with an Element ... *//** Determines if the object has been set up with an octet stream ... *//** Determines if {@link #setOutputStream} has been called with a ... *//** Determines if the object has been set up with a ByteArray ... *//** Determines if the object has been set up with a pre-calculated digest. ... *//** Is the object correctly set up? ... *//** Returns mimeType ... *//** Sets mimeType ... */this.mimeType/** Return SourceURI ... *//** Sets SourceURI ... */this.sourceURI/** Method toString ... */getBytes(...).lengthIOException iexCanonicalizationException cexXMLSignatureInputDebugger dbnew XMLSignatureInputDebugger(...)/** Gets the exclude node of this XMLSignatureInput ... *//** Sets the exclude node of this XMLSignatureInput ... *//** Gets the node of this XMLSignatureInput ... */this.excludeCommentsCanonicalizerBase c14nizernew Canonicalizer11_OmitComments(...)int bytesreadgetBytesFromStream(...)new XMLSecurityRuntimeException(...)// NO defensive copy// select all nodes, also the comments.// if a not-wellformed nodeset exists, put a container around it.../** Class XMLSignatureInputDebugger *//** Field _xmlSignatureInput */Set<String> inclusiveNamespaces;Writer writer;/** Field writer */String HTMLPrefix;/** The HTML Prefix* */String HTMLSuffix;/** HTML Suffix * */String HTMLExcludePrefix;String HTMLIncludePrefix;String HTMLIncludeOrExcludeSuffix;String HTMLIncludedInclusiveNamespacePrefix;String HTMLExcludedInclusiveNamespacePrefix;AttrCompare ATTR_COMPARE;/** Constructor XMLSignatureInputDebugger ... */getInputNodeSet(...)this.inclusiveNamespaces/** Method canonicalizeXPathNodeSet ... */int currentNodeTypegetPositionRelativeToDocumentElement(...)Attr[] attrs2Object[] attrs3Attr aboolean includedboolean inclusive/** Checks whether a Comment or ProcessingInstruction is before or after the ... */Element documentElementNode x/** Normalizes an {@link Attr}ibute value ... *//** Normalizes a {@link org.w3c.dom.Comment} value ... *//** Method outputTextToWriter ... */// get only a single node as anchor to fetch the owner document/* The XPath data model allows to select only the first of a ... */// we output all Attrs which are available// included and inclusive// included and not inclusive// excluded and inclusive// excluded and not inclusive// traversal/** An abstract representation of the result of dereferencing a ds:Reference URI. *//* Copyright (c) 2005, 2018, Oracle and/or its affiliates. All rights reserved. *//* $Id$ *//** An abstract representation of a {@code ReferenceData} type containing a node-set. *//** Returns a read-only iterator over the nodes contained in this ... *//** A representation of a {@code ReferenceData} type containing an OctetStream. */InputStream octetStream;/** Creates a new {@code ReferenceOctetStreamData}. ... */this.octetStream/** Returns the input stream of this {@code ReferenceOctetStreamData}. ... *//** Returns the URI String identifying the data object represented by this ... *//** Returns the MIME type associated with the data object represented by this ... *//** A representation of a {@code ReferenceNodeSetData} type containing a node-set. ... */Node root;new DelayedNodeIterator(...)ReferenceSubTreeData$DelayedNodeIterator/** This is an Iterator that contains a backing node-set that is ... */List<Node> nodeSet;ListIterator<Node> li;boolean withComments;this.withCommentsdereferenceSameDocumentURI(...)/** Dereferences a same-document URI fragment. ... */List<Node> nodeSetnodeSetMinusCommentNodes(...)/** Recursively traverses the subtree, and returns an XPath-equivalent ... */Node pSibling// emulate XPath which only returns the first node in// contiguous text/cdata nodes/** Constructor InvalidTransformException *//** Constructor InvalidTransformException ... */import TransformBase64Decodeimport TransformC14Nimport TransformC14N11import TransformC14N11_WithCommentsimport TransformC14NExclusiveimport TransformC14NExclusiveWithCommentsimport TransformC14NWithCommentsimport TransformEnvelopedSignatureimport TransformXPathimport TransformXPath2Filterimport TransformXSLTimport HelperNodeList/** Implements the behaviour of the {@code ds:Transform} element. ... */Transform.classnew ConcurrentHashMap<String,Class<? extends TransformSpi>>(...)Map<String,Class<? extends TransformSpi>> transformSpiHash;/** All available Transform classes are registered here */TransformSpi transformSpi;/** Generates a Transform object that implements the specified ... */HelperNodeList contextNodesnew HelperNodeList(...)initializeTransform(...)/** Constructs {@link Transform} ... */String algorithmURIClass<? extends TransformSpi> transformSpiClassConstants._TAG_TRANSFORMnew TransformationException(...)new InvalidTransformException(...)TransformSpi tmpInstantiationException ex/** Registers implementing class of the Transform algorithm with algorithmURI ... */Class<? extends TransformSpi> transformSpiTransforms.TRANSFORM_BASE64_DECODETransformBase64Decode.classTransformC14N.classTransformC14NWithComments.classTransformC14N11.classTransformC14N11_WithComments.classTransformC14NExclusive.classTransformC14NExclusiveWithComments.classTransforms.TRANSFORM_XPATHTransformXPath.classTransforms.TRANSFORM_ENVELOPED_SIGNATURETransformEnvelopedSignature.classTransforms.TRANSFORM_XSLTTransformXSLT.classTransforms.TRANSFORM_XPATH2FILTERTransformXPath2Filter.class/** Transforms the input, and generates {@link XMLSignatureInput} as output. ... */XMLSignatureInput resulttransformSpi.secureValidationenginePerformTransform(...)/** Initialize the transform object. */TransformSpi newTransformSpi// retrieve Algorithm Attribute from ds:Transform// give it to the current document/** Base class which all Transform algorithms extend. The common methods that ... *//** The mega method which MUST be implemented by the Transformation Algorithm. ... *//** Constructor TransformationException *//** Constructor TransformationException ... *//** Holder of the {@link com.sun.org.apache.xml.internal.security.transforms.Transform} steps to ... */Transforms.classString TRANSFORM_C14N_OMIT_COMMENTS;/** Canonicalization - Required Canonical XML (omits comments) */String TRANSFORM_C14N_WITH_COMMENTS;/** Canonicalization - Recommended Canonical XML with Comments */String TRANSFORM_C14N11_OMIT_COMMENTS;/** Canonicalization - Required Canonical XML 1.1 (omits comments) */String TRANSFORM_C14N11_WITH_COMMENTS;/** Canonicalization - Recommended Canonical XML 1.1 with Comments */String TRANSFORM_C14N_EXCL_OMIT_COMMENTS;/** Canonicalization - Required Exclusive Canonicalization (omits comments) */String TRANSFORM_C14N_EXCL_WITH_COMMENTS;/** Canonicalization - Recommended Exclusive Canonicalization with Comments */String TRANSFORM_XSLT;/** Transform - Optional XSLT */String TRANSFORM_BASE64_DECODE;/** Transform - Required base64 decoding */String TRANSFORM_XPATH;/** Transform - Recommended XPath */String TRANSFORM_ENVELOPED_SIGNATURE;/** Transform - Required Enveloped Signature */String TRANSFORM_XPOINTER;/** Transform - XPointer */String TRANSFORM_XPATH2FILTER;/** Transform - XPath Filter */...[] transforms;/** Constructs {@link Transforms}. ... *//** Constructs {@link Transforms} from {@link Element} which is ... */int numberOfTransformElems/** Adds the {@code Transform} with the specified <code>Transform ... */Transform transform/** Adds a user-provided Transform step. ... */Element transformElement/** Applies all included {@code Transform}s to xmlSignatureInput and ... */checkSecureValidation(...)/** Return the nonnegative number of transformations. ... */initTransforms(...)transforms.length/** Return the <i>i</i><sup>th</sup> {@code {@link Transform}}. ... */// At least one Transform element must be present. Bad.import Functionimport XPATHErrorResources/** The 'here()' function returns a node-set containing the attribute or ... *//** The here function returns a node-set containing the attribute or ... */Node xpathOwnerNodegetOwnerObject(...)int xpathOwnerNodeDTMgetCurrentNode(...)int docContextXNodeSet nodesNodeSetDTM nodeSetmutableNodeset(...)XPATHErrorResources.ER_CONTEXT_HAS_NO_OWNERDOCDocument currentDocDocument xpathOwnerDocint hereNodedetach(...)/** No arguments to process, so this does nothing. ... */// check whether currentNode and the node containing the XPath expression// are in the same document// returns a node-set containing the attribute /  processing instruction node// returns a node-set containing the parent element of the// text node that directly bears the XPath expression/** $todo$ Do I have to do this detach() call? */import TransformSpi/** Implements the {@code http://www.w3.org/2000/09/xmldsig#base64} decoding ... */String implementedTransformURI;/** Field implementedTransformURI */TransformBase64Decode.implementedTransformURI/** Method enginePerformTransform ... */new XMLSignatureInput(...)traverseElement(...)byte[] decodedBytesbyte[] base64Bytes//Exceptional case there is current not text case testing this(Before it was a//a common case)./** Implements the {@code http://www.w3.org/TR/2001/REC-xml-c14n-20010315} ... */TransformC14N.implementedTransformURICanonicalizer20010315OmitComments c14n/** Implements the {@code http://www.w3.org/2006/12/xml-c14n11} ... */Canonicalizer11_OmitComments c14n/** Implements the {@code http://www.w3.org/2006/12/xml-c14n-11#WithComments} ... */Canonicalizer11_WithComments c14nnew Canonicalizer11_WithComments(...)/** Class TransformC14NExclusive */Canonicalizer20010315ExclOmitComments c14nnew Canonicalizer20010315ExclOmitComments(...)/** Implements the {@code http://www.w3.org/TR/2001/REC-xml-c14n-20010315#WithComments} ... */Canonicalizer20010315ExclWithComments c14nnew Canonicalizer20010315ExclWithComments(...)Canonicalizer20010315WithComments c14nnew Canonicalizer20010315WithComments(...)/** Implements the {@code http://www.w3.org/2000/09/xmldsig#enveloped-signature} ... */Node signatureElementsearchSignatureElement(...)setExcludeNode(...)addNodeFilter(...)new EnvelopedNodeFilter(...)TransformEnvelopedSignature$EnvelopedNodeFilterNode exclude;isDescendantOrSelf(...)/** If the actual input is an octet stream, then the application MUST ... *///return !XMLUtils.isDescendantOrSelf(exclude, n);import XPathAPIimport XPathFactory/** Class TransformXPath ... */Element xpathElementConstants._TAG_XPATHNode xpathnodegetStrFromNode(...)XPathFactory xpathFactoryXPathAPI xpathAPIInstancenewXPathAPI(...)setNeedsToBeExpanded(...)needsCircumvent(...)new XPathNodeFilter(...)setNodeSet(...)DOMException exTransformXPath$XPathNodeFilterXPathAPI xPathAPI;Node xpathnode;Element xpathElement;String str;this.xpathnodethis.strthis.xpathElementthis.xPathAPIboolean includeObject[] eArgsimport XPath2FilterContainer/** Implements the <I>XML Signature XPath Filter v2.0</I> ... */List<NodeList> unionNodesnew ArrayList<NodeList>(...)List<NodeList> subtractNodesList<NodeList> intersectNodesElement[] xpathElementsXPath2FilterContainer.XPathFilter2NSXPath2FilterContainer._TAG_XPATH2Document inputDocxpathElements.lengthXPath2FilterContainer xpathContainergetXPathFilterTextNode(...)NodeList subtreeRootsselectNodeList(...)isIntersect(...)isSubtract(...)isUnion(...)new XPath2NodeFilter(...)TransformerException exboolean hasUnionFilter;boolean hasSubtractFilter;boolean hasIntersectFilter;Set<Node> unionNodes;Set<Node> subtractNodes;Set<Node> intersectNodes;int inSubtract;int inIntersect;int inUnion;this.unionNodesconvertNodeListToSet(...)this.subtractNodesthis.intersectNodesrooted(...)inList(...)/** Method rooted ... */Node rootNodenew HashSet<Node>(...)NodeList rootNodes//TODO OPTIMIZE/** Class TransformXPointer */Transforms.TRANSFORM_XPOINTER/** Class TransformXSLT ... */String XSLTSpecNS;String defaultXSLTSpecNSprefix;String XSLTSTYLESHEET;Element xsltElementTransformerFactory tFactorySource stylesheetDOMSource sourceStreamResult resultSource xmlSourceStreamResult outputTargetByteArrayOutputStream baos1TransformerConfigurationException ex// Process XSLT stylesheets in a secure manner/* This transform requires an octet stream as input. If the actual ... *//* This complicated transformation of the stylesheet itself is necessary ... */// Force Xalan to use \n as line separator on all OSes. This// avoids OS specific signature validation failures due to line// separator differences in the transformed output. Unfortunately,// this is not a standard JAXP property so will not work with non-Xalan// implementations.import TransformParam/** This Object serves as Content for the ds:Transforms for exclusive ... */String _TAG_EC_INCLUSIVENAMESPACES;/** Field _TAG_EC_INCLUSIVENAMESPACES */String _ATT_EC_PREFIXLIST;/** Field _ATT_EC_PREFIXLIST */String ExclusiveCanonicalizationNamespace;/** Field ExclusiveCanonicalizationNamespace *//** Constructor XPathContainer ... *//** Constructor InclusiveNamespaces ... */SortedSet<String> prefixListInclusiveNamespaces._ATT_EC_PREFIXLIST/** Method getInclusiveNamespaces ... *//** Decodes the {@code inclusiveNamespaces} String and returns all ... */SortedSet<String> prefixes/** Implements the parameters for the <A ... */XPath2FilterContainer._ATT_FILTER_VALUE_INTERSECTXPath2FilterContainer._ATT_FILTER_VALUE_SUBTRACTXPath2FilterContainer._ATT_FILTER_VALUE_UNIONString _ATT_FILTER;/** Field _ATT_FILTER */String _ATT_FILTER_VALUE_INTERSECT;/** Field _ATT_FILTER_VALUE_INTERSECT */String _ATT_FILTER_VALUE_SUBTRACT;/** Field _ATT_FILTER_VALUE_SUBTRACT */String _ATT_FILTER_VALUE_UNION;/** Field _ATT_FILTER_VALUE_UNION */String INTERSECT;/** Field INTERSECT */String SUBTRACT;/** Field SUBTRACT */String UNION;/** Field UNION */String _TAG_XPATH2;/** Field _TAG_XPATH2 */String XPathFilter2NS;/** Field XPathFiler2NS *//** Constructor XPath2FilterContainer *//** Constructor XPath2FilterContainer ... */XPath2FilterContainer._ATT_FILTERString filterStr/** Creates a new XPath2FilterContainer with the filter type "intersect". ... */new XPath2FilterContainer(...)/** Creates a new XPath2FilterContainer with the filter type "subtract". ... *//** Creates a new XPath2FilterContainer with the filter type "union". ... *//** Method newInstances ... */HelperNodeList nlString xpathXPath2FilterContainer c/** Creates a XPath2FilterContainer from an existing Element; needed for verification. ... *//** Returns {@code true} if the {@code Filter} attribute has value "intersect". ... *//** Returns {@code true} if the {@code Filter} attribute has value "subtract". ... *//** Returns {@code true} if the {@code Filter} attribute has value "union". ... *//** Returns the XPath 2 Filter String ... *//** Returns the first Text node which contains information from the XPath 2 ... *//** Constructor XPath2FilterContainer04 *//** Constructor XPath2FilterContainer04 ... */XPath2FilterContainer04._ATT_FILTERXPath2FilterContainer04._ATT_FILTER_VALUE_INTERSECTXPath2FilterContainer04._ATT_FILTER_VALUE_SUBTRACTXPath2FilterContainer04._ATT_FILTER_VALUE_UNION/** Creates a new XPath2FilterContainer04 with the filter type "intersect". ... */new XPath2FilterContainer04(...)/** Creates a new XPath2FilterContainer04 with the filter type "subtract". ... *//** Creates a new XPath2FilterContainer04 with the filter type "union". ... *//** Creates a XPath2FilterContainer04 from an existing Element; needed for verification. ... */XPath2FilterContainer04._TAG_XPATH2XPath2FilterContainer04.XPathFilter2NS/** This Object serves both as namespace prefix resolver and as container for ... *//** Sets the TEXT value of the {@code ds:XPath} Element. ... */Text xpathTextNode nodeToBeRemoved/** Returns the TEXT value of the {@code ds:XPath} Element. ... *//** Implements the parameters for a custom Transform which has a better performance ... */String TRANSFORM_XPATHFILTERCHGP;String _TAG_INCLUDE_BUT_SEARCH;String _TAG_EXCLUDE_BUT_SEARCH;String _TAG_EXCLUDE;String _TAG_XPATHCHGP;/** Field _TAG_XPATHCHGP */String _ATT_INCLUDESLASH;/** Field _ATT_INCLUDESLASH */boolean IncludeSlash;/** Field IncludeSlash */boolean ExcludeSlash;/** Field ExcludeSlash *//** Constructor XPathFilterCHGPContainer *//** Constructor XPathFilterCHGPContainer ... */XPathFilterCHGPContainer._ATT_INCLUDESLASHElement includeButSearchElemcreateElementForFamily(...)XPathFilterCHGPContainer._TAG_INCLUDE_BUT_SEARCHindentXPathText(...)Element excludeButSearchElemXPathFilterCHGPContainer._TAG_EXCLUDE_BUT_SEARCHElement excludeElemXPathFilterCHGPContainer._TAG_EXCLUDE/** Method indentXPathText ... *//** Creates a new XPathFilterCHGPContainer; needed for generation. ... */new XPathFilterCHGPContainer(...)/** Creates a XPathFilterCHGPContainer from an existing Element; needed for verification. ... *//** Method getXStr ... */Element xElem/** Method getIncludeButSearch ... */getXStr(...)/** Method getExcludeButSearch ... *//** Method getExclude ... *//** Method getIncludeSlashPolicy ... *//** Returns the first Text node which contains information from the XPath ... */selectNodeText(...)/** Method getHereContextNodeIncludeButSearch ... */getHereContextNode(...)/** Method getHereContextNodeExcludeButSearch ... *//** Method getHereContextNodeExclude ... */XPathFilterCHGPContainer._TAG_XPATHCHGPimport Base64DecodingException/** Implementation of MIME's Base64 encoding and decoding conversions. ... */int BASE64DEFAULTLENGTH;/** Field BASE64DEFAULTLENGTH *//** Returns a byte-array representation of a <code>{@link BigInteger}<code>. ... */byte[] bigBytesint startSrcint bigLenbigBytes.lengthint startDstbyte[] resizedBytes/** Encode in Base64 the given {@code {@link BigInteger}}. ... *//** Returns a byte-array representation of a {@code {@link BigInteger}}. ... *//** Method decodeBigIntegerFromElement ... *//** Decode a base 64 string into a {@link BigInteger} ... *//** This method takes an (empty) Element and a BigInteger and adds the ... */String encodedInt/** Method decode ... *//** Method encodeToElement ... */decodeInternal(...)/** Encode a byte array and fold lines at the standard 76th character unless ... *//** Base64 decode the lines from the reader and return an InputStream ... */byte[] retBytesUnsyncByteArrayOutputStream baosnew UnsyncByteArrayOutputStream(...)/** Encode a byte array in Base64 format and return an optionally ... *//** Encodes hex octets into Base64 ... */long lengthDataBitslong fewerThan24bitsint quartesPerLineint numberLinesint quartet/** Decodes Base64 data into octets ... */getBytesInternal(...)byte dataSbyte d3byte d4new Base64DecodingException(...)/** Decodes Base64 data into outputstream ... *//** Decodes Base64 data into  outputstream ... */int readbyte d1byte d2byte readed// we don't allow instantiation//round bitlen// some copying needed// no need to skip anything//valid length of the string// correct values// skip sign bit// valid length of the string//pad with leading nulls//encodedData[encodedIndex] = 0xa;//decodedData = new byte[ (numberQuadruple)*3];//first last bits.//the begin//byte decodedData[] = null;//  first last bits./** This class is extremely useful for loading classes in a fault ... *//** Provides all constants and some translation functions for i18n. ... */String configurationFile;/** Field configurationFile */String configurationFileNew;/** Field configurationFileNew */String exceptionMessagesResourceBundleDir;/** Field exceptionMessagesResourceBundleDir */String exceptionMessagesResourceBundleBase;/** Field exceptionMessagesResourceBundleBase is the location of the {@code ResourceBundle} */String SIGNATURESPECIFICATION_URL;/** The URL of the ... */String SignatureSpecNS;/** The namespace of the ... */String SignatureSpec11NS;String MoreAlgorithmsSpecNS;/** The URL for more algorithms * */String XML_DSIG_NS_MORE_07_05;/** The (newer) URL for more algorithms * */String XML_LANG_SPACE_SpecNS;/** The URI for XML spec */String NamespaceSpecNS;/** The URI for XMLNS spec */String _ATT_ALGORITHM;/** Tag of Attr Algorithm* */String _ATT_URI;/** Tag of Attr URI* */String _ATT_TYPE;/** Tag of Attr Type* */String _ATT_ID;/** Tag of Attr Id* */String _ATT_MIMETYPE;/** Tag of Attr MimeType* */String _ATT_ENCODING;/** Tag of Attr Encoding* */String _ATT_TARGET;/** Tag of Attr Target* */String _TAG_CANONICALIZATIONMETHOD;/** Tag of Element CanonicalizationMethod * */// SPKIData (SPKISexp)// PGPData ((PGPKeyID, PGPKeyPacket?) | (PGPKeyPacket))// X509IssuerSerial (X509IssuerName, X509SerialNumber)// X509Data ((X509IssuerSerial | X509SKI | X509SubjectName | X509Certificate)+ | X509CRL)// RetrievalMethod (Transforms?)// RSAKeyValue (Modulus, Exponent)// DSAKeyValue (P, Q, G, Y, J?, (Seed, PgenCounter)?)// KeyValue (DSAKeyValue|RSAKeyValue)// KeyInfo (KeyName|KeyValue|RetrievalMethod|X509Data|PGPData|SPKIData|MgmtData)String _TAG_DIGESTMETHOD;/** Tag of Element DigestMethod * */String _TAG_DIGESTVALUE;/** Tag of Element DigestValue * */String _TAG_MANIFEST;/** Tag of Element Manifest * */String _TAG_METHODS;/** Tag of Element Methods * */String _TAG_OBJECT;/** Tag of Element Object * */String _TAG_REFERENCE;/** Tag of Element Reference * */String _TAG_SIGNATURE;/** Tag of Element Signature * */String _TAG_SIGNATUREMETHOD;/** Tag of Element SignatureMethod * */String _TAG_HMACOUTPUTLENGTH;/** Tag of Element HMACOutputLength * */String _TAG_SIGNATUREPROPERTIES;/** Tag of Element SignatureProperties * */String _TAG_SIGNATUREPROPERTY;/** Tag of Element SignatureProperty * */String _TAG_SIGNATUREVALUE;/** Tag of Element SignatureValue * */String _TAG_SIGNEDINFO;/** Tag of Element SignedInfo * */String _TAG_TRANSFORM;/** Tag of Element Transform * */String _TAG_TRANSFORMS;/** Tag of Element Transforms * */String _TAG_XPATH;/** Tag of Element XPath * */String _TAG_KEYINFO;/** Tag of Element KeyInfo * */String _TAG_KEYNAME;/** Tag of Element KeyName * */String _TAG_KEYVALUE;/** Tag of Element KeyValue * */String _TAG_RETRIEVALMETHOD;/** Tag of Element RetrievalMethod * */String _TAG_X509DATA;/** Tag of Element X509Data * */String _TAG_PGPDATA;/** Tag of Element PGPData * */String _TAG_SPKIDATA;/** Tag of Element SPKIData * */String _TAG_MGMTDATA;/** Tag of Element MgmtData * */String _TAG_RSAKEYVALUE;/** Tag of Element RSAKeyValue * */String _TAG_E    W    