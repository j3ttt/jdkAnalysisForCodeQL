/Users/jettt/IdeaProjects/jdk_test/.idea/compiler.xml/Users/jettt/IdeaProjects/jdk_test/.idea/Users/jettt/IdeaProjects/jdk_test/Users/jettt/IdeaProjects/Users/jettt/Users/projectversion4componentnameCompilerConfigurationannotationProcessingprofileMaven default annotation processors profileenabledtruesourceOutputDirtarget/generated-sources/annotationssourceTestOutputDirtarget/generated-test-sources/test-annotationsoutputRelativeToContentRootvaluemodulejdk_testUTF-8/Users/jettt/IdeaProjects/jdk_test/.idea/encodings.xmlEncodingfileurlfile://$PROJECT_DIR$/src/main/javacharsetfile://$PROJECT_DIR$/src/main/resources/Users/jettt/IdeaProjects/jdk_test/.idea/jarRepositories.xmlRemoteRepositoriesConfigurationremote-repositoryoptionidcentralCentral Repositoryhttps://repo.maven.apache.org/maven2Maven Central repositoryhttps://repo1.maven.org/maven2jboss.communityJBoss Community repositoryhttps://repository.jboss.org/nexus/content/repositories/public//Users/jettt/IdeaProjects/jdk_test/.idea/libraries/lib.xml/Users/jettt/IdeaProjects/jdk_test/.idea/librarieslibraryTablelibrarylibCLASSESrootfile://$PROJECT_DIR$/src/main/resources/libJAVADOCSOURCESjarDirectoryrecursivefalse/Users/jettt/IdeaProjects/jdk_test/.idea/libraries/lib__2_.xmllib (2)NATIVE/Users/jettt/IdeaProjects/jdk_test/.idea/libraries/lib__3_.xmllib (3)/Users/jettt/IdeaProjects/jdk_test/.idea/misc.xmlExternalStorageConfigurationManagerMavenProjectsManageroriginalFileslist$PROJECT_DIR$/pom.xmlProjectRootManager2languageLevelJDK_1_8project-jdk-name1.8project-jdk-typeJavaSDKoutputfile://$PROJECT_DIR$/out/Users/jettt/IdeaProjects/jdk_test/.idea/workspace.xmlChangeListManagerdefault18cbae9c-ed65-4a8f-8d03-e9ffa7886802Default ChangelistcommentSHOW_DIALOGHIGHLIGHT_CONFLICTSHIGHLIGHT_NON_ACTIVE_CHANGELISTLAST_RESOLUTIONIGNOREMavenRunnerskipTestsProjectId2Ft62ENgcqil8vHmCcFMddj1ZpgProjectViewStatehideEmptyMiddlePackagesshowLibraryContentsPropertiesComponentpropertyRunOnceActivity.OpenProjectViewOnStartRunOnceActivity.ShowReadmeOnStartWebServerToolWindowFactoryStateaspect.path.notification.shownnode.js.detected.package.eslintnode.js.detected.package.tslintnode.js.path.for.package.eslintnode.js.path.for.package.tslintnode.js.selected.package.eslint(autodetect)node.js.selected.package.tslintnodejs_package_manager_pathnpmproject.structure.last.editedSDKsproject.structure.proportion0.15project.structure.side.proportion0.31264368settings.editor.selected.configurablereference.projectsettings.compiler.javacompilerSvnConfigurationconfigurationTaskManagertaskactiveDefaultsummaryDefault taskchangelistcreated1665298823766numberpresentableIdupdatedworkItemfrom1665298827286duration1107000166530052601664500016653012270684806000serversTypeScriptGeneratedFilesManagerWindowStateProjectServicestatewidth1358height210keyGridCell.Tab.0.bottomtimestamp1665305447381screenx0y231440877GridCell.Tab.0.bottom/0.23.1440.877@0.23.1440.877GridCell.Tab.0.center1665305447380GridCell.Tab.0.center/0.23.1440.877@0.23.1440.877GridCell.Tab.0.leftGridCell.Tab.0.left/0.23.1440.877@0.23.1440.877GridCell.Tab.0.rightGridCell.Tab.0.right/0.23.1440.877@0.23.1440.87721463SettingsEditor1665300753795SettingsEditor/0.23.1440.877@0.23.1440.877378201670675run.anything.popup1665304967585run.anything.popup/0.23.1440.877@0.23.1440.877443285vcs.readOnlyHandler.ReadOnlyStatusDialog1665303202656vcs.readOnlyHandler.ReadOnlyStatusDialog/0.23.1440.877@0.23.1440.877/Users/jettt/IdeaProjects/jdk_test/pom.xmlhttp://maven.apache.org/POM/4.0.0xsihttp://www.w3.org/2001/XMLSchema-instanceschemaLocationhttp://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsdmodelVersion4.0.0groupIdorg.exampleartifactId1.0-SNAPSHOTpropertiesproject.build.sourceEncodingmaven.compiler.encodingjava.versionmaven.compiler.sourcemaven.compiler.targetdependenciesdependencysun.javajava-runtime1.8.0java-tools/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/PortableActivationIDL/Activator.java/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/PortableActivationIDL/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/Users/jettt/IdeaProjects/jdk_test/src/main/java/Users/jettt/IdeaProjects/jdk_test/src/main/Users/jettt/IdeaProjects/jdk_test/srccom.sun.corba.se.PortableActivationIDLcom/sun/corba/se/PortableActivationIDL/Activator.java .Generated by the IDL-to-Java compiler (portable), version "3.2"from /jenkins/workspace/8-2-build-macosx-x86_64/jdk8u251/737/corba/src/share/classes/com/sun/corba/se/PortableActivationIDL/activation.idlThursday, March 12, 2020 2:38:17 AM PDT interface Activator/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/PortableActivationIDL/ActivatorHelper.java__typeCode/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/PortableActivationIDL/ActivatorHelper.class/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/PortableActivationIDL/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/Users/jettt/IdeaProjects/jdk_test/target/classes/com/Users/jettt/IdeaProjects/jdk_test/target/classes/Users/jettt/IdeaProjects/jdk_test/targetprivatestatic_id<clinit><clinit>()"IDL:PortableActivationIDL/Activator:1.0"IDL:PortableActivationIDL/Activator:1.0<nulltype>voidathatoutboolean"Activator"Activatoristreamjava.langClass<>/Users/jettt/IdeaProjects/jdk_test/target/classes/java/lang/Class.class/Users/jettt/IdeaProjects/jdk_test/target/classes/java/lang/Users/jettt/IdeaProjects/jdk_test/target/classes/javapublicfinalClass<_ActivatorStub>ostreamobjdelegatestubcom/sun/corba/se/PortableActivationIDL/ActivatorHelper.java ./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/PortableActivationIDL/ActivatorHolder.java<obinit><obinit>()initialValueiocom/sun/corba/se/PortableActivationIDL/ActivatorHolder.java ./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/PortableActivationIDL/ActivatorOperations.javaserverIdserverObjEndPointInfo[]lengthcloneclone()orbIdorbendPointInfopoaTemplateString[]orbAdapterNamecom/sun/corba/se/PortableActivationIDL/ActivatorOperations.java .A new ORB started server registers itself with the ActivatorA server is shutting down that was started by this activator.Complete termination of the server is detected by the death of theprocess implementing the server.Called whenever an ORB instance is created.  This registersthe transport endpoints and the ORB proxy callback object.Note that we cannot detect when an ORB shuts down, althoughall of the POA shutdowns should still be reported.Construct or find an ORBD object template corresponding to theserver's object template and return it.  Called whenever apersistent POA is created.Called whenever a POA is destroyed.If the server is not running, start it up.  This is allowedwhether or not the server has been installed.If the server is running, shut it downInvoke the server install hook.  If the server is notcurrently running, this method will activate it.Invoke the server uninstall hook.  If the server is notAfter this hook completes, the server may still be running.list active serverslist all registered ORBs for a serverFind the server template that corresponds to the ORBD'sadapter id. interface ActivatorOperations/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/PortableActivationIDL/BadServerDefinition.java_reason$reason"  "  com/sun/corba/se/PortableActivationIDL/BadServerDefinition.java . ctor class BadServerDefinition/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/PortableActivationIDL/BadServerDefinitionHelper.java__active/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/PortableActivationIDL/BadServerDefinitionHelper.class"IDL:PortableActivationIDL/BadServerDefinition:1.0"IDL:PortableActivationIDL/BadServerDefinition:1.0Class<TypeCode>StructMember[]_members0int1_tcOf_members0"reason"reason"BadServerDefinition"BadServerDefinitioncom/sun/corba/se/PortableActivationIDL/BadServerDefinitionHelper.java . read and discard the repository ID write the repository ID/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/PortableActivationIDL/BadServerDefinitionHolder.javacom/sun/corba/se/PortableActivationIDL/BadServerDefinitionHolder.java ./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/PortableActivationIDL/EndPointInfo.java_endpointType_portcom/sun/corba/se/PortableActivationIDL/EndPointInfo.java . class EndPointInfo/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/PortableActivationIDL/EndPointInfoHelper.java/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/PortableActivationIDL/EndPointInfoHelper.class"IDL:PortableActivationIDL/EndPointInfo:1.0"IDL:PortableActivationIDL/EndPointInfo:1.0"endpointType"endpointType"TCPPort"TCPPort"port"port"EndPointInfo"EndPointInfocom/sun/corba/se/PortableActivationIDL/EndPointInfoHelper.java ./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/PortableActivationIDL/EndPointInfoHolder.javacom/sun/corba/se/PortableActivationIDL/EndPointInfoHolder.java ./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/PortableActivationIDL/EndpointInfoListHelper.java/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/PortableActivationIDL/EndpointInfoListHelper.class"IDL:PortableActivationIDL/EndpointInfoList:1.0"IDL:PortableActivationIDL/EndpointInfoList:1.0"EndpointInfoList"EndpointInfoList_len0_o1_i0com/sun/corba/se/PortableActivationIDL/EndpointInfoListHelper.java .A list of endpoint information for a particular ORB./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/PortableActivationIDL/EndpointInfoListHolder.javacom/sun/corba/se/PortableActivationIDL/EndpointInfoListHolder.java ./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/PortableActivationIDL/IIOP_CLEAR_TEXT.java"IIOP_CLEAR_TEXT"IIOP_CLEAR_TEXTcom/sun/corba/se/PortableActivationIDL/IIOP_CLEAR_TEXT.java .Thursday, March 12, 2020 2:38:16 AM PDTPossible values for endpointType argument on Server.getEndpoint()If you change the value of this constant then updatecore.EndPoint accordingly.  It has a duplicate definitionto avoid a compilation dependency./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/PortableActivationIDL/InitialNameService.javacom/sun/corba/se/PortableActivationIDL/InitialNameService.java .Interface used to support binding references in the bootstrap nameservice. interface InitialNameService/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/PortableActivationIDL/InitialNameServiceHelper.java/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/PortableActivationIDL/InitialNameServiceHelper.class"IDL:PortableActivationIDL/InitialNameService:1.0"IDL:PortableActivationIDL/InitialNameService:1.0"InitialNameService"InitialNameServiceClass<_InitialNameServiceStub>com/sun/corba/se/PortableActivationIDL/InitialNameServiceHelper.java ./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/PortableActivationIDL/InitialNameServiceHolder.javacom/sun/corba/se/PortableActivationIDL/InitialNameServiceHolder.java ./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/PortableActivationIDL/InitialNameServiceOperations.javaisPersistantcom/sun/corba/se/PortableActivationIDL/InitialNameServiceOperations.java .bind initial name interface InitialNameServiceOperations/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/PortableActivationIDL/InitialNameServicePackage/NameAlreadyBound.java/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/PortableActivationIDL/InitialNameServicePackagecom.sun.corba.se.PortableActivationIDL.InitialNameServicePackagecom/sun/corba/se/PortableActivationIDL/InitialNameServicePackage/NameAlreadyBound.java . class NameAlreadyBound/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/PortableActivationIDL/InitialNameServicePackage/NameAlreadyBoundHelper.java/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/PortableActivationIDL/InitialNameServicePackage/NameAlreadyBoundHelper.class/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/PortableActivationIDL/InitialNameServicePackage"IDL:PortableActivationIDL/InitialNameService/NameAlreadyBound:1.0"IDL:PortableActivationIDL/InitialNameService/NameAlreadyBound:1.0"NameAlreadyBound"NameAlreadyBoundcom/sun/corba/se/PortableActivationIDL/InitialNameServicePackage/NameAlreadyBoundHelper.java ./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/PortableActivationIDL/InitialNameServicePackage/NameAlreadyBoundHolder.javacom/sun/corba/se/PortableActivationIDL/InitialNameServicePackage/NameAlreadyBoundHolder.java ./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/PortableActivationIDL/InvalidORBid.javacom/sun/corba/se/PortableActivationIDL/InvalidORBid.java . class InvalidORBid/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/PortableActivationIDL/InvalidORBidHelper.java/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/PortableActivationIDL/InvalidORBidHelper.class"IDL:PortableActivationIDL/InvalidORBid:1.0"IDL:PortableActivationIDL/InvalidORBid:1.0"InvalidORBid"InvalidORBidcom/sun/corba/se/PortableActivationIDL/InvalidORBidHelper.java ./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/PortableActivationIDL/InvalidORBidHolder.javacom/sun/corba/se/PortableActivationIDL/InvalidORBidHolder.java ./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/PortableActivationIDL/Locator.javacom/sun/corba/se/PortableActivationIDL/Locator.java . interface Locator/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/PortableActivationIDL/LocatorHelper.java/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/PortableActivationIDL/LocatorHelper.class"IDL:PortableActivationIDL/Locator:1.0"IDL:PortableActivationIDL/Locator:1.0"Locator"LocatorClass<_LocatorStub>com/sun/corba/se/PortableActivationIDL/LocatorHelper.java ./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/PortableActivationIDL/LocatorHolder.javacom/sun/corba/se/PortableActivationIDL/LocatorHolder.java ./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/PortableActivationIDL/LocatorOperations.javaendPointendPointTypelocationcom/sun/corba/se/PortableActivationIDL/LocatorOperations.java .locate server - returns the port with a specific type for all registeredORBs of an active server.Starts the server if it is not already running.locate server - returns all ports registered with a specified ORB foran active serverget the port for the endpoint of the locatorUseful from external BadServerIdHandlers which needto pick a particular port type. interface LocatorOperations/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/PortableActivationIDL/LocatorPackage/ServerLocationPerORB.java/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/PortableActivationIDL/LocatorPackagecom.sun.corba.se.PortableActivationIDL.LocatorPackage_hostname_portscom/sun/corba/se/PortableActivationIDL/LocatorPackage/ServerLocationPerORB.java . class ServerLocationPerORB/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/PortableActivationIDL/LocatorPackage/ServerLocationPerORBHelper.java/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/PortableActivationIDL/LocatorPackage/ServerLocationPerORBHelper.class/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/PortableActivationIDL/LocatorPackage"IDL:PortableActivationIDL/Locator/ServerLocationPerORB:1.0"IDL:PortableActivationIDL/Locator/ServerLocationPerORB:1.0"hostname"hostname"ports"ports"ServerLocationPerORB"ServerLocationPerORBcom/sun/corba/se/PortableActivationIDL/LocatorPackage/ServerLocationPerORBHelper.java ./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/PortableActivationIDL/LocatorPackage/ServerLocationPerORBHolder.javacom/sun/corba/se/PortableActivationIDL/LocatorPackage/ServerLocationPerORBHolder.java ./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/PortableActivationIDL/LocatorPackage/ServerLocationPerType.javaORBPortInfo[]com/sun/corba/se/PortableActivationIDL/LocatorPackage/ServerLocationPerType.java . class ServerLocationPerType/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/PortableActivationIDL/LocatorPackage/ServerLocationPerTypeHelper.java/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/PortableActivationIDL/LocatorPackage/ServerLocationPerTypeHelper.class"IDL:PortableActivationIDL/Locator/ServerLocationPerType:1.0"IDL:PortableActivationIDL/Locator/ServerLocationPerType:1.0"ORBPortInfoList"ORBPortInfoList"ServerLocationPerType"ServerLocationPerTypecom/sun/corba/se/PortableActivationIDL/LocatorPackage/ServerLocationPerTypeHelper.java ./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/PortableActivationIDL/LocatorPackage/ServerLocationPerTypeHolder.javacom/sun/corba/se/PortableActivationIDL/LocatorPackage/ServerLocationPerTypeHolder.java ./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/PortableActivationIDL/NoSuchEndPoint.javacom/sun/corba/se/PortableActivationIDL/NoSuchEndPoint.java . class NoSuchEndPoint/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/PortableActivationIDL/NoSuchEndPointHelper.java/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/PortableActivationIDL/NoSuchEndPointHelper.class"IDL:PortableActivationIDL/NoSuchEndPoint:1.0"IDL:PortableActivationIDL/NoSuchEndPoint:1.0"NoSuchEndPoint"NoSuchEndPointcom/sun/corba/se/PortableActivationIDL/NoSuchEndPointHelper.java ./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/PortableActivationIDL/NoSuchEndPointHolder.javacom/sun/corba/se/PortableActivationIDL/NoSuchEndPointHolder.java ./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/PortableActivationIDL/ORBAlreadyRegistered.java_orbIdcom/sun/corba/se/PortableActivationIDL/ORBAlreadyRegistered.java . class ORBAlreadyRegistered/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/PortableActivationIDL/ORBAlreadyRegisteredHelper.java/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/PortableActivationIDL/ORBAlreadyRegisteredHelper.class"IDL:PortableActivationIDL/ORBAlreadyRegistered:1.0"IDL:PortableActivationIDL/ORBAlreadyRegistered:1.0"ORBId"ORBId"orbId""ORBAlreadyRegistered"ORBAlreadyRegisteredcom/sun/corba/se/PortableActivationIDL/ORBAlreadyRegisteredHelper.java ./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/PortableActivationIDL/ORBAlreadyRegisteredHolder.javacom/sun/corba/se/PortableActivationIDL/ORBAlreadyRegisteredHolder.java ./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/PortableActivationIDL/ORBPortInfo.javacom/sun/corba/se/PortableActivationIDL/ORBPortInfo.java . class ORBPortInfo/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/PortableActivationIDL/ORBPortInfoHelper.java/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/PortableActivationIDL/ORBPortInfoHelper.class"IDL:PortableActivationIDL/ORBPortInfo:1.0"IDL:PortableActivationIDL/ORBPortInfo:1.0"ORBPortInfo"ORBPortInfocom/sun/corba/se/PortableActivationIDL/ORBPortInfoHelper.java ./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/PortableActivationIDL/ORBPortInfoHolder.javacom/sun/corba/se/PortableActivationIDL/ORBPortInfoHolder.java ./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/PortableActivationIDL/ORBPortInfoListHelper.java/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/PortableActivationIDL/ORBPortInfoListHelper.class"IDL:PortableActivationIDL/ORBPortInfoList:1.0"IDL:PortableActivationIDL/ORBPortInfoList:1.0com/sun/corba/se/PortableActivationIDL/ORBPortInfoListHelper.java .A list of ORB and port information for a particular endpoint type./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/PortableActivationIDL/ORBPortInfoListHolder.javacom/sun/corba/se/PortableActivationIDL/ORBPortInfoListHolder.java ./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/PortableActivationIDL/ORBProxy.javacom/sun/corba/se/PortableActivationIDL/ORBProxy.java .ORB callback interface, passed to Activator in registerORB method. interface ORBProxy/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/PortableActivationIDL/ORBProxyHelper.java/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/PortableActivationIDL/ORBProxyHelper.class"IDL:PortableActivationIDL/ORBProxy:1.0"IDL:PortableActivationIDL/ORBProxy:1.0"ORBProxy"ORBProxyClass<_ORBProxyStub>com/sun/corba/se/PortableActivationIDL/ORBProxyHelper.java ./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/PortableActivationIDL/ORBProxyHolder.javacom/sun/corba/se/PortableActivationIDL/ORBProxyHolder.java ./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/PortableActivationIDL/ORBProxyOperations.javacom/sun/corba/se/PortableActivationIDL/ORBProxyOperations.java .Method used to cause ORB to activate the named adapter, if possible.This will cause the named POA to register itself with the activator asa side effect.  This should always happen before this call can complete.This method returns true if adapter activation succeeded, otherwise itreturns false. interface ORBProxyOperations/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/PortableActivationIDL/ORBidListHelper.java/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/PortableActivationIDL/ORBidListHelper.class"IDL:PortableActivationIDL/ORBidList:1.0"IDL:PortableActivationIDL/ORBidList:1.0"ORBidList"ORBidListcom/sun/corba/se/PortableActivationIDL/ORBidListHelper.java .A list of ORB IDs./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/PortableActivationIDL/ORBidListHolder.javacom/sun/corba/se/PortableActivationIDL/ORBidListHolder.java ./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/PortableActivationIDL/Repository.javacom/sun/corba/se/PortableActivationIDL/Repository.java . interface Repository/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/PortableActivationIDL/RepositoryHelper.java/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/PortableActivationIDL/RepositoryHelper.class"IDL:PortableActivationIDL/Repository:1.0"IDL:PortableActivationIDL/Repository:1.0"Repository"RepositoryClass<_RepositoryStub>com/sun/corba/se/PortableActivationIDL/RepositoryHelper.java ./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/PortableActivationIDL/RepositoryHolder.javacom/sun/corba/se/PortableActivationIDL/RepositoryHolder.java ./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/PortableActivationIDL/RepositoryOperations.javaserverDefapplicationNamecom/sun/corba/se/PortableActivationIDL/RepositoryOperations.java .register server definition.This returns the serverId of the server.  A newly created server isalways uninstalled.unregister server definitionget server definitionReturn whether the server has been installedMark the server as being installed.  Raises ServerAlreadyInstalledif the server is currently marked as installed.Mark the server as being uninstalled.  Raises ServerAlreadyUninstalledif the server is currently marked as uninstalled.list registered serversReturns list of ALL applicationNames defined in ServerDefs of registeredservers.Find the ServerID associated with the given application name. interface RepositoryOperations/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/PortableActivationIDL/RepositoryPackage/AppNamesHelper.java/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/PortableActivationIDL/RepositoryPackagecom.sun.corba.se.PortableActivationIDL.RepositoryPackage/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/PortableActivationIDL/RepositoryPackage/AppNamesHelper.class/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/PortableActivationIDL/RepositoryPackage"IDL:PortableActivationIDL/Repository/AppNames:1.0"IDL:PortableActivationIDL/Repository/AppNames:1.0"AppNames"AppNamescom/sun/corba/se/PortableActivationIDL/RepositoryPackage/AppNamesHelper.java .Type used for a list of application names/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/PortableActivationIDL/RepositoryPackage/AppNamesHolder.javacom/sun/corba/se/PortableActivationIDL/RepositoryPackage/AppNamesHolder.java ./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/PortableActivationIDL/RepositoryPackage/ServerDef.java_applicationName_serverName_serverClassPath_serverArgs_serverVmArgs_isInstalledcom/sun/corba/se/PortableActivationIDL/RepositoryPackage/ServerDef.java . serverName values. Class name of server's main class. class path used to run the server. arguments passed to the server arguments passed to the server's Java VM1 class ServerDef/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/PortableActivationIDL/RepositoryPackage/ServerDefHelper.java/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/PortableActivationIDL/RepositoryPackage/ServerDefHelper.class"IDL:PortableActivationIDL/Repository/ServerDef:1.0"IDL:PortableActivationIDL/Repository/ServerDef:1.06"applicationName""serverName"serverName"serverClassPath"serverClassPath3"serverArgs"serverArgs"serverVmArgs"serverVmArgs5"isInstalled"isInstalled"ServerDef"ServerDefcom/sun/corba/se/PortableActivationIDL/RepositoryPackage/ServerDefHelper.java ./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/PortableActivationIDL/RepositoryPackage/ServerDefHolder.javacom/sun/corba/se/PortableActivationIDL/RepositoryPackage/ServerDefHolder.java ./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/PortableActivationIDL/ServerAlreadyActive.java_serverIdcom/sun/corba/se/PortableActivationIDL/ServerAlreadyActive.java . class ServerAlreadyActive/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/PortableActivationIDL/ServerAlreadyActiveHelper.java/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/PortableActivationIDL/ServerAlreadyActiveHelper.class"IDL:PortableActivationIDL/ServerAlreadyActive:1.0"IDL:PortableActivationIDL/ServerAlreadyActive:1.0"ServerId"ServerId"serverId""ServerAlreadyActive"ServerAlreadyActivecom/sun/corba/se/PortableActivationIDL/ServerAlreadyActiveHelper.java ./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/PortableActivationIDL/ServerAlreadyActiveHolder.javacom/sun/corba/se/PortableActivationIDL/ServerAlreadyActiveHolder.java ./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/PortableActivationIDL/ServerAlreadyInstalled.javacom/sun/corba/se/PortableActivationIDL/ServerAlreadyInstalled.java . class ServerAlreadyInstalled/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/PortableActivationIDL/ServerAlreadyInstalledHelper.java/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/PortableActivationIDL/ServerAlreadyInstalledHelper.class"IDL:PortableActivationIDL/ServerAlreadyInstalled:1.0"IDL:PortableActivationIDL/ServerAlreadyInstalled:1.0"ServerAlreadyInstalled"ServerAlreadyInstalledcom/sun/corba/se/PortableActivationIDL/ServerAlreadyInstalledHelper.java ./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/PortableActivationIDL/ServerAlreadyInstalledHolder.javacom/sun/corba/se/PortableActivationIDL/ServerAlreadyInstalledHolder.java ./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/PortableActivationIDL/ServerAlreadyRegistered.javacom/sun/corba/se/PortableActivationIDL/ServerAlreadyRegistered.java . class ServerAlreadyRegistered/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/PortableActivationIDL/ServerAlreadyRegisteredHelper.java/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/PortableActivationIDL/ServerAlreadyRegisteredHelper.class"IDL:PortableActivationIDL/ServerAlreadyRegistered:1.0"IDL:PortableActivationIDL/ServerAlreadyRegistered:1.0"ServerAlreadyRegistered"ServerAlreadyRegisteredcom/sun/corba/se/PortableActivationIDL/ServerAlreadyRegisteredHelper.java ./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/PortableActivationIDL/ServerAlreadyRegisteredHolder.javacom/sun/corba/se/PortableActivationIDL/ServerAlreadyRegisteredHolder.java ./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/PortableActivationIDL/ServerAlreadyUninstalled.javacom/sun/corba/se/PortableActivationIDL/ServerAlreadyUninstalled.java . class ServerAlreadyUninstalled/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/PortableActivationIDL/ServerAlreadyUninstalledHelper.java/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/PortableActivationIDL/ServerAlreadyUninstalledHelper.class"IDL:PortableActivationIDL/ServerAlreadyUninstalled:1.0"IDL:PortableActivationIDL/ServerAlreadyUninstalled:1.0"ServerAlreadyUninstalled"ServerAlreadyUninstalledcom/sun/corba/se/PortableActivationIDL/ServerAlreadyUninstalledHelper.java ./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/PortableActivationIDL/ServerAlreadyUninstalledHolder.javacom/sun/corba/se/PortableActivationIDL/ServerAlreadyUninstalledHolder.java ./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/PortableActivationIDL/ServerHeldDown.javacom/sun/corba/se/PortableActivationIDL/ServerHeldDown.java . class ServerHeldDown/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/PortableActivationIDL/ServerHeldDownHelper.java/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/PortableActivationIDL/ServerHeldDownHelper.class"IDL:PortableActivationIDL/ServerHeldDown:1.0"IDL:PortableActivationIDL/ServerHeldDown:1.0"ServerHeldDown"ServerHeldDowncom/sun/corba/se/PortableActivationIDL/ServerHeldDownHelper.java ./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/PortableActivationIDL/ServerHeldDownHolder.javacom/sun/corba/se/PortableActivationIDL/ServerHeldDownHolder.java ./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/PortableActivationIDL/ServerIdsHelper.java/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/PortableActivationIDL/ServerIdsHelper.class"IDL:PortableActivationIDL/ServerIds:1.0"IDL:PortableActivationIDL/ServerIds:1.0"ServerIds"ServerIdscom/sun/corba/se/PortableActivationIDL/ServerIdsHelper.java .Sequence of server Ids, used for queries about servers./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/PortableActivationIDL/ServerIdsHolder.javacom/sun/corba/se/PortableActivationIDL/ServerIdsHolder.java ./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/PortableActivationIDL/ServerManager.javacom/sun/corba/se/PortableActivationIDL/ServerManager.java .Interface used to combine the Activator and Locator when both areimplemented together in the same process, as is currently the casefor our implementation. interface ServerManager/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/PortableActivationIDL/ServerManagerHelper.java/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/PortableActivationIDL/ServerManagerHelper.class"IDL:PortableActivationIDL/ServerManager:1.0"IDL:PortableActivationIDL/ServerManager:1.0"ServerManager"ServerManagerClass<_ServerManagerStub>com/sun/corba/se/PortableActivationIDL/ServerManagerHelper.java ./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/PortableActivationIDL/ServerManagerHolder.javacom/sun/corba/se/PortableActivationIDL/ServerManagerHolder.java ./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/PortableActivationIDL/ServerManagerOperations.javacom/sun/corba/se/PortableActivationIDL/ServerManagerOperations.java . interface ServerManagerOperations/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/PortableActivationIDL/ServerNotActive.javacom/sun/corba/se/PortableActivationIDL/ServerNotActive.java . class ServerNotActive/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/PortableActivationIDL/ServerNotActiveHelper.java/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/PortableActivationIDL/ServerNotActiveHelper.class"IDL:PortableActivationIDL/ServerNotActive:1.0"IDL:PortableActivationIDL/ServerNotActive:1.0"ServerNotActive"ServerNotActivecom/sun/corba/se/PortableActivationIDL/ServerNotActiveHelper.java ./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/PortableActivationIDL/ServerNotActiveHolder.javacom/sun/corba/se/PortableActivationIDL/ServerNotActiveHolder.java ./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/PortableActivationIDL/ServerNotRegistered.javacom/sun/corba/se/PortableActivationIDL/ServerNotRegistered.java . class ServerNotRegistered/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/PortableActivationIDL/ServerNotRegisteredHelper.java/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/PortableActivationIDL/ServerNotRegisteredHelper.class"IDL:PortableActivationIDL/ServerNotRegistered:1.0"IDL:PortableActivationIDL/ServerNotRegistered:1.0"ServerNotRegistered"ServerNotRegisteredcom/sun/corba/se/PortableActivationIDL/ServerNotRegisteredHelper.java ./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/PortableActivationIDL/ServerNotRegisteredHolder.javacom/sun/corba/se/PortableActivationIDL/ServerNotRegisteredHolder.java ./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/PortableActivationIDL/ServerProxy.javacom/sun/corba/se/PortableActivationIDL/ServerProxy.java .Server callback interface, passed to Activator in registerServer method. interface ServerProxy/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/PortableActivationIDL/ServerProxyHelper.java/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/PortableActivationIDL/ServerProxyHelper.class"IDL:PortableActivationIDL/ServerProxy:1.0"IDL:PortableActivationIDL/ServerProxy:1.0"ServerProxy"ServerProxyClass<_ServerProxyStub>com/sun/corba/se/PortableActivationIDL/ServerProxyHelper.java ./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/PortableActivationIDL/ServerProxyHolder.javacom/sun/corba/se/PortableActivationIDL/ServerProxyHolder.java ./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/PortableActivationIDL/ServerProxyOperations.javacom/sun/corba/se/PortableActivationIDL/ServerProxyOperations.java .Shutdown this server.  Returns after orb.shutdown() completes.Install the server.  Returns after the install hook completesexecution in the server.Uninstall the server.  Returns after the uninstall hookcompletes execution. interface ServerProxyOperations/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/PortableActivationIDL/TCPPortHelper.java/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/PortableActivationIDL/TCPPortHelper.class"IDL:PortableActivationIDL/TCPPort:1.0"IDL:PortableActivationIDL/TCPPort:1.0com/sun/corba/se/PortableActivationIDL/TCPPortHelper.java .Type of TCP port number, used in structures that describetransport endpoints.  The valid range is actually 0-65535, butwe use a long here to avoid signed/unsigned conversion headachesin Java./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/PortableActivationIDL/_ActivatorImplBase.java__ids/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/PortableActivationIDL/_ActivatorImplBase.classjava.utilHashtable<>/Users/jettt/IdeaProjects/jdk_test/target/classes/java/util/Hashtable.class/Users/jettt/IdeaProjects/jdk_test/target/classes/java/utilDictionary<>/Users/jettt/IdeaProjects/jdk_test/target/classes/java/util/Dictionary.classabstractMap<>/Users/jettt/IdeaProjects/jdk_test/target/classes/java/util/Map.class_methodsHashtable<>()removeremove(java.lang.Object)putput(java.lang.Object,java.lang.Object)getget(java.lang.Object)Enumeration<>/Users/jettt/IdeaProjects/jdk_test/target/classes/java/util/Enumeration.classEnumeration<V>elementselements()Enumeration<K>keyskeys()isEmptyisEmpty()sizesize()DictionaryDictionary()Dictionary<>()? super V? extends Vjava.util.functionBiFunction<? super V,? super V,? extends V>/Users/jettt/IdeaProjects/jdk_test/target/classes/java/util/function/BiFunction.class/Users/jettt/IdeaProjects/jdk_test/target/classes/java/util/functionmergemerge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)BiFunction<>? super KBiFunction<? super K,? super V,? extends V>computecompute(java.lang.Object,java.util.function.BiFunction)computeIfPresentcomputeIfPresent(java.lang.Object,java.util.function.BiFunction)Function<? super K,? extends V>/Users/jettt/IdeaProjects/jdk_test/target/classes/java/util/function/Function.classcomputeIfAbsentcomputeIfAbsent(java.lang.Object,java.util.function.Function)Function<>replacereplace(java.lang.Object,java.lang.Object)replace(java.lang.Object,java.lang.Object,java.lang.Object)remove(java.lang.Object,java.lang.Object)putIfAbsentputIfAbsent(java.lang.Object,java.lang.Object)replaceAllreplaceAll(java.util.function.BiFunction)BiConsumer<? super K,? super V>/Users/jettt/IdeaProjects/jdk_test/target/classes/java/util/function/BiConsumer.classforEachforEach(java.util.function.BiConsumer)BiConsumer<>getOrDefaultgetOrDefault(java.lang.Object,java.lang.Object)hashCodehashCode()equalsequals(java.lang.Object)Set<>/Users/jettt/IdeaProjects/jdk_test/target/classes/java/util/Set.classCollection<>/Users/jettt/IdeaProjects/jdk_test/target/classes/java/util/Collection.classIterable<>/Users/jettt/IdeaProjects/jdk_test/target/classes/java/lang/Iterable.classEntry<K,V>/Library/Java/JavaVirtualMachines/jdk1.8.0_251.jdk/Contents/Home/jre/lib/rt.jar/Library/Java/JavaVirtualMachines/jdk1.8.0_251.jdk/Contents/Home/jre/lib/Library/Java/JavaVirtualMachines/jdk1.8.0_251.jdk/Contents/Home/jre/Library/Java/JavaVirtualMachines/jdk1.8.0_251.jdk/Contents/Home/Library/Java/JavaVirtualMachines/jdk1.8.0_251.jdk/Contents/Library/Java/JavaVirtualMachines/jdk1.8.0_251.jdk/Library/Java/JavaVirtualMachines/Library/Java/Library/Library/Java/JavaVirtualMachines/jdk1.8.0_251.jdk/Contents/Home/jre/lib/rt.jar/java/Library/Java/JavaVirtualMachines/jdk1.8.0_251.jdk/Contents/Home/jre/lib/rt.jar/java/util/Library/Java/JavaVirtualMachines/jdk1.8.0_251.jdk/Contents/Home/jre/lib/rt.jar/java/util/Map$Entry.classSet<Entry<K,V>>Collection<Entry<K,V>>Iterable<Entry<K,V>>entrySetentrySet()Collection<V>Iterable<V>valuesvalues()Set<K>Collection<K>Iterable<K>keySetkeySet()clearclear()? extends KMap<? extends K,? extends V>putAllputAll(java.util.Map)containsValuecontainsValue(java.lang.Object)containsKeycontainsKey(java.lang.Object)synchronizedtoStringtoString()rehashrehash()protectedcontainscontains(java.lang.Object)HashtableHashtable(java.util.Map)Hashtable<>(java.util.Map)Hashtable()Hashtable(int)Hashtable<>(int)floatHashtable(int,float)Hashtable<>(int,float)"registerServer"registerServer"serverGoingDown"serverGoingDown"registerORB"registerORB"registerPOA"registerPOA"poaDestroyed"poaDestroyed"activate"activate"shutdown"shutdown"install"install7"uninstall"uninstall8"getActiveServers"getActiveServers9"getORBNames"getORBNames10"lookupPOATemplate"lookupPOATemplate11$methodin$rh__method$ex$resultcom/sun/corba/se/PortableActivationIDL/_ActivatorImplBase.java . Constructors PortableActivationIDL/Activator/registerServer PortableActivationIDL/Activator/serverGoingDown PortableActivationIDL/Activator/registerORB PortableActivationIDL/Activator/registerPOA PortableActivationIDL/Activator/poaDestroyed PortableActivationIDL/Activator/activate PortableActivationIDL/Activator/shutdown PortableActivationIDL/Activator/install PortableActivationIDL/Activator/uninstall PortableActivationIDL/Activator/getActiveServers PortableActivationIDL/Activator/getORBNames PortableActivationIDL/Activator/lookupPOATemplate _invoke Type-specific CORBA::Object operations class _ActivatorImplBase/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/PortableActivationIDL/_ActivatorStub.javawriteObjectwriteObject(java.io.ObjectOutputStream)/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/PortableActivationIDL/_ActivatorStub.classreadObjectreadObject(java.io.ObjectInputStream)$in$out$rmsstrargspropscom/sun/corba/se/PortableActivationIDL/_ActivatorStub.java . registerServer serverGoingDown registerORB registerPOA poaDestroyed activate shutdown install uninstall getActiveServers getORBNames lookupPOATemplate class _ActivatorStub/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/PortableActivationIDL/_InitialNameServiceImplBase.java/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/PortableActivationIDL/_InitialNameServiceImplBase.class"bind"bindcom/sun/corba/se/PortableActivationIDL/_InitialNameServiceImplBase.java . PortableActivationIDL/InitialNameService/bind class _InitialNameServiceImplBase/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/PortableActivationIDL/_InitialNameServiceStub.java/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/PortableActivationIDL/_InitialNameServiceStub.classcom/sun/corba/se/PortableActivationIDL/_InitialNameServiceStub.java . bind class _InitialNameServiceStub/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/PortableActivationIDL/_LocatorImplBase.java/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/PortableActivationIDL/_LocatorImplBase.class"locateServer"locateServer"locateServerForORB"locateServerForORB"getEndpoint"getEndpoint"getServerPortForType"getServerPortForTypecom/sun/corba/se/PortableActivationIDL/_LocatorImplBase.java . PortableActivationIDL/Locator/locateServer PortableActivationIDL/Locator/locateServerForORB PortableActivationIDL/Locator/getEndpoint PortableActivationIDL/Locator/getServerPortForType class _LocatorImplBase/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/PortableActivationIDL/_LocatorStub.java/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/PortableActivationIDL/_LocatorStub.classcom/sun/corba/se/PortableActivationIDL/_LocatorStub.java . locateServer locateServerForORB getEndpoint getServerPortForType class _LocatorStub/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/PortableActivationIDL/_ORBProxyImplBase.java/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/PortableActivationIDL/_ORBProxyImplBase.class"activate_adapter"activate_adaptercom/sun/corba/se/PortableActivationIDL/_ORBProxyImplBase.java . PortableActivationIDL/ORBProxy/activate_adapter class _ORBProxyImplBase/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/PortableActivationIDL/_ORBProxyStub.java/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/PortableActivationIDL/_ORBProxyStub.classcom/sun/corba/se/PortableActivationIDL/_ORBProxyStub.java . activate_adapter class _ORBProxyStub/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/PortableActivationIDL/_RepositoryImplBase.java/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/PortableActivationIDL/_RepositoryImplBase.class"unregisterServer"unregisterServer"getServer"getServer"listRegisteredServers"listRegisteredServers"getApplicationNames"getApplicationNames"getServerID"getServerIDcom/sun/corba/se/PortableActivationIDL/_RepositoryImplBase.java . PortableActivationIDL/Repository/registerServer PortableActivationIDL/Repository/unregisterServer PortableActivationIDL/Repository/getServer PortableActivationIDL/Repository/isInstalled PortableActivationIDL/Repository/install PortableActivationIDL/Repository/uninstall PortableActivationIDL/Repository/listRegisteredServers PortableActivationIDL/Repository/getApplicationNames PortableActivationIDL/Repository/getServerID class _RepositoryImplBase/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/PortableActivationIDL/_RepositoryStub.java/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/PortableActivationIDL/_RepositoryStub.classcom/sun/corba/se/PortableActivationIDL/_RepositoryStub.java . unregisterServer getServer isInstalled listRegisteredServers getApplicationNames getServerID class _RepositoryStub/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/PortableActivationIDL/_ServerManagerImplBase.java/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/PortableActivationIDL/_ServerManagerImplBase.class12131415com/sun/corba/se/PortableActivationIDL/_ServerManagerImplBase.java . class _ServerManagerImplBase/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/PortableActivationIDL/_ServerManagerStub.java/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/PortableActivationIDL/_ServerManagerStub.classcom/sun/corba/se/PortableActivationIDL/_ServerManagerStub.java . class _ServerManagerStub/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/PortableActivationIDL/_ServerProxyImplBase.java/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/PortableActivationIDL/_ServerProxyImplBase.classcom/sun/corba/se/PortableActivationIDL/_ServerProxyImplBase.java . PortableActivationIDL/ServerProxy/shutdown PortableActivationIDL/ServerProxy/install PortableActivationIDL/ServerProxy/uninstall class _ServerProxyImplBase/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/PortableActivationIDL/_ServerProxyStub.java/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/PortableActivationIDL/_ServerProxyStub.classcom/sun/corba/se/PortableActivationIDL/_ServerProxyStub.java . class _ServerProxyStub/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/activation/CommandHandler.java/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/activation/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/implcom.sun.corba.se.impl.activationhelpTypecmdCopyright (c) 1997, 2002, Oracle and/or its affiliates. All rights reserved.ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.@authorRohit Garg@sinceJDK1.2/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/activation/NameServiceStartThread.javadbDir/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/activation/NameServiceStartThread.class/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/activation/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impltheOrbtheDirnameServicerootContexte"NameService did not start successfully"NameService did not start successfullyCopyright (c) 1999, 2003, Oracle and/or its affiliates. All rights reserved. REVISIT: After Merlin to see if we can get rid of this Thread and make the registration of PNameService for INS and BootStrap neat. start Name Service/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/activation/ORBD.javaString[][]orbServers/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/activation/ORBD.classdbDirNameprocessArgsprocessArgs(java.lang.String[])runrun(java.lang.String[])initSvcPort""acceptorHashtable<Object,Object>Dictionary<Object,Object>Map<Object,Object>Enumeration<Object>Dictionary<Object,Object>()? super Object? extends ObjectBiFunction<? super Object,? super Object,? extends Object>Function<? super Object,? extends Object>BiConsumer<? super Object,? super Object>Entry<Object,Object>Set<Entry<Object,Object>>Collection<Entry<Object,Object>>Iterable<Entry<Object,Object>>Collection<Object>Iterable<Object>Set<Object>Map<? extends Object,? extends Object>Hashtable<Object,Object>(java.util.Map)Hashtable<Object,Object>()Hashtable<Object,Object>(int)Hashtable<Object,Object>(int,float)"1000"1000"org.omg.CORBA.ORBClass"org.omg.CORBA.ORBClass"com.sun.corba.se.impl.orb.ORBImpl"com.sun.corba.se.impl.orb.ORBImplfirstRuntheThread"ORBD begins initialization."ORBD begins initialization.pollingTimestartupDelay"ORBD is ready."ORBD is ready."ORBD serverid: "ORBD serverid: "activation dbdir: "activation dbdir: "activation port: "activation port: "activation Server Polling Time: "activation Server Polling Time: " milli-seconds " milli-seconds "activation Server Startup Delay: "activation Server Startup Delay: cex"orbd.commfailure"orbd.commfailureiex"orbd.internalexception"orbd.internalexceptionex"orbd.usage"orbd.usage"orbd"orbd"-port"-port"-defaultdb"-defaultdb"-serverid"-serverid"-serverPollingTime"-serverPollingTime"-serverStartupDelay"-serverStartupDelaydefaultDbDirdirCreatedfileSep"file.separator"file.separatorlogDir"user.dir"user.dirserverMgrrepositoryactivatorserverCopyright (c) 1997, 2004, Oracle and/or its affiliates. All rights reserved. create a bootstrap server REVISIT: see ORBConfigurator. use factory in TransportDefault. For debugging.props.put( ORBConstants.DEBUG_PROPERTY, "naming" ) ;props.put( ORBConstants.DEBUG_PROPERTY, "transport,giop,naming" ) ; See Bug 4396928 for more information about why we are initializing the ORBClass to PIORB (now ORBImpl, but should check the bugid). parse the args and try setting the values for these properties orbd is being run the first time The following two lines start the Persistent NameServiceEnsure that the Db directory exists. If not, create the Dband the log directory and return true. Otherwise return false. determine the ORB db directory create the db and the logs directories create Initial Name Service object create Repository object create Locator and Activator objectsGo through the list of ORB Servers and initialize and startthem up.List of servers to be auto registered and started by the ORBd.Each server entry is of the form {id, name, path, args, vmargs}./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/activation/ProcessMonitorThread.javainterruptThreadinterruptThread()/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/activation/ProcessMonitorThread.classHashMap<>/Users/jettt/IdeaProjects/jdk_test/target/classes/java/util/HashMap.classAbstractMap<>/Users/jettt/IdeaProjects/jdk_test/target/classes/java/util/AbstractMap.classstartstart(java.util.HashMap)Iterator<>/Users/jettt/IdeaProjects/jdk_test/target/classes/java/util/Iterator.classcheckServerHealthcheckServerHealth(java.util.Iterator)ProcessMonitorThreadProcessMonitorThread(java.util.HashMap,int)instancesleepTimeserverTableServerTableSleepTimeserverListlongiteratoriterator()Spliterator<>/Users/jettt/IdeaProjects/jdk_test/target/classes/java/util/Spliterator.classSpliterator<T>spliteratorspliterator()? super TConsumer<? super T>/Users/jettt/IdeaProjects/jdk_test/target/classes/java/util/function/Consumer.classforEach(java.util.function.Consumer)Consumer<>Iterator<T>java.util.streamStream<>/Users/jettt/IdeaProjects/jdk_test/target/classes/java/util/stream/Stream.class/Users/jettt/IdeaProjects/jdk_test/target/classes/java/util/streamBaseStream<>/Users/jettt/IdeaProjects/jdk_test/target/classes/java/util/stream/BaseStream.classStream<E>BaseStream<E,Stream<E>>parallelStreamparallelStream()streamstream()Spliterator<E>?Collection<?>Iterable<?>retainAllretainAll(java.util.Collection)? super EPredicate<? super E>/Users/jettt/IdeaProjects/jdk_test/target/classes/java/util/function/Predicate.classremoveIfremoveIf(java.util.function.Predicate)Predicate<>removeAllremoveAll(java.util.Collection)? extends ECollection<? extends E>Iterable<? extends E>addAlladdAll(java.util.Collection)containsAllcontainsAll(java.util.Collection)addadd(java.lang.Object)Object[]TT[]toArraytoArray(java.lang.Object[])toArray()Iterator<E>transientAbstractMapAbstractMap()AbstractMap<>()internalWriteEntriesinternalWriteEntries(java.io.ObjectOutputStream)Node<K,V>/Library/Java/JavaVirtualMachines/jdk1.8.0_251.jdk/Contents/Home/jre/lib/rt.jar/java/util/HashMap$Node.classafterNodeRemovalafterNodeRemoval(java.util.HashMap.Node)Node<>Entry<>afterNodeInsertionafterNodeInsertion(boolean)afterNodeAccessafterNodeAccess(java.util.HashMap.Node)reinitializereinitialize()TreeNode<>/Library/Java/JavaVirtualMachines/jdk1.8.0_251.jdk/Contents/Home/jre/lib/rt.jar/java/util/HashMap$TreeNode.class/Library/Java/JavaVirtualMachines/jdk1.8.0_251.jdk/Contents/Home/jre/lib/rt.jar/java/util/LinkedHashMap$Entry.classTreeNode<K,V>replacementTreeNodereplacementTreeNode(java.util.HashMap.Node,java.util.HashMap.Node)newTreeNodenewTreeNode(int,java.lang.Object,java.lang.Object,java.util.HashMap.Node)replacementNodereplacementNode(java.util.HashMap.Node,java.util.HashMap.Node)newNodenewNode(int,java.lang.Object,java.lang.Object,java.util.HashMap.Node)capacitycapacity()loadFactorloadFactor()removeNoderemoveNode(int,java.lang.Object,java.lang.Object,boolean,boolean)Node[]Node<K,V>[]treeifyBintreeifyBin(java.util.HashMap.Node[],int)Node<>[]resizeresize()putValputVal(int,java.lang.Object,java.lang.Object,boolean,boolean)getNodegetNode(int,java.lang.Object)putMapEntriesputMapEntries(java.util.Map,boolean)HashMapHashMap(java.util.Map)HashMap<>(java.util.Map)HashMap()HashMap<>()HashMap(int)HashMap<>(int)HashMap(int,float)HashMap<>(int,float)thresholdmodCounttabletableSizeFortableSizeFor(int)Class<?>compareComparablescompareComparables(java.lang.Class,java.lang.Object,java.lang.Object)comparableClassForcomparableClassFor(java.lang.Object)hashhash(java.lang.Object)MIN_TREEIFY_CAPACITYUNTREEIFY_THRESHOLDTREEIFY_THRESHOLDDEFAULT_LOAD_FACTORMAXIMUM_CAPACITYDEFAULT_INITIAL_CAPACITYhasNexthasNext()Consumer<? super E>forEachRemainingforEachRemaining(java.util.function.Consumer)remove()nextnext()entryCopyright (c) 2001, 2003, Oracle and/or its affiliates. All rights reserved.ProcessMonitorThread is started when ServerManager is instantiated. Thethread wakes up every minute (This can be changed by setting sleepTime) andmakes sure that all the processes (Servers) registered with the ServerToolare healthy. If not the state in ServerTableEntry will be changed toDe-Activated.Note: This thread can be killed from the main thread by callinginterrupThread() Sleep's for a specified time, before checking the Servers health. This will repeat as long as the ServerManager (ORBD) is up and running. Check each ServerTableEntry to make sure that they are in the right state. Too late to complain, Just use the default sleepTime/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/activation/RepositoryImpl.javawrapper/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/activation/RepositoryImpl.classdbillegalServerIddebuggetDBServerDefgetDBServerDef(int)printServerDefprintServerDef(com.sun.corba.se.spi.activation.RepositoryPackage.ServerDef)RepositoryImplRepositoryImpl(com.sun.corba.se.spi.orb.ORB,java.io.File,boolean)serialVersionUID8458417785209341858L8458417785209341858dbFile"servers.db"servers.dbfisoissd"ServerDef[applicationName="ServerDef[applicationName=" serverName=" serverName=" serverClassPath=" serverClassPath=" serverArgs=" serverArgs=" serverVmArgs=" serverVmArgs="]"]theServerIdenumerationhasMoreElementshasMoreElements()nextElementnextElement()"RepositoryImpl: registerServer called " +
                            "to register ServerDef "RepositoryImpl: registerServer called to register ServerDef " with " with "a new server Id"a new server Id"server Id "server Id " FAILED because it is already registered." FAILED because it is already registered."RepositoryImpl: registerServer called " +
                                        "to register ServerDef "" with new serverId " with new serverId " with assigned serverId " with assigned serverId endpoint"main class not found."main class not found."no main method found."no main method found."server application error."server application error."unknown Exception."unknown Exception."RepositoryImpl: unregisterServer for serverId "RepositoryImpl: unregisterServer for serverId " called: server not registered" called: server not registered" called" called"RepositoryImpl: getServer for serverId "RepositoryImpl: getServer for serverId " returns " returns int[]sbctrchar' ' "RepositoryImpl: listRegisteredServers returns"RepositoryImpl: listRegisteredServers returnsresultserverIdsnextServerIddbServerDef"RepositoryImpl: getServerID for "RepositoryImpl: getServerID for " is " is Vector<>/Users/jettt/IdeaProjects/jdk_test/target/classes/java/util/Vector.classAbstractList<>/Users/jettt/IdeaProjects/jdk_test/target/classes/java/util/AbstractList.classAbstractCollection<>/Users/jettt/IdeaProjects/jdk_test/target/classes/java/util/AbstractCollection.classList<>/Users/jettt/IdeaProjects/jdk_test/target/classes/java/util/List.classvVector<>()AbstractCollectionAbstractCollection()AbstractCollection<>()subListsubList(int,int)ListIterator<>/Users/jettt/IdeaProjects/jdk_test/target/classes/java/util/ListIterator.classListIterator<E>listIteratorlistIterator(int)listIterator()lastIndexOflastIndexOf(java.lang.Object)indexOfindexOf(java.lang.Object)remove(int)add(int,java.lang.Object)setset(int,java.lang.Object)get(int)Comparator<? super E>/Users/jettt/IdeaProjects/jdk_test/target/classes/java/util/Comparator.classsortsort(java.util.Comparator)Comparator<>UnaryOperator<E>/Users/jettt/IdeaProjects/jdk_test/target/classes/java/util/function/UnaryOperator.classFunction<E,E>replaceAll(java.util.function.UnaryOperator)UnaryOperator<>addAll(int,java.util.Collection)removeRangeremoveRange(int,int)List<E>Collection<E>Iterable<E>AbstractListAbstractList()AbstractList<>()elementDataelementData(int)removeAllElementsremoveAllElements()removeElementremoveElement(java.lang.Object)addElementaddElement(java.lang.Object)insertElementAtinsertElementAt(java.lang.Object,int)removeElementAtremoveElementAt(int)setElementAtsetElementAt(java.lang.Object,int)lastElementlastElement()firstElementfirstElement()elementAtelementAt(int)lastIndexOf(java.lang.Object,int)indexOf(java.lang.Object,int)Enumeration<E>setSizesetSize(int)ensureCapacityensureCapacity(int)trimToSizetrimToSize()copyIntocopyInto(java.lang.Object[])VectorVector(java.util.Collection)Vector<>(java.util.Collection)Vector()Vector(int)Vector<>(int)Vector(int,int)Vector<>(int,int)capacityIncrementelementCountapps"RepositoryImpl: getApplicationNames returns "RepositoryImpl: getApplicationNames returns "-debug"-debugflushflush()/Library/Java/JavaVirtualMachines/jdk1.8.0_251.jdk/Contents/Home/jre/lib/rt.jar/com/Library/Java/JavaVirtualMachines/jdk1.8.0_251.jdk/Contents/Home/jre/lib/rt.jar/com/sun/Library/Java/JavaVirtualMachines/jdk1.8.0_251.jdk/Contents/Home/jre/lib/rt.jar/com/sun/corba/Library/Java/JavaVirtualMachines/jdk1.8.0_251.jdk/Contents/Home/jre/lib/rt.jar/com/sun/corba/se/Library/Java/JavaVirtualMachines/jdk1.8.0_251.jdk/Contents/Home/jre/lib/rt.jar/com/sun/corba/se/impl/Library/Java/JavaVirtualMachines/jdk1.8.0_251.jdk/Contents/Home/jre/lib/rt.jar/com/sun/corba/se/impl/activation/Library/Java/JavaVirtualMachines/jdk1.8.0_251.jdk/Contents/Home/jre/lib/rt.jar/com/sun/corba/se/impl/activation/RepositoryImpl$RepositoryDB.classincrementServerIdCounterincrementServerIdCounter()RepositoryDBRepositoryDB(java.io.File)serverIdCounter255256fosoos/Library/Java/JavaVirtualMachines/jdk1.8.0_251.jdk/Contents/Home/jre/lib/rt.jar/com/sun/corba/se/impl/activation/RepositoryImpl$DBServerDef.classvmArgsclassPathDBServerDefDBServerDef(com.sun.corba.se.spi.activation.RepositoryPackage.ServerDef,int)"DBServerDef(applicationName="DBServerDef(applicationName=", name=", name=", classPath=", classPath=", args=", args=", vmArgs=", vmArgs=", id=", id=", isInstalled=", isInstalled=")")server_id added serialver computed by the tool if databse does not exist, create it otherwise read it in export the repository check if server already registered generate a new server id add server def to the database verify that the entry is valid check to see if the server is registered remove server from the databaseTypically the Repositoy is created within the ORBd VM but it canbe independently started as well. See Bug 4396928 for more information about why we are initializing the ORBClass to PIORB (now ORBImpl, but see the bug). create the repository object wait for shutdown initialize the Server Id counter and hashtable. the lower id range is reserved for system servers/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/activation/ServerMain.javajava.ioregisterCallbackregisterCallback(java.lang.Class)/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/activation/ServerMain.classgetServerIdgetServerId()getNamedMethodgetNamedMethod(java.lang.Class,java.lang.String)isPublicStaticVoidisPublicStaticVoid(java.lang.reflect.Method)getMainMethodgetMainMethod(java.lang.Class)writeLogMessagewriteLogMessage(java.io.PrintStream,java.lang.String)redirectIOStreamsredirectIOStreams()"Server terminated normally"Server terminated normally"main class not found"main class not found"no main method"no main method"application error"application error"server ID not defined"server ID not defined"server registration failed"server registration failed"unknown error"unknown errorlogDirNamefoutStream".out".outferrStream".err".errpSoutpSerr"Server started"Server startedpstreammsgdate"["["] "] "\n"
"        "        "ERROR:  "ERROR:  code"FATAL:  "FATAL:  ": ": serverClassClass[]Class<>[]argTypesClass<String[]>methodClass<?>[]getDeclaredMethodgetDeclaredMethod(java.lang.String,java.lang.Class[])AnnotatedType[]getAnnotatedInterfacesgetAnnotatedInterfaces()getAnnotatedSuperclassgetAnnotatedSuperclass()classValueMap? extends AnnotationClass<? extends Annotation>Map<Class<? extends Annotation>,Annotation>getDeclaredAnnotationMapgetDeclaredAnnotationMap()getAnnotationTypegetAnnotationType()casAnnotationTypecasAnnotationType(sun.reflect.annotation.AnnotationType,sun.reflect.annotation.AnnotationType)Annotation[]getDeclaredAnnotationsgetDeclaredAnnotations()AA[]getDeclaredAnnotationsByTypegetDeclaredAnnotationsByType(java.lang.Class)Class<A>getDeclaredAnnotationgetDeclaredAnnotation(java.lang.Class)getAnnotationsgetAnnotations()getAnnotationsByTypegetAnnotationsByType(java.lang.Class)isAnnotationPresentisAnnotationPresent(java.lang.Class)getAnnotationgetAnnotation(java.lang.Class)U? extends UClass<? extends U>asSubclassasSubclass(java.lang.Class)Class<U>castcast(java.lang.Object)Map<String,T>enumConstantDirectoryenumConstantDirectory()getEnumConstantsSharedgetEnumConstantsShared()getEnumConstantsgetEnumConstants()isEnumisEnum()desiredAssertionStatusdesiredAssertionStatus()getConstantPoolgetConstantPool()nativebytebyte[]getExecutableTypeAnnotationBytesgetExecutableTypeAnnotationBytes(java.lang.reflect.Executable)getRawTypeAnnotationsgetRawTypeAnnotations()getRawAnnotationsgetRawAnnotations()getPrimitiveClassgetPrimitiveClass(java.lang.String)getProtectionDomaingetProtectionDomain()getResourcegetResource(java.lang.String)getResourceAsStreamgetResourceAsStream(java.lang.String)java.lang.reflectConstructor<>/Users/jettt/IdeaProjects/jdk_test/target/classes/java/lang/reflect/Constructor.class/Users/jettt/IdeaProjects/jdk_test/target/classes/java/lang/reflectConstructor<T>getDeclaredConstructorgetDeclaredConstructor(java.lang.Class[])getDeclaredFieldgetDeclaredField(java.lang.String)Constructor[]Constructor<>[]Constructor<?>Constructor<?>[]getDeclaredConstructorsgetDeclaredConstructors()Method[]getDeclaredMethodsgetDeclaredMethods()Field[]getDeclaredFieldsgetDeclaredFields()getDeclaredClassesgetDeclaredClasses()getConstructorgetConstructor(java.lang.Class[])getMethodgetMethod(java.lang.String,java.lang.Class[])getFieldgetField(java.lang.String)getConstructorsgetConstructors()getMethodsgetMethods()getFieldsgetFields()getClassesgetClasses()isMemberClassisMemberClass()isLocalClassisLocalClass()isAnonymousClassisAnonymousClass()getCanonicalNamegetCanonicalName()getTypeNamegetTypeName()getSimpleNamegetSimpleName()getEnclosingClassgetEnclosingClass()getDeclaringClassgetDeclaringClass()getEnclosingConstructorgetEnclosingConstructor()getEnclosingMethodgetEnclosingMethod()setSignerssetSigners(java.lang.Object[])getSignersgetSigners()getModifiersgetModifiers()getComponentTypegetComponentType()Type[]getGenericInterfacesgetGenericInterfaces()getInterfacesgetInterfaces()getPackagegetPackage()getGenericSuperclassgetGenericSuperclass()Class<? super T>getSuperclassgetSuperclass()TypeVariable[]TypeVariable<>/Users/jettt/IdeaProjects/jdk_test/target/classes/java/lang/reflect/TypeVariable.classTypeVariable<>[]TypeVariable<Class>TypeVariable<Class>[]getTypeParametersgetTypeParameters()getClassLoader0getClassLoader0()getClassLoadergetClassLoader()getNamegetName()isSyntheticisSynthetic()isAnnotationisAnnotation()isPrimitiveisPrimitive()isArrayisArray()isInterfaceisInterface()isAssignableFromisAssignableFrom(java.lang.Class)isInstanceisInstance(java.lang.Object)newInstancenewInstance()forNameforName(java.lang.String,boolean,java.lang.ClassLoader)forName(java.lang.String)toGenericStringtoGenericString()"main"mainexcmodifiers" is not public static" is not public static" declares exceptions" declares exceptionsClass<Void>" does not have a void return type" does not have a void return typemethodNameClass<ORB>serverClassNameclmainMethodserverVerifyFlagparams"class "class " found" found"Valid Server"Valid Server"ClassNotFound exception: "ClassNotFound exception: "Exception: "Exception: installMethoduninstallMethodshutdownMethod"false""exception "exception invokeMethodinvokeMethod(java.lang.reflect.Method)/Library/Java/JavaVirtualMachines/jdk1.8.0_251.jdk/Contents/Home/jre/lib/rt.jar/com/sun/corba/se/impl/activation/ServerCallback.classServerCallbackServerCallback(org.omg.CORBA.ORB,java.lang.reflect.Method,java.lang.reflect.Method,java.lang.reflect.Method)methodArgs"could not invoke "could not invoke " method: " method: "Shutdown starting"Shutdown starting"Shutdown completed"Shutdown completed"Install starting"Install starting"Install completed"Install completed"uninstall starting"uninstall starting"uninstall completed"uninstall completedCopyright (c) 1997, 2012, Oracle and/or its affiliates. All rights reserved.Ken CavanaughTODO:1.  Rewrite all uses of ORB properties to use constants from someplace.The strings are scattered between here, the ORB classes, andServerTableEntry.2.  Consider a more general log facility.3.  Remove ServerCallback from POAORB.4.  Needs to be merged with Harold's changes to support SSL.5.  Logs need to be internationalized. redirect out and err streamsWrite a time-stamped message to the indicated PrintStream.Write information to standard out only.Write error message to standard out and standard err.Write final message to log(s) and then terminate by callingSystem.exit( code ).  If code == OK, write a normal terminationmessage to standard out, otherwise write an abnormal terminationmessage to standard out and standard error. check modifiers: public static check return type and exceptions determine the class loader to be used for loading the class since ServerMain is going to be in JDK and we need to have this class to load application classes, this is required here. determine the main class determine the main class, try loading with current class loader eat the exception and try to load using SystemClassLoader get the main method This piece of code is required, to verify the server definition without launching it. verify the server build args to the main and call it NOTE: Very important to pass this property, otherwise the Persistent Server registration will be unsucessfull. shutdown the ORB and wait for completion/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/activation/ServerManagerImpl.javagetRunningEntrygetRunningEntry(int)/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/activation/ServerManagerImpl.classlocateServerForORB(com.sun.corba.se.impl.activation.ServerTableEntry,java.lang.String,boolean)locateServer(com.sun.corba.se.impl.activation.ServerTableEntry,java.lang.String,boolean)getEntrygetEntry(int)ServerManagerImplServerManagerImpl(com.sun.corba.se.spi.orb.ORB,com.sun.corba.se.spi.transport.CorbaTransportManager,com.sun.corba.se.spi.activation.Repository,java.lang.String,boolean)serverStartupDelayinitialPorttransportManagerdelaycls"ServerManagerImpl: activate for server Id "ServerManagerImpl: activate for server Id " failed because server is already active. " +
                                    "entry = " failed because server is already active. entry = "ServerManagerImpl: locateServer called with " +
                                " serverId="ServerManagerImpl: locateServer called with  serverId=" endpointType=" endpointType=" block=false" block=false" found location " found location " and activated it" and activated it"ServerManagerImpl: activate for server Id " +
                                    " threw NoSuchEndpoint exception, which was ignored"ServerManagerImpl: activate for server Id  threw NoSuchEndpoint exception, which was ignored"ServerManagerImpl: active for server Id "ServerManagerImpl: active for server Id " called, but no such server is registered." called, but no such server is registered." called.  This server is now active." called.  This server is now active.endpointList"ServerManagerImpl: registerEndpoint for server Id "ServerManagerImpl: registerEndpoint for server Id "ServerManagerImpl: registerEndpoints for server Id "ServerManagerImpl: registerEndpoints for server Id ArrayList<>/Users/jettt/IdeaProjects/jdk_test/target/classes/java/util/ArrayList.classArrayList<>(int)subListRangeChecksubListRangeCheck(int,int,int)ArrayListArrayList(java.util.Collection)ArrayList<>(java.util.Collection)ArrayList()ArrayList<>()ArrayList(int)"ServerManagerImpl: getActiveServers returns"ServerManagerImpl: getActiveServers returns"ServerManagerImpl: shutdown for server Id "ServerManagerImpl: shutdown for server Id " throws ServerNotActive." throws ServerNotActive." completed." completed." threw exception " threw exception "ServerManagerImpl: getEntry: " +
                                        "no active server found."ServerManagerImpl: getEntry: no active server found."ServerManagerImpl: getEntry: " +
                                        " active server found "ServerManagerImpl: getEntry:  active server found ".".blockserverORBAndPortListhostlistLength"ServerManagerImpl: locateServer: " +
                                        "server held down"ServerManagerImpl: locateServer: server held down"ServerManagerImpl: locateServer: " +
                                    "server located at location "ServerManagerImpl: locateServer: server located at location " ORBid  " ORBid  " Port " Port endpointInfoList"ServerManagerImpl: locateServerForORB: " +
                                        "server held down"ServerManagerImpl: locateServerForORB: server held down" endpointType  " endpointType  " block=true" block=true"ServerManagerImpl: locateServerForORB called with " +
                                " serverId="ServerManagerImpl: locateServerForORB called with  serverId=" orbId=" orbId=okeynewIORoktempclearPortlistenerPortsaddriptempiortemp"ServerManagerImpl: handle called for server id"ServerManagerImpl: handle called for server id"  orbid  "  orbid  "IDL:org/omg/CORBA/Object:1.0"IDL:org/omg/CORBA/Object:1.0"ServerManagerImpl: handle " +
                                "throws ForwardException"ServerManagerImpl: handle throws ForwardException"Exception = "Exception = Copyright (c) 1997, 2013, Oracle and/or its affiliates. All rights reserved.Hemanth Puttaswamy Using HashMap, since synchronization should be done by the calling routines REVISIT - NOT USED. The ServerStartupDelay is the delay added after the Server registers end point information. This is to allow the server to completely initialize after ORB is instantiated. Just use the default 1000 milliseconds as the default locate the server We call getEntry here so that state of the entry is checked for validity before we actually go and locate a server orbId is ignored for now unlike vectors, list is not synchronized get an entry all done collect the active entries if server location is desired, then wait for the server to register back, then return location this is to see if the server has any listeners passing in entry to eliminate multiple lookups for the same entry in some casesThis method is used to obtain the registered ports for an ORB.This is useful for custom Bad server ID handlers in ORBD. we need to get the serverid and the orbid from the object key get the ORBName corresponding to the orbMapid, that was first registered by the server we received a list of ports corresponding to an ORB in a particular server, now retrieve the one corresponding to IIOP_CLEAR_TEXT, and for other created the tagged components to be added to the IOR create a new IOR with the correct port and correct tagged components This delay is required in case of Server is activated or re-activated the first time. Server needs some time before handling all the requests. (Talk to Ken to see whether there is a better way of doing this)./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/activation/ServerTableEntry.java/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/activation/ServerTableEntry.classdestroydestroy()isActiveisActive()getORBListgetORBList()lookupForORBlookupForORB(java.lang.String)lookuplookup(java.lang.String)isValidisValid()checkProcessHealthcheckProcessHealth()deActivatedeActivate()holdDownholdDown()uninstall()install()registerPortsregisterPorts(java.lang.String,com.sun.corba.se.spi.activation.EndPointInfo[])registerregister(com.sun.corba.se.spi.activation.Server)activate()printDebugprintDebug(java.lang.String,java.lang.String)ServerTableEntryServerTableEntry(com.sun.corba.se.impl.logging.ActivationSystemException,int,com.sun.corba.se.spi.activation.RepositoryPackage.ServerDef,int,java.lang.String,boolean,boolean)pathSepjavaHomeactivationCmdactivateRetryCountprocessorbAndPortInfoActivationRetryMaxwaitTimeprintStateprintState()HELD_DOWNRUNNINGACTIVATEDACTIVATINGDE_ACTIVATED2000"java.home"java.home"java.class.path"java.class.path"path.separator"path.separator"UNKNOWN"UNKNOWN"DE_ACTIVATED""ACTIVATING  "ACTIVATING  "ACTIVATED   "ACTIVATED   "RUNNING     "RUNNING     "HELD_DOWN   "HELD_DOWN   "ServerTableEntry[" + "state="ServerTableEntry[state=" serverId=" serverId=" activateRetryCount=" activateRetryCount=verify"bin"bin"java "java " " +

            // add ORB properties
            "-Dioser=" -Dioser="ioser"ioser" " +
            "-D" -D"="="=true " +
            "-D"=true -D" ""-D"-D"=true "=true "-classpath "-classpath " com.sun.corba.se.impl.activation.ServerMain " com.sun.corba.se.impl.activation.ServerMain " -debug" -debug"ServerTableEntry constructed with activation command "ServerTableEntry constructed with activation command "Server being verified w/"Server being verified w/"verify""returns "returns "returns unknown error because of exception "returns unknown error because of exception "ServerTableEntry: method  ="ServerTableEntry: method  ="ServerTableEntry: server  ="ServerTableEntry: server  ="ServerTableEntry: state   ="ServerTableEntry: state   ="ServerTableEntry: message ="ServerTableEntry: message ="activating server"activating server"throwing premature process exit"throwing premature process exit"register""process registered back"process registered backnumListenerPortsserverListenerPorts"registering type: "registering type: "  port  "  port  "registerPorts""process registered Ports"process registered PortslocalServerObjlocalProcess"holdDown""server held down"server held down"deActivate""server deactivated"server deactivatedexitVale1"isValid""returns true"returns true"reactivating server"reactivating server"holding server down"holding server downorbAndPortListsetORBidsnumElements"lookup num-ports "lookup num-ports "   "   "lookup""throwing server held down error"throwing server held down errorportListorbList"destroy""server shutdown successfully"server shutdown successfully"server shutdown threw exception"server shutdown threw exception"process destroyed successfully"process destroyed successfully"process destroy threw exception"process destroy threw exceptionCopyright (c) 1997, 2003, Oracle and/or its affiliates. All rights reserved.Anita Jindal state of each entry get the string needed to make the activation command create a HashMap with capacity 255 Since all methods are synchronized, we don't need any additional synchronization mechanisms compute the activation command add path to the java vm add any arguments to the server Java VM add ORB properties we need to pass in the verify flag, so that the server is not launched, when we try to validate its definition during registration into the RepositoryImpl add classpath to the server add server class name and arguments Add the debug flag, if anyVerify whether the server definition is valid.state = RUNNING;notifyAll(); find if the ORB is already registered, then throw an exception store all listener ports and their types put this set of listener ports in the HashMap associated with the orbId _REVISIT_, If the state is not equal to ACTIVATED then it is a bug need to log that error, once the Logging framework is in place for rip-int. shutdown the server call the uninstall what kind of exception should be thrown If the State in the ServerTableEntry is RUNNING and the Process was shut down abnormally, The method will change the server state as De-Activated. Clear the PortInformation as it is old Move the state to De-Activated, So that the next call to this server will re-activate. get an entry corresponding to orbId return the port corresponding to the endpointType have everything in the table no element in HashMap corresponding to ORBid found ex.printStackTrace();/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/activation/ServerTool.javacom.sun.corba.se.spi.activationmaxNameLen/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/activation/ServerTool.classhandlersexecuteCommandexecuteCommand(java.lang.String[])printAvailableCommandsprintAvailableCommands()readCommandreadCommand(java.io.BufferedReader)getServerIdForAliasgetServerIdForAlias(org.omg.CORBA.ORB,java.lang.String)commandArgtoolNamehelpCommand"help"help"servertool"servertool"-cmd"-cmdcmdNameLenhandlerrepserveridcmdLenj"servertool.banner"servertool.banner"servertool.usage"servertool.usagetool" > " > cmdLinest"servertool.shorthelp"servertool.shorthelp"\t"	" - " - cmdArgsRegisterServerRegisterServer()/Library/Java/JavaVirtualMachines/jdk1.8.0_251.jdk/Contents/Home/jre/lib/rt.jar/com/sun/corba/se/impl/activation/RegisterServer.class"servertool.register"servertool.register"servertool.register1"servertool.register1classpathvmargsarg"-server"-server"-applicationName"-applicationName"-classpath"-classpath"-args"-args"-vmargs"-vmargs"servertool.register2"servertool.register2"servertool.register3"servertool.register3"servertool.register4"servertool.register4"servertool.baddef"servertool.baddef/Library/Java/JavaVirtualMachines/jdk1.8.0_251.jdk/Contents/Home/jre/lib/rt.jar/com/sun/corba/se/impl/activation/UnRegisterServer.classUnRegisterServerUnRegisterServer()"unregister"unregister"servertool.unregister"servertool.unregister"servertool.unregister1"servertool.unregister1"servertool.unregister2"servertool.unregister2"servertool.nosuchserver"servertool.nosuchserver/Library/Java/JavaVirtualMachines/jdk1.8.0_251.jdk/Contents/Home/jre/lib/rt.jar/com/sun/corba/se/impl/activation/LocateServer.classLocateServerLocateServer()"locate"locate"servertool.locate"servertool.locate"servertool.locate1"servertool.locate1locatornumEntries"-endpointType"-endpointType"servertool.locate2"servertool.locate2orbPort"\t\t"		"servertool.helddown"servertool.helddown/Library/Java/JavaVirtualMachines/jdk1.8.0_251.jdk/Contents/Home/jre/lib/rt.jar/com/sun/corba/se/impl/activation/LocateServerForORB.classLocateServerForORBLocateServerForORB()"locateperorb"locateperorb"servertool.locateorb"servertool.locateorb"servertool.locateorb1"servertool.locateorb1"-orbid"-orbid"servertool.locateorb2"servertool.locateorb2Port"servertool.nosuchorb"servertool.nosuchorbGetServerIDGetServerID()/Library/Java/JavaVirtualMachines/jdk1.8.0_251.jdk/Contents/Home/jre/lib/rt.jar/com/sun/corba/se/impl/activation/GetServerID.class"getserverid"getserverid"servertool.getserverid"servertool.getserverid"servertool.getserverid1"servertool.getserverid1"servertool.getserverid2"servertool.getserverid2sortServerssortServers(int[])/Library/Java/JavaVirtualMachines/jdk1.8.0_251.jdk/Contents/Home/jre/lib/rt.jar/com/sun/corba/se/impl/activation/ListServers.classprintServerDef(com.sun.corba.se.spi.activation.RepositoryPackage.ServerDef,int,java.io.PrintStream)ListServersListServers()"list""servertool.list"servertool.list"servertool.list1"servertool.list1listOneServer"servertool.list2"servertool.list2"\t   "	   "servertool.appname"servertool.appname"servertool.name"servertool.name"servertool.classpath"servertool.classpath"servertool.args"servertool.args"servertool.vmargs"servertool.vmargs"servertool.serverid"servertool.serveridlowesttempListActiveServersListActiveServers()/Library/Java/JavaVirtualMachines/jdk1.8.0_251.jdk/Contents/Home/jre/lib/rt.jar/com/sun/corba/se/impl/activation/ListActiveServers.class"listactive"listactive"servertool.listactive"servertool.listactive"servertool.listactive1"servertool.listactive1ListAliasesListAliases()/Library/Java/JavaVirtualMachines/jdk1.8.0_251.jdk/Contents/Home/jre/lib/rt.jar/com/sun/corba/se/impl/activation/ListAliases.class"listappnames"listappnames"servertool.listappnames"servertool.listappnames"servertool.listappnames1"servertool.listappnames1applicationNames"servertool.listappnames2"servertool.listappnames2/Library/Java/JavaVirtualMachines/jdk1.8.0_251.jdk/Contents/Home/jre/lib/rt.jar/com/sun/corba/se/impl/activation/ShutdownServer.classShutdownServerShutdownServer()"servertool.shutdown"servertool.shutdown"servertool.shutdown1"servertool.shutdown1"servertool.shutdown2"servertool.shutdown2"servertool.servernotrunning"servertool.servernotrunning/Library/Java/JavaVirtualMachines/jdk1.8.0_251.jdk/Contents/Home/jre/lib/rt.jar/com/sun/corba/se/impl/activation/StartServer.classStartServerStartServer()"startup"startup"servertool.startserver"servertool.startserver"servertool.startserver1"servertool.startserver1"servertool.startserver2"servertool.startserver2"servertool.serverup"servertool.serverupQuitQuit()/Library/Java/JavaVirtualMachines/jdk1.8.0_251.jdk/Contents/Home/jre/lib/rt.jar/com/sun/corba/se/impl/activation/Quit.class"quit"quit"servertool.quit"servertool.quit"servertool.quit1"servertool.quit1HelpHelp()/Library/Java/JavaVirtualMachines/jdk1.8.0_251.jdk/Contents/Home/jre/lib/rt.jar/com/sun/corba/se/impl/activation/Help.class"servertool.help"servertool.help"servertool.help1"servertool.help1/Library/Java/JavaVirtualMachines/jdk1.8.0_251.jdk/Contents/Home/jre/lib/rt.jar/com/sun/corba/se/impl/activation/ListORBs.classListORBsListORBs()"orblist"orblist"servertool.orbidmap"servertool.orbidmap"servertool.orbidmap1"servertool.orbidmap1"servertool.orbidmap2"servertool.orbidmap2"\t "	 "\tno such server found."	no such server found.JDK1.3 if command specified in the args, get it get the command create the POA ORB if command specified in the args, process it process commands interactively create a buffered reader to read commands from standard in print tool banner process commands until user quits print short help handle the help command print long help for a specific command determine the subcommand and execute it construct args to the command execute the command unknown command - print available commands determine longest command name parse register server command minimally the server class name has to be specified register server and activate it register the server with the repository activate the server print success message the server id has to be specified deactivate server, hold it down and and unregister it deactivate the server unregister the server from the repository parse command determine if list single server or all servers process the list server commandDo a simple bubble sort to sort the server ids in ascendingorder. process the list active servers command determine the server id startup the server/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/copyobject/CopierManagerImpl.java/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/copyobjectcom.sun.corba.se.impl.copyobject/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/copyobject/CopierManagerImpl.class/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/copyobjectmapdefaultIdfactoryCopyright (c) 2003, Oracle and/or its affiliates. All rights reserved./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/copyobject/FallbackObjectCopierImpl.javasecond/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/copyobject/FallbackObjectCopierImpl.classfirstsrcrceTrys a first ObjectCopier.  If the first throws a ReflectiveCopyException,falls back and tries a second ObjectCopier. XXX log this fallback at a low level/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/copyobject/JavaStreamObjectCopierImpl.java/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/copyobject/JavaStreamObjectCopierImpl.classos10000arris"Failed with exception:"Failed with exception:Copyright (c) 2004, Oracle and/or its affiliates. All rights reserved. Yes, so make sure it is connected and converted to a stub (if needed).../Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/copyobject/ORBStreamObjectCopierImpl.java/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/copyobject/ORBStreamObjectCopierImpl.class/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/copyobject/ReferenceObjectCopierImpl.java/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/corba/AnyImpl.java/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/corbacom.sun.corba.se.impl.corbagetPrimitiveTypeCodeForClassgetPrimitiveTypeCodeForClass(java.lang.Class,com.sun.corba.se.spi.orb.ORB)/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/corba/AnyImpl.class/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/corbacheckExtractBadOperationListcheckExtractBadOperationList(int[])checkExtractBadOperationcheckExtractBadOperation(int)getTCKindNamegetTCKindName(int)equalMemberequalMember(org.omg.CORBA.TypeCode,org.omg.CORBA.portable.InputStream,org.omg.CORBA.portable.InputStream)realTyperealType(org.omg.CORBA.TypeCode)realType()convertToNativeconvertToNative(com.sun.corba.se.spi.orb.ORB,org.omg.CORBA.Any)boolean[]isStreamedDEFAULT_BUFFER_SIZEisInitializedobjecttypeCode32theStreamaISjava.securityPrivilegedAction<>/Users/jettt/IdeaProjects/jdk_test/target/classes/java/security/PrivilegedAction.class/Users/jettt/IdeaProjects/jdk_test/target/classes/java/security/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/corba/AnyImpl$AnyOutputStream$1.classPrivilegedAction<AnyInputStream>run()()anyanyImplobjImplaTypebadtcotherAnycopyOfMyStreamcopyOfOtherStreamshortdoublememberTypemyStreamotherStreammineothermyDiscriminatorotherDiscriminatorrealTypeCodeImplmemberIndexbadKindboundsfinalorb/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/corba/AnyImpl$1.classPrivilegedAction<AnyOutputStream>kindobjholderlong[]longholder"UNKNOWN("UNKNOWN(expectedtcNameexpectedNamelfdbcidsClass<? extends Object>Map<String,? extends Object>? extends Object[]Constructor<? extends Object>? super ? extends ObjectClass<? super ? extends Object>TypeVariable<Class<? extends Object>>TypeVariable<Class<? extends Object>>[]"IDL:omg.org/CORBA/Object:1.0"IDL:omg.org/CORBA/Object:1.0p? extends SerializableClass<? extends Serializable>ttypebktcORBclassTCrepStrscomponentClassembeddedType"Sequence"SequenceClass<String>"StringValue"StringValueClass<Integer>Class<Byte>Class<Long>Class<Float>Class<Double>Class<Short>Class<Character>Comparable<>/Users/jettt/IdeaProjects/jdk_test/target/classes/java/lang/Comparable.classcompareTocompareTo(java.lang.Object)Class<Boolean>returnValueinputLicensed Materials - Property of IBMRMI-IIOP v1.0Copyright IBM Corp. 1998 1999  All Rights Reserved subclasses must provide a matching helper class Always valid. Validity depends upon typecode. The 'value' and 'object' instance members are used to hold immutable types as defined by the isStreamed[] table below. Otherwise, 'stream' is non-null and holds the value in CDR marshaled format. As an optimization, the stream type is an Any extension of CDR stream that is used to detect an optimization in read_value(). Setting the typecode via the type() accessor wipes out the value. An attempt to extract before the value is set will result in a BAD_OPERATION exception being raised.This boolean array tells us if a given typecode must bestreamed. Objects that are immutable don't have to be streamed. null void short long ushort ulong float double boolean char octet any TypeCode Principal objref struct union enum string sequence array alias except longlong ulonglong longdouble wchar wstring fixed value value_box (used to be true) native abstract interface/////////////////////////////////////////////////////////////////////////A constructor that sets the Any to contain a null. It also marksthe value as being invalid so that extractions throw an exceptionuntil an insertion has been performed. null is a valid value Create a new AnyImpl which is a copy of obj. basic accessorsreturns the type of the element contained in the Any.@resultthe TypeCode for the element in the Any Note: Indirect types are handled in kind() method impossiblesets the type of the element to be contained in the Any.@paramdebug.log ("type2"); set the typecode null is the only legal value this Any can have after resetting the type codechecks for equality between Anys.the Any to be compared with.true if the Anys are equal, false otherwise.debug.log ("equal"); first check for typecode equality. note that this will take aliases into account Resolve aliases here _REVISIT_ Possible optimization for the case where otherAny is a AnyImpl and the endianesses match. Need implementation of CDRInputStream.equals() For now we disable this to encourage testing the generic, unoptimized code below. Unfortunately this generic code needs to copy the whole stream at least once.    if (AnyImpl.isStreamed[realType.kind().value()]) {        if (otherAny instanceof AnyImpl) {            return ((AnyImpl)otherAny).stream.equals(stream);        }    } handle primitive types Too complicated to handle value types the way we handle other complex types above. Don't try to decompose it here for faster comparison, just use Object.equals(). Unspecified for Java Needed for equal() in order to achieve linear performance for complex types. Uses up (recursively) copies of the InputStream in both Anys that got created in equal(). just so that the two stream are in sync error resolving alias above accessors for marshaling/unmarshalingreturns an output stream that an Any value can be marshaled into.the OutputStream to marshal value of Any intodebug.log ("create_output_stream");returns an input stream that an Any value can be marshaled out of.the InputStream to marshal value of Any out of. We create a new InputStream so that multiple threads can call here and read the streams in parallel without thread safety problems.debug.log ("create_input_stream"); marshaling/unmarshaling routines If the InputStream is a CDRInputStream then we can copy the bytes since it is in our format and does not have alignment issues.debug.log ("read_value"); Assume that someone isn't going to think they can keep reading from this stream after calling us. That would be likely for an IIOPInputStream but if it is an AnyInputStream then they presumably obtained it via our create_output_stream() so they could write the contents of an IDL data type to it and then call create_input_stream() for us to read it. This is how Helper classes typically implement the insert() method. We should probably document this behavior in the 1.1 revision task force. could only have been created here We could optimize this by noticing whether the target stream has ever had anything marshaled on it that required an alignment of greater than 4 (was write_double() ever called on it). If not, then we can just do a byte array copy without having to drive the remarshaling through typecode interpretation.debug.log ("write_value"); _REVISIT_ check isInitialized whether all we write is TypeCode!takes a streamable and inserts its reference into the anythe streamable to insertdebug.log ("insert_Streamable");debug.log( "extract_Streamable" ) ; insertion/extraction/replacement for all basic typesSee the description of the <a href="#anyOps">general Any operations.</a>debug.log ("insert_short");debug.log ("extract_short");debug.log ("insert_long"); A long value is applicable to enums as well, so don't erase the enum type code in case it was initialized that way before.debug.log ("extract_long");debug.log ("insert_ushort");debug.log ("extract_ushort");debug.log ("insert_ulong");debug.log ("extract_ulong");debug.log ("insert_float");debug.log ("extract_float");debug.log ("insert_double");debug.log ("extract_double");debug.log ("insert_longlong");debug.log ("extract_longlong");debug.log ("insert_ulonglong");debug.log ("extract_ulonglong");debug.log ("insert_boolean");debug.log ("extract_boolean");debug.log ("insert_char");debug.log ("extract_char");debug.log ("insert_wchar");debug.log ("extract_wchar");debug.log ("insert_octet");debug.log ("extract_octet");debug.log ("insert_string"); Make sure type code information for bounded strings is not erased Check if bounded strings length is not exceededdebug.log ("extract_string");debug.log ("insert_wstring");debug.log ("extract_wstring");debug.log ("insert_any");debug.log ("extract_any");debug.log ("insert_Object");A variant of the insertion operation that takes a typecodeargument as well.debug.log ("insert_Object2");debug.log ("extract_Object"); Check if the object contained here is of the type in typeCodedebug.log ("insert_TypeCode");debug.log ("extract_TypeCode");@deprecatedNote that the Serializable really should be an IDLEntity ofsome kind.  It shouldn't just be an RMI-IIOP type.  Currently,we accept and will produce RMI repIds with the latestcalculations if given a non-IDLEntity Serializable.debug.log ("extract_Value");debug.log ("insert_Value"); See note in getPrimitiveTypeCodeForClass.  We have to use the latest type code fixes in this case since there is no way to know what ORB will actually send this Any.  In RMI-IIOP, when using Util.writeAny, we can do the versioning correctly, and use the insert_Value(Serializable, TypeCode) method. The ORB singleton uses the latest version.debug.log ("insert_Value2"); type isn't even of kind fixedUtility method for insert_Value and Util.writeAny.The ORB passed in should have the desired ORBVersion.  Itis used to generate the type codes. Look in the cache first All cases need to be able to create repository IDs. See bug 4391648 for more info about the tcORB in this case. Assertion: c instanceof Serializable? Arrays - may recurse for multi-dimensional arrays Strings Anything else We know that this is a TypeCodeImpl since it is our ORB Intruct classTC to store its buffer Update the cacheIt looks like this was copied from io.ValueUtility at somepoint.It's used by createTypeCodeForClass.  The tcORB passed inshould have the desired ORB version, and is used tocreate the type codes.debug.log ("getPrimitiveTypeCodeForClass"); For Merlin or later JDKs, or for foreign ORBs, we correctly say that a Java char maps to a CORBA wchar.  For backwards compatibility with our older ORBs, we say it maps to a CORBA char.  This is only used in RMI-IIOP in our javax.rmi.CORBA.Util delegate's writeAny method.  In Java IDL, there's no way to know the ORB version that the Any will be sent out with -- it could be different than the one used to create the Any -- so we use the most recent version (see insert_Value). _REVISIT_ Not sure if this is right. Extracts a member value according to the given TypeCode from the given complex Any (at the Anys current internal stream position, consuming the anys stream on the way) and returns it wrapped into a new Any This method could very well be moved into TypeCodeImpl or a common utility class, but is has to be in this package. There is no other way for DynAnys to find out whether the Any is initialized./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/corba/AnyImplHelper.java/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/corba/AnyImplHelper.class"IDL:omg.org/CORBA/Any:1.0"IDL:omg.org/CORBA/Any:1.0Copyright (c) 1999, 2002, Oracle and/or its affiliates. All rights reserved./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/corba/AsynchInvoke.java_notifyORB/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/corba/AsynchInvoke.class_orb_reqreqToInvokeOnn helper class for deferred invocationsThe AsynchInvoke class allows for the support of asynchronousinvocations. Instances of these are created with a request object,and when run, perform an invocation. The instance is alsoresponsible for waking up a client that might be waiting on the'get_response' method.The run operation calls the invocation on the request object,updates the RequestImpl state to indicate that the asynchronousinvocation is complete, and wakes up any client that might bewaiting on a 'get_response' call. do the actual invocation for the asynchronous case, note that the response has been received. update local boolean indicator notify any client waiting on a 'get_response'/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/corba/CORBAObjectImpl.javatypeids Bare implementation of CORBA Object./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/corba/ContextImpl.java/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/corba/ContextImpl.classparentpropNamepropValuestartScopeopFlagsCopyright (c) 1996, 2003, Oracle and/or its affiliates. All rights reserved./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/corba/ContextListImpl.java_contexts/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/corba/ContextListImpl.classCAPACITY_INCREMENTINITIAL_CAPACITYctxtindexCopyright (c) 1996, 2002, Oracle and/or its affiliates. All rights reserved. Note: This orb could be an instanceof ORBSingleton or ORB/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/corba/EnvironmentImpl.java_exc/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/corba/EnvironmentImpl.class/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/corba/ExceptionListImpl.java_exceptions/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/corba/ExceptionListImpl.class/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/corba/NVListImpl.java/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/corba/NVListImpl.class_namedValuesflagstmpValitemNameval Note: the size arg is only a hint of the size of the NVList./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/corba/NamedValueImpl.java/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/corba/NamedValueImpl.class_flags_value_name/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/corba/PrincipalImpl.java/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/corba/PrincipalImpl.class/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/corba/RequestImpl.java_paramObjects/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/corba/RequestImpl.class_paramLongs_paramCodes_wrapper_ctxList_ctx_resulttargetObjectctxoperationNameargumentListresultContainerexceptionListctxListnewCtxexceptionTypeinvokeObjectnvreturnAnyreturnTypeCopyright (c) 1996, 2004, Oracle and/or its affiliates. All rights reserved. data members invocation-specific stuff support for deferred invocations. protected instead of private since it needs to be set by the thread object doing the asynchronous invocation. constructor REVISIT - used to be protected.  Now public so it can be accessed from xgiop. initialize the orb initialize target, context and operation name initialize argument list if not passed in set result container. initialize exception list if not passed in initialize context list if not passed in initialize environment this method has to be synchronized even though it seems "readonly" since the thread object doing the asynchronous invocation can potentially update this variable in parallel. updates are currently simply synchronized againt the request object. release the lock. wait to be notified by the thread that is doing the asynchronous invocation. private helper methodsThe doInvocation operation is where the real mechanics ofperforming the request invocation is done. Initiate Client Portable Interceptors.  Inform the PIHandler that this is a DII request so that it knows to ignore the second inevitable call to initiateClientPIRequest in createRequest. Also, save the RequestImpl object for later use. Marshal args REVISIT - minor code. This is already handled in subcontract. REVISIT - uncomment.throw new INTERNAL(); NOTE: The exception should not be thrown. However, JDK 1.4 and earlier threw the exception, so we keep the behavior to be compatible. REVISIT -  make protected after development - so xgiop can get it. First unmarshal the return value if it is not void Now unmarshal the out/inout args Cannot happen since we only iterate till _arguments.count()/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/corba/ServerRequestImpl.java_exception/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/corba/ServerRequestImpl.class_resultAny_exceptionSet_resultSet_paramsCalled_ins_arguments_opNamereqresresult_tc booleans to check for various operation invocation restrictions if we support contexts, this would presumably also  be available on the server invocation unmarshal the value into the Any hang on to the NVList for marshaling the result check for invocation restrictions Notify portable interceptors of the result so that ServerRequestInfo.result() functions as desired. actual marshaling of the reply msg header and params takes place after the DSI returns control to the ORB. except can be called by the DIR at any time (CORBA 2.2 section 6.3). Ensure that the Any contains a SystemException or a UserException. If the UserException is not a declared exception, the client will get an UNKNOWN exception. Inform Portable interceptors of the exception that was set so sending_exception can return the right value. The user can only call arguments once and not at all after set_exception.  (internal flags ensure this).  However, the user can call set_exception multiple times.  Therefore, we only invoke receive_request the first time set_exception is called (if they haven't already called arguments). We need to invoke intermediate points here. actual marshaling of the reply msg header and exception takes placeThis is called from the ORB after the DynamicImplementation.invokereturns. Here we set the result if result() has not already been called.@returnthe exception if there is one (then ORB will not callmarshalReplyParams()) otherwise return null. Two things to be checked (CORBA 2.2 spec, section 6.3): 1. Unless it calls set_exception(), the DIR must call arguments()    exactly once, even if the operation signature contains    no parameters. 2. Unless set_exception() is called, if the invoked operation has a    non-void result type, set_result() must be called exactly once    before the DIR returns. normal invocation return Neither a result nor an exception has been set. Assume that the return type is void. If this is not so, the client will throw a MARSHAL exception while unmarshaling the return value.returns. Here we marshal the return value and inout/out params. marshal the operation return value marshal the inouts/outs/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/corba/TCUtility.javaunmarshalInunmarshalIn(org.omg.CORBA.portable.InputStream,org.omg.CORBA.TypeCode,long[],java.lang.Object[])/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/corba/TCUtility.classmarshalInmarshalIn(org.omg.CORBA.portable.OutputStream,org.omg.CORBA.TypeCode,long,java.lang.Object)0xFFFFL655350xFFFFFFFFL42949672950xFFLlaoabigDecimalCopyright (c) 1998, 2004, Oracle and/or its affiliates. All rights reserved.Static functions for TypeCode interpretation. nothing to write _REVISIT_ As soon as the java-rtf adds digits and scale parameters to OutputStream, this check will be unnecessary Nothing to read InputStream, this check will be unnecessary/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/corba/TypeCodeFactory.javatcimpl/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/corba/TypeCodeImpl.javaindentindent(int)/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/corba/TypeCodeImpl.classprintStreamprintStream(java.io.PrintStream,int)currentUnionMemberIndexcurrentUnionMemberIndex(org.omg.CORBA.Any)read_value_bodyread_value_body(org.omg.CORBA_2_3.portable.InputStream)read_value_kindread_value_kind(org.omg.CORBA_2_3.portable.InputStream)read_value_kind(com.sun.corba.se.impl.encoding.TypeCodeReader)read_value_recursiveread_value_recursive(com.sun.corba.se.impl.encoding.TypeCodeInputStream)lazy_content_typelazy_content_type()getParentAtLevelgetParentAtLevel(int)setParentsetParent(com.sun.corba.se.impl.corba.TypeCodeImpl)setIdsetId(java.lang.String)setIndirectTypesetIndirectType(com.sun.corba.se.impl.corba.TypeCodeImpl)tryIndirectTypetryIndirectType()indirectTypeindirectType()cachingEnabledoutBuffer_indirectType_parentOffset_parentshort[]_memberAccess_concrete_base_type_modifier_scale_digits_contentType_length_defaultIndex_discriminatorAnyImpl[]_unionLabelsTypeCodeImpl[]_memberTypes_memberNames_memberCount_kindkindNamestypeTableCOMPLEXSIMPLEEMPTY0xFFFFFFFF-1"null"null"void""short""long""ushort"ushort"ulong"ulong"float""double""boolean""char""octet"octet"any""typecode"typecode"principal"principal"objref"objref"struct"struct"union"union"enum"enum"string"string"sequence"sequence"array"array"alias"alias"exception"exception"longlong"longlong"ulonglong"ulonglong"longdouble"longdouble"wchar"wchar"wstring"wstring"fixed"fixed"value""valueBox"valueBox"native""abstractInterface"abstractInterfacetcitccbcreationKind"Object"ObjectmembersUnionMember[]discriminator_typeValueMember[]type_modifierconcrete_baseoriginal_typeboundelement_typeoffsetdigitsscaletcosnewTypenewIDlevelrealParentmyRealTypeotherRealTypemyIDotherIDmyKindtcismyPositiontopStreamstreamOffsettopPosindirectTypePosition_encapwrapperOutStreamposdstseqLengthtmptagValuelabelIndexdiscriminatorValue"TypeCodeImpl with kind "TypeCodeImpl with kind " and id " and id byteOut1024printOut" =\n" =
"indirect "indirect " = {" = {"<unknown type>"<unknown type>";";"}"}"union "union "..."..."enum "enum "unbounded string "unbounded string "bounded string("bounded string(") ") "alias "alias " = " = "<unresolved>"<unresolved>"wstring["wstring["fixed("fixed(", ", "valueBox "valueBox "abstractInterface "abstractInterface enableCachingCopyright (c) 1996, 2013, Oracle and/or its affiliates. All rights reserved. no chance of subclasses, so no problems with runtime helper lookupstatic final boolean debug = false; the indirection TCKind, needed for recursive typecodes. typecode encodings have three different categories that determine how the encoding should be done. no parameters simple parameters. complex parameters. need to use CDR encapsulation for parameters a table storing the encoding category for the various typecodes. tk_null tk_void tk_short tk_long tk_ushort tk_ulong tk_float tk_double tk_boolean tk_char tk_octet tk_any tk_typecode tk_principal tk_objref tk_struct tk_union tk_enum tk_string tk_sequence tk_array tk_alias tk_except tk_longlong tk_ulonglong tk_longdouble tk_wchar tk_wstring tk_fixed tk_value tk_value_box tk_native tk_abstract_interface Maps TCKind values to names This is also used in AnyImpl. the typecode kind data members for representing the various kinds of typecodes. the typecode repository id the typecode name member count names of members types of members values of union labels union discriminator type union default index string/seq/array length seq/array/alias type value type _REVISIT_ We might want to keep references to the ValueMember classes passed in at initialization instead of copying the relevant data. Is the data immutable? What about StructMember, UnionMember etc.? VM_NONE, VM_CUSTOM, VM_ABSTRACT, VM_TRUNCATABLE concrete base type visibility of ValueMember recursive sequence support the enclosing type code the level of enclosure recursive type code support caches the byte buffer written in write_value for quick remarshaling... ... but only if caching is enabled the ORB instance: may be instanceof ORBSingleton or ORB Constructors... initialized to tk_null to handle conversion of "remote" typecodes into "native" style. also see the 'convertToNative(ORB orb, TypeCode tc)' function This is a protection against misuse of this constructor. Should only be used if tc is not an instance of this class! Otherwise we run into problems with recursive/indirect type codes. _REVISIT_ We should make this constructor private set up kind set up parameters concrete base may be null_memberAccess = tc._memberAccess; Need to reconstruct _memberAccess using member_count() and member_visibility() set up member types set up member names set up member count set up stuff for unions set up length set up content type dont have to worry about these since code ensures we dont step out of bounds. for primitive types private API. dont bother checking that     (creationKind < 0 || creationKind > typeTable.length) do initialization for special cases this is being used to create typecode for CORBA::Object for structs and exceptions else initializes to null for unions check whether this is the default branch. for value types for enums for aliases and value boxes for strings for sequences and arrays for recursive sequences for recursive type codes This is the type code of the type we stand in for, not our own. Try to resolve it now. May return null in which case we try again later (see indirectType()). for fixedif (digits < 1 || digits > 31)throw new BAD_TYPECODE(); Other creation functions... Optimization: If we checked for and returned constant primitive typecodes here we could reduce object creation and also enable more efficient typecode comparisons for primitive typecodes.if (debug) System.out.println("Created TypeCodeOutputStream " + tcos + " with no parent"); Support for indirect/recursive type codes Nothing we can do about that. Assert that _kind == tk_indirect can't happen check whether return value != this which would indicate that the repository id isn't unique. This is an unresolved recursive sequence tc. Try to resolve it now if the hierarchy is complete. Create a recursive type code object as the content type. This is when the recursive sequence typecode morphes into a sequence typecode containing a recursive typecode. Other private functions TypeCode operations _REVISIT_ for all optional names/ids, we might want to check that they are equal in case both are non-nil.return indirectType().equal(tc); make sure kinds are identical. no parameters to check. check for bound. check for logical id. ignore name since its optional. check for member count check for repository id check for member types. ignore id and names since those are optional. check for default index check for discriminator type check for label types and values check for branch types check member count ignore names since those are optional. check bound/length check content type ignore id and name since those are optional. concrete_base may be null check for equality with the true type dont have to worry about these since the code ensures these dont arise.The equivalent operation is used by the ORB when determining type equivalencefor values stored in an IDL any. If the result of the kind operation on either TypeCode is tk_alias, recursively replace the TypeCode with the result of calling content_type, until the kind is no longer tk_alias. Note: Always resolve indirect types first! If results of the kind operation on each typecode differ, equivalent returns false. At this point the id operation is valid for both TypeCodes. Return true if the results of id for both TypeCodes are non-empty strings and both strings are equal. If both ids are non-empty but are not equal, then equivalent returns FALSE. id operation is not valid for either or both TypeCodes If either or both id is an empty string, or the TypeCode kind does not support the id operation, perform a structural comparison of the TypeCodes. impossible if we checked correctly above Structural comparison succeeded! _REVISIT_ It isn't clear whether this method should operate on this or a copy. For now just return this unmodified because the name and member_name fields aren't used for comparison anyways. Recursive is the only form of indirect type codes right now. Indirection can also be used for repeated type codes.return indirectType().id(); // same as _id exception and objref typecodes must have a repository id. structs, unions, enums, and aliases may or may not. all other typecodes throw the BadKind exception. _REVISIT_ Why create a new Any for this? hardly possible unless caller knows our "private" stream classes.if (debug) System.out.println("Created WrapperInputStream " + wrapper + don't wrap a CDRInputStream reading "inner" TypeCodes. Bug fix 5034649: allow for padding that precedes the typecode kind. check validity of kind Don't do any work if this is native We have to remember the stream and position for EVERY type code in case some recursive or indirect type code references it. The encoding used for indirection is the same as that used for recursive , TypeCodes i.e., a 0xffffffff indirection marker followed by a long offset (in units of octets) from the beginning of the long offset. substract 4 to get back to the beginning of the long offset. Now we have to find the referenced type by its indirectTypePosition within topStream.if (debug) System.out.println( "TypeCodeImpl looking up indirection at position topPos " +topPos + " - 4 + offset " + streamOffset + " = " + indirectTypePosition); unmarshal the kind start unmarshaling the rest of the typecode, based on the encoding (empty, simple or complex). nothing to unmarshal get the repository id get the name discriminant typecode default index get the number of members create arrays for the label values, names and types of members read off label values, names and types for the default case, read off the zero octet _REVISIT_ figure out long double mapping case TCKind.tk_longdouble: _unionLabels[i].insert_longdouble(_encap.getDouble()); break; create arrays for the identifier names read off identifier names get the type of the sequence get the bound on the length of the sequence get the type of the array get the length of the array get the type aliased create arrays for the names and types of members read off member names and typesif (debug) System.out.println("TypeCode " + _name + " reading member " + _memberNames[i]); get the type modifier create arrays for the names, types and visibility of members read off value member visibilities Wrap OutputStream into TypeCodeOutputStream. This test shouldn't be necessary according to the Java language spec. Cache the buffer for repeated writesif (outBuffer != null)System.out.println("Caching outBuffer with length = " +outBuffer.length + " for id = " + _id);System.out.println("Using cached outBuffer: length = " + outBuffer.length +", id = " + _id); Write the first 4 bytes first to trigger alignment. We know that it is the kind.System.out.println("Buffer is empty for " + _id);if (debug) tcos.printBuffer();if (debug) System.out.println("Writing indirection " + _name + "to " + _id);if (debug) System.out.println("TypeCodeImpl " + tcos + " writing indirection " + _id +" to position " + pos + " at position " + topPos); All that gets written is _kind and offset. The original approach changed for 5034649 topStream.addIDAtPosition(_id, tcos.getTopLevelPosition()); marshal the kindif (debug) System.out.println("Writing " + _name + " with id " + _id); Bug fix 5034649: Do this AFTER the write of the _kind in case the alignment for the long changes the position. nothing more to marshal marshal the bound on string length unknown typecode kind create an encapsulation put the repository id put the name put the number of members marshal label values, names and types for the default case, marshal the zero octet _encap.putDouble(_unionLabels[i].extract_longdouble()); marshal identifier names put the type of the sequence put the bound on the length of the sequence put the type of the array put the length of the array put the type aliased marshal member names and types " writing member " + _memberNames[i]); put the type modifier marshal the encapsulationThis is not a copy of the TypeCodeImpl objects, but instead itcopies the value this type code is representing.See AnyImpl read_value and write_value for usage.The state of this TypeCodeImpl instance isn't changed, only usedby the Any to do the correct copy. make sure length bound in typecode is not violatedAny tmp = new AnyImpl(_orb); Copy repositoryId Fall into ... _REVISIT_ what about the inherited members of this values concrete base type? copy each element, using the corresponding member type_REVISIT_ More generic code?{Any discriminator = new AnyImpl(_orb);discriminator.read_value(src, _discriminator);discriminator.write_value(dst);int labelIndex = currentUnionMemberIndex(discriminator);if (labelIndex == -1) {// check if label has not been foundif (_defaultIndex == -1)// throw exception if default was not expectedthrow new MARSHAL();else// must be of the default branch type_memberTypes[_defaultIndex].copy(src, dst);} else {_memberTypes[labelIndex].copy(src, dst); { double value = src.read_double();  tagValue.insert_longdouble(value);  dst.putDouble(value);  break; using the value of the tag, find out the type of the value following. use equality over anys check if label has not been found must be of the default branch type get the length of the sequence check for sequence bound violated write the length of the sequence copy each element of the seq using content type make sure it's resolved copy each element of the array using content type follow the alias need to follow offset, get unmarshal typecode from that offset, and use that to do the copy Don't need to read type code before using it to do the copy. It should be fully usable. Utility methods Only for union type. Returns the index of the union member corresponding to the discriminator. If not found returns the default index or -1 if there is no default index. memberName might differ from the name of the member./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/corba/TypeCodeImplHelper.java/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/corba/TypeCodeImplHelper.class"IDL:omg.org/CORBA/TypeCode:1.0"IDL:omg.org/CORBA/TypeCode:1.0Copyright (c) 1999, 2004, Oracle and/or its affiliates. All rights reserved./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/dynamicany/DynAnyBasicImpl.java/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/dynamicanycom.sun.corba.se.impl.dynamicanyorg.omg.DynamicAnyDynAnyBasicImplDynAnyBasicImpl()/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/dynamicany/DynAnyBasicImpl.class/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/dynamicanycopyValuedyn_anyictcCopyright (c) 2000, 2003, Oracle and/or its affiliates. All rights reserved. set the current position to 0 if any has components, otherwise to -1. DynAny interface methods Spec: Returns a copy of the internal Any If the other DynAny is a constructed one we don't want it to have to create its Any representation just for this test.System.out.println("Comparing anys"); The flag "true" indicates copying the Any value Throw InvalidValue if this is a bounded string and the length is exceeded _REVISIT_ Copy value here? The spec doesn't allow us to throw back this exception incase the anys any if of type Principal, native or abstract interface./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/dynamicany/DynAnyCollectionImpl.javaDynAnyCollectionImplDynAnyCollectionImpl()/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/dynamicany/DynAnyCollectionImpl.classAny[]anyscontentTypeDynAny[]itcexpectedTypeCode Instance variables Keep in sync with DynAny[] components at all times. get a hold of the default initialized Any without copying This method has a different meaning for sequence and array: For sequence value of 0 indicates an unbounded sequence, values > 0 indicate a bounded sequence. For array any value indicates the boundary. _REVISIT_ More efficient copy operation Collection methods Initializes the elements of the ordered collection. If value does not contain the same number of elements as the array dimension, the operation raises InvalidValue. If one or more elements have a type that is inconsistent with the collections TypeCode, the operation raises TypeMismatch. This operation does not change the current position. We know that this is of kind tk_sequence or tk_array _REVISIT_ More info Creates the appropriate subtype without copying the AnySystem.out.println(this + " created component " + components[i]); Other representations are invalidated by this operation Same semantics as set_elements(Any[])/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/dynamicany/DynAnyComplexImpl.javaaddComponentaddComponent(int,java.lang.String,org.omg.CORBA.Any,org.omg.DynamicAny.DynAny)/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/dynamicany/DynAnyComplexImpl.classNameDynAnyPair[]allocComponentsallocComponents(org.omg.DynamicAny.NameDynAnyPair[])NameValuePair[]allocComponents(org.omg.DynamicAny.NameValuePair[])allocComponents(int)DynAnyComplexImplDynAnyComplexImpl()nameDynAnyPairsnameValuePairsnamesmemberAnymemberDynAnymemberNameexpectedMemberCountexpectedMemberNameexpectedMemberType Instance variables components and names above are kept in sync with these two arrays at all times. We can be sure that typeCode is of kind tk_struct Initialize components lazily, on demand. This is an optimization in case the user is only interested in storing Anys. For DynAnyComplex, the operation sets the current position to -1 for empty exceptions and to zero for all other TypeCodes. The members (if any) are (recursively) initialized to their default values. _REVISIT_ Overridden to provide more efficient copying. Copies all the internal representations which is faster than reconstructing them.public org.omg.DynamicAny.DynAny copy() {if (status == STATUS_DESTROYED) {throw new OBJECT_NOT_EXIST();DynAnyComplexImpl returnValue = null;if ((representations & REPRESENTATION_ANY) != 0) {// The flag "true" indicates copying the Any valuereturnValue = (DynAnyComplexImpl)DynAnyUtil.createMostDerivedDynAny(any, orb, true);if ((representations & REPRESENTATION_COMPONENTS) != 0) {return returnValue; Complex methods Creates references to the parameter instead of copying it. We know that this is of kind tk_struct Initializes components, names, nameValuePairs and nameDynAnyPairs representation from the Any representation This typeCode is of kind tk_struct. _DEBUG_System.out.println("Created DynAny for " + memberName +                   ", type " + memberType.kind().value()); from the internal TypeCode information with default values This is not done recursively, only one level. More levels are initialized lazily, on demand.if (memberDynAny instanceof DynAnyConstructedImpl) {if ( ! ((DynAnyConstructedImpl)memberDynAny).isRecursive()) {// This is the recursive part((DynAnyConstructedImpl)memberDynAny).initializeComponentsFromTypeCode();} // Other implementations have their own way of dealing with implementing the spec. It is probably right not to destroy the released component DynAnys. Some other DynAny or a user variable might still hold onto them and if not then the garbage collector will take care of it./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/dynamicany/DynAnyConstructedImpl.javaDynAnyConstructedImplDynAnyConstructedImpl()/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/dynamicany/DynAnyConstructedImpl.classisRecursiverepresentationscomponentsnewIndexcurrentComponenttm needed for recursive type codes Constructed DynAnys maintain an ordered collection of component DynAnys.System.out.println(this + " constructed with any " + any); assertion: typeCode has been checked to be valid for this particular subclass. note: We don't copy TypeCodes since they are considered immutable. _REVISIT_ Would need REPRESENTATION_TYPECODE for lazy initializationif ( ! isRecursive()) {    initializeComponentsFromTypeCode(); No way to find out unless the TypeCode spec changes. DynAny traversal methods _REVISIT_ What about status? If all we got is TypeCode representation (no value) then we don't want to force creating a default valueSystem.out.println(this + " checkInitAny before writeAny"); Makes sure that the components representation is initialized Makes sure that the Any representation is initializedSystem.out.println(this + " checkInitAny: reps does not have REPRESENTATION_ANY");System.out.println(this + " checkInitAny: reps has REPRESENTATION_COMPONENTS");System.out.println(this + " checkInitAny: reps has REPRESENTATION_TYPECODE");System.out.println(this + " checkInitAny: reps != REPRESENTATION_ANY"); Collapses the whole DynAny hierarchys values into one single streamed AnySystem.out.println(this + " initializeAnyFromComponents"); Not our implementation. Nothing we can do to prevent copying.System.out.println(this + " to_any "); Anys value may still be uninitialized if DynAny was initialized by TypeCode only This changes the current position of dyn_any. Make sure that our position isn't changed. Remember the current position to restore it laterSystem.out.println(this + " comparing component " + i + "=" + components[i] +                   " of type " + components[i].type().kind().value());System.out.println("Not equal component " + i); impossible, we checked the type codes already Restore the current position of the other DynAny getter / setter methods/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/dynamicany/DynAnyFactoryImpl.javaorg.omg.DynamicAny.DynAnyFactoryPackage/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/dynamicany/DynAnyFactoryImpl.classDynAnyFactoryImplDynAnyFactoryImpl()"IDL:omg.org/DynamicAny/DynAnyFactory:1.0"IDL:omg.org/DynamicAny/DynAnyFactory:1.0Copyright (c) 2000, 2011, Oracle and/or its affiliates. All rights reserved. DynAnyFactory interface methods Returns the most derived DynAny type based on the Anys TypeCode. Returns the most derived DynAny type based on the TypeCode. Needed for org.omg.CORBA.Object/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/dynamicany/DynAnyImpl.java/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/dynamicany/DynAnyImpl.class"IDL:omg.org/DynamicAny/DynAny:1.0"IDL:omg.org/DynamicAny/DynAny:1.0"Unable to find DynAnyFactory"Unable to find DynAnyFactorydynAnynewStatustempAny A DynAny is destroyable if it is the root of a DynAny hierarchy. A DynAny is undestroyable if it is a node in a DynAny hierarchy other than the root. A DynAny is destroyed if its root has been destroyed. An Any is used internally to implement the basic DynAny. It stores the DynAnys TypeCode. For primitive types it is the only representation. For complex types it is the streamed representation. Destroyable is the default status for free standing DynAnys. Uses getAny() if this is our implementation, otherwise uses to_any() which copies the Any. _REVISIT_ Nothing we can do about copying at this point if this is not our implementation of DynAny. To prevent this we would need another representation, one where component DynAnys are initialized but not the component Anys.System.out.println(this + " writeAny of type " + type().kind().value()); This clears the data part of the Any while keeping the TypeCode info. Makes a copy of the Any value inside the parameter Makes a copy of the Any parameter If the passed Any does not contain a legal value (such as a null string), the operation raises InvalidValue./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/dynamicany/DynAnyUtil.javaset_current_componentset_current_component(org.omg.DynamicAny.DynAny,org.omg.DynamicAny.DynAny)/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/dynamicany/DynAnyUtil.classisInitialized(org.omg.CORBA.Any)convertToNative(org.omg.DynamicAny.DynAny,com.sun.corba.se.spi.orb.ORB)copycopy(org.omg.CORBA.Any,com.sun.corba.se.spi.orb.ORB)createDefaultAnyOfTypecreateDefaultAnyOfType(org.omg.CORBA.TypeCode,com.sun.corba.se.spi.orb.ORB)extractAnyFromStreamextractAnyFromStream(org.omg.CORBA.TypeCode,org.omg.CORBA.portable.InputStream,com.sun.corba.se.spi.orb.ORB)createMostDerivedDynAnycreateMostDerivedDynAny(org.omg.CORBA.TypeCode,com.sun.corba.se.spi.orb.ORB)createMostDerivedDynAny(org.omg.CORBA.Any,com.sun.corba.se.spi.orb.ORB,boolean)isConstructedDynAnyisConstructedDynAny(org.omg.DynamicAny.DynAny)isConsistentTypeisConsistentType(org.omg.CORBA.TypeCode)0.0"0.0"inAnyimport org.omg.CORBA.ORBPackage.*; DynFixed is constructed but not a subclass of DynAnyConstructedImplreturn (dynAny instanceof DynAnyConstructedImpl);static Any extractAnyFromAny(TypeCode memberType, Any any, ORB orb) {// Moved this functionality into AnyImpl because it is needed for Any.equal()return ((AnyImpl)any).extractAny(memberType, orb); Creates a default Any of the given type. The spec for DynAny differs from Any on initialization via type code: - false for boolean - zero for numeric types - zero for types octet, char, and wchar - the empty string for string and wstring - nil for object references - a type code with a TCKind value of tk_null for type codes - for Any values, an Any containing a type code with a TCKind value of tk_null   type and no value false for boolean zero for numeric types zero for types octet, char, and wchar the empty string for string and wstring Make sure that type code for bounded strings gets respected Doesn't erase the type of bounded string nil for object references a type code with a TCKind value of tk_null for type codes We can reuse the type code that's already in the any. for Any values, an Any containing a type code with a TCKind value of tk_null type and no value. This is exactly what the default AnyImpl constructor provides. _REVISIT_ Note that this inner Any is considered uninitialized. There are no default value for complex types since there is no concept of a hierarchy of Anys. Only DynAnys can be arrange in a hierarchy to mirror the TypeCode hierarchy. See DynAnyConstructedImpl.initializeComponentsFromTypeCode() on how this DynAny hierarchy is created from TypeCodes. Any is already initialized to nullstatic Any setTypeOfAny(TypeCode typeCode, Any value) {if (value != null) {value.read_value(value.create_input_stream(), typeCode);return value;static Any copy(Any inAny, ORB orb) {Any outAny = null;if (inAny != null && orb != null) {outAny = orb.create_any();outAny.read_value(inAny.create_input_stream(), inAny.type());// isInitialized is set to truereturn outAny; if copy flag wasn't true we would be using our DynAny with a foreign Any in it. Returning simply the value of Any.isInitialized() is not enough. The DynAny spec says that Anys containing null strings do not contain a "legal value" (see ptc 99-10-07, 9.2.3.3) This is a convenient method to reset the current component to where it was before we changed it. See DynAnyConstructedImpl.equal for use.impossible/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/dynamicany/DynArrayImpl.javaDynArrayImplDynArrayImpl()/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/dynamicany/DynArrayImpl.class Initializes components and anys representation This typeCode is of kind tk_array. _REVISIT_ Could use read_xxx_array() methods on InputStream for efficiency but only for primitive types from the internal TypeCode information with default values. DynArray interface methods Initializes the elements of the array. If one or more elements have a type that is inconsistent with the DynArrays TypeCode,public void set_elements (org.omg.CORBA.Any[] value)throws org.omg.DynamicAny.DynAnyPackage.TypeMismatch,org.omg.DynamicAny.DynAnyPackage.InvalidValue;/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/dynamicany/DynEnumImpl.javaorg.omg.DynamicAny.DynAnyPackagecomputeCurrentEnumeratorIndexcomputeCurrentEnumeratorIndex(java.lang.String)/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/dynamicany/DynEnumImpl.classmemberName(int)memberCountmemberCount()DynEnumImplDynEnumImpl()currentEnumeratorIndexanAny This int and the any value are kept in sync at all times The current position of a DynEnum is always -1. The any doesn't have to be initialized. We have a default value in this case. _REVISIT_: Fix Me Sets the current position to -1 and sets the value of the enumerator to the first enumerator value indicated by the TypeCode. Returns always 0 for DynEnum Calling current_component on a DynAny that cannot have components, such as a DynEnum or an empty exception, raises TypeMismatch. DynEnum interface methods Returns the value of the DynEnum as an IDL identifier. Sets the value of the DynEnum to the enumerated value whose IDL identifier is passed in the value parameter. If value contains a string that is not a valid IDL identifier for the corresponding enumerated type, the operation raises InvalidValue. Returns the value of the DynEnum as the enumerated values ordinal value. Enumerators have ordinal values 0 to n-1, as they appear from left to right in the corresponding IDL definition. Sets the value of the DynEnum as the enumerated values ordinal value. If value contains a value that is outside the range of ordinal values/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/dynamicany/DynFixedImpl.javaDynFixedImplDynFixedImpl()/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/dynamicany/DynFixedImpl.classpreservedPrecisionsigndIndex'd'integerPartfractionPartcurrentScalecurrentDigitsdotIndex'.''-'-"-"'+'+"+"'D'Dnfe"DynFixed with value="DynFixed with value=", digits=", digits=", scale=", scale= Sets the current position to -1 and the value to zero.public int component_count() {return 0; DynFixed interface methods Initializes the value of the DynFixed. The val string must contain a fixed string constant in the same format as used for IDL fixed-point literals. It may consist of an integer part, an optional decimal point, a fraction part and an optional letter d or D. The integer and fraction parts both must be sequences of decimal (base 10) digits. Either the integer part or the fraction part, but not both, may be missing. If val contains a value whose scale exceeds that of the DynFixed or is not initialized, The return value is true if val can be represented as the DynFixed without loss of precision. If val has more fractional digits than can be represented in the DynFixed, fractional digits are truncated and the return value is false. If val does not contain a valid fixed-point literal or contains extraneous characters other than leading or trailing white space, the operation raises TypeMismatch. First get rid of leading or trailing whitespace which is allowed Now scan for the sign Now get rid of the letter d or D. Just to be sure Now look for the dot to determine the integer part Let's see if we have to drop some precision truncate the fraction part currentScale > 0 drop the fraction completely integerPart.length() > digits unable to truncate fraction part Reinterpreted to mean raise InvalidValue only if the integer part exceeds precision, which is handled above (integerPart.length() > digits)if (currentScale > scale) {throw new InvalidValue("Scale exceeds " + scale); Now check whether both parts are valid numbers/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/dynamicany/DynSequenceImpl.javaDynSequenceImplDynSequenceImpl()/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/dynamicany/DynSequenceImpl.classlenoldLengthnewComponentsnewAnys _REVIST_ Could make this a subclass of DynArrayImpl But that would mean that an object that implements DynSequence also implements DynArray which the spec doesn't mention (it also doesn't forbid it). Sets the current position to -1 and creates an empty sequence. This typeCode is of kind tk_sequence. already done in the type code constructor Writing the length first is the only difference to supers implementation DynSequence interface methods Returns the current length of the sequence Sets the length of the sequence. Increasing the length of a sequence adds new elements at the tail without affecting the values of already existing elements. Newly added elements are default-initialized. Increasing the length of a sequence sets the current position to the first newly-added element if the previous current position was -1. Otherwise, if the previous current position was not -1, the current position is not affected. Increasing the length of a bounded sequence to a value larger than the bound raises InvalidValue. Decreasing the length of a sequence removes elements from the tail without affecting the value of those elements that remain. The new current position after decreasing the length of a sequence is determined as follows: ?f the length of the sequence is set to zero, the current position is set to -1. ?f the current position is -1 before decreasing the length, it remains at -1. ?f the current position indicates a valid element and that element is not removed when the length is decreased, the current position remains unaffected. ?f the current position indicates a valid element and that element is removed, the current position is set to -1. Increase length Newly added elements are default-initialized Decrease lengthfor (int i=len; i<oldLength; i++) {    components[i].destroy(); ?f the current position indicates a valid element and that element is removed, the current position is set to -1. Length unchanged Maybe components is now default initialized from type code Initializes the elements of the sequence. The length of the DynSequence is set to the length of value. The current position is set to zero if value has non-zero length and to -1 if value is a zero-length sequence. If the length of value exceeds the bound of a bounded sequence, If value contains one or more elements whose TypeCode is not equivalent to the element TypeCode of the DynSequence, the operation raises TypeMismatch.public void set_elements(org.omg.CORBA.Any[] value)/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/dynamicany/DynStructImpl.javaDynStructImplDynStructImpl()/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/dynamicany/DynStructImpl.class For DynStruct, the operation sets the current position to -1 Methods differing from DynValues/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/dynamicany/DynUnionImpl.java/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/dynamicany/DynUnionImpl.classdefaultIndexdefaultIndex()memberType(int)memberLabelmemberLabel(int)discriminatorTypediscriminatorType()DynUnionImplDynUnionImpl()currentMemberIndexcurrentMemberdiscriminatordiscriminatorAnynewDiscriminatornewDiscriminatorAnynewCurrentMemberIndex index either points to the discriminator or the named member is it exists. The currently active member, which is of the same type as the discriminator. We can be sure that typeCode is of kind tk_union Sets the current position to zero. The discriminator value is set to a value consistent with the first named member of the union. That member is activated and (recursively) initialized to its default value.System.out.println(this + " initializeComponentsFromTypeCode"); We can be sure that memberCount() > 0 according to the IDL language spec Convenience methods Necessary to guarantee OBJECT_NOT_EXIST in member() DynUnion interface methodsReturns the current discriminator value. Sets the discriminator of the DynUnion to the specified value. If the TypeCode of the parameter is not equivalent to the TypeCode of the unions discriminator, the operation raises TypeMismatch. Setting the discriminator to a value that is consistent with the currently active union member does not affect the currently active member. Setting the discriminator to a value that is inconsistent with the currently active member deactivates the member and activates the member that is consistent with the new discriminator value (if there is a member for that value) by initializing the member to its default value. If the discriminator value indicates a non-existent union member this operation sets the current position to 0 (has_no_active_member returns true in this case). Otherwise the current position is set to 1 (has_no_active_member returns false and component_count returns 2 in this case). _REVISIT_ Could possibly optimize here if we don't need to initialize components Sets the discriminator to a value that is consistent with the value of the default case of a union; it sets the current position to zero and causes component_count to return 2. Calling set_to_default_member on a union that does not have an explicit default case raises TypeMismatch. Sets the discriminator to a value that does not correspond to any of the unions case labels. It sets the current position to zero and causes component_count to return 1. Calling set_to_no_active_member on a union that has an explicit default case or on a union that uses the entire range of discriminator values for explicit case labels raises TypeMismatch. _REVISIT_ How does one check for "entire range of discriminator values"? erase the discriminators value so that it does not correspond to any of the unions case labels Returns true if the union has no active member (that is, the unions value consists solely of its discriminator because the discriminator has a value that is not listed as an explicit case label). Calling this operation on a union that has a default case returns false. Calling this operation on a union that uses the entire range of discriminator values for explicit case labels returns false. Returns the currently active member. If the union has no active member, the operation raises InvalidValue. Note that the returned reference remains valid only for as long as the currently active member does not change. Using the returned reference beyond the life time of the currently active member raises OBJECT_NOT_EXIST. Returns the name of the currently active member. If the unions TypeCode does not contain a member name for the currently active member, the operation returns an empty string. Calling member_name on a union without an active member raises InvalidValue. Returns the TCKind value of the TypeCode of the currently active member./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/dynamicany/DynValueBoxImpl.javaDynValueBoxImplDynValueBoxImpl()/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/dynamicany/DynValueBoxImpl.classboxed DynValueBox methods/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/dynamicany/DynValueCommonImpl.javaDynValueCommonImplDynValueCommonImpl()/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/dynamicany/DynValueCommonImpl.class DynValueCommon methods Returns TRUE if this object represents a null valuetype Changes the representation to a null valuetype. If this object represents a null valuetype then this operation replaces it with a newly constructed value with its components initialized to default values as in DynAnyFactory::create_dyn_any_from_type_code. If this object represents a non-null valuetype, then this operation has no effect. the rest is done lazily else: there is nothing to do Methods differing from DynStruct Required to raise InvalidValue if this is a null value type. Overridden methods Overridden to change to non-null status. If we didn't get an exception then this must be a valid non-null value/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/dynamicany/DynValueImpl.javaDynValueImplDynValueImpl()/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/dynamicany/DynValueImpl.class/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/encoding/BufferManagerFactory.java/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/encodingcom.sun.corba.se.impl.encodingencodingVersion"Unknown GIOP version: "Unknown GIOP version: strategy"newBufferManagerRead"newBufferManagerRead"Collect strategy invalid for reading"Collect strategy invalid for reading"Unknown buffer manager read strategy: "Unknown buffer manager read strategy: "newBufferManagerWrite"newBufferManagerWrite"Unknown buffer manager write strategy: "Unknown buffer manager write strategy: Copyright (c) 2000, 2004, Oracle and/or its affiliates. All rights reserved.Creates read/write buffer managers to handle over/under flowin CDR*putStream. The next two methods allow creation of BufferManagers based on GIOP version. We may want more criteria to be involved in this decision. These are only used for sending messages (so could be fragmenting) REVISIT - On the reading side, shouldn't we monitor the incoming fragments on a given connection to determine what fragment size they're using, then use that ourselves? The stream reader can handle fragmented and non fragmented messages REVISIT - what is appropriate?/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/encoding/BufferManagerRead.javabyteBufferheaderbbwirequestIdCase: Called from ReaderThread on complete message or fragments.The given buf may be entire message or a fragment.The ReaderThread finds the ReadBufferManager instance either inin a fragment map (when collecting - GIOP 1.2 phase 1) orin an active server requests map (when streaming - GIOP 1.2 phase 2).As a model for implementation see IIOPInputStream'sconstructor of the same name. There are going to be some variations.Case: called from CDRInputStream constructor before unmarshaling.Does:this.bufQ.get()If streaming then sync on bufQ and wait if empty.Case: called from CDRInputStream.grow.Called once after creating this buffer manager and beforeit begins processing.Returns the mark/reset handler for this stream.Signals that the processing be cancelled.Close BufferManagerRead and perform any oustanding cleanup./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/encoding/BufferManagerReadGrow.javamarkEngaged/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/encoding/BufferManagerReadGrow.class/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/encodinginputStreamstreamMementoBufferManagerReadGrowBufferManagerReadGrow(com.sun.corba.se.spi.orb.ORB)newFragment REVISIT - This should go in an abstract class called           BufferManagerReadBase which should implement           BufferManagerRead. Then, this class should extend           BufferManagerReadBase. REVISIT - should we consider throwing an exception similar to what's           done for underflow()??? Mark and reset handler ------------------------- This will never happen Nothing to close and cleanup./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/encoding/BufferManagerReadStream.java/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/encoding/BufferManagerReadStream.classLinkedList<>/Users/jettt/IdeaProjects/jdk_test/target/classes/java/util/LinkedList.classAbstractSequentialList<>/Users/jettt/IdeaProjects/jdk_test/target/classes/java/util/AbstractSequentialList.classDeque<>/Users/jettt/IdeaProjects/jdk_test/target/classes/java/util/Deque.classQueue<>/Users/jettt/IdeaProjects/jdk_test/target/classes/java/util/Queue.classfragmentStackdprintdprint(java.lang.String)BufferManagerReadStreamBufferManagerReadStream(com.sun.corba.se.spi.orb.ORB)FRAGMENT_TIMEOUTfragmentQueueendOfStreamcancelReqIdreceivedCancel60000bbAddress80strMsg"processFragment() - queueing ByteBuffer id ("processFragment() - queueing ByteBuffer id (") to fragment queue.") to fragment queue.interruptedbbAddrsb1msg1"underflow() - dequeued ByteBuffer id ("underflow() - dequeued ByteBuffer id (") from fragment queue.") from fragment queue.byteBufferPool"underflow() - releasing ByteBuffer id ("underflow() - releasing ByteBuffer id (") to ByteBufferPool.") to ByteBufferPool.inputBbAddressabbwi"close() - fragmentQueue is "close() - fragmentQueue is "releasing ByteBuffer id ("releasing ByteBuffer id (") to ") to "ByteBufferPool."ByteBufferPool.AbstractSequentialListAbstractSequentialList()AbstractSequentialList<>()peekpeek()elementelement()pollpoll()offeroffer(java.lang.Object)descendingIteratordescendingIterator()poppop()pushpush(java.lang.Object)removeLastOccurrenceremoveLastOccurrence(java.lang.Object)removeFirstOccurrenceremoveFirstOccurrence(java.lang.Object)peekLastpeekLast()peekFirstpeekFirst()getLastgetLast()getFirstgetFirst()pollLastpollLast()pollFirstpollFirst()removeLastremoveLast()removeFirstremoveFirst()offerLastofferLast(java.lang.Object)offerFirstofferFirst(java.lang.Object)addLastaddLast(java.lang.Object)addFirstaddFirst(java.lang.Object)/Library/Java/JavaVirtualMachines/jdk1.8.0_251.jdk/Contents/Home/jre/lib/rt.jar/java/util/LinkedList$Node.classNode<E>nodenode(int)unlinkunlink(java.util.LinkedList.Node)linkBeforelinkBefore(java.lang.Object,java.util.LinkedList.Node)linkLastlinkLast(java.lang.Object)LinkedListLinkedList(java.util.Collection)LinkedList<>(java.util.Collection)LinkedList()LinkedList<>()lastitrset(java.lang.Object)previousIndexpreviousIndex()nextIndexnextIndex()previousprevious()hasPrevioushasPrevious()"close() - fragmentStack - releasing "close() - fragmentStack - releasing "ByteBuffer id ("ByteBuffer id ("BufferManagerReadStream"iterCopyright (c) 2000, 2009, Oracle and/or its affiliates. All rights reserved. We should convert endOfStream to a final static dummy end node REVISIT - This should go in BufferManagerRead. But, since           BufferManagerRead is an interface. BufferManagerRead           might ought to be an abstract class instead of an           interface. print address of ByteBuffer being queuedSystem.out.println("ENTER underflow"); print address of ByteBuffer being dequeued VERY IMPORTANT Release bbwi.byteBuffer to the ByteBufferPool only if this BufferManagerStream is not marked for potential restore. print address of ByteBuffer being releasedSystem.out.println("EXIT underflow"); Release any queued ByteBufferWithInfo's byteBuffers to the ByteBufferPoool release ByteBuffers on fragmentQueue IMPORTANT: The fragment queue may have one ByteBuffer            on it that's also on the CDRInputStream if            this method is called when the stream is 'marked'.            Thus, we'll compare the ByteBuffer passed            in (from a CDRInputStream) with all ByteBuffers            on the stack. If one is found to equal, it will            not be released to the ByteBufferPool. print address of ByteBuffer released release ByteBuffers on fragmentStack IMPORTANT: The fragment stack may have one ByteBuffer Mark and reset handler ---------------------------------------- List of fragment ByteBufferWithInfos received since the mark was engaged. Original state of the stream Get the magic Object that the stream will use to reconstruct it's state when reset is called Collects fragments received since the mark was engaged. REVISIT - call to reset without call to mark If we actually did peek across fragments, we need to push those fragments onto the front of the buffer queue. Give the stream the magic Object to restore it's state./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/encoding/BufferManagerWrite.javaBufferManagerWriteBufferManagerWrite(com.sun.corba.se.spi.orb.ORB)/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/encoding/BufferManagerWrite.classoutputObjectDefines the contract between the BufferManager andCDR stream on the writing side.  The CDR streamcalls back to the BufferManagerWrite when it needsmore room in the output buffer to continue.  TheBufferManager can then grow the output buffer oruse some kind of fragmentation technique.Has the stream sent out any fragments so far?Has the entire message been sent?  (HassendMessage been called?)Returns the correct buffer size for this type ofbuffer manager as set in the ORB.Called from CDROutputStream.grow.bbwi.buf contains a byte array which needs to grow by bbwi.needed bytes.This can be handled in several ways:1. Resize the bbwi.buf like the current implementation ofCDROutputStream.grow.2. Collect the buffer for a later send:this.bufQ.put(bbwi);return new ByteBufferWithInfo(bbwi.length);3. Send buffer as fragment:Backpatch fragment size field in bbwi.buf.Set more fragments bit in bbwi.buf.this.connection.send(bbwi);return reinitialized bbwi.buf with fragment headerAll cases should adjust the returned bbwi.* appropriately.Should set the bbwi.fragmented flag to true only in cases 2 and 3.Called after Stub._invoke (i.e., before complete message has been sent).IIOPOutputStream.writeTo called from IIOPOutputStream.invokeCase: overflow was never called (bbwi.buf contains complete message).Backpatch size field.If growing or collecting:this.bufQ.put(bbwi).this.bufQ.iterate // However, see comment in getBufferQthis.connection.send(fragment)If streaming:this.connection.send(bbwi).Case: overflow was called N times (bbwi.buf contains last buffer).backpatch size field in first buffer.backpatch fragment size field in bbwi.buf.Set no more fragments bit.A reference to the connection level stream will be required whensending fragments.Close the BufferManagerWrite and do any outstanding cleanup. XREVISIT - Currently a java.lang.Object during the rip-int-generic transition.  Should eventually become a GIOPOutputObject./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/encoding/BufferManagerWriteCollect.java/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/encoding/BufferManagerWriteCollect.classBufferManagerWriteCollectBufferManagerWriteCollect(com.sun.corba.se.spi.orb.ORB)sentFragmentqueuenewBbwibufsconn"sendMessage() - releasing ByteBuffer id ("sendMessage() - releasing ByteBuffer id ("close() - releasing ByteBuffer id ("close() - releasing ByteBuffer id ("BufferManagerWriteCollect"BufferManagerWriteCollectIteratorBufferManagerWriteCollectIterator()/Library/Java/JavaVirtualMachines/jdk1.8.0_251.jdk/Contents/Home/jre/lib/rt.jar/com/sun/corba/se/impl/encoding/Library/Java/JavaVirtualMachines/jdk1.8.0_251.jdk/Contents/Home/jre/lib/rt.jar/com/sun/corba/se/impl/encoding/BufferManagerWriteCollect$BufferManagerWriteCollectIterator.classCollect buffer manager. Set the fragment's "more fragments" bit to true, put it in the queue, and allocate a new bbwi. Set the fragment's moreFragments field to true Enqueue the previous fragment Create a new bbwi XREVISIT - Downcast Now we must marshal in the fragment header/GIOP header REVISIT - we can optimize this by not creating the fragment message each time. Send all fragments Enqueue the last fragment With the collect strategy, we must lock the connection while fragments are being sent.  This is so that there are no interleved fragments in GIOP 1.1. Note that this thread must not call writeLock again in any of its send methods! Get a reference to ByteBufferPool so that the ByteBufferWithInfo ByteBuffer can be released to the ByteBufferPool Release ByteBufferWithInfo's ByteBuffer back to the pool of ByteBuffers.Close the BufferManagerWrite - do any outstanding cleanup.For a BufferManagerWriteGrow any queued ByteBufferWithInfo musthave its ByteBuffer released to the ByteBufferPool. iterate thru queue and release any ByteBufferWithInfo's ByteBuffer that may be remaining on the queue to the ByteBufferPool./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/encoding/BufferManagerWriteGrow.java/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/encoding/BufferManagerWriteGrow.classBufferManagerWriteGrowBufferManagerWriteGrow(com.sun.corba.se.spi.orb.ORB)orbDatabufferSize"BufferManagerWriteGrow.getBufferSize: bufferSize == "BufferManagerWriteGrow.getBufferSize: bufferSize == "BufferManagerWriteGrow.getBufferSize: orbData reference is NULL"BufferManagerWriteGrow.getBufferSize: orbData reference is NULL"BufferManagerWriteGrow.getBufferSize: orb reference is NULL"BufferManagerWriteGrow.getBufferSize: orb reference is NULLCopyright (c) 2000, 2017, Oracle and/or its affiliates. All rights reserved. The code that once lived directly in CDROutputStream.grow() has been moved ByteBufferWithInfo.growBuffer(). Grow ByteBufferWithInfo to a larger size. Must be false for the grow caseNo work to do for a BufferManagerWriteGrow./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/encoding/BufferManagerWriteStream.javasendFragmentsendFragment(boolean)/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/encoding/BufferManagerWriteStream.classBufferManagerWriteStreamBufferManagerWriteStream(com.sun.corba.se.spi.orb.ORB)fragmentCountseisLastFragmentCopyright (c) 2000, 2010, Oracle and/or its affiliates. All rights reserved.Streaming buffer manager. Reuse the old buffer REVISIT - need to account for case when needed > available even after fragmenting.  This is the large array case, so the caller should retry when it runs out of space. REVISIT: need an ORBSystem.out.println("sendFragment: last?: " + isLastFragment); Send the fragment Sends the last fragmentNo work to do for a BufferManagerWriteStream/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/encoding/BufferQueue.java/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/encoding/BufferQueue.classitemSimple unsynchronized queue implementation for ByteBufferWithInfos. XREVISIT - Should be in orbutil or package private Adds the given ByteBufferWithInfo to the front of the queue./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/encoding/ByteBufferWithInfo.java/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/encoding/ByteBufferWithInfo.classbufferManagerusePooledByteBuffersmsgStr"constructor (ORB, BufferManagerWrite) - got "constructor (ORB, BufferManagerWrite) - got ") from ByteBufferPool.") from ByteBufferPool.newPositiontheLengthnewLengthnewBBnewbbAddress"growBuffer() - got ByteBuffer id ("growBuffer() - got ByteBuffer id (msgStr2"growBuffer() - releasing ByteBuffer id ("growBuffer() - releasing ByteBuffer id ("ByteBufferWithInfo:"ByteBufferWithInfo:" buflen = " buflen = " byteBuffer.limit = " byteBuffer.limit = " index = " index = " position = " position = " needed = " needed = " byteBuffer = " byteBuffer = "not null"not null" fragmented = " fragmented = "ByteBufferWithInfo"ByteBufferWithInfo Notes about the class. Assumptions, the ByteBuffer's position is set by the constructor's index variable and the ByteBuffer's limit points to the end of the data. Also, since the index variable tracks the current empty position in the buffer, the ByteBuffer's position is updated any time there's a call to this class's position(). Although, a ByteBuffer's length is it's capacity(), the context in which length is used in this object, this.buflen is actually the ByteBuffer limit(). REVISIT - index should eventually be replaced with byteBuffer.position() Current empty position in buffer. REVISIT - CHANGE THESE TO PRIVATE Marshal buffer. Total length of buffer. // Unnecessary... How many more bytes are needed on overflow. Did the overflow operation fragment? Right now, EncapsOutputStream's do not use pooled byte buffers. EncapsOutputStream's is the only one that does not use pooled byte buffers. Hence, the reason for the boolean 'usePooledByteBuffers'. See EncapsOutputStream for additional information. print address of ByteBuffer gotten from pool don't allocate from pool, allocate non-direct ByteBuffer Shallow copy constructor So IIOPOutputStream seems more intuitive accessor to buflen get position in this buffer REVISIT - This should be changed to return the           value of byteBuffer.position() rather           than this.index. But, byteBuffer.position           is manipulated via ByteBuffer writes, reads,           gets and puts. These locations need to be           investigated and updated before           byteBuffer.position() can be returned here. return byteBuffer.position(); set position in this buffer REVISIT - This should be changed to set only the           value of byteBuffer.position rather           than this.index. This change should be made           in conjunction with the change to this.position(). mutator to buflen Grow byteBuffer to a size larger than position() + needed This code used to live directly in CDROutputStream.grow. Recall that the byteBuffer size is 'really' the limit or buflen. print address of ByteBuffer just gotten return 'old' byteBuffer reference to the ByteBuffer pool update the byteBuffer with a larger ByteBuffer limit and buflen must be set to newLength./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/encoding/CDRInputObject.javagetCodeSetsgetCodeSets()/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/encoding/CDRInputObject.classomgWrapperunmarshaledHeadercorbaConnection".CDRInputObject constructor:".CDRInputObject constructor:".unmarshalHeader->: ".unmarshalHeader->: ".unmarshalHeader: !!ERROR!!: ".unmarshalHeader: !!ERROR!!: ".unmarshalHeader<-: ".unmarshalHeader<-: codesetscharSetwcharSet"CDRInputObject"CDRInputObjectCopyright (c) 2001, 2004, Oracle and/or its affiliates. All rights reserved.Harold Carr REVISIT - think about this some more. This connection normally is accessed from the message mediator. However, giop input needs to get code set info from the connetion *before* the message mediator is available. XREVISIT - Should the header be kept in the stream or the message mediator?  Or should we not have a header and have the information stored in the message mediator directly?Unmarshal the extended GIOP headerNOTE: May be fragmented, so should not be called by the ReaderThread.See CorbaResponseWaitingRoomImpl.waitForResponse.  It is donethere in the client thread. Unmarshal the extended GIOP message from the buffer.Override the default CDR factory behavior to get thenegotiated code sets from the connection.These are only called once per message, the first time needed.In the local case, there is no Connection, so use thelocal code sets. If the connection doesn't have its negotiated code sets by now, fall back on the defaults defined in CDRInputStream. code sets by now, we have to throw an exception. See CORBA formal 00-11-03 13.9.2.6. For GIOP 1.2 and UTF-16, use big endian if there is no byte order marker.  (See issue 3405b) For GIOP 1.1 and UTF-16, use the byte order the stream if there isn't (and there shouldn't be) a byte order marker. GIOP 1.0 doesn't have wchars.  If we're talking to a legacy ORB, we do what our old ORBs did. If we're local and don't have a Connection, use the local code sets, otherwise get them from the connection. If the connection doesn't have negotiated code sets yet, then we use ISO8859-1 for char/string and wchar/wstring are illegal. ----------------------------------------------------------- Below this point are commented out methods with features from the old stream.  We must find ways to address these issues in the future. XREVISIT     private XIIOPInputStream(XIIOPInputStream stream) {         super(stream);         this.conn = stream.conn;         this.msg = stream.msg;         this.unmarshaledHeader = stream.unmarshaledHeader;     } return new XIIOPInputStream(this); End of file./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/encoding/CDRInputStream.javaprintBufferprintBuffer()/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/encoding/CDRInputStream.classimplInputStreamFactoryInputStreamFactory()/Library/Java/JavaVirtualMachines/jdk1.8.0_251.jdk/Contents/Home/jre/lib/rt.jar/com/sun/corba/se/impl/encoding/CDRInputStream$InputStreamFactory.classlittleEndianbufMgrchar[]float[]double[]clzrep_idseqoffreadlimitbboctetBoundaryheaderPaddingmessageMediatorThis is delegates to the real implementation.NOTE:Before using the stream for valuetype unmarshaling, one must callperformORBVersionSpecificInit(). We can move this out somewhere later.  For now, it serves its purpose to create a concrete CDR delegate based on the GIOP version. else fall through and report exception. Required for the case when a ClientResponseImpl is created with a SystemException due to a dead server/closed connection with no warning.  Note that the stream will not be initialized in this case. Probably also required by ServerRequestImpl. REVISIT. org.omg.CORBA.portable.InputStream org.omg.CORBA_2_3.portable.InputStream com.sun.corba.se.impl.encoding.MarshalInputStream org.omg.CORBA.DataInputStream org.omg.CORBA.portable.ValueBase java.io.InputStream Needed by TCUtilityreturn true if our ByteBuffer is sharing/equal to bb This should be overridden by any stream (ex: IIOPInputStream) which wants to read values.  Thus, TypeCodeInputStream doesn't have to do this. Use Latin-1 for GIOP 1.0 or when code set negotiation was not performed. Subclasses must decide what to do here.  It's inconvenient to make the class and this method abstract because of dup(). Prints the current buffer in a human readable formAligns the current position on the given octet boundaryif there are enough bytes available to do so.  Otherwise,it just returns.  This is used for some (but not all)GIOP 1.2 message headers. Needed by request and reply messages for GIOP versions >= 1.2 only.This must be called after determining the proper ORB version,and setting it on the stream's ORB instance.  It can be calledafter reading the service contexts, since that is the only placewe can get the ORB version info.Trying to unmarshal things requiring repository IDs before callingthis will result in NullPtrExceptions. In the case of SystemExceptions, a stream is created with its default constructor (and thus no impl is set).Resets any internal references to code set converters.This is useful for forcing the CDR stream to reacquireconverters (probably from its subclasses) when statehas changed. ValueInputStream -----------------------------/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/encoding/CDRInputStreamBase.javaperformORBVersionSpecificInitperformORBVersionSpecificInit()/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/encoding/CDRInputStreamBase.classalignOnBoundaryalignOnBoundary(int)getCodeBasegetCodeBase()setHeaderPaddingsetHeaderPadding(boolean)CDRInputStreamBaseCDRInputStreamBase()Describes CDRInputStream delegates and provides someimplementation.  Non-default constructors are avoided inthe delegation to separate instantiation from initialization,so we use init methods. REVISIT - should we make these throw UnsupportedOperationExceptions? Right now, they'll go up to the java.io versions!     public abstract int read(byte b[]) throws IOException;     public abstract int read(byte b[], int off, int len) throws IOException     public abstract long skip(long n) throws IOException;     public abstract int available() throws IOException;     public abstract void close() throws IOException; This should return false so that outside users (people using the JDK) don't have any guarantees that mark/reset will work in their custom marshaling code.  This is necessary since they could do things like expect obj1a == obj1b in the following code: is.mark(10000); Object obj1a = is.readObject(); is.reset(); Object obj1b = is.readObject(); Needed by AnyImpl and ServiceContexts Needed by TypeCodeImpl Needed by IIOPInputStream and other subclasses ValueInputStream -------------------------/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/encoding/CDRInputStream_1_0.java/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/encoding/CDRInputStream_1_0.classgetConvertedCharsgetConvertedChars(int,com.sun.corba.se.impl.encoding.CodeSetConversion.BTCConverter)getClassFromStringgetClassFromString(java.lang.String,java.lang.String)getClassFromString(java.lang.String,java.lang.String,java.lang.Class)skipToOffsetskipToOffset(int)_idsread_fixed_bufferread_fixed_buffer()read_codebase_URLread_codebase_URL()read_repositoryIdread_repositoryId()read_repositoryIdsread_repositoryIds()readValueTagreadValueTag()end_blockend_block()handleEndOfValuehandleEndOfValue()start_blockstart_block()readEndTagreadEndTag()readIDLValuereadIDLValue(int,java.lang.String,java.lang.Class,java.lang.String)readBoxedIDLEntityreadBoxedIDLEntity(java.lang.Class,java.lang.String)readIDLValueWithHelperreadIDLValueWithHelper(com.sun.org.omg.CORBA.portable.ValueHelper,int)readClassreadClass()isCustomTypeisCustomType(com.sun.org.omg.CORBA.portable.ValueHelper)readRepositoryIdsreadRepositoryIds(int,java.lang.Class,java.lang.String,org.omg.CORBA.portable.BoxedValueHelper)readRepositoryIds(int,java.lang.Class,java.lang.String)handleIndirectionhandleIndirection()internalReadStringinternalReadString(int)createRepositoryIdHandlerscreateRepositoryIdHandlers()specialNoOptionalDataStatewcharConvertercharConverterrepIdStrsrepIdUtilchunkedValueNestingLevelcodebaseCacherepositoryIdCachevalueCachemaxBlockLengthkReadMethod"read"read0x7fffff002147483392"IDL:omg.org/CORBA/DataInputStream:1.0"IDL:omg.org/CORBA/DataInputStream:1.0? extends CDRInputStream_1_0Class<? extends CDRInputStream_1_0>Map<String,? extends CDRInputStream_1_0>CDRInputStream_1_0[]? extends CDRInputStream_1_0[]Constructor<? extends CDRInputStream_1_0>? super ? extends CDRInputStream_1_0Class<? super ? extends CDRInputStream_1_0>TypeVariable<Class<? extends CDRInputStream_1_0>>TypeVariable<Class<? extends CDRInputStream_1_0>>[]alignincrdataSizecheckForEndTagrequiredNumBytesnextLongalignResultb1b20x00FF0x000000FF0x0000FF0065280b3b4bufPos0xFF2416i1i2allowIndirection0xffffffffavailbyteswantedpvalueiorsffcodeBasestubFactoryridclassNameisIDLInterfaceisIDLClass<IDLEntity>Map<String,IDLEntity>IDLEntity[]Constructor<IDLEntity>? super IDLEntityClass<? super IDLEntity>TypeVariable<Class<IDLEntity>>TypeVariable<Class<IDLEntity>>[]servantdelcodebaseindirectioncachedValuevalueTagexpectedTypeexpectedTypeRepIdvTypesaveIsChunkedcodebase_URLrepositoryIDStringvalueClasssysExhelperrepositoryIdcodebasesclassRepIdrepositoryID"readClass codebases: "readClass codebases: " rep Id: " rep Id: cnfemereadMethodClass<InputStream>? extends ValueHelperClass<? extends ValueHelper>Map<String,? extends ValueHelper>ValueHelper[]? extends ValueHelper[]Constructor<? extends ValueHelper>? super ? extends ValueHelperClass<? super ? extends ValueHelper>TypeVariable<Class<? extends ValueHelper>>TypeVariable<Class<? extends ValueHelper>>[]nsmeieiaeiae2iteclazzclazzLoaderhelperClass"Helper"HelperPrivilegedExceptionAction<>/Users/jettt/IdeaProjects/jdk_test/target/classes/java/security/PrivilegedExceptionAction.class/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/encoding/CDRInputStream_1_0$1.classpaerepIdmarshalClass<StreamableValue>Map<String,StreamableValue>StreamableValue[]Constructor<StreamableValue>? super StreamableValueClass<? super StreamableValue>TypeVariable<Class<StreamableValue>>TypeVariable<Class<StreamableValue>>[]Class<CustomValue>Map<String,CustomValue>CustomValue[]Constructor<CustomValue>? super CustomValueClass<? super CustomValue>TypeVariable<Class<CustomValue>>TypeVariable<Class<CustomValue>>[]Class<ValueBase>Map<String,ValueBase>ValueBase[]Constructor<ValueBase>? super ValueBaseClass<? super ValueBase>TypeVariable<Class<ValueBase>>TypeVariable<Class<ValueBase>>[]anEndTagnumRepIdsrepIDbuffer64doubleDigitfirstDigitsecondDigitwroteFirstDigitmore0xf02400x0f"----- Input Buffer -----"----- Input Buffer -----"Current position: "Current position: "Total length : "Total length : charBufkhex"0""------------------------"------------------------specialNoOptionalDataState_/Library/Java/JavaVirtualMachines/jdk1.8.0_251.jdk/Contents/Home/jre/lib/rt.jar/com/sun/corba/se/impl/encoding/CDRInputStream_1_0$StreamMemento.classbbwi_valueHandler_isChunked_stringIndirection_valueIndirection_chunkedValueNestingLevel_end_flag_blockLength_memcodebaseURLcnfeOutercnfeInnermue"getClassFromString failed with rep id "getClassFromString failed with rep id " and codebase " and codebase numBytesconvertertmpBufneededoutputObj".close - releasing ByteBuffer id (".close - releasing ByteBuffer id (Copyright (c) 1997, 2017, Oracle and/or its affiliates. All rights reserved. Set to the ORB's transportDebugFlag value.  This value is used if the ORB is null. Value cache Repository ID cache codebase cache Current Class Stack (repository Ids of current class being read) private Stack currentStack = null; Length of current chunk, or a large positive number if not in a chunk Read end flag (value nesting depth) Beginning with the resolution to interop issue 3526 (4328?), only enclosing chunked valuetypes are taken into account when computing the nesting level.  However, we still need the old computation around for interoperability with our older ORBs. Flag used to determine whether blocksize was zero private int checkForNullBlock = -1; In block flag private boolean inBlock = false; Indicates whether we are inside a value private boolean outerValueDone = true; Int used by read_value(Serializable) that is set by this class before calling ValueFactory.read_value Int set by readStringOrIndirection to communicate the actual offset of the string length field back to the caller Flag indicating whether we are unmarshalling a chunked value Repository ID handlers Code set converters (created when first needed) RMI-IIOP stream format version 2 case in which we know that there is no more optional data available.  If the Serializable's readObject method tries to read anything, we must throw a MARSHAL with the special minor code so that the ValueHandler can give the correct exception to readObject.  The state is cleared when the ValueHandler calls end_value after the readObject method exits. Template method To ensure we keep bbwi.byteBuffer.limit in sync with bbwi.buflen.NOTE:  size passed to init means buffer size See description in CDRInputStream Called by Request and Reply message. Valid for GIOP versions >= 1.2 only. Illegal for GIOP versions < 1.2. Since chunks can end at arbitrary points (though not within primitive CDR types, arrays of primitives, strings, wstrings, or indirections), we must check here for termination of the current chunk. we must throw a MARSHAL exception with the special minor code Are we at the end of the current chunk?  If so, try to interpret the next long as a chunk length. (It has to be either a chunk length, end tag, or valuetag.) If it isn't a chunk length, blockLength will remain set to maxBlockLength. What's next is either a valuetag or an end tag.  If it's a valuetag, we're probably being called as part of the process to read the valuetag.  If it's an end tag, then there isn't enough data left in this valuetype to read! Are we already past the end of the current chunk? This is always an error. If what's next on the wire isn't a chunk length or what we want to read (which can't be split across chunks) won't fit in the current chunk, throw this exception. This probably means that we're in an RMI-IIOP Serializable's readObject method or a custom marshaled IDL type is reading too much/in an incorrect order REVISIT - We should look at using the built in advancement           of using ByteBuffer.get() rather than explicitly           advancing the ByteBuffer's position.           This is true for anywhere we are incrementing           the ByteBuffer's position. It was an end tag, so there wasn't enough data left in the valuetype's encoding on the wire to read what we wanted WARNING: Must compute real alignment after calling checkBlockLength since it may move the position This can be overridden.... Marshal primitives. No such type in java Don't allow transmission of wchar/wstring data with foreign ORBs since it's against the spec. If we're talking to one of our legacy ORBs, do what they did: Check for indirection Workaround for ORBs which send string lengths of zero to mean empty string. IMPORTANT: Do not replace 'new String("")' with "", it may result in a Serialization bug (See serialization.zerolengthstring) and bug id: 4728756 for details Skip over the 1 byte null skip the two null terminator bytes bbwi.position(bbwi.position() + 2); Must call alignAndCheck at least once to ensure we aren't at the end of a chunk.  Of course, we should only call it if we actually need to read something, otherwise we might end up with an exception at the end of the stream. Microbenchmarks are showing a loop of ByteBuffer.get(int) being faster than ByteBuffer.get(byte[], int, int). read off the typecode REVISIT We could avoid this try-catch if we could peek the typecode kind off this stream and see if it is a tk_value.  Looking at the code we know that for tk_value the Any.read_value() below ignores the tc argument anyway (except for the kind field). But still we would need to make sure that the whole typecode, including encapsulations, is read off. We can be sure that the whole typecode encapsulation has been read off. read off the value of the any ------------ RMI related methods -------------------------- IDL to Java ptc-00-01-08 1.21.4.1 The clz argument to read_Object can be either a stub Class or the "Class object for the RMI/IDL interface type that is statically expected." This functions as follows: 1. If clz==null, just use the repository ID from the stub 2. If clz is a stub class, just use it as a static factory.    clz is a stub class iff StubAdapter.isStubClass( clz ).    In addition, clz is a IDL stub class iff    IDLEntity.class.isAssignableFrom( clz ). 3. If clz is an interface, use it to create the appropriate    stub factory. In any case, we must first read the IOR. Could not create stubFactory, so use null. XXX stubFactory handling is still too complex: Can we resolve the stubFactory question once in a single place? clz is an interface classThis is used as a general utility (e.g., the PortableInterceptorimplementation uses it.   If stubFactory is null, the ior'sIIOPProfile must support getServant. If we managed to load a stub, return it, otherwise we must fail... Return the "default" stub... In RMI-IIOP the ValueHandler will recognize this exception and use the provided indirection value to lookup a possible indirection to an object currently on the deserialization stack.Examines the valuetag to see how many (if any) repository IDsare present on the wire.  If no repository ID informationis on the wire but the expectedType or expectedTypeRepIdis known, it will return one of those (favoring theexpectedType's repId). Failing that, it uses the suppliedBoxedValueHelper to obtain the repository ID, as a last resort. Throw an exception if we have no repository ID info and no expectedType to work with.  Otherwise, how would we know what to unmarshal? Read value tag Is value null? Is this an indirection to a previously read valuetype? Save where this valuetype started so we can put it in the indirection valueCache later Need to save this special marker variable to restore its value during recursion Read repository id(s) If isChunked was determined to be true based on the valuetag, this will read a chunk length Remember that end_flag keeps track of all nested valuetypes and is used for older ORBs read in the class whether with the old ClassDesc or the new one By this point, either the expectedType or repositoryIDString is guaranteed to be non-null. No point attempting to use value handler below, since the class information is not available. Must be some form of RMI-IIOP valuetype Just rethrow any CORBA system exceptions that come out of the ValueHandler Skip any remaining chunks until we get to an end tag or a valuetag.  If we see a valuetag, that means there was another valuetype in the sender's version of this class that we need to skip over. Read and process the end tag if we're chunking. Assumes that we're at the position of the end tag (handleEndOfValue should assure this) Cache the valuetype that we read Allow for possible continuation chunk. If we're a nested valuetype inside of a chunked valuetype, and that enclosing valuetype has more data to write, it will need to have this new chunk begin after we wrote our end tag. value is null Indirection tag end_block(); Read repository id Compare rep. ids to see if we should use passed helper for callback Put into valueCache allow for possible continuation chunk This method is actually called indirectly by read_value(String repositoryId). Therefore, it is not a truly independent read call that handles header information itself. Put into valueCache using valueIndirection if (inBlock)    end_block(); Pre-Merlin/J2EE 1.3 ORBs wrote the repository ID and codebase strings in the wrong order. look for two-argument static read method must be boxed value helper found two-argument read method, so must be non-boxed value... ...create a blank instance Value's constructor is protected or private So, use the helper to read the value. NOTE : This means that in this particular case a recursive ref. would fail. add blank instance to cache table if custom type, call unmarshal method call two-argument read method using reflection getDeclaredMethod requires RuntimePermission accessDeclaredMembers if a different class loader is used (even though the javadoc says otherwise) this gets caught below Always try to find a ValueFactory first, as required by the spec. There are some complications here in the IDL 3.0 mapping (see 1.13.8), but basically we must always be able to override the DefaultFactory or Helper mappings that are also used.  This appears to be the case even in the boxed value cases.  The original code only did the lookup in the case of class implementing either StreamableValue or CustomValue, but abstract valuetypes only implement ValueBase, and really require the use of the repId to find a factory (including the DefaultFactory). use new-style OBV support (factory object) XXX log marshal at one of the INFO levels Could not get a factory, so try alternatives use old-style OBV support (helper object) must be a boxed IDLEntity, so make a reflective call to the helper's static read method... If there was no error in getting the factory, use it.End tags are only written for chunked valuetypes.Before Merlin, our ORBs wrote end tags which took into accountall enclosing valuetypes.  This was changed by an interop resolution(see details around chunkedValueNestingLevel) to only includeenclosing chunked types.ORB versioning and end tag compaction are handled here. Read the end tag End tags should always be negative, and the outermost enclosing chunked valuetype should have a -1 end tag. handleEndOfValue should have assured that we were at the end tag position! If the ORB is null, or if we're sure we're talking to a foreign ORB, Merlin, or something more recent, we use the updated end tag computation, and are more strenuous about the values. If the end tag we read was less than what we were expecting, then the sender must think it's sent more enclosing chunked valuetypes than we have.  Throw an exception. If the end tag is bigger than what we expected, but still negative, then the sender has done some end tag compaction.  We back up the stream 4 bytes so that the next time readEndTag is called, it will get down here again.  Even with fragmentation, we'll always be able to do this. When talking to Kestrel or Ladybird, we use our old end tag rules and are less strict.  If the end tag isn't what we expected, we back up, assuming compaction. This only keeps track of the enclosing chunked valuetypes This keeps track of all enclosing valuetypes if (outerValueDone) if called from alignAndCheck, need to reset blockLength to avoid an infinite recursion loop on read_long() call Must remember where we began the chunk to calculate how far along we are.  See notes above about chunkBeginPos. _REVISIT_ unsafe, should use a Java long inBlock = true; System.out.println("start_block snooped a " + Integer.toHexString(blockLength)); not a chunk length field Makes sure that if we were reading a chunked value, we end up at the right place in the stream, no matter how little the unmarshalling code read. After calling this method, if we are chunking, we should be in position to read the end tag. If we're not chunking, we don't have to worry about skipping remaining chunks or finding end tags Skip any remaining chunks Now look for the end tag This is a little wasteful since we're reading this long up to 3 times in the worst cases (once in start_block, once here, and once in readEndTag Peek next long We did find an end tag, so we're done.  readEndTag should take care of making sure it's the correct end tag, etc.  Remember that since end tags, chunk lengths, and valuetags have non overlapping ranges, we can tell by the value what the longs are. A custom marshaled valuetype left extra data on the wire, and that data had another nested value inside of it.  We've just read the value tag or null of that nested value. In an attempt to get by it, we'll try to call read_value() to get the nested value off of the wire.  Afterwards, we must call handleEndOfValue recursively to read any further chunks that the containing valuetype might still have after the nested value. This probably means that the code to skip chunks has an error, and ended up setting blockLength to something other than maxBlockLength even though we weren't starting a new chunk. if in a chunk, check for underflow or overflow Chunk ended correctly Skip over anything left by bad unmarshaling code (ex: a buggy custom unmarshaler).  See handleEndOfValue. outerValueDone = false; ------------ End RMI related methods ----------------------------------------------------------------------------------------------// CDRInputStream state management.Are we at the end of the input stream?     public final boolean isAtEnd() {      return bbwi.position() == bbwi.buflen;     public int available() throws IOException {         return bbwi.buflen - bbwi.position(); Read # of repository ids read first array element and store it as an indirection to the whole array read and ignore the subsequent array elements, but put them in the indirection table in case there are later indirections back to them IndirectionDataInputStream methods digits isn't really needed here This method is unable to yield the correct scale. Each octet contains (up to) two decimal digits. If the fixed type has an odd number of decimal digits, then the representation begins with the first (most significant) digit. Otherwise, this first half-octet is all zero, and the first digit is in the second half-octet. The sign configuration, in the last half-octet of the representation, is 0xD for negative numbers and 0xC for positive and zero values. positive number or zero zero positive number done negative numberfor debugging For every 16 bytes, there is one line of output.  First, the hex output of the 16 bytes with each byte separated by a space. Add any extra spaces to align the text column in case we didn't end at 16 Now output the ASCII equivalents.  Non-ASCII characters are shown as periods. Number of bytes to skip Mark and reset ------------------------------------------------- These are the fields that may change after marking the stream position, so we need to save them. ---------------------------------- end Mark and Reset Provides a hook so subclasses of CDRInputStream can provide a CodeBase.  This ultimately allows us to grab a Connection instance in IIOPInputStream, the only subclass where this is actually used.Attempts to find the class described by the givenrepository ID string and expected type.  The firstattempt is to find the class locally, falling backon the URL that came with the value.  The secondattempt is to use a URL from the remote CodeBase. First try to load the class locally, then use the provided URL (if it isn't null) class cannot be loaded remotely. Get a URL from the remote CodeBase and retry Don't bother trying to find it locally again if we got a null URL Failed to load the class Always report a bad URLrepository ID string.  At most, three attempts are made:Try to find it locally, through the provided URL, andfinally, via a URL from the remote CodeBase. First try to load the class locally Try to load the class using the provided codebase URL (falls out below) Try to load the class using a URL from the remote CodeBase Don't bother if the codebaseURL is null Will ultimately return null if all three attempts fail, but don't do anything here. If we get here, we have failed to load the class Utility method used to get chars from bytes REVISIT - Look at CodeSetConversion.BTCConverter to see           if it can work with an NIO ByteBuffer. We should           avoid getting the bytes into an array if possible. To be honest, I doubt this saves much real time If the entire string is in this buffer, just convert directly from the bbwi rather than allocating and copying. Microbenchmarks are showing a loop of ByteBuffer.get(int) being faster than ByteBuffer.get(byte[], int, int). Stretches across buffers.  Unless we provide an incremental conversion interface, allocate and copy the bytes. Stream needs to go into a state where it throws standard exception until end_value is called.  This means the sender didn't send any custom data.  If the reader here tries to read more, we need to throw an exception before reading beyond where we're supposed to One should never indirect to a custom wrapper REVISIT - Could verify repository ID even though it isn't used elsewhere Note: isChunked should be true here.  Should have been set to true in the containing value's read_value Note that isChunked should still be true here. If the containing valuetype is the highest chunked value, it will get set to false at the end of read_value. tell BufferManagerRead to release any ByteBuffers It's possible bbwi.byteBuffer is shared between this InputStream and an OutputStream. Thus, we check if the Input/Output streams are using the same ByteBuffer. If they sharing the same ByteBuffer we need to ensure only one of those ByteBuffers are released to the ByteBufferPool. Set OutputStream's ByteBuffer and bbwi to null so its ByteBuffer cannot be released to the pool release this stream's ByteBuffer to the pool/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/encoding/CDRInputStream_1_1.javaalignmentoldSizefragmentOffset_/Library/Java/JavaVirtualMachines/jdk1.8.0_251.jdk/Contents/Home/jre/lib/rt.jar/com/sun/corba/se/impl/encoding/CDRInputStream_1_1$FragmentableStreamMemento.class See notes in CDROutputStream Some other ORBs may have found a way to send 1.1 fragments which put alignment bytes at the end of a fragment We must recalculate the alignment after a possible fragmentation since the new bbwi.position() (after the header) may require a different alignment. Save the size of the current buffer for possible fragmentOffset calculation By this point we should be guaranteed to have a new fragment whose header has already been unmarshalled.  bbwi.position() should point to the end of the header. Clear the flag Mark/reset --------------------------------------- -------------------------------------------------- In GIOP 1.1, interoperability with wchar is limited to 2 byte fixed width encodings.  CORBA formal 99-10-07 15.3.1.6. WARNING:  For UTF-16, this means that there can be no byte order marker, so it must default to big endian! Because of the alignAndCheck, we should be guaranteed 2 bytes of real data. Did the provided bytes convert to more than one character?  This may come up as more unicode values are assigned, and a single 16 bit Java char isn't enough. Better to use strings for i18n purposes. Don't include the two byte null for the following computations.  Remember that since we're limited to a 2 byte fixed width code set, the "length" was the number of such 2 byte code points plus a 2 byte null. Skip over the 2 byte null/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/encoding/CDRInputStream_1_2.java/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/encoding/CDRInputStream_1_2.classalignIncr Indicates whether the header is padded. In GIOP 1.2 and above, the body must be aligned on an 8-octet boundary, and so the header is padded appropriately. However, if there is no body to a request or reply message, there is no header padding, in the unfragmented case. used to remember headerPadding flag when mark() and restore() are used. Called by RequestMessage_1_2 or ReplyMessage_1_2 classes only. the mark and reset methods have been overridden to remember the headerPadding flag. This method has been overriden to ensure that the duplicated stream inherits the headerPadding flag, in case of GIOP 1.2 and above, streams. headerPadding bit is set by read method of the RequestMessage_1_2 or ReplyMessage_1_2 classes. When set, the very first body read operation (from the stub code) would trigger an alignAndCheck method call, that would in turn skip the header padding that was inserted during the earlier write operation by the sender. The padding ensures that the body is aligned on an 8-octet boundary, for GIOP versions 1.2 and beyond. In GIOP 1.2, a fragment may end with some alignment padding (which leads to all fragments ending perfectly on evenly divisible 8 byte boundaries).  A new fragment never requires alignment with the header since it ends on an 8 byte boundary. In GIOP 1.2, a wchar is encoded as an unsigned octet length followed by the octets of the converted wchar. In GIOP 1.2, wstrings are not terminated by a null.  The length is the number of octets in the converted format. A zero length string is represented with the 4 byte length value of 0./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/encoding/CDROutputObject.java/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/encoding/CDROutputObject.classCDROutputObjectCDROutputObject(com.sun.corba.se.spi.orb.ORB,com.sun.corba.se.spi.ior.iiop.GIOPVersion,com.sun.corba.se.impl.protocol.giopmsgheaders.Message,com.sun.corba.se.impl.encoding.BufferManagerWrite,byte,com.sun.corba.se.spi.protocol.CorbaMessageMediator)connectiongiopVersionmanagerstreamFormatVersionmediator".writeTo: ".writeTo: useByteOrderMarkers"CDROutputObject" REVISIT - only used on sendCancelRequest. NOTE: Used in SharedCDR (i.e., must be grow). Used in msgtypes test. REVISIT Used on sendCancelRequest. Used for needs addressing mode. Header should only be in message mediator. Another possibility: merge header and message mediator. REVISIT - make protected once all encoding togetherWrite the contents of the CDROutputStream to the specifiedoutput stream.  Has the side-effect of pushing any currentMessage onto the Message list.The output stream to write to. Update the GIOP MessageHeader size field.overrides create_input_stream from CDROutputStreamreturn new XIIOPInputStream(orb(), getByteBuffer(), getIndex(),isLittleEndian(), getMessageHeader(), conn); REVISIT - only set when doing sendCancelRequest. XREVISIT - If CDROutputObject doesn't live in the iiop package, it will need this, here, to give package access to xgiop. With UTF-16: For GIOP 1.2, we can put byte order markers if we want to, and use the default of big endian otherwise.  (See issue 3405b) For GIOP 1.1, we don't use BOMs and use the endianness of the stream. In the normal case, let the converter system handle it/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/encoding/CDROutputStream.java/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/encoding/CDROutputStream.classOutputStreamFactoryOutputStreamFactory()/Library/Java/JavaVirtualMachines/jdk1.8.0_251.jdk/Contents/Home/jre/lib/rt.jar/com/sun/corba/se/impl/encoding/CDROutputStream$OutputStreamFactory.classcontextsrepository_idtagposIndirectedTo REVISIT - what is appropriate?  INTERNAL exceptions are really hard to track later. REVISIT - These two constructors should be re-factored to better hide the fact that someone extending this class 'can' construct a CDROutputStream that does not use pooled ByteBuffers. Right now, only EncapsOutputStream does _not_ use pooled ByteBuffers, see EncapsOutputStream. NOTE: When a stream is constructed for non-channel-backed sockets it notifies the constructor not to use pooled (i.e, direct) ByteBuffers. org.omg.CORBA.portable.OutputStream Provided by IIOPOutputStream and EncapsOutputStream org.omg.CORBA_2_3.portable.OutputStream java.io.OutputStream com.sun.corba.se.impl.encoding.MarshalOutputStream org.omg.CORBA.DataOutputStream Other Used in indirections. Overridden by TypeCodeOutputStream. XREVISIT - return to final if possible REVISIT - was protected - need access from msgtypes test. REVISIT: was protected - but need to access from xgiop. ValueOutputStream -----------------------------/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/encoding/CDROutputStreamBase.java/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/encoding/CDROutputStreamBase.classfreeInternalCachesfreeInternalCaches()CDROutputStreamBaseCDROutputStreamBase()Describes CDROutputStream delegates and provides some Required by parent CDROutputStream See EncapsOutputStream, the only one that uses the non-pooled ByteBuffers, for additional info.     public abstract void write(byte b[]) throws IOException;     public abstract void write(byte b[], int off, int len) throws IOException;     public abstract void flush() throws IOException; Required by IIOPOutputStream and other subclasses org.omg.CORBA.portable.ValueOutputStream/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/encoding/CDROutputStream_1_0.java/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/encoding/CDROutputStream_1_0.classwriteIDLEntitywriteIDLEntity(org.omg.CORBA.portable.IDLEntity)shouldWriteAsIDLEntityshouldWriteAsIDLEntity(java.io.Serializable)writeClassBodywriteClassBody(java.lang.Class)writeClasswriteClass(java.lang.String,java.lang.Class)writeNestingLevelwriteNestingLevel()writeEndTagwriteEndTag(boolean)writeIDLValuewriteIDLValue(java.io.Serializable,java.lang.String)writeValueTagwriteValueTag(boolean,boolean,java.lang.String)write_codebasewrite_codebase(java.lang.String,int)write_repositoryIdwrite_repositoryId(java.lang.String)updateIndirectionTableupdateIndirectionTable(int,java.lang.Object,java.lang.Object)writeRMIIIOPValueTypewriteRMIIIOPValueType(java.io.Serializable,java.lang.Class)writeValueBasewriteValueBase(org.omg.CORBA.portable.ValueBase,java.lang.Class)writeArraywriteArray(java.io.Serializable,java.lang.Class)writeWStringValuewriteWStringValue(java.lang.String)internalWriteOctetArrayinternalWriteOctetArray(byte[],int,int)writeBigEndianLongLongwriteBigEndianLongLong(long)writeLittleEndianLongLongwriteLittleEndianLongLong(long)writeBigEndianLongwriteBigEndianLong(int)writeLittleEndianLongwriteLittleEndianLong(int)writeBigEndianShortwriteBigEndianShort(short)writeLittleEndianShortwriteLittleEndianShort(short)writeBigEndianWcharwriteBigEndianWchar(char)writeLittleEndianWcharwriteLittleEndianWchar(char)valueHandlerend_flag_indexend_flag_positionmustChunkend_flagkWriteMethodINDIRECTION_TAG"write"write"IDL:omg.org/CORBA/DataOutputStream:1.0"IDL:omg.org/CORBA/DataOutputStream:1.0itrequiredSize404856refnullIORcorbaObjecttheObjectccevholdMustChunkisCustommodifier"CDROutputStream_1_0 start_block, position"CDROutputStream_1_0 start_block, position"CDROutputStream_1_0 start_block, blockSizeIndex "CDROutputStream_1_0 start_block, blockSizeIndex "CDROutputStream_1_0.java end_block"CDROutputStream_1_0.java end_block"CDROutputStream_1_0.java end_block, in a block"CDROutputStream_1_0.java end_block, in a blockbufchunkItuseRepIdchunked? extends IDLEntityClass<? extends IDLEntity>Class<OutputStream>writeMethod/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/encoding/CDROutputStream_1_0$1.classstringBuffer'0'signumstringLengthchdigitnumDigits0xd0xc"+++++++ Output Buffer ++++++++"+++++++ Output Buffer ++++++++"++++++++++++++++++++++++++++++"++++++++++++++++++++++++++++++"start_value w/ rep id "start_value w/ rep id " called at pos " called at pos " position " position "end_value called at pos "end_value called at pos "mustChunk is "mustChunk is inputObj Codebase cache Write end flag Beginning with the resolution to interop issue 3526, In block marker Last end tag position ValueHandler REVISIT - This should be re-factored so that including whether to use pool byte buffers or not doesn't need to be known. ORB must not be null.  See CDROutputStream constructor. Micro-benchmarks show ByteBuffer.get(int) out perform the bulk ByteBuffer.get(byte[], offset, length). No-op for GIOP 1.0 Default implementation of grow.  Subclassers may override this. Always grow the single buffer. This needs to delegate fragmentation policy for IIOP 1.1. The 'if' stmt is commented out since we need the alignAndReserve to be called, particularly when the first body byte is written, to induce header padding to align the body on a 8-octet boundary, for GIOP versions 1.2 and above. Refer to internalWriteOctetArray() method that also has a similar change.if (bbwi.position() + 1 > bbwi.buflen)      REVISIT - Should just use ByteBuffer.put(byte) and let it                increment the ByteBuffer position. This is true                for all write operations in this file. CORBA formal 99-10-07 15.3.1.6: "In the case of multi-byte encodings of characters, a single instance of the char type may only hold one octet of any multi-byte character encoding." These wchar methods are only used when talking to legacy ORBs, now. If it's one of our legacy ORBs, do what they did: A string is encoded as an unsigned CORBA long for the number of bytes to follow (including a terminating null). There is only one octet per character in the string. Write the null ending When talking to our legacy ORBs, do what they did: This will only have an effect if we're already chunking Performs no checks and doesn't tamper with chunking This flag forces the alignAndReserve method to be called the first time an octet is written. This is necessary to ensure that the body is aligned on an 8-octet boundary. Note the 'if' condition inside the 'while' loop below. Also, refer to the write_octet() method that has a similar change. IDL to Java formal 01-06-06 1.21.4.2 Assume value type. Is it a CORBA.Object? Yes. Write our flag... Now write out the object... Write WStringValue's repository ID Add indirection for object to indirection table Write Value chunk Write end tagd11638 Write value_tag Write repository ID _REVISIT_ could check to see whether chunking really needed Get rep id Write rep id Allow the ValueHandler to call writeReplace on the Serializable (if the method is present) Write null tag and return Write rep. id Handle null references Handle shared references Handle arrays Handle IDL Value types RMI-IIOP value type Check to see if we need to start another block for a possible outer value no need to test for custom on the non-chunked pathMove inBlock=true to after write_long since write_long mighttrigger grow which will lead to erroneous behavior with amissing blockSizeIndex.inBlock = true; Save space in the buffer for block sizeHas to happen after write_long since write_long couldtrigger grow which is overridden by supper classes todepend on inBlock. Remember where to put the size of the endblock less 4 Utility method which will hopefully decrease chunking complexity by allowing us to end_block and update chunk lengths without calling alignAndReserve.  Otherwise, it's possible to get into recursive scenarios which lose the chunking state. Test to see if the block was of zero length If so, remove the block instead of ending it (This can happen if the last field written  in a value was another value) Need to assert that blockSizeIndex == bbwi.position()?  REVISIT System.out.println("      post end_block: " + get_offset() + " " + bbwi.position()); CDROutputStream state management. Micro-benchmarks are showing a loop of ByteBuffer.get(int) is faster than ByteBuffer.get(byte[], offset, length) int indirection = get_offset(); Use an indirection if available Write it as a string.  Note that we have already done the special case conversion of non-Latin-1 characters to escaped Latin-1 sequences in RepositoryId. It's not a good idea to cache them now that we can have multiple code sets. Add indirection for id to indirection table Handles end tag compaction... We are exactly at the same position and index as the end of the last end tag.  Thus, we can back up over it and compact the tags. Special case in which we're at the beginning of a new fragment, but the position is the same.  We can't back up, so we just write the new end tag without compaction.  This occurs when a value ends and calls start_block to open a continuation chunk, but it's called at the very end of a fragment. Remember the last index and position.  These are only used when chunking. Increment the nesting levelHandles ORB versioning of the end tag.  Should onlybe called if chunking.If talking to our older ORBs (Standard Extension,Kestrel, and Ladybird), write the end flag that takesinto account all enclosing valuetypes.If talking a newer or foreign ORB, or if the orbinstance is null, write the end flag that only takesinto account the enclosing chunked valuetypes. and codebase strings in the wrong order.  This handles backwards compatibility. Casts and returns an Object as a Serializable This is required for JDK 1.1 only to avoid VerifyErrors when passing arrays as Serializable private java.io.Serializable make_serializable(java.lang.Object object)  return (java.io.Serializable)object; } Write the IDLEntity using reflectionDataOutputStream methods This will stay a custom add-on until the java-rtf issue is resolved. Then it should be declared in org.omg.CORBA.portable.OutputStream. Pads the string representation of bigDecimal with zeros to fit the given digits and scale before it gets written to the stream. Get rid of the sign Determine integer and fraction parts Pad both parts with zeros as necessary This string contains no sign or dot This method should be remove by the java-rtf issue. Right now the scale and digits information of the type code is lost. This string might contain sign and/or dot The string may contain a sign and dot Each octet contains (up to) two decimal digits First calculate the length of the string without optional sign and dot If the fixed type has an odd number of decimal digits, then the representation begins with the first (most significant) digit. is 0xD for negative numbers and 0xC for positive and zero values Must ensure that there are no chunks between the tag and the actual indirection value.  This isn't talked about in the spec, but seems to cause headaches in our code. At the very least, this method isolates the indirection code that was duplicated so often. write indirection tag write indirection Use parent.getRealIndex() so that it can be overridden by TypeCodeOutputStreamsSystem.out.println("CDROutputStream_1_0 writing indirection pos " + posIndirectedTo +" - real index " + parent.getRealIndex(get_offset()) + " = " +(posIndirectedTo - parent.getRealIndex(get_offset()))); Make sure to chunk the custom data possible outer value.  Since we're in the stream format 2 custom type contained by another custom type, mustChunk should always be true. Here's why we need to open a continuation chunk: We need to enclose the default data of the next subclass down in chunks.  There won't be an end tag separating the superclass optional data and the subclass's default data. tell BufferManagerWrite to release any ByteBuffers this OutputStream and an InputStream. Thus, we check Set InputStream's ByteBuffer and bbwi to null/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/encoding/CDROutputStream_1_1.java This is used to keep indirections working across fragments.  When added to the current bbwi.position(), the result is the current position in the byte stream without any fragment headers. It is equal to the following: n = number of buffers (0 is original buffer, 1 is first fragment, etc) n == 0, fragmentOffset = 0 n > 0, fragmentOffset          = sum i=[1,n] { bbwi_i-1_.size - buffer i header length } Notice that in 1.1, we won't end a fragment with alignment padding.  We also won't guarantee that our fragments end on evenly divisible 8 byte boundaries.  There may be alignment necessary with the header of the next fragment since the header isn't aligned on an 8 byte boundary, so we have to calculate it twice. Must recompute the alignment after a grow. In the case of fragmentation, the alignment calculation may no longer be correct. People shouldn't be able to set their fragment sizes so small that the fragment header plus this alignment fills the entire buffer. Save the current size for possible post-fragmentation calculation At this point, if we fragmented, we should have a ByteBufferWithInfo with the fragment header already marshalled.  The size and length fields should be updated accordingly, and the fragmented flag should be set. Update fragmentOffset so indirections work properly. At this point, oldSize is the entire length of the previous buffer.  bbwi.position() is the length of the fragment header of this buffer. Note that the following code prohibits UTF-16 with a byte order marker (which would result in 4 bytes). The length is the number of code points (which are 2 bytes each) including the 2 byte null.  See CORBA formal 99-10-07 15.3.2.7. Write the 2 byte null ending/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/encoding/CDROutputStream_1_2.java/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/encoding/CDROutputStream_1_2.classcheckPrimitiveAcrossFragmentedChunkcheckPrimitiveAcrossFragmentedChunk()handleChunkoldIndextotalNumBytesmaxLength There's a situation with chunking with fragmentation in which the alignment for a primitive value is needed to fill fragment N, but the primitive won't fit so must go into fragment N + 1.  The behavior is the same as that for specialChunks. Unfortunately, given the current code, we can't reuse specialChunk.  If you wrap each of the following write calls with handleSpecialChunkBegin/End, you will lose your state because the primitive calls will change the variables, etc. All of the CDR code should be rewritten moving chunking to a different level, perhaps in the buffer managers. We want to move to a compositional model rather than using inheritance. Note that in the grow case, chunks are _NOT_ closed at grow points, now. **** NOTE **** Since we will not support valuetypes with GIOP 1.1, that also means we do not support chunking there. Used in chunking.  Here's how this works: When chunking and writing an array of primitives, a string, or a wstring, _AND_ it won't fit in the buffer do the following.  (As you can see, this is a very "special" chunk.)     1.  Write the length of the chunk including the array length     2.  Set specialChunk to true 3 applies to ALL chunking:     3.  In grow, if we need to fragment and specialChunk is false               a) call end_block               b) fragment Now back to the array only case:     [write the data]     4.  if specialChunk is true               a) Close the chunk               b) Set specialChunk to false Indicates whether the header should be padded. In GIOP 1.2 and above, the body must be aligned on a 8-octet boundary, and so the header needs to be message, there is no need to pad the header, in the unfragmented case. If we're chunking and the item won't fit in the buffer Duplicating some code from end_block.  Compute and write the total chunk length.write_long(oldSize - blockSizeIndex); Set the special flag so we don't end the chunk when we fragment If we're in a chunk and the item spanned fragments This is unnecessary, but I just want to show that we're done with the current chunk.  (the end_block call is inappropriate here) Start a new chunk since we fragmented during the item. Thus, no one can go back to add more to the chunk length Now turn off the flag so we go back to the normal behavior of closing a chunk when we fragment and reopening afterwards. Called after writing primitives It would be nice to have a StreamPosition abstraction if we could avoid allocation overhead. Start a new chunk headerPadding bit is set by the write operation of RequestMessage_1_2 or ReplyMessage_1_2 classes. When set, the very first body write operation (from the stub code) would trigger an alignAndReserve method call, that would in turn add the appropriate header padding, such that the body is aligned on a 8-octet boundary. The padding is required for GIOP versions 1.2 and above, only if body is present. In GIOP 1.2, we always end fragments at our fragment size, which is an "evenly divisible 8 byte boundary" (aka divisible by 16).  A fragment can end with appropriate alignment padding, but no padding is needed with respect to the next GIOP fragment header since it ends on an 8 byte boundary. See notes where specialChunk is defined, as well as the above notes for primitiveAcrossFragmentedChunk. If we're writing a primitive and chunking, we need to update the chunk length to include the length of the primitive (unless this complexity is handled by specialChunk). Note that this is wasted processing in the grow case, but that we don't actually close the chunk in that case. with the fragment header already marshalled.  The buflen and position Note that fragmented is only true in the streaming and collect cases. We just fragmented, and need to signal that we should start a new chunk after writing the primitive. followed by the octets of the converted wchar.  This is good, but it causes problems with our chunking code.  We don't want that octet to get put in a different chunk at the end of the previous fragment. Ensure that this won't happen by overriding write_wchar_array and doing our own handleSpecialChunkBegin/End here. Write the bytes without messing with chunking See CDROutputStream_1_0 Unfortunately, because of chunking, we have to convert the entire char[] to a byte[] array first so we can know how many bytes we're writing ahead of time.  You can't split an array of primitives into multiple chunks. Remember that every wchar starts with an octet telling its length.  The buffer size is an upper bound estimate. Convert one wchar Make sure to add the octet length Copy it into our buffer Now that we know the total length, we can deal with chunking. Note that we don't have to worry about alignment since they're just octets. Must use totalNumBytes rather than buffer.length since the buffer.length is only the upper bound estimate. Write the octet array without tampering with chunking/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/encoding/CachedCodeBase.javagetObjectFromIORgetObjectFromIOR()/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/encoding/CachedCodeBase.classconnectedCodeBaseconnectedCodeBase()Hashtable<IOR,CodeBase>Dictionary<IOR,CodeBase>Map<IOR,CodeBase>iorMapiorMapLockvolatilebasesfvdsimplementationsHashtable<IOR,CodeBase>()put(com.sun.corba.se.spi.ior.IOR,com.sun.org.omg.SendingContext.CodeBase)Enumeration<CodeBase>Enumeration<IOR>Dictionary<IOR,CodeBase>()? super CodeBase? extends CodeBaseBiFunction<? super CodeBase,? super CodeBase,? extends CodeBase>merge(com.sun.corba.se.spi.ior.IOR,com.sun.org.omg.SendingContext.CodeBase,java.util.function.BiFunction)? super IORBiFunction<? super IOR,? super CodeBase,? extends CodeBase>compute(com.sun.corba.se.spi.ior.IOR,java.util.function.BiFunction)computeIfPresent(com.sun.corba.se.spi.ior.IOR,java.util.function.BiFunction)Function<? super IOR,? extends CodeBase>computeIfAbsent(com.sun.corba.se.spi.ior.IOR,java.util.function.Function)replace(com.sun.corba.se.spi.ior.IOR,com.sun.org.omg.SendingContext.CodeBase)replace(com.sun.corba.se.spi.ior.IOR,com.sun.org.omg.SendingContext.CodeBase,com.sun.org.omg.SendingContext.CodeBase)putIfAbsent(com.sun.corba.se.spi.ior.IOR,com.sun.org.omg.SendingContext.CodeBase)BiConsumer<? super IOR,? super CodeBase>getOrDefault(java.lang.Object,com.sun.org.omg.SendingContext.CodeBase)Entry<IOR,CodeBase>Set<Entry<IOR,CodeBase>>Collection<Entry<IOR,CodeBase>>Iterable<Entry<IOR,CodeBase>>Collection<CodeBase>Iterable<CodeBase>Set<IOR>Collection<IOR>Iterable<IOR>? extends IORMap<? extends IOR,? extends CodeBase>Hashtable<IOR,CodeBase>(java.util.Map)Hashtable<IOR,CodeBase>(int)Hashtable<IOR,CodeBase>(int,float)urlResultrepIdsurlResultsFullValueDescription[]results"CodeBase unavailable on connection: "CodeBase unavailable on connection: Copyright (c) 2001, 2012, Oracle and/or its affiliates. All rights reserved.Provides the reading side with a per connection cache ofinfo obtained via calls to the remote CodeBase.Previously, most of this was in IIOPConnection.Features:Delays cache creation unless usedPostpones remote calls until necessaryHandles creating obj ref from IORMaintains caches for the following maps:CodeBase IOR to obj ref (global)RepId to implementation URL(s)RepId to remote FVDRepId to superclass type listNeeds cache management. Ensures that we've used the connection's IOR to create a valid CodeBase delegate.  If this returns false, then it is not valid to access the delegate. The delegate was null, so see if the connection's IOR was set.  If so, then we just need to connect it.  Otherwise, there is no hope of checking the remote code base.  That could be bug if the service context processing didn't occur, or it could be that we're talking to a foreign ORB which doesn't include this optional service context. REVISIT.  Use Merlin logging service to report that codebase functionality was requested but unavailable. Recheck the condition to make sure another thread didn't already do this while we waited Do we have a reference initialized by another connection? Connect the delegate and update the cache Save it for the benefit of other connections It's now safe to use the delegate/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/encoding/CodeSetCache.javasetConvertersetConverter(java.lang.Object,java.nio.charset.CharsetEncoder)/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/encoding/CodeSetCache.classsetConverter(java.lang.Object,java.nio.charset.CharsetDecoder)getCharToByteConvertergetCharToByteConverter(java.lang.Object)getByteToCharConvertergetByteToCharConverter(java.lang.Object)CTB_CACHE_MAPBTC_CACHE_MAPThreadLocal<>/Users/jettt/IdeaProjects/jdk_test/target/classes/java/lang/ThreadLocal.classconverterCachesCodeSetCacheCodeSetCache()/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/encoding/CodeSetCache$1.classchildValuechildValue(java.lang.Object)createInheritedMapcreateInheritedMap(java.lang.ThreadLocal.ThreadLocalMap)createMapcreateMap(java.lang.Thread,java.lang.Object)getMapgetMap(java.lang.Thread)get()ThreadLocalThreadLocal()ThreadLocal<>()Supplier<>/Users/jettt/IdeaProjects/jdk_test/target/classes/java/util/function/Supplier.classSThreadLocal<S>withInitialwithInitial(java.util.function.Supplier)? extends SSupplier<? extends S>initialValue()Map[]Map<>[]WeakHashMap<>/Users/jettt/IdeaProjects/jdk_test/target/classes/java/util/WeakHashMap.classWeakHashMap<>()removeMappingremoveMapping(java.lang.Object)resize(int)/Library/Java/JavaVirtualMachines/jdk1.8.0_251.jdk/Contents/Home/jre/lib/rt.jar/java/util/WeakHashMap$Entry.classjava.lang.refWeakReference<>/Users/jettt/IdeaProjects/jdk_test/target/classes/java/lang/ref/WeakReference.class/Users/jettt/IdeaProjects/jdk_test/target/classes/java/lang/refReference<>/Users/jettt/IdeaProjects/jdk_test/target/classes/java/lang/ref/Reference.classWeakReference<Object>Reference<Object>getEntry(java.lang.Object)unmaskNullunmaskNull(java.lang.Object)WeakHashMapWeakHashMap(java.util.Map)WeakHashMap<>(java.util.Map)WeakHashMap()WeakHashMap(int)WeakHashMap<>(int)WeakHashMap(int,float)WeakHashMap<>(int,float)Entry[]Entry<K,V>[]btcMapctbMapThread local cache of sun.io code set converters for performance.The thread local class contains a single reference to a Map[]containing two WeakHashMaps.  One for CharsetEncoders andone for CharsetDecoders.  Constants are defined for indexing.This is used internally by CodeSetConversion.The ThreadLocal data is a 2 element Map array indexedby BTC_CACHE_MAP and CTB_CACHE_MAP.Index in the thread local converterCaches array forthe byte to char converter Map.  A key is the Javaname corresponding to the desired code set.the char to byte converter Map.  A key is the JavaRetrieve a CharsetDecoder from the Map using the given key.Retrieve a CharsetEncoder from the Map using the given key.Stores the given CharsetDecoder in the thread local cache,and returns the same converter.Stores the given CharsetEncoder in the thread local cache,/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/encoding/CodeSetComponentInfo.javaforWCharData/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/encoding/CodeSetComponentInfo.classforCharDatacharDatawcharDataconversionCodeSets/Library/Java/JavaVirtualMachines/jdk1.8.0_251.jdk/Contents/Home/jre/lib/rt.jar/com/sun/corba/se/impl/encoding/CodeSetComponentInfo$CodeSetComponent.classnativeCodeSet37sbuf"CodeSetComponent("CodeSetComponent("native:"native:" conversion:" conversion:"CodeSetComponentInfo("CodeSetComponentInfo("char_data:"char_data:" wchar_data:" wchar_data:wchar_data/Library/Java/JavaVirtualMachines/jdk1.8.0_251.jdk/Contents/Home/jre/lib/rt.jar/com/sun/corba/se/impl/encoding/CodeSetComponentInfo$CodeSetContext.classchar_datacharEncodingwcharEncoding"CodeSetContext char set: "CodeSetContext char set: " wchar set: " wchar set: stoknativeSetconversionIntsconversionListnseeCopyright (c) 1998, 2003, Oracle and/or its affiliates. All rights reserved.CodeSetComponent is part of an IOR multi-component profile.  Twoinstances constitute a CodeSetComponentInfo (one for char and onefor wchar data)CodeSetContext goes in a GIOP service contextOur default code set scheme is as follows:char data:Native code set:  ISO 8859-1 (8-bit)Conversion sets:  UTF-8, ISO 646 (7-bit)wchar data:Native code set:  UTF-16Conversion sets:  UCS-2Pre-Merlin/J2EE 1.3 JavaSoft ORBs listed ISO646 for char andUCS-2 for wchar, and provided no conversion sets.  They alsodidn't do correct negotiation or provide the fallback sets.UCS-2 is still in the conversion list for backwards compatibility.The fallbacks are UTF-8 for char and UTF-16 for wchar.In GIOP 1.1, interoperability with wchar is limited to 2 byte fixedwidth encodings since its wchars aren't preceded by a length.Thus, I've chosen not to include UTF-8 in the conversion setfor wchar data.Creates a CodeSetComponent from a String which contains a commadelimited list of OSF Code Set Registry numbers.  An INITIALIZEexception is thrown if any of the numbers are not known by ourregistry.  Used by corba.ORB init.The first number in the list is taken as the native code set,and the rest is the conversion code set list.The numbers can either be decimal or hex. The first value is the native code set Now process the other values as part of the conversion code set list. decode allows us to specify hex, decimal, etc Otherwise return the CodeSetComponent representing the given valuesCode sets for local cases without a connection./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/encoding/CodeSetConversion.javacache/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/encoding/CodeSetConversion.classFALLBACK_CODESETimplementationCodeSetConversionCodeSetConversion()selectEncodingselectEncoding(com.sun.corba.se.impl.encoding.CodeSetComponentInfo.CodeSetComponent,com.sun.corba.se.impl.encoding.CodeSetComponentInfo.CodeSetComponent)chToConvertstrToConvertconvertCharArrayconvertCharArray()/Library/Java/JavaVirtualMachines/jdk1.8.0_251.jdk/Contents/Home/jre/lib/rt.jar/com/sun/corba/se/impl/encoding/CodeSetConversion$JavaCTBConverter.classcodesetnumCharscharsctbalignmentForEncodingtmpCharseticneucneisemieuce/Library/Java/JavaVirtualMachines/jdk1.8.0_251.jdk/Contents/Home/jre/lib/rt.jar/com/sun/corba/se/impl/encoding/CodeSetConversion$JavaBTCConverter.classresultingNumCharsbyteBufilejavaCodeSetNameswitchToConverterswitchToConverter(com.sun.corba.se.impl.encoding.OSFCodeSetRegistry.Entry)/Library/Java/JavaVirtualMachines/jdk1.8.0_251.jdk/Contents/Home/jre/lib/rt.jar/com/sun/corba/se/impl/encoding/CodeSetConversion$UTF16BTCConverter.classhasUTF16ByteOrderMarkerhasUTF16ByteOrderMarker(byte[],int,int)UTF16_LE_MARKERUTF16_BE_MARKERconverterUsesBOMdefaultToLittleEndian0xfeff652790xfffe65534markernewCodeSetclientserverNativecsc/Library/Java/JavaVirtualMachines/jdk1.8.0_251.jdk/Contents/Home/jre/lib/rt.jar/com/sun/corba/se/impl/encoding/CodeSetConversion$CodeSetConversionHolder.classCodeSetConversionHolderCodeSetConversionHolder()Collection of classes, interfaces, and factory methods forCORBA code set conversion.This is mainly used to shield other code from the sun.ioconverters which might change, as well as provide some basictranslation from conversion to CORBA error exceptions.  Someextra work is required here to facilitate the way CORBAsays it uses UTF-16 as of the 00-11-03 spec.REVISIT - Since the nio.Charset and nio.Charset.Encoder/Decoderuse NIO ByteBuffer and NIO CharBuffer, the interactionand interface between this class and the CDR streamsshould be looked at more closely for optimizations toavoid unnecessary copying of data between char[] &CharBuffer and byte[] & ByteBuffer, especiallyDirectByteBuffers.Abstraction for char to byte conversion.Must be used in the proper sequence:1)  convert2)  Optional getNumBytes and/or getAlignment (if necessary)3)  getBytes (see warning) Perform the conversion of the provided char or String, allowing the caller to query for more information before writing. How many bytes resulted from the conversion? What's the maximum number of bytes per character? What byte boundary should the stream align to before calling writeBytes?  For instance, a fixed width encoding with 2 bytes per char in a stream which doesn't encapsulate the char's bytes should align on a 2 byte boundary.  (Ex:  UTF16 in GIOP1.1) Note: This has no effect on the converted bytes.  It is just information available to the caller. Get the resulting bytes.  Warning:  You must use getNumBytes() to determine the end of the data in the byte array instead of array.length!  The array may be used internally, so don't save references.Abstraction for byte to char conversion. In GIOP 1.1, interoperability can only be achieved with fixed width encodings like UTF-16.  This is because wstrings specified how many code points follow rather than specifying the length in octets. Called after getChars to determine the true size of the converted array. Perform the conversion using length bytes from the given input stream.  Warning:  You must use getNumChars() to determine the correct length of the resulting array. The same array may be used internally over multiple calls.Implementation of CTBConverter which uses a nio.Charset.CharsetEncoderto do the real work.  Handles translation of exceptions to theappropriate CORBA versions. nio.Charset.CharsetEncoder actually does the work here have to use it directly rather than through String's interface because we want to know when errors occur during the conversion. Proper alignment for this type of converter.  For instance, ASCII has alignment of 1 (1 byte per char) but UTF16 has alignment of 2 (2 bytes per char) Char buffer to hold the input. How many bytes are generated from the conversion? How many characters were converted (temporary variable for cross method communication) ByteBuffer holding the converted input.  This is necessary since we have to do calculations that require the conversion before writing the array to the stream. What code set are we using? This can only happen if one of our Entries has an invalid name. an unsupported name. The CharToByteConverter only takes a char[] Try to save a memory allocation if possible.  Usual space/time trade off.  If we could get the char[] out of the String without copying, that would be great, but it's forbidden since String is immutable. Note that you can't use buffer.length since the buffer might be larger than the actual number of converted bytes depending on the encoding. Possible optimization of directly converting into the CDR buffer. However, that means the CDR code would have to reserve a 4 byte string length ahead of time, and we'd need a confusing partial conversion scheme for when we couldn't fit everything in the buffer but needed to know the converted length before proceeding due to fragmentation. Then there's the issue of the chunking code. For right now, this is less messy and basic tests don't show more than a 1 ms penalty worst case.  Less than a factor of 2 increase. Convert the characters ByteBuffer returned by the encoder will set its limit to byte immediately after the last written byte. an encoding operation is already in progress There were illegal Unicode char pairs A character doesn't map to the desired code set CORBA formal 00-11-03. If this happens, then some other encoding error occuredSpecial UTF16 converter which can either always write a BOMor use a specified byte order without one. Using this constructor, we will always write a BOM Using this constructor, we don't use a BOM and use the byte order specifiedImplementation of BTCConverter which uses a sun.io.ByteToCharConverterfor the real work.  Handles translation of exceptions to the Obtain a Decoder Should only be called if isFixedWidthEncoding is true IMPORTANT: This calls OSFCodeSetRegistry.Entry, not            CharsetDecoder.maxCharsPerByte(). Possible optimization of reading directly from the CDR byte buffer.  The sun.io converter supposedly can handle incremental conversions in which a char is broken across two convert calls. Basic tests didn't show more than a 1 ms increase worst case.  It's less than a factor of 2 increase. Also makes the interface more difficult. CharBuffer returned by the decoder will set its limit IMPORTANT - It's possible the underlying char[] in the             CharBuffer returned by btc.decode(byteBuf)             is longer in length than the number of characters             decoded. Hence, the check below to ensure the             char[] returned contains all the chars that have             been decoded and no more. There were a decoding operation already in progress A character doesn't map to the desired code set. If this happens, then a character decoding error occured.Utility method to find a CharsetDecoder in thecache or create a new one if necessary.  Throws anINTERNAL if the code set is unknown. This can only happen if one of our charset entries has an illegal name.Special converter for UTF16 since it's required to optionallysupport a byte order marker while the internal Java converterseither require it or require that it isn't there.The solution is to check for the byte order marker, and if weneed to do something differently, switch internal converters. When there isn't a byte order marker, used the byte order specified.Utility method for determining if a UTF-16 byte order marker is present. If there aren't enough bytes to represent the marker and data, return false.The current solution for dealing with UTF-16 in CORBAis that if our sun.io converter requires byte order markers,and then we see a CORBA wstring/wchar without them, weswitch to the sun.io converter that doesn't require them. Use the getConverter method from our superclass.CTB converter factory for single byte or variable length encodings.CTB converter factory for multibyte (mainly fixed) encodings.Because of the awkwardness with byte order markers and the possibility ofusing UCS-2, you must specify both the endianness of the stream as well aswhether or not to use byte order markers if applicable.  UCS-2 has no byteorder markers.  UTF-16 has optional markers.If you select useByteOrderMarkers, there is no guarantee that the encodingwill use the endianness specified. UCS2 doesn't have byte order markers, and we're encoding it as UTF-16 since UCS2 isn't available in all Java platforms. They should be identical with only minor differences in negative cases. We can write UTF-16 with or without a byte order marker. Everything else uses the generic JavaCTBConverter. Variable width encodings are aligned on 1 byte boundaries. A fixed width encoding with a max. of 4 bytes/char should align on a 4 byte boundary.  Note that UTF-16 is a special case because of the optional byte order marker, so it's handled above. This doesn't matter for GIOP 1.2 wchars and wstrings since the encoded bytes are treated as an encapsulation.BTCConverter factory for single byte or variable width encodings.BTCConverter factory for fixed width multibyte encodings.Follows the code set negotiation algorithm in CORBA formal 99-10-07 13.7.2.Returns the proper negotiated OSF character encoding number orCodeSetConversion.FALLBACK_CODESET. A "null" value for the server's nativeCodeSet means that the server desired not to indicate one.  We'll take that to mean that it wants the first thing in its conversion list. If it's conversion list is empty, too, then use the fallback codeset. Best case -- client and server don't have to convert Is this client capable of converting to the server's native code set? The client will convert to the server's native code set. Is the server capable of converting to the client's The server will convert to the client's See if there are any code sets that both the server and client support (giving preference to the server).  The order of conversion sets is from most to least desired. Before using the fallback codesets, the spec calls for a compatibility check on the native code sets.  It doesn't make sense because loss free communication is always possible with UTF8 and UTF16, the fall back code sets.  It's also a lot of work to implement.  In the case of incompatibility, the spec says to throw a CODESET_INCOMPATIBLE exception. Use the fallbackPerform the code set negotiation algorithm and come up withthe two encodings to use. No one should instantiate a CodeSetConversion but the singleton instance method initialize-on-demand holderCodeSetConversion is a singleton, and this is the access point. Singleton instance Number used internally to indicate the fallback code set. Provides a thread local cache for the sun.io converters./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/encoding/EncapsInputStream.java/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/encoding/EncapsInputStream.classdataeisCopyright (c) 2001, 2013, Oracle and/or its affiliates. All rights reserved.Encapsulations are supposed to explicitly define theircode sets and GIOP version.  The original resolution to issue 2784said that the defaults were UTF-8 and UTF-16, but that was notagreed upon.These streams currently use CDR 1.2 with ISO8859-1 for char/string andUTF16 for wchar/wstring.  If no byte order marker is available,the endianness of the encapsulation is used.When more encapsulations arise that have their own special codesets defined, we can make all constructors take such parameters. corba/EncapsOutputStream corba/ORBSingleton iiop/ORB ior/IdentifiableBase ior/IIOPProfile corba/AnyImpl CDREncapsCodec ServiceContext Assumes big endian (can use consumeEndian to read and set the endianness if it is an encapsulation with a byte order mark at the beginning)Full constructor with a CodeBase parameter useful forunmarshaling RMI-IIOP valuetypes (technically against theintention of an encapsulation, but necessary due to OMGissue 4795.  Used by ServiceContexts. Wide characters don't exist in GIOP 1.0 In GIOP 1.1, we shouldn't have byte order markers.  Take the order of the stream if we don't see them. Assume anything else adheres to GIOP 1.2 requirements. Our UTF_16 converter will work with byte order markers, and if they aren't present, it will use the provided endianness. With no byte order marker, it's big endian in GIOP 1.2. formal 00-11-03 15.3.16./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/encoding/EncapsOutputStream.java/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/encoding/EncapsOutputStream.classisLittleEndianuseBOM REVISIT - Right now, EncapsOutputStream's do not use pooled byte buffers. This is controlled by the following static constant. This should be re-factored such that the EncapsOutputStream doesn't know it's using pooled byte buffers. REVISIT - Right now, valuetypes in encapsulations will only use stream format version 1, which may create problems for service contexts or codecs (?). corba/ORB iiop/GIOPImpl GIOP version 1.2 with no fragmentation, big endian, UTF8 for char data and UTF-16 for wide char data; REVISIT.  A UTF-16 encoding with GIOP 1.1 will not work with byte order markers. Used by IIOPProfileTemplate In the case of GIOP 1.1, we take the byte order of the stream and don't use byte order markers since we're limited to a 2 byte fixed width encoding. Assume anything else meets GIOP 1.2 requirements Use byte order markers?  If not, use big endian in GIOP 1.2. (formal 00-11-03 15.3.16)/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/encoding/IDLJavaSerializationInputStream.java/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/encoding/IDLJavaSerializationInputStream.classsetMarkDatasetMarkData(boolean,int,int,java.util.LinkedList)skipBytesskipBytes(int)read_any_arrayread_any_array(org.omg.CORBA.Any[],int,int)initObjectInputStreaminitObjectInputStream()markedItemQpeekCountpeekIndexmarkOndirectReadLengthbisbufSizesetPositionsetPosition(int)/Library/Java/JavaVirtualMachines/jdk1.8.0_251.jdk/Contents/Home/jre/lib/rt.jar/com/sun/corba/se/impl/encoding/IDLJavaSerializationInputStream$_ByteArrayInputStream.classgetPositiongetPosition()_ByteArrayInputStream_ByteArrayInputStream(byte[])MarshalObjectInputStreamMarshalObjectInputStream(java.io.InputStream,com.sun.corba.se.spi.orb.ORB)/Library/Java/JavaVirtualMachines/jdk1.8.0_251.jdk/Contents/Home/jre/lib/rt.jar/com/sun/corba/se/impl/encoding/IDLJavaSerializationInputStream$MarshalObjectInputStream.class/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/encoding/IDLJavaSerializationInputStream$MarshalObjectInputStream$1.classre"resolveObject failed"resolveObject failed"read_boolean"read_boolean"read_char"read_char"read_octet"read_octet"read_short"read_short0xFF000000-167772160x00FF000016711680"read_long"read_long"read_longlong"read_longlong"read_float"read_float"read_double"read_double"read_string"read_string"read_wstring"read_wstring"read_value"read_valueisObject"getPosition"readLimit"mark"mark? extends IDLJavaSerializationInputStreamClass<? extends IDLJavaSerializationInputStream>Map<String,? extends IDLJavaSerializationInputStream>IDLJavaSerializationInputStream[]? extends IDLJavaSerializationInputStream[]Constructor<? extends IDLJavaSerializationInputStream>? super ? extends IDLJavaSerializationInputStreamClass<? super ? extends IDLJavaSerializationInputStream>TypeVariable<Class<? extends IDLJavaSerializationInputStream>>TypeVariable<Class<? extends IDLJavaSerializationInputStream>>[]"skipBytes""setIndex"setIndex"+++++++ Input Buffer ++++++++"+++++++ Input Buffer ++++++++Implementation class that uses Java serialization for input streams.This assumes a GIOP version 1.2 message format.This class uses a ByteArrayInputStream as the underlying buffer. Thefirst 16 bytes are directly read out of the underlying buffer. This allows[GIOPHeader (12 bytes) + requestID (4 bytes)] to be read as bytes.Subsequent write operations on this output stream object usesObjectInputStream class to read into the buffer. This allows unmarshalingcomplex types and graphs using the ObjectInputStream implementation.Note, this class assumes a GIOP 1.2 style header. Further, the first12 bytes, that is, the GIOPHeader is read directly from the receivedmessage, before this stream object is called. So, this class effectivelyreads only the requestID (4 bytes) directly, and uses theObjectInputStream for further unmarshaling.Ram Jeyaraman [GIOPHeader(12) + requestID(4)] bytes Used for mark / reset operations. needs SerializablePermission("enableSubstitution")Connect the Stub to the ORB. Note: at this point, the buffer position is zero. The setIndex() method call can be used to set a desired read index. Called from read_octet or read_long or read_ulong method.System.out.print(" is "); Primitive types. dequeue peek enqueue check if size < [ GIOPHeader(12) + requestID(4)] bytesmarkedItemQ.addLast(Byte.valueOf(value)); // only in JDK 1.5 Use big endian (network byte order). This is fixed. Both the writer and reader use the same byte order. Cannot happen. All direct reads are contained within the first 16 bytes. String types. Array types.// Cannot use this efficient read due to mark/reset support.try {while (length > 0) {int n = is.read(value, offset, length);offset += n;length -= n;} catch (Exception e) {throw wrapper.javaSerializationException(e, "read_octet_array"); Complex types. kind off this stream and see if it is a tk_value. Looking at the code we know that for tk_value the Any.read_value() below ignores the tc argument anyway (except for the kind field). read off the value of the any. We don't need an implementation for this method, since principal is absent in GIOP version 1.2 or above. Each octet contains (up to) two decimal digits. If the fixed type has an odd number of decimal digits, then the representation     public int read(byte b[]) throws IOException;     public int read(byte b[], int off, int len) throws IOException     public long skip(long n) throws IOException;     public int available() throws IOException;     public void close() throws IOException; Nested mark disallowed. Further, mark is not supported until first 16 bytes are read.// Note: only ByteArrayInputStream supports mark/reset.if (is == null || is.markSupported() == false) {throw wrapper.javaSerializationException("mark");is.mark(readLimit);is.reset();throw wrapper.javaSerializationException(e, "reset"); Set the buffer position. Set mark related data. Used exclusively by the dup() method. no-op. We don't care about body alignment while using Java serialization. What the GIOP spec states does not apply here. this is redundant, since buffer size was already specified as part of the init call. So, ignore. No-op./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/encoding/IDLJavaSerializationOutputStream.java/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/encoding/IDLJavaSerializationOutputStream.classwrite_fixedwrite_fixed(java.lang.String,int)initObjectOutputStreaminitObjectOutputStream()directWriteLengthbosgetByteArraygetByteArray()/Library/Java/JavaVirtualMachines/jdk1.8.0_251.jdk/Contents/Home/jre/lib/rt.jar/com/sun/corba/se/impl/encoding/IDLJavaSerializationOutputStream$_ByteArrayOutputStream.class_ByteArrayOutputStream_ByteArrayOutputStream(int)initialSizeMarshalObjectOutputStreamMarshalObjectOutputStream(java.io.OutputStream,com.sun.corba.se.spi.orb.ORB)/Library/Java/JavaVirtualMachines/jdk1.8.0_251.jdk/Contents/Home/jre/lib/rt.jar/com/sun/corba/se/impl/encoding/IDLJavaSerializationOutputStream$MarshalObjectOutputStream.class/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/encoding/IDLJavaSerializationOutputStream$MarshalObjectOutputStream$1.class"replaceObject failed"replaceObject failed"write_boolean"write_boolean"write_char"write_char"write_octet"write_octet"write_short"write_short"write_long"write_long"write_longlong"write_longlong"write_float"write_float"write_double"write_double"write_string"write_string"write_wstring"write_wstring"write_octet_array"write_octet_array"write_value"write_valueisCorbaObjecttheCorbaObject"writeTo"writeTo"toByteArray"toByteArray"getByteBufferWithInfo"getByteBufferWithInfoCopyright (c) 2004, 2013, Oracle and/or its affiliates. All rights reserved.Implementation class that uses Java serialization for output streams.This class uses a ByteArrayOutputStream as the underlying buffer. Thefirst 16 bytes are direct writes into the underlying buffer. This allows[GIOPHeader (12 bytes) + requestID (4 bytes)] to be written as bytes.ObjectOutputStream class to write into the buffer. This allows marshalingcomplex types and graphs using the ObjectOutputStream implementation.Note, this class assumes a GIOP 1.2 style header. Note, we expect that thefirst 16 bytes are written only using the write_octet, write_long orwrite_ulong method calls.Checks for objects that are instances of java.rmi.Remotethat need to be serialized as proxy (Stub) objects.System.out.print(" os "); direct write. Cannot happen. All direct writes are contained Complex types (objects and graphs). First calculate the string length without optional sign and dot. If the fixed type has an odd number of decimal digits, then the representation begins with the first (most significant) digit. Otherwise, this first half-octet is all zero, and the first digit is in the second half-octet. The sign configuration in the last half-octet of the representation, Write the boolean flag. Now write out the object. com.sun.corba.se.os.encoding.MarshalOutputStream new copy. Other. Java serialization uses network byte order, that is, big-endian.System.out.println("Total length : " + buf.length); Note: These methods are defined in the super class and accessible.public abstract void write(byte b[]) throws IOException;public abstract void write(byte b[], int off, int len)    throws IOException;public abstract void flush() throws IOException;public abstract void close() throws IOException;/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/encoding/MarkAndResetHandler.javaDefines an abstraction for a RestorableInputStream toimplement mark/reset./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/encoding/MarshalInputStream.javastubClassreadAheadLimitThe methods necessary to support RMIAdditional Methods Determines the current byte stream position (also handles fragmented streams) mark/reset from java.io.InputStreamThis must be called once before unmarshaling valuetypes or anythingthat uses repository IDs.  The ORB's version should be setto the desired value prior to calling.Tells the input stream to null any code set converterreferences, forcing it to reacquire them if it needsconverters again.  This is used when the serverinput stream needs to switch the connection's char code setconverter to something different after reading thecode set service context for the first time.  Initially,we use ISO8859-1 to read the operation name (it can'tbe more than ASCII)./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/encoding/MarshalOutputStream.java/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/encoding/OSFCodeSetRegistry.javaUTF_16LE/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/encoding/OSFCodeSetRegistry.classUTF_16BEOSFCodeSetRegistryOSFCodeSetRegistry()0x00010001655370x00010109658010x05010001839516170x00010100657920x0001002065568"ISO-8859-1"ISO-8859-1"UTF-16BE"UTF-16BE"UTF-16LE"UTF-16LE"UTF-16"UTF-16"UTF-8""UCS-2"UCS-2"US-ASCII"US-ASCIIEntryEntry(java.lang.String,int,boolean,int)/Library/Java/JavaVirtualMachines/jdk1.8.0_251.jdk/Contents/Home/jre/lib/rt.jar/com/sun/corba/se/impl/encoding/OSFCodeSetRegistry$Entry.classmaxBytesPerCharisFixedWidthencodingNumjavaNameencodingValueInformation from the OSF code set registry version 1.2g.Use the Entry corresponding to the desired code set.Consider rename to CodeSetRegistry since OSF is dead. Numbers from the OSF code set registry version 1.2g. Please see the individual Entry definitions for more details.An entry in the OSF registry which allows usersto find out the equivalent Java character encodingname as well as some other facts from the registry.Returns the Java equivalent name.  If the encoding hasan optional byte order marker, this name will map to theJava encoding that includes the marker.Get the OSF registry number for this code set.Is this a fixed or variable width code set?  (In CORBAterms, "non-byte-oriented" or a "byte-oriented"code set, respectively)First checks reference equality since it's expectedpeople will use the pre-defined constant Entries.Uses the registry number as the hash code.8-bit encoding required for GIOP 1.0, and used as the char setwhen nothing else is specified.UTF-16 as specified in the OSF registry has an optionalbyte order marker.  UTF-16BE and UTF-16LE are not in the OSFregistry since it is no longer being developed.  When the OMGswitches to the IANA registry, these can be public.  Rightnow, they're used internally by CodeSetConversion.Fallback wchar code set.In the resolution of issue 3405b, UTF-16 defaults to big endian, sodoesn't have to have a byte order marker.  Unfortunately, this has to bea special case for compatibility.Fallback char code set.  Also the code set for char datain encapsulations.  However, since CORBA says chars areonly one octet, it is really the same as Latin-1.At least in JDK 1.3, UCS-2 isn't one of the mandatory Java characterencodings.  However, our old ORBs require what they call UCS2, eventhough they didn't necessarily do the correct encoding of it.This is a special case for our legacy ORBs, and put as the last thingin our conversion list for wchar data.If a foreign ORB actually tries to speak UCS2 with us, it probablywon't work!  Beware!This is the encoding older JavaSoft ORBs advertised as theirCORBA char code set.  Actually, they took the lower byte ofthe Java char.  This is a 7-bit encoding, so theywere really sending ISO8859-1.Given an OSF registry value, return the corresponding Entry.Returns null if an Entry for that value is unavailable./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/encoding/RestorableInputStream.javaDefines the methods on an input stream which providea way to get and restore its internal state withoutviolating encapsulation./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/encoding/TypeCodeInputStream.javaisEncapsulation/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/encoding/TypeCodeInputStream.classenclosuretypeMappositionencapencapLengthencapBuffer"typeMap = {"typeMap = {"  key = "  key = ", value = ", value = Copyright (c) 2002, 2013, Oracle and/or its affiliates. All rights reserved.if (TypeCodeImpl.debug) System.out.println("Creating typeMap");if (TypeCodeImpl.debug) System.out.println(this + " adding tc " + tc + " at position " + position);if (TypeCodeImpl.debug) {System.out.println("Getting tc " + (TypeCode)typeMap.get(new Integer(position)) +" at position " + position); The enclosed stream has to consider if the enclosing stream had to read the enclosed stream completely when creating it. This is why the size of the enclosed stream needs to be substracted. Substract getBufferLength from the parents pos because it read this stream from its own when creating itSystem.out.println("TypeCodeInputStream.getTopLevelPosition using getTopLevelPosition " + topPos +(isEncapsulation ? " - encaps length 4" : "") +" - getBufferLength() " + getBufferLength() +" + getPosition() " + getPosition() + " = " + pos);System.out.println("TypeCodeInputStream.getTopLevelPosition returning getPosition() = " +getPosition() + " because enclosure is " + enclosure); _REVISIT_ Would be nice if we didn't have to copy the buffer! read off part of the buffer corresponding to the encapsulation create an encapsulation using the marshal bufferSystem.out.println("Created TypeCodeInputStream " + encap + " with parent " + is);encap.printBuffer(); first entry in an encapsulation is the endianess/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/encoding/TypeCodeOutputStream.java/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/encoding/TypeCodeOutputStream.classfirstLongtostheBuffertcBufferSystem.out.println("Created TypeCodeInputStream " + tcis + " with no parent");tcis.printBuffer();public boolean isEncapsulatedIn(TypeCodeOutputStream outerEnclosure) {if (outerEnclosure == this)return true;if (enclosure == null)return false;if (enclosure instanceof TypeCodeOutputStream)return ((TypeCodeOutputStream)enclosure).isEncapsulatedIn(outerEnclosure);// Last chance! Recursion ends with first non TypeCodeOutputStream.return (enclosure == outerEnclosure); Add four bytes for the encaps length, not another 4 for the byte order which is included in getPosition().System.out.println("TypeCodeOutputStream.getTopLevelPosition using getTopLevelPosition " +((TypeCodeOutputStream)enclosure).getTopLevelPosition() +" + getPosition() " + getPosition() +(isEncapsulation ? " + encaps length 4" : "") +" = " + pos);System.out.println("TypeCodeOutputStream.getTopLevelPosition returning getPosition() = " +getPosition() + ", enclosure is " + enclosure);if (TypeCodeImpl.debug) System.out.println(this + " adding id " + id + " at position " + position);if (TypeCodeImpl.debug) System.out.println("Getting position " + ((Integer)typeMap.get(id)).intValue() +" for id " + id); Writes this streams buffer to the given OutputStream without byte order flag and length as is the case for encapsulations. Make sure to align s to 4 byte boundaries. Unfortunately we can't do just this: s.alignAndReserve(4, 4); So we have to take the first four bytes given in firstLong and write them with a call to write_long which will trigger the alignment. Then write the rest of the byte array.System.out.println(this + ".writeRawBuffer(" + s + ", " + firstLong + ")");if (s instanceof CDROutputStream) {System.out.println("Parent position before writing kind = " + ((CDROutputStream)s).getIndex());System.out.println("Parent position after writing kind = " + ((CDROutputStream)s).getIndex()); get bytes from DirectByteBuffer NOTE: Microbenchmarks are showing it is faster to do       a loop of ByteBuffer.get(int) than it is to do       a bulk ByteBuffer.get(byte[], offset, length)System.out.println("Parent position after writing all " + getIndex() + " bytes = " + ((CDROutputStream)s).getIndex());if (TypeCodeImpl.debug) System.out.println("Created TypeCodeOutputStream " + encap + " with parent " + this);if (TypeCodeImpl.debug) System.out.println("Created TypeCodeOutputStream " + tos + " with parent " + os);if (TypeCodeImpl.debug) System.out.println("TypeCodeOutputStream.getRealIndex using getTopLevelPosition " +topPos + " instead of getPosition " + getPosition());protected void printBuffer() {super.printBuffer(); Returns the buffer trimmed of the trailing zeros and without the known _kind value at the beginning.System.out.println("outBuffer length = " + (getIndex() - 4)); Micro-benchmarks show that DirectByteBuffer.get(int) is faster than DirectByteBuffer.get(byte[], offset, length). REVISIT - May want to check if buffer is direct or non-direct           and use array copy if ByteBuffer is non-direct./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/encoding/TypeCodeReader.javaCopyright (c) 2002, 2003, Oracle and/or its affiliates. All rights reserved. for debuggingpublic void printBuffer();/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/encoding/WrapperInputStream.javastartPos/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/encoding/WrapperInputStream.classsortedKeysif (TypeCodeImpl.debug) System.out.println("Getting tc " + (TypeCodeImpl)typeMap.get(new Integer(position)) + WrapperInputStream has no enclosureif (TypeCodeImpl.debug) System.out.println("WrapperInputStream.getTopLevelPosition " +"returning getPosition " + getPosition() + " - startPos " + startPos +" = " + (getPosition() - startPos)); This is never actually called on a WrapperInputStream, but exists to satisfy the interface requirement.public void printBuffer() { stream.printBuffer(); }/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/interceptors/CDREncapsCodec.java/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/interceptorscom.sun.corba.se.impl.interceptorsdecodeImpldecodeImpl(byte[],org.omg.CORBA.TypeCode)/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/interceptors/CDREncapsCodec.class/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/interceptorsencodeImplencodeImpl(org.omg.CORBA.Any,boolean)majorminorsendTypeCodecdrOutcdrInCopyright (c) 2000, 2013, Oracle and/or its affiliates. All rights reserved.CDREncapsCodec is an implementation of Codec, as describedin orbos/99-12-02, that supports CDR encapsulation version 1.0, 1.1, and1.2. The ORB that created the factory this codec was created from The GIOP version we are encoding for******************************************************************NOTE: CDREncapsCodec must remain immutable!  This is so that wecan pre-create CDREncapsCodecs for each version of GIOP inCodecFactoryImpl.*****************************************************************Creates a new codec implementation.  Uses the given ORB to createCDRInputStreams when necessary.The ORB to use to create a CDRInputStream or CDROutputStreamThe major version of GIOP we are encoding forThe minor version of GIOP we are encoding forConvert the given any into a CDR encapsulated octet sequenceDecode the given octet sequence into an any based on a CDRencapsulated octet sequence.Convert the given any into a CDR encapsulated octet sequence.  Onlythe data is stored.  The type code is not.encapsulated octet sequence.  The type code is expected not to appearin the octet sequence, and the given type code is used instead.Convert the given any into a CDR encapsulated octet sequence.If sendTypeCode is true, the type code is sent with the message, as ina standard encapsulation.  If it is false, only the data is sent.Either way, the endian type is sent as the first part of the message. _REVISIT_ Note that InvalidTypeForEncoding is never thrown in the body of this method.  This is due to the fact that CDR*Stream will never throw an exception if the encoding is invalid.  To fix this, the CDROutputStream must know the version of GIOP it is encoding for and it must check to ensure that, for example, wstring cannot be encoded in GIOP 1.0. As part of the GIOP 1.2 work, the CDRInput and OutputStream will be versioned.  This can be handled once this work is complete. Create output stream with default endianness. This is an encapsulation, so put out the endian: Sometimes encode type code: Encode value and return.encapsulated octet sequence.  If the type code is null, it isexpected to appear in the octet sequence.  Otherwise, the giventype code is used. return value _REVISIT_ Currently there is no way for us to distinguish between a FormatMismatch and a TypeMismatch because we cannot get this information from the CDRInputStream.  If a RuntimeException occurs, it is turned into a FormatMismatch exception. If type code not specified, read it from octet stream: Create a new Any object: See above note./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/interceptors/ClientRequestInfoImpl.javagetEntryCountgetEntryCount()/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/interceptors/ClientRequestInfoImpl.classdecrementEntryCountdecrementEntryCount()incrementEntryCountincrementEntryCount()getRetryRequestgetRetryRequest()setRetryRequestsetRetryRequest(com.sun.corba.se.spi.protocol.RetryType)getLocatedIORgetLocatedIOR()boolean[][]validCallresetreset()cachedEffectiveComponentscachedReplyServiceContextscachedRequestServiceContextscachedEffectiveProfilecachedReceivedExceptioncachedResultcachedReceivedExceptionIdcachedOperationContextcachedContextsTypeCode[]cachedExceptionsParameter[]cachedArgumentscachedEffectiveTargetObjectcachedTargetObjectdiiInitiaterequestentryCountretryRequestCALL_RECEIVE_OTHERCALL_RECEIVE_EXCEPTIONCALL_RECEIVE_REPLYCALL_SEND_POLLCALL_SEND_REQUESTmyORBcorbaContactInfo? extends ExceptionClass<? extends Exception>Map<String,? extends Exception>Exception[]? extends Exception[]Constructor<? extends Exception>? super ? extends ExceptionClass<? super ? extends Exception>TypeVariable<Class<? extends Exception>>TypeVariable<Class<? extends Exception>>[]TaggedComponent[]integerIdjustCreatedCacheptempservice_contextexcListcountexcTCListctxListToReturnnvList"*"*contextnvResultcontactInfoListserviceContextsreplyStatuspiCurrentPushedmethodIDvalidCallIndexCopyright (c) 2000, 2012, Oracle and/or its affiliates. All rights reserved.Implementation of the ClientRequestInfo interface as specified inorbos/99-12-02 section 5.4.2. The available constants for startingPointCall The available constants for endingPointCall//////////////////////////////////////////////////////////////////// NOTE: IF AN ATTRIBUTE IS ADDED, PLEASE UPDATE RESET(); The current retry request status.  True if this request is being retried and this info object is to be reused, or false otherwise. The number of times this info object has been (re)used.  This is incremented every time a request is retried, and decremented every time a request is complete.  When this reaches zero, the info object is popped from the ClientRequestInfoImpl ThreadLocal stack in the ORB. The RequestImpl is set when the call is DII based. The DII query calls like ParameterList, ExceptionList, ContextList will be delegated to RequestImpl. Sources of client request information Cached information: key = Integer, value = IOP.ServiceContext. key = Integer, value = TaggedComponentReset the info object so that it can be reused for a retry,for example. Please keep these in the same order that they're declared above. 6763340 Do not reset entryCount because we need to know when to pop this from the stack. Clear cached attributes:*********************************************************************Access protection******************************************************************** Method IDs for all methods in ClientRequestInfo.  This allows for a convenient O(1) lookup for checkAccess(). ClientRequestInfo validity table (see ptc/00-08-06 table 21-1). Note: These must be in the same order as specified in contants. LEGEND: s_req = send_request     r_rep = receive_reply s_pol = send_poll        r_exc = receive_exception                          r_oth = receive_other A true value indicates call is valid at specified point. A false value indicates the call is invalid. NOTE: If the order or number of columns change, update checkAccess() accordingly.                              { s_req, s_pol, r_rep, r_exc, r_oth } RequestInfo methods:request_idoperationargumentsexceptionsoperation_contextresponse_expectedsync_scopereply_statusforward_referenceget_slotget_request_service_contextget_reply_service_context ClientRequestInfo methods::targeteffective_targeteffective_profilereceived_exceptionreceived_exception_idget_effective_componentget_effective_componentsget_request_policyadd_request_service_contextPublic ClientRequestInfo interfacesCreates a new ClientRequestInfo implementation.The constructor is package scope since no other package need createan instance of this class.The object which the client called to perform the operation. access is currently valid for all states:checkAccess( MID_TARGET );The actual object on which the operation will be invoked.  If thereply_status is LOCATION_FORWARD, then on subsequent requests,effective_target will contain the forwarded IOR while target willremain unchanged.checkAccess( MID_EFFECTIVE_TARGET ); Note: This is not necessarily the same as locatedIOR. Reason: See the way we handle COMM_FAILURES in ClientRequestDispatcher.createRequest, v1.32 REVISIT - get through chain like getLocatedIOR helper below.The profile that will be used to send the request.  If a locationforward has occurred for this operation's object and that object'sprofile change accordingly, then this profile will be that locatedprofile.checkAccess( MID_EFFECTIVE_PROFILE ); Good citizen: In the interest of efficiency, we assume interceptors will not modify the returned TaggedProfile in any way so we need not make a deep copy of it.Contains the exception to be returned to the client. will not modify the returned Any in any way so we needThe CORBA::RepositoryId of the exception to be returned to the client. Note: exception should never be null here since we will throw a BAD_INV_ORDER if this is not called from receive_exception. _REVISIT_ We need to be able to handle a UserException in the DII case.  How do we extract the ID from a UserException?Returns the IOP::TaggedComponent with the given ID from the profileselected for this request.  IF there is more than one component for agiven component ID, it is undefined which component this operationreturns (get_effective_component should be called instead).Returns all the tagged components with the given ID from the profileselected for this request. Look in cache: null could mean we cached null or not in cache. Not in cache.  Get it from the profile: As per ptc/00-08-06, section 21.3.13.6., If not found, raise BAD_PARAM with minor code INVALID_COMPONENT_ID. Good citizen: In the interest of efficiency, we will assume interceptors will not modify the returned TaggedCompoent[], or the TaggedComponents inside of it.  Otherwise, we would need to clone the array and make a deep copy of its contents.Returns the given policy in effect for this operation. _REVISIT_ Our ORB is not policy-based at this time.Allows interceptors to add service contexts to the request.<p>There is no declaration of the order of the service contexts.  Theymay or may not appear in the order they are added. NOTE: When adding a method, be sure to: 1. Add a MID_* constant for that method 2. Call checkAccess at the start of the method 3. Define entries in the validCall[][] table for interception points.Public RequestInfo interfacesThese are implemented here because they have differingimplementations depending on whether this is a client or a serverrequest info object.See RequestInfoImpl for javadoc.checkAccess( MID_REQUEST_ID );NOTE: The requestId in client interceptors is the same as theGIOP request id.  This works because both interceptors andrequest ids are scoped by the ORB on the client side.checkAccess( MID_OPERATION ); If it is DII request then get the arguments from the DII req and convert that into parameters. Good citizen: In the interest of efficiency, we assume interceptors will be "good citizens" in that they will not modify the contents of the Parameter[] array.  We also assume they will not change the values of the containing Anys. Get the list of exceptions from DII request data, If there are no exceptions raised then this method will return null. modify the contents of the TypeCode[] array.  We also assume they will not change the values of the containing TypeCodes. Get the list of contexts from DII request data, If there are no contexts then this method will return null. modify the contents of the String[] array. _REVISIT_ The API for get_values is not compliant with the spec, Revisit this code once it's fixed. _REVISIT_ Our ORB doesn't support Operation Context, This code will not be excerscised until it's supported. The first parameter in get_values is the start_scope which if blank makes it as a global scope. The second parameter is op_flags which is set to RESTRICT_SCOPE As there is only one defined in the spec. The Third param is the pattern which is '*' requiring it to get all the contexts. The String[] array will contain Name and Value for each context and hence double the size in the array. Get the result from the DII request data. Good citizen: In the interest of efficiency, we assume that interceptors will not modify the contents of the result Any. Otherwise, we would need to create a deep copy of the Any.checkAccess( MID_RESPONSE_EXPECTED ); Check to make sure we are in LOCATION_FORWARD state as per ptc/00-08-06, table 21-1 footnote 2. Do not cache this value since if an interceptor raises forward request then the next interceptor in the list should see the new value. REVISIT - this most likely causes reportRedirect to happen twice. Once here and once inside the request dispatcher.does not contain an etry for that ID, BAD_PARAM with a minor code ofTBD_BP is raised. In the event this is called from a oneway, we will have no response object. In the event this is called after a IIOPConnection.purgeCalls, we will have a response object, but that object will not contain a header (which would hold the service context container).  See bug 4624102. REVISIT: this is the only thing used from response at this time.  However, a more general solution would avoid accessing other parts of response's header. Instead of throwing a NullPointer, we will "gracefully" handle these with a BAD_PARAM with minor code 25. REVISIT how this is programmed - not what it does. See purge calls test.  The waiter is woken up by the call to purge calls - but there is no reply containing service contexts. Override RequestInfoImpl connection to work in framework.Package-scope interfaces REVISIT - so mediator can handle DII in subcontract.Set or reset the retry request flag.Retrieve the current retry request status.Increases the entry count by 1.Decreases the entry count by 1.Retrieve the current entry countOverridden from RequestInfoImpl.  Calls the super class, thensets the ending point call depending on the reply status.Sets DII request object in the RequestInfoObject.Keeps track of whether initiate was called for a DII request.  The ORBneeds to know this so it knows whether to ignore a second call toinitiateClientPIRequest or not.See comment for setDIIInitiateThe PICurrent stack should only be popped if it was pushed.This is generally the case.  But exceptions which occurafter the stub's entry to _request but before the pushend up in _releaseReply which will try to pop unless told not to.Overridden from RequestInfoImpl. Clear cached values:See description for RequestInfoImpl.checkAccess Make sure currentPoint matches the appropriate index in the validCall table: Check the validCall table:/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/interceptors/CodecFactoryImpl.javanullParamnullParam()/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/interceptors/CodecFactoryImpl.classCodec[]codecsMAX_MINOR_VERSION_SUPPORTEDencCodecFactoryImpl is the implementation of the Codec Factory, as describedin orbos/99-12-02. The ORB that created this Codec Factory The maximum minor version of GIOP supported by this codec factory. Currently, this is 1.2. The pre-created minor versions of Codec version 1.0, 1.1, ..., 1.(MAX_MINOR_VERSION_SUPPORTED)Creates a new CodecFactory implementation.  Stores the ORB thatcreated this factory, for later use by the Codec. Precreate a codec for version 1.0 through 1.(MAX_MINOR_VERSION_SUPPORTED).  This can be done since Codecs are immutable in their current implementation. This is an optimization that eliminates the overhead of creating a new Codec each time create_codec is called.Creates a codec of the given encoding.  The only format recognizedby this factory is ENCODING_CDR_ENCAPS, versions 1.0 through1.(MAX_MINOR_VERSION_SUPPORTED).@exceptionUnknownEncodingThrown if this factory cannot create aCodec of the given encoding. This is the only format we can currently create codecs for:Called when an invalid null parameter was passed.  Throws aBAD_PARAM with a minor code of 1/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/interceptors/IORInfoImpl.javamakeStateDonemakeStateDone()/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/interceptors/IORInfoImpl.classmakeStateEstablishedmakeStateEstablished()checkStatecheckState(int,int)checkState(int)addIORComponentToProfileInternaladdIORComponentToProfileInternal(org.omg.IOP.TaggedComponent,java.util.Iterator)IORInfoImplIORInfoImpl(com.sun.corba.se.spi.oa.ObjectAdapter)orbutilWrapperadapterSTATE_DONESTATE_ESTABLISHEDSTATE_INITIALtagged_componentprofile_idfindernewTaggedComponentfoundtaggedProfileTemplateexpectedStateexpectedState1expectedState2IORInfoImpl is the implementation of the IORInfo class, as describedin orbos/99-12-02, section 7. State values that determine which methods are allowed. get_effective_policy, manager_id, and adapter_state are valid unless STATE_DONE add_component, and add_component_to_profile are valid. adapter_template, and R/W to current_factory are valid No methods are valid in this state The current state of this object The ObjectAdapter associated with this IORInfo object.Creates a new IORInfo implementation.  This info object will establishtagged components with the template for the provided IOR Template.An ORB service implementation may determine what server side policyof a particular type is in effect for an IOR being constructed bycalling the get_effective_policy operation.  When the IOR beingconstructed is for an object implemented using a POA, all Policyobjects passed to the PortableServer::POA::create_POA call thatcreated that POA are accessible via get_effective_policy.If a policy for the given type is not known to the ORB, then thisoperation will raise INV_POLICY with a standard minor code of 2.The CORBA::PolicyType specifying the type of policy toreturn.The effective CORBA::Policy object of the requested type.If the given policy type is known, but no policy of that tpye isin effect, then this operation will return a nil object reference.A portable ORB service implementation calls this method from itsimplementation of establish_components to add a tagged component tothe set which will be included when constructing IORs.  Thecomponents in this set will be included in all profiles.Any number of components may exist with the same component ID.The IOP::TaggedComponent to addcomponents in this set will be included in the specified profile.If the given profile ID does not define a known profile or it isimpossible to add components to thgat profile, BAD_PARAM is raisedwith a minor code of TBD_BP + 3.The IOP::TaggedComponent to add.The IOP::ProfileId tof the profile to which thiscomponent will be added.The type of the server port(see connection.ORBSocketFactory for discussion).The listen port number for that type.@throwsUnknownTypeif no port of the given type is found. At this point, the iortemp must contain only a single IIOPProfileTemplate.  This is a restriction of our implementation.  Also, note the the ObjectReferenceTemplate is called when a certain POA is created in a certain ORB in a certain server, so the server_id, orb_id, and poa_id operations must be well-defined no matter what kind of implementation is used: e.g., if a POA creates IORs with multiple profiles, they must still all agree about this information.  Thus, we are justified in extracting the single IIOPProfileTemplate to create an ObjectReferenceTemplate here.Internal utility method to add an IOR component to the set of profilespresent in the iterator. Convert the given IOP::TaggedComponent into the appropriate type for the TaggedProfileTemplate Iterate through TaggedProfileTemplates and add the given tagged component to the appropriate one(s). If no profile was found with the given id, throw a BAD_PARAM: (See orbos/00-08-06, section 21.5.3.3.) REVISIT: add minor codes!/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/interceptors/InterceptorInvoker.javaupdateClientRequestDispatcherForwardupdateClientRequestDispatcherForward(com.sun.corba.se.impl.interceptors.ClientRequestInfoImpl)/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/interceptors/InterceptorInvoker.classinvokeServerInterceptorEndingPointinvokeServerInterceptorEndingPoint(com.sun.corba.se.impl.interceptors.ServerRequestInfoImpl)invokeServerInterceptorIntermediatePointinvokeServerInterceptorIntermediatePoint(com.sun.corba.se.impl.interceptors.ServerRequestInfoImpl)invokeServerInterceptorStartingPointinvokeServerInterceptorStartingPoint(com.sun.corba.se.impl.interceptors.ServerRequestInfoImpl)invokeClientInterceptorEndingPointinvokeClientInterceptorEndingPoint(com.sun.corba.se.impl.interceptors.ClientRequestInfoImpl)invokeClientInterceptorStartingPointinvokeClientInterceptorStartingPoint(com.sun.corba.se.impl.interceptors.ClientRequestInfoImpl)ObjectReferenceTemplate[]adapterStateChangedadapterStateChanged(org.omg.PortableInterceptor.ObjectReferenceTemplate[],short)adapterManagerStateChangedadapterManagerStateChanged(int,short)objectAdapterCreatedobjectAdapterCreated(com.sun.corba.se.spi.oa.ObjectAdapter)setEnabledsetEnabled(boolean)InterceptorInvokerInterceptorInvoker(com.sun.corba.se.spi.orb.ORB,com.sun.corba.se.impl.interceptors.InterceptorList,com.sun.corba.se.impl.interceptors.PICurrent)currentinterceptorListpiCurrentinfoIORInterceptor[]iorInterceptorsInterceptor[]interceptorinterceptor30managerIdnewStateinterceptorstemplatesClientRequestInterceptor[]clientInterceptorsflowStackIndexcontinueProcessingendingPointCallServerRequestInterceptor[]serverInterceptorsintermediatePointCallforwardRequestHandles invocation of interceptors.  Has specific knowledge of how toinvoke IOR, ClientRequest, and ServerRequest interceptors.Makes use of the InterceptorList to retrieve the list of interceptors tobe invoked.  Most methods in this class are package scope so that theymay only be called from the PIHandlerImpl. The ORB The list of interceptors to be invoked True if interceptors are to be invoked, or false if not Note: This is a global enable/disable flag, whereas the enable flag in the RequestInfoStack in PIHandlerImpl is only for a particular Thread. PICurrent variable. NOTE: Be careful about adding additional attributes to this class. Multiple threads may be calling methods on this invoker at the same time.Creates a new Interceptor Invoker.  Constructor is package scope soonly the ORB can create it.  The invoker is initially disabled, andmust be explicitly enabled using setEnabled().Enables or disables the interceptor invokerIOR Interceptor invocationCalled when a new POA is created.The Object Adapter associated with the IOR interceptor. If invocation is not yet enabled, don't do anything. Create IORInfo object to pass to IORInterceptors: Call each IORInterceptor: Implementation note: This loop counts backwards for greater efficiency. Benchmarks have shown that counting down is more efficient than counting up in Java for loops, as a compare to zero is faster than a subtract and compare to zero.  In this case, it doesn't really matter much, but it's simply a force of habit. as per PI spec (orbos/99-12-02 sec 7.2.1), if establish_components throws an exception, ignore it. Change the state so that only template operations are valid Note that exceptions here are NOT ignored, as per the ORT spec (orbos/01-01-04) Change the state so that no operations are valid, in case a reference to info escapes this scope. This also completes the actions associated with the template interceptors on this POA. No-op: ignore exception in this caseClient Interceptor invocationInvokes either send_request, or send_poll, depending on the valueof info.getStartingPointCall() Make a a fresh slot table available to TSC in case interceptors need to make out calls. Client's TSC is now RSC via RequestInfo. Get all ClientRequestInterceptors: We will assume that all interceptors returned successfully, and adjust the flowStackIndex to the appropriate value if we later discover otherwise. Determine whether we are calling send_request or send_poll: (This is currently commented out because our ORB does not yet support the Messaging specification, so send_poll will never occur.  Once we have implemented messaging, this may be uncommented.) int startingPointCall = info.getStartingPointCall(); Again, it is not necessary for a switch here, since there is only one starting point call type (see above comment).switch( startingPointCall ) {case ClientRequestInfoImpl.CALL_SEND_REQUEST:clientInterceptors[i].send_request( info );break;case ClientRequestInfoImpl.CALL_SEND_POLL:clientInterceptors[i].send_poll( info ); as per PI spec (orbos/99-12-02 sec 5.2.1.), if interception point throws a ForwardRequest, no other Interceptors' send_request operations are called. For some reason, using break here causes the VM on NT to lose track of the value of flowStackIndex after exiting the for loop.  I changed this to check a boolean value instead and it seems to work fine. interception point throws a SystemException, check a boolean value instead and it seems to work fine. Remember where we left off in the flow stack: Make the SlotTable fresh for the next interception point. end enabled checkInvokes either receive_reply, receive_exception, or receive_other,depending on the value of info.getEndingPointCall() NOTE: It is assumed someplace else prepared a fresh TSC slot table. Determine whether we are calling receive_reply, receive_exception, or receive_other: If we would be calling RECEIVE_REPLY, but this is a one-way call, override this and call receive_other: Only step through the interceptors whose starting points have successfully returned. Unlike the previous loop, this one counts backwards for a reason - we must execute these in the reverse order of the starting points. interception point throws a ForwardException, ending point call changes to receive_other. ending point call changes to receive_exception. See doc for setPICurrentPushed as to why this is necessary. Check info for null in case errors happen before initiate. After the pop, original client's TSC slot table remains avaiable via PICurrent.Server Interceptor invocationInvokes receive_request_service_context interception points. Make a fresh slot table for RSC. Make a fresh slot table for TSC in case Get all ServerRequestInterceptors: Currently, there is only one server-side starting point interceptor called receive_request_service_contexts. as per PI spec (orbos/99-12-02 sec 5.3.1.), if no other Interceptors' starting points are called and send_other is called. The remaining points, ServantManager and Servant all run in the same logical thread. Now TSC and RSC are equivalent.Invokes receive_request interception points NOTE: do not touch the slotStack.  The RSC and TSC are equivalent at this point. Currently, there is only one server-side intermediate point interceptor called receive_request. no other Interceptors' intermediate points areInvokes either send_reply, send_exception, or send_other, REVISIT: This is moved out to PIHandlerImpl until dispatch path is rearchitected.  It must be there so that it always gets executed so if an interceptor raises an exception any service contexts added in earlier points this point get put in the exception reply (via the SC Q).info.setCurrentExecutionPoint( info.EXECUTION_POINT_ENDING ); Determine whether we are calling send_exception, or send_other: ending point call changes to send_exception. Remember that all interceptors' starting and ending points have already been executed so we need not do anything. Get rid of the Server side RSC.Private utility methodsUpdate the client delegate in the event of a ForwardRequest, given theinformation in the passed-in info object. ForwardRequest may be null if the forwarded IOR is set internal to the ClientRequestDispatcher rather than explicitly through Portable Interceptors.  In this case, we need not update the client delegate ForwardRequest object. Convert the forward object into an IOR:/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/interceptors/InterceptorList.javasortInterceptorssortInterceptors()/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/interceptors/InterceptorList.classdestroyAlldestroyAll()growInterceptorArraygrowInterceptorArray(int)initInterceptorArraysinitInterceptorArrays()hasInterceptorsOfTypehasInterceptorsOfType(int)getInterceptorsgetInterceptors(int)locklock()register_interceptorregister_interceptor(org.omg.PortableInterceptor.Interceptor,int)InterceptorListInterceptorList(com.sun.corba.se.impl.logging.InterceptorsSystemException)Interceptor[][]lockedclassTypesNUM_INTERCEPTOR_TYPESINTERCEPTOR_TYPE_IORINTERCEPTOR_TYPE_SERVERINTERCEPTOR_TYPE_CLIENTClass<ClientRequestInterceptor>Class<ServerRequestInterceptor>Class<IORInterceptor>interceptorNameanonymousfoundDuplicateclassTypecurrentLengthreplacementArraynumTypesnumInterceptorssortedunsortedsortedIteratorunsortedIteratorProvides a repository of registered Portable Interceptors, organizedby type.  This list is designed to be accessed as efficiently aspossible during runtime, with the expense of added complexity duringinitialization and interceptor registration.  The class is designedto easily allow for the addition of new interceptor types. Interceptor type list.  If additional interceptors are needed, add additional types in numerical order (do not skip numbers), and update NUM_INTERCEPTOR_TYPES and classTypes accordingly. NUM_INTERCEPTOR_TYPES represents the number of interceptor types, so we know how many lists to maintain. Array of class types for interceptors.  This is used to create the appropriate array type for each interceptor type.  These must match the indices of the constants declared above. True if no further interceptors may be registered with this list. List of interceptors currently registered.  There are NUM_INTERCEPTOR_TYPES lists of registered interceptors. For example, interceptors[INTERCEPTOR_TYPE_CLIENT] contains an array of objects of type ClientRequestInterceptor.Creates a new Interceptor List.  Constructor is package scope soonly the ORB can create it. Create empty interceptors arrays for each type:Registers an interceptor of the given type into the interceptor list.The type is one of:<ul><li>INTERCEPTOR_TYPE_CLIENT - ClientRequestInterceptor<li>INTERCEPTOR_TYPE_SERVER - ServerRequestInterceptor<li>INTERCEPTOR_TYPE_IOR - IORInterceptor</ul>DuplicateNameThrown if an interceptor of the givenname already exists for the given type. If locked, deny any further addition of interceptors. Cache interceptor name: If this is not an anonymous interceptor, search for an interceptor of the same name in this category: An O(n) search will suffice because register_interceptor is not likely to be called often.Locks this interceptor list so that no more interceptors may beregistered.  This method is called after all interceptors areregistered for security reasons.Retrieves an array of interceptors of the given type.  For efficiency,the type parameter is assumed to be valid.Returns true if there is at least one interceptor of the given type,or false if not.Initializes all interceptors arrays to zero-length arrays of thecorrect type, based on the classTypes list. Create a zero-length array for each type:Grows the given interceptor array by one: Create new array to replace the old one.  The new array will be one element larger but have the same type as the old one.Destroys all interceptors in this list by invoking their destroy()method.Sort interceptors. Get fresh sorting bins for each non empty type. not synchronized like we want. Let the RuntimeExceptions thrown by sort (i.e., ClassCastException and UnsupportedOperationException) flow back to the user./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/interceptors/ORBInitInfoImpl.java/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/interceptors/ORBInitInfoImpl.classcheckStagecheckStage()setStagesetStage(int)ORBInitInfoImplORBInitInfoImpl(com.sun.corba.se.spi.orb.ORB,java.lang.String[],java.lang.String,org.omg.IOP.CodecFactory)MESSAGE_ORBINITINFO_INVALIDstagecodecFactory"ORBInitInfo object is only valid during ORB_init"ORBInitInfo object is only valid during ORB_initobjRefPolicy[]policiespolicy_factoryORBInitInfoImpl is the implementation of the ORBInitInfo class to bepassed to ORBInitializers, as described in orbos/99-12-02. The ORB we are initializing The arguments passed to ORB_init The ID of the ORB being initialized The CodecFactory The current stage of initialization The pre-initialization stage (pre_init() being called) The post-initialization stage (post_init() being called) Reject all calls - this object should no longer be around. The description for the OBJECT_NOT_EXIST exception in STAGE_CLOSEDCreates a new ORBInitInfoImpl object (scoped to package)The arguments passed to ORB_init.Return the ORB behind this ORBInitInfo.  This is defined in theORBInitInfoExt interface.Sets the current stage we are in.  This limits access to certainfunctionality.Throws an exception if the current stage is STAGE_CLOSED.This is called before any method is invoked to ensure thatno method invocations are attempted after all calls to post_init()are completed.The following are implementations of the ORBInitInfo operations.This attribute contains the arguments passed to ORB_init.  They mayor may not contain the ORB's argumentsThis attribute is the ID of the ORB being initializedThis attribute is the IOP::CodecFactory.  The CodecFactory is normallyobtained via a call to ORB::resolve_initial_references( "CodecFactory" )but since the ORB is not yet available and Interceptors, particularlywhen processing service contexts, will require a Codec, a means ofobtaining a Codec is necessary during ORB intialization.See orbos/99-12-02, Chapter 11, Dynamic Initial References on page11-81.  This operation is identical to ORB::register_initial_referencedescribed there.  This same functionality exists here because the ORB,not yet fully initialized, is not yet available but initial referencesmay need to be registered as part of Interceptor registration.This method may not be called during post_init. As per CORBA 3.0 section 21.8.1, if null is passed as the obj parameter, throw BAD_PARAM with minor code OMGSystemException.RIR_WITH_NULL_OBJECT. Though the spec is talking about IDL null, we will address both Java null and IDL null: Note: Local Objects can never be nil! This check was made to determine that the objref is a non-local objref that is fully initialized: this was called only for its side-effects of possibly throwing exceptions.  However, registering local objects should be permitted! XXX/Revisit? IOR ior = ORBUtility.getIOR( obj ) ; Delegate to ORB.  If ORB version throws InvalidName, convert to equivalent Portable Interceptors InvalidName.This operation is only valid during post_init.  It is identical toORB::resolve_initial_references.  This same functionality exists herebecause the ORB, not yet fully initialized, is not yet available,but initial references may be required from the ORB as partof Interceptor registration.(incorporates changes from errata in orbos/00-01-01)This method may not be called during pre_init. Initializer is not allowed to invoke this method during this stage. _REVISIT_ Spec issue: What exception should really be thrown here? Convert PIDL to IDL exception: New method from CORBA 3.1 XXX ignore policies for nowThis operation is used to add a client-side request Interceptor tothe list of client-side request Interceptors.If a client-side request Interceptor has already been registeredwith this Interceptor's name, DuplicateName is raised.This operation is used to add a server-side request Interceptor tothe list of server-side request Interceptors.If a server-side request Interceptor has already been registeredThis operation is used to add an IOR Interceptor tothe list of IOR Interceptors.If an IOR Interceptor has already been registeredA service calls allocate_slot_id to allocate a slot onPortableInterceptor::Current.The index to the slot which has been allocated.Register a PolicyFactory for the given PolicyType.If a PolicyFactory already exists for the given PolicyType,BAD_INV_ORDER is raised with a minor code of TBD_BIO+2./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/interceptors/PICurrent.javasetORBInitializingsetORBInitializing(boolean)/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/interceptors/PICurrent.classresetSlotTableresetSlotTable()popSlotTablepopSlotTable()pushSlotTablepushSlotTable()getSlotTablegetSlotTable()allocateSlotIdallocateSlotId()PICurrentPICurrent(com.sun.corba.se.spi.orb.ORB)threadLocalSlotTableorbInitializingslotCounter/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/interceptors/PICurrent$1.classslotIdinitPICurrent is the implementation of Current as specified in the PortableInterceptors Spec orbos/99-12-02.IMPORTANT: PICurrent is implemented with the assumption that get_slot()or set_slot() will not be called in ORBInitializer.pre_init() andpost_init(). slotCounter is used to keep track of ORBInitInfo.allocate_slot_id() The ORB associated with this PICurrent object. True if the orb is still initialzing and get_slot and set_slot are not to be called. ThreadLocal contains a stack of SlotTable which are used for resolve_initial_references( "PICurrent" );PICurrent constructor which will be called for every ORBinitialization.This method will be called from ORBInitInfo.allocate_slot_id( ).simply returns a slot id by incrementing slotCounter.This method gets the SlotTable which is on the top of theThreadLocalStack.This method pushes a SlotTable on the SlotTableStack. When there isa resolve_initial_references("PICurrent") after this call. The newPICurrent will be returned.This method pops a SlotTable on the SlotTableStack.This method sets the slot data at the given slot id (index) in theSlot Table which is on the top of the SlotTableStack. As per ptc/00-08-06 if the ORB is still initializing, disallow calls to get_slot and set_slot.  If an attempt is made to call, throw a BAD_INV_ORDER.This method gets the slot data at the given slot id (index) from theThis method resets all the slot data to null in theSlot Table which is on the top of SlotTableStack.Called from ORB when the ORBInitializers are about to startinitializing./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/interceptors/PIHandlerImpl.java/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/interceptors/PIHandlerImpl.classcreateORBInitInfocreateORBInitInfo()postInitORBInitializerspostInitORBInitializers(com.sun.corba.se.impl.interceptors.ORBInitInfoImpl)preInitORBInitializerspreInitORBInitializers(com.sun.corba.se.impl.interceptors.ORBInitInfoImpl)isClientPIEnabledForThisThreadisClientPIEnabledForThisThread()peekServerRequestInfoImplStackpeekServerRequestInfoImplStack()peekClientRequestInfoImplStackpeekClientRequestInfoImplStack()convertPIReplyStatusToReplyMessageconvertPIReplyStatusToReplyMessage(short)serverPIHandleExceptionsserverPIHandleExceptions(com.sun.corba.se.impl.interceptors.ServerRequestInfoImpl)threadLocalServerRequestInfoStackthreadLocalClientRequestInfoStackREPLY_MESSAGE_TO_PI_REPLY_STATUSpolicyFactoryTableinterceptorInvokerhasServerInterceptorshasClientInterceptorshasIORInterceptorsserverRequestIdCounterprintSpacesprintSpaces(int)printPopprintPop()printPushprintPush()pushLevelprintPushPopEnabled/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/interceptors/PIHandlerImpl$1.class/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/interceptors/PIHandlerImpl$2.class"PUSH"PUSH"POP"POPRequestInfoStackRequestInfoStack()/Library/Java/JavaVirtualMachines/jdk1.8.0_251.jdk/Contents/Home/jre/lib/rt.jar/com/sun/corba/se/impl/interceptors/Library/Java/JavaVirtualMachines/jdk1.8.0_251.jdk/Contents/Home/jre/lib/rt.jar/com/sun/corba/se/impl/interceptors/PIHandlerImpl$RequestInfoStack.classStack<>/Users/jettt/IdeaProjects/jdk_test/target/classes/java/util/Stack.classORBInitializer[]orbInitInfoinfoStackinvokeEndingPointpiReplyStatusdiiRequestemptyempty()searchsearch(java.lang.Object)StackStack()Stack<>()rtEnum<RetryType>/Users/jettt/IdeaProjects/jdk_test/target/classes/java/lang/Enum.classComparable<RetryType>compareTo(com.sun.corba.se.spi.protocol.RetryType)finalizefinalize()Enum<>Enum<T>Comparable<T>valueOfvalueOf(java.lang.Class,java.lang.String)Class<T>Class<E>Class<RetryType>compareTo(java.lang.Enum)EnumEnum(java.lang.String,int)Enum<RetryType>(java.lang.String,int)ordinalordinal()name()requestImplreplyMessageprevExceptionnewPIReplyStatusnewExceptionobjectIdtargetMostDerivedInterfacepolicy"There is no PolicyFactory Registered for type "There is no PolicyFactory Registered for type " Could Not Find PolicyFactory for the Type " Could Not Find PolicyFactory for the Type Provides portable interceptor functionality. REVISIT - delete these after framework merging. A unique id used in ServerRequestInfo. This does not correspond to the GIOP request id. Stores the codec factory for producing codecs The arguments passed to the application's main method.  May be null. This is used for ORBInitializers and set from set_parameters. The list of portable interceptors, organized by type: Cached information for optimization - do we have any interceptors registered of the given types?  Set during ORB initialization. temp always true The class responsible for invoking interceptors There will be one PICurrent instantiated for every ORB. This table contains a list of PolicyFactories registered using ORBInitInfo.registerPolicyFactory() method. Key for the table is PolicyType which is an Integer Value is PolicyFactory. Table to convert from a ReplyMessage.? to a PI replyStatus short. Note that this table relies on the order and constants of ReplyMessage not to change. = ReplyMessage.NO_EXCEPTION = ReplyMessage.USER_EXCEPTION = ReplyMessage.SYSTEM_EXCEPTION = ReplyMessage.LOCATION_FORWARD = ReplyMessage.LOCATION_FORWARD_PERM = ReplyMessage.NEEDS_ADDRESSING_MODE ThreadLocal containing a stack to store client request info objects and a disable count. ThreadLocal containing the current server request info object. Class to contain all ThreadLocal data for ClientRequestInfo maintenance. We use an ArrayList instead since it is not thread-safe. RequestInfoStack is used quite frequently. Number of times a request has been made to disable interceptors. When this reaches 0, interception hooks are disabled.  Any higher value indicates they are enabled. NOTE: The is only currently used on the client side. Create codec factory: Create new interceptor list: Create a new PICurrent. Create new interceptor invoker, initially disabled: Register the PI current and Codec factory objects If we have any orb initializers, make use of them: Create the ORBInitInfo object to pass to ORB intializers: Make sure get_slot and set_slot are not called from within ORB initializers: Call pre_init on all ORB initializers: Call post_init on all ORB initializers: Proprietary: sort interceptors: Re-enable get_slot and set_slot to be called from within Ensure nobody makes any more calls on this object. Set cached flags indicating whether we have interceptors registered of a given type. XXX This must always be true, so that using the new generic RPC framework can pass info between the PI stack and the framework invocation stack.  Temporary until Harold fixes this.  Note that this must never be true until after the ORBInitializer instances complete executing.hasClientInterceptors = interceptorList.hasInterceptorsOfType(InterceptorList.INTERCEPTOR_TYPE_CLIENT ); Enable interceptor invoker (not necessary if no interceptors are registered).  This should be the last stage of ORB initialization.ptc/00-08-06 p 205: "When an application calls ORB::destroy, the ORB1) waits for all requests in progress to complete2) calls the Interceptor::destroy operation for each interceptor3) completes destruction of the ORB"This must be called at the end of ORB.destroy.  Note that this is notpart of the PIHandler interface, since ORBImpl implements the ORB interface.****************Client PI hooks*************** Invoke the starting interception points and record exception and reply status info in the info object: Check reply status.  If we will not have another chance later to invoke the client ending points, do it now. Note: Transport retry cannot happen here since this happens before the request hits the wire. Do not throw anything.  Otherwise, it must be a SystemException, UserException or RemarshalException. It should not be possible for an interceptor to throw a UserException.  By asserting instead of throwing the UserException, we need not declare anything but RemarshalException in the throws clause. Needed when an error forces a retry AFTER initiateClientPIRequest but BEFORE invokeClientPIStartingPoint. Translate ReplyMessage.replyStatus into PI replyStatus: Note: this is also an assertion to make sure a valid replyStatus is passed in (IndexOutOfBoundsException will be thrown otherwise) Invoke the ending interception points and record exception Check reply status: If this is a forward or a retry, reset and reuse info object: fix for 6763340: ... and return a RemarshalException so the orb internals know Get the most recent info object from the thread local ClientRequestInfoImpl stack: In RequestImpl.doInvocation we already called initiateClientPIRequest( true ), so ignore this initiate. If there is no info object or if we are not retrying a request, push a new ClientRequestInfoImpl on the stack: 6763340: don't push unless this is not a retry Note: the entry count is automatically initialized to 0. Reset the retry request flag so that recursive calls will push a new info object, and bump up entry count so we know when to pop this info object: KMC 6763340: I don't know why this wasn't set earlier, but we do not want a retry to pick up the previous reply status, so clear it here.  Most likely a new info was pushed before, so that this was not a problem. If this is a DII request, make sure we ignore the next initiate. fix for 6763340 If the replyStatus has not yet been set, this is an indication that the ORB threw an exception before we had a chance to invoke the client interceptor ending points. _REVISIT_ We cannot handle any exceptions or ForwardRequests flagged by the ending points here because there is no way to gracefully handle this in any of the calling code. This is a rare corner case, so we will ignore this for now. Decrement entry count, and if it is zero, pop it from the stack. fix for 6763340, and probably other cases (non-recursive retry) RequestInfoStack<ClientRequestInfoImpl> infoStack =     threadLocalClientRequestInfoStack.get();Server PI hooks Handle SystemException or ForwardRequest: Clear servant from info object so that the user has control over its lifetime: REVISIT: This needs to be done "early" for the following workaround. REVISIT: This was done inside of invokeServerInterceptorEndingPoint but needs to be here for now.  See comment in that method for why. It is possible we might have entered this method more than once (e.g. if an ending point threw a SystemException, then a new ServerResponseImpl is created). Note: this is also an assertion to make sure a valid replyStatus is passed in (IndexOutOfBoundsException will be thrown otherwise) Make forwarded IOR available to interceptors, if applicable: REVISIT: Do early above for now. Make reply message available to interceptors:info.setReplyMessage( replyMessage ); Remember exception so we can tell if an interceptor changed it. _REVISIT_ We do not have access to the User Exception at this point, so treat it as an UNKNOWN for now. Note that if this is a DSI call, we do have the user exception. Invoke the ending interception points: Check reply status.  If an interceptor threw a SystemException and it is different than the one that we came in with, rethrow it so the proper response can be constructed: If we are to forward the location: Treat a ForwardRequest as a ForwardException. Treat a ForwardRequest by changing the IOR. Notify request object that once response is constructed, make sure we execute ending points.The following methods are private utility methods.**********************************************************************Handles exceptions for the starting and intermediate points forserver request interceptors.  This is common code that has beenfactored out into this utility method.This method will NOT work for ending points. If a system exception was thrown, throw it to caller: If an interceptor throws a forward request, convert it into a ForwardException for easier handling:Utility method to convert a PI reply status short to a ReplyMessageconstant.  This is a reverse lookup on the table defined inREPLY_MESSAGE_TO_PI_REPLY_STATUS.  The reverse lookup need not beperformed as quickly since it is only executed in exceptionconditions.Convenience method to get the ClientRequestInfoImpl object off thetop of the ThreadLocal stack.  Throws an INTERNAL exception ifthe Info stack is empty.Convenience method to get the ServerRequestInfoImpl object off thetop of the ThreadLocal stack.  Returns null if there are none.Convenience method to determine whether Client PI is enabledfor requests on this thread.Call pre_init on all ORB initializers Inform ORBInitInfo we are in pre_init stage Step through each initializer instantiation and call its pre_init.  Ignore any exceptions. As per orbos/99-12-02, section 9.3.1.2, "If there are any exceptions, the ORB shall ignore them and proceed."Call post_init on all ORB initializers Inform ORBInitInfo we are in post_init stage Step through each initializer instantiation and call its post_init. Ignore any exceptions.Creates the ORBInitInfo object to be passed to ORB intializers'pre_init and post_init methods arguments comes from set_parameters.  May be null. _REVISIT_ The spec does not specify which ID this is to be. We currently get this from the corba.ORB, which reads it from the ORB_ID_PROPERTY property.Called by ORBInitInfo when an interceptor needs to be registered. We will assume interceptor is not null, since it is called internally. Register with interceptor list:This is the implementation of standard API defined in org.omg.CORBA.ORBclass. This method finds the Policy Factory for the given Policy Typeand instantiates the Policy object from the Factory. It will throwPolicyError exception, If the PolicyFactory for the given type isnot registered._REVISIT_, Once Policy Framework work is completed, Reorganizethis method to com.sun.corba.se.spi.orb.ORB.This method registers the Policy Factory in the policyFactoryTable,which is a HashMap. This method is made package private, becauseit is used internally by the  Interceptors./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/interceptors/PINoOpHandlerImpl.javaCopyright (c) 2003, 2012, Oracle and/or its affiliates. All rights reserved.This is No-Op implementation of PIHandler. It is used in ORBConfiguratorto initialize a piHandler before the Persistent Server Activation. ThisPIHandler implementation will be replaced by the real PIHandler inORB.postInit( ) call./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/interceptors/RequestInfoImpl.javasetSlotTablesetSlotTable(com.sun.corba.se.impl.interceptors.SlotTable)/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/interceptors/RequestInfoImpl.classgetExceptiongetException()insertUserExceptioninsertUserException(org.omg.CORBA.UserException,org.omg.CORBA.Any)insertApplicationExceptioninsertApplicationException(org.omg.CORBA.portable.ApplicationException,org.omg.CORBA.Any)appExceptionhelperClassNamereadParamsMap<String,?>TypeVariable<Class<?>>TypeVariable<Class<?>>[]ueInputStreamuserExceptionreadArgumentsexceptionClass? extends UserExceptionClass<? extends UserException>insertMethodParamsinsertMethod"insert"insertinsertMethodArgumentsClass<Any>parNVListplistcachedServiceContextsoutputStreamcoreServiceContextnumcallalreadyExecutedexecutionPointslotTableImplementation of the RequestInfo interface as specified inorbos/99-12-02 section 5.4.1. The ORB from which to get PICurrent and other info The number of interceptors actually invoked for this client request. See setFlowStackIndex for a detailed description. The type of starting point call to make to the interceptors See ClientRequestInfoImpl and ServerRequestInfoImpl for a list of appropriate constants. The type of intermediate point call to make to the interceptors See ServerRequestInfoImpl for a list of appropriate constants. This does not currently apply to client request interceptors but is here in case intermediate points are introduced in the future. The type of ending point call to make to the interceptors The reply status to return in reply_status.  This is initialized to UNINITIALIZED so that we can tell if this has been set or not. Constant for an uninitizlied reply status. Which points we are currently executing (so we can implement the validity table). Set to true if all interceptors have had all their points executed. Sources of request information The ForwardRequest object if this request is being forwarded. Either the forwardRequest or the forwardRequestIOR field is set. When set, the other field is set to null initially.  If the other field is queried, it is lazily calculated and cached.  These two attributes are always kept in sync. PICurrent's  SlotTable The exception to be returned by received_exception and received_exception_id Please keep these in the same order as declared above. We don't need to reset the Slots because they are already in the clean state after recieve_<point> interceptor are called. Method IDs for all methods in RequestInfo.  This allows for a The last value from RequestInfo (be sure to update this):Public interfacesCreates a new RequestInfoImpl object. Capture the current TSC and make it the RSC of this request.Implementation for request_id() differs for client and serverimplementations.Uniquely identifies an active request/reply sequence.  Once arequest/reply sequence is concluded this ID may be reused.  (thisis NOT necessarily the same as the GIOP request_id).Implementation for operation() differs for client and serverThe name of the operation being invoked.This method returns the list of arguments for the operation that wasinvoked. It raises NO_RESOURCES exception if the operation is not invokedby using DII mechanism.This method returns the list of exceptios  that was raised when theoperation was invoked. It raises NO_RESOURCES exception if the operationis not invoked by using DII mechanism.This method returns the list of contexts for the DII operation.It raises NO_RESOURCES exception if the operation is not invoked byusing DII mechanism.This method returns the list of operation_context for the DII operation.This method returns the result from the invoked DII operation.Implementation for response_expected() differs for client and serverIndicates whether a response is expected.  On the client, a reply isnot returned when response_expected is false, so receive_reply cannotbe called.  receive_other is called unless an exception occurs, inwhich case receive_exception is called.  On the client, withinsend_poll, this attribute is true.Defined in the Messaging specification.  Pertinent only whenresponse_expected is false.  If response_expected is true, the valueof sync_scope is undefined.  It defines how far the request shallprogress before control is returned to the client.  This attribute mayhave one of the follwing values:<li>Messaging::SYNC_NONE</li><li>Messaging::SYNC_WITH_TRANSPORT</li><li>Messaging::SYNC_WITH_SERVER</li><li>Messaging::SYNC_WITH_TARGET</li> REVISIT - get from MessageMediatorDescribes the state of the result of the operation invocation.  Itsvalue can be one of the following:<li>PortableInterceptor::SUCCESSFUL</li><li>PortableInterceptor::SYSTEM_EXCEPTION</li><li>PortableInterceptor::USER_EXCEPTION</li><li>PortableInterceptor::LOCATION_FORWARD</li><li>PortableInterceptor::TRANSPORT_RETRY</li>Implementation for forward_reference() differs for client and serverIf the reply_status attribute is LOCATION_FORWARDthen this attribute will contain the objectto which the request will be forwarded.  It is indeterminate whether aforwarded request will actually occur.Returns the data from the given slot of the PortableInterceptor::Currentthat is in the scope of the request.If the given slot has not been set, then an any containing a type codewith a TCKind value of tk_null is returned.If the ID does not define an allocated slot, InvalidSlot is raised.checkAccess( MID_GET_SLOT ); Delegate the call to the slotTable which was set when RequestInfo was created.Implementation for get_request_service_context() differs for clientand server implementations.This operation returns a copy of the service context with the given IDthat is associated with the request.  If the request's service contextImplementation for get_reply_service_context() differs for clientthat is associated with the reply.  IF the request's service contextdoes not contain an entry for that ID, BAD_PARAM with a minor code of 3. Define entries in the validCall[][] table for interception points    in both ClientRequestInfoImpl and ServerRequestInfoImpl.Proprietary methodsThe connection on which the request is made.Note: we store the connection as an internal type butexpose it here as an external type.Inserts the UserException inside the given ApplicationExceptioninto the given Any.  Throws an UNKNOWN with minor codeOMGSYstemException.UNKNOWN_USER_EXCEPTION if the Helper class could not befound to insert it with. Extract the UserException from the ApplicationException. Look up class name from repository id: Find the read method on the helper class: Invoke the read method, passing in the input stream to retrieve the user exception.  Mark and reset the stream as to not disturb it. Insert this UserException into the provided Any using the helper class.Inserts the UserException into the given Any.Throws an UNKNOWN with minor code Find insert( Any, class ) method Call helper.insert( result, userException ):Protected utility methodsInternal utility method to convert an NVList into a PI Parameter[] _REVISIT_ This utility method should probably be doing a deep copy so interceptor can't accidentally change the arguments. ParameterMode spec can be found in 99-10-07.pdf Section:10.5.22 nv.flags spec can be found in 99-10-07.pdf Section 7.1.1 nv.flags has ARG_IN as 1, ARG_OUT as 2 and ARG_INOUT as 3 To convert this into enum PARAM_IN, PARAM_OUT and PARAM_INOUT the value is subtracted by 1.Utility to wrap the given Exception in an Any object and return it.If the exception is a UserException which cannot be inserted intoan any, then this returns an Any containing the system exceptionUNKNOWN. Note: exception should never be null here since we will throw a BAD_INV_ORDER if this is not called from receive_exception. Use the Helper class for this exception to insert it into an Any. Insert the user exception inside the application exception into the Any result: As per ptc/00-08-06, 21.3.13.4. if we cannot find the appropriate class, then return an any containing UNKNOWN, with a minor code of 1.  This is conveniently the same exception that is returned from the insertApplicationException utility method.Utility method to look up a service context with the given id andconvert it to an IOP.ServiceContext.  Uses the given HashMap asa cache.  If not found in cache, the result is inserted in the cache. Search cache first: null could normally mean that either we cached the value null or it's not in the cache.  However, there is no way for us to cache the value null in the following code. Not in cache.  Find it and put in cache. Get the desired "core" service context. Convert the "core" service context to an "IOP" ServiceContext by writing it to a CDROutputStream and reading it back. Good citizen: For increased efficiency, we assume that interceptors will not modify the returned ServiceContext.  Otherwise, we would have to make a deep copy.Utility method to add an IOP.ServiceContext to a core.ServiceContextsobject.  If replace is true, any service context with the given idis replaced.Raises BAD_INV_ORDER if replace is false and a service context withthe given id already exists.Uses the given HashMap as a cache.  If a service context is placedin the container, it goes in the HashMap as well. Convert IOP.service_context to core.ServiceContext: Constructor expects id to already have been read from stream. Place IOP.ServiceContext in cache as well:Sets the number of interceptors whose starting interceptionpoints were successfully invoked on this client call.  As specifiedin orbos/99-12-02, section 5.2.1., not all interceptors willbe invoked if a ForwardRequest exception or a system exceptionis raised.  This keeps track of how many were successfully executedso we know not to execute the corresponding ending interceptionpoints for the interceptors whose starting interception pointswere not completed.  This simulates the "Flow Stack Visual Model"presented in section 5.1.3.Returns the number of interceptors whose starting interceptionpoints were actually invoked on this client request.  SeesetFlowStackIndex for more details.Sets which ending interception point should be calledfor each interceptor in the virtual flow stack.Retrieves the current ending point call type (seesetEndingPointCall for more details).Sets which intermediate interception point should be calledRetrieves the current intermediate point call type (seeSets which starting interception point should be calledRetrieves the current starting point call type (seesetStartingPointCall for more details).Returns true if all interceptors' starting and ending pointshave already executed to completion, or false if not yet.Sets whether all interceotrs' starting and ending pointshave already been executed to completion.Sets the value to be returned by reply_statusGets the current reply_status without doing an access check(available only to package and subclasses)Stores the given ForwardRequest object for later analysis.This version supplements setForwardRequest( IOR );Stores the given IOR for later forward request analysis.This version supplements setForwardRequest( ForwardRequest );Retrieves the ForwardRequest object as a ForwardRequest exception. Convert the internal IOR to a forward request exception by creating an object reference.Retrieves the IOR of the ForwardRequest exception.Sets the exception to be returned by received_exception andreceived_exception_id.Returns the exception to be returned by received_exception andSets the execution point that we are currently executing(starting points, intermediate points, or ending points).This allows us to enforce the validity table.Check whether the caller is allowed to access this method atthis particular time.  This is overridden in subclasses to implementthe validity table specified in ptc/00-04-05, table 21-1 and 21-2.The currentExecutionPoint attribute is checked, and if access isforbidden at this time, BAD_INV_ORDER is raised with a minor code ofTBD_BIO.The ID of this method, one of the MID_* constants.This allows us to easily look up the method access in a table.Note that method ids may overlap between subclasses.The server side does an explicit set rather than taking thecurrent PICurrent table as is done in the general RequestInfoImplconstructor./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/interceptors/ServerRequestInfoImpl.javaisDynamicisDynamic()/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/interceptors/ServerRequestInfoImpl.classisForwardRequestRaisedInEndingisForwardRequestRaisedInEnding()setForwardRequestRaisedInEndingsetForwardRequestRaisedInEnding()releaseServantreleaseServant()setReplyMessagesetReplyMessage(com.sun.corba.se.impl.protocol.giopmsgheaders.ReplyMessage)enqueueenqueue(com.sun.corba.se.impl.interceptors.ServerRequestInfoImpl.AddReplyServiceContextCommand)checkForNullTemplatecheckForNullTemplate()ServerRequestInfoImplServerRequestInfoImpl(com.sun.corba.se.spi.orb.ORB)cachedSendingExceptionserverRequestIdobjectAdapterdsiExceptiondsiResultdsiArgumentsaddReplyServiceContextQueueadapterNameadapterIdforwardRequestRaisedInEndingCALL_SEND_OTHERCALL_SEND_EXCEPTIONCALL_SEND_REPLYCALL_INTERMEDIATE_NONECALL_RECEIVE_REQUESTCALL_RECEIVE_REQUEST_SERVICE_CONTEXToaidaddReplyscs/Library/Java/JavaVirtualMachines/jdk1.8.0_251.jdk/Contents/Home/jre/lib/rt.jar/com/sun/corba/se/impl/interceptors/ServerRequestInfoImpl$AddReplyServiceContextCommand.classAddReplyServiceContextCommandAddReplyServiceContextCommand()Implementation of the ServerRequestInfo interface as specified inorbos/99-12-02 section 5.4.3. The available constants for intermediatePointCall.  The default (0) is receive_request, but can be set to none on demand. Set to true if the server ending point raised ForwardRequest at some point in the ending point. Sources of server request information: Information cached from calls to oktemp reset cached attributes: Method IDs for all methods in ServerRequestInfo.  This allows for a ServerRequestInfo validity table (see ptc/00-08-06 table 21-2). r_rsc = receive_request_service_contexts r_req = receive_request s_rep = send_reply s_exc = send_exception s_oth = send_other                              { r_rsc, r_req, s_rep, s_exc, s_oth } ServerRequestInfo methods::sending_exceptionobject_idadapter_idtarget_most_derived_inte...get_server_policyset_slottarget_is_aadd_reply_service_contextorb_idadapter_nameCreates a new ServerRequestInfo implementation.Any containing the exception to be returned to the client. sending_exception should not be callable if both dsiException and exception are null.The opaque object_id describing the target of the operation invocation. For some reason, we never set object id.  This could be because a servant locator caused a location forward or raised an exception.  As per ptc/00-08-06, section 21.3.14, we throw NO_RESOURCES interceptors will not change the resulting byte[] array. Otherwise, we would need to make a clone of this array. For some reason, we never set the ObjectKeyTemplateThe opaque identifier for the object adapter.The RepositoryID for the most derived interface of the servant.Returns the policy in effect for this operation for the given policytype.checkAccess( MID_GET_SERVER_POLICY ); _REVISIT_ RTF Issue: get_server_policy spec not in sync with get_effective_policy spec.Allows an Interceptor to set a slot in the Current that is in the scopeof the request.  If data already exists in that slot, it will beoverwritten.  If the ID does not define an allocated slot, InvalidSlotis raised.checkAccess( MID_SET_SLOT );Returns true if the servant is the given RepositoryId, false if it isnot.Allows Interceptors to add service contexts to the request.checkAccess( MID_ADD_REPLY_SERVICE_CONTEXT ); May be null.  If this is null, create a new one in its place. This is during and ending point, so we now have enough information to add the reply service context. We enqueue all adds for the following reasons: If we are not in the ending point then we do not yet have a pointer to the ServiceContexts object so we cannot access the service contexts until we get to the ending point. So we enqueue this add reply service context request. It is added when we do have a handle on the service contexts object. If we are in the ending point and we just add directly to the SC container but then an interceptor raises a SystemException then that add will be lost since a new container is created for the SystemException response. Therefore we always enqueue and never dequeue (per request) so that all adds will be completed. REVISIT: this does not add to the cache.See ServerRequestInfo for javadocs.NOTE: The request id in server interceptors is NOT thesame as the GIOP request id.  The ORB may be servicing severalconnections, each with possibly overlapping sets of request ids.Therefore we create a request id specific to interceptors. If it is a DSI request then get the arguments from the DSI req _REVISIT_ PI RTF Issue: No exception list on server side. We do not support this because our ORB does not send contexts. We do not support this because our ORB does not send operation_context. state as per ptc/00-08-06, table 21-2Private-scope classes and methods A command encapsulating a request to add a reply service context. These commands are enqueued until we have a handle on the actual reply service context, at which point they are executed. Adds the given add reply service context command to the queue of such commands.  If a command is detected to have the same id as the service context in this command, and replace is false, BAD_INV_ORDER is thrown.  If replace is true, the original command in the queue is replaced by this command.Package and protected-scope methodsOverridden from RequestInfoImpl.  This version calls the superand then, if we are changing to ending points, executes allenqueued AddReplyServiceContextCommands. If we are transitioning to ending point, we will now have a pointer to the reply service contexts, so we can execute all queued add reply service context requests. _REVISIT_  The only way this can happen is if during rrsc or rr, the interceptor tried to add with replace=false to a service context that is present in the reply message.  At that time there was no way for us to check for this, so the best we can do is ignore the original request. We specifically do not empty the SC queue so that if the interceptor raises an exception the queued service contexts will be put in the exception response.Stores the various sources of information used for this info object. Clear cached exception value: Make sure DSIException is null because this is the more recent one.Set reply messageRelease the servant object so the user has control over its lifetime.Called after receive_request is finished executing.Sets the forwardRequestRaisedInEnding flag to true, indicating thata server ending point has raised location forward at some point.Returns true if ForwardRequest was raised by a server ending pointor false otherwise.Returns true if this is a dynamic invocation, or false if not/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/interceptors/SlotTable.javagetSizegetSize()/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/interceptors/SlotTable.classresetSlotsresetSlots()SlotTableSlotTable(com.sun.corba.se.spi.orb.ORB,int)dirtyFlagtheSlotDataslotSizeSlotTable is used internally by PICurrent to store the slot information. The vector where all the slot data for the current thread is stored Required for instantiating Any object. The flag to check whether there are any updates in the current SlotTable. The slots will be reset to null, only if this flag is set.The constructor instantiates an Array of Any[] of size given by slotSizeparameter.This method sets the slot data at the given slot id (index). First check whether the slot is allocated If not, raise the invalid slot exceptionThis method get the slot data for the given slot id (index).This method resets all the slot data to null if dirtyFlag is set.This method returns the size of the allocated slots./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/interceptors/SlotTableStack.javapeekSlotTablepeekSlotTable()/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/interceptors/SlotTableStack.classSlotTableStackSlotTableStack(com.sun.corba.se.spi.orb.ORB,com.sun.corba.se.impl.interceptors.SlotTable)tablePoolcurrentIndextableContainer/Library/Java/JavaVirtualMachines/jdk1.8.0_251.jdk/Contents/Home/jre/lib/rt.jar/com/sun/corba/se/impl/interceptors/SlotTableStack$SlotTablePool.classputSlotTableputSlotTable(com.sun.corba.se.impl.interceptors.SlotTable)SlotTablePoolSlotTablePool()HIGH_WATER_MARKSlotTable[]pooltableTempSlotTableStack is the container of SlotTable instances for each thread SlotTablePool is the container for reusable SlotTables' Contains a list of reusable SlotTable High water mark for the pool If the pool size reaches this limit then putSlotTable will not put SlotTable to the pool. currentIndex points to the last SlotTable in the listPuts SlotTable to the re-usable pool. If there are enough SlotTables in the pool, then don't add this table to the pool. Let the garbage collector collect it.Gets SlotTable from the re-usable pool. If there are no entries in the pool then return null Works like a stack, Gets the last one added first Contains all the active SlotTables for each thread. The List is made to behave like a stack. Keeps track of number of PICurrents in the stack. For Every Thread there will be a pool of re-usable SlotTables' stored in SlotTablePool The ORB associated with this slot table stackConstructs the stack and and SlotTablePool SlotTableStack will be created with one SlotTable on the stack. This table is used as the reference to query for number of allocated slots to create other slottables.pushSlotTable  pushes a fresh Slot Table on to the stack by doing thefollowing,1: Checks to see if there is any SlotTable in SlotTablePoolIf present then use that instance to push into the SlotTableStack2: If there is no SlotTable in the pool, then creates a new one andpushes that into the SlotTableStack get an existing PICurrent to get the slotSize NOTE: Very important not to always "add" - otherwise a memory leak. Add will cause the table to grow. Set will override unused slots.popSlotTable does the following1: pops the top SlotTable in the SlotTableStack2: resets the slots in the SlotTable which resets the slotvalues tonull if there are any previous sets.3: puts the reset SlotTable into the SlotTablePool to reuse Do not pop the SlotTable, If there is only one. This should not happen, But an extra check for safety. Do not leak memory.peekSlotTable gets the top SlotTable from the SlotTableStack withoutpopping./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/io/FVDCodeBaseImpl.java/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/iocom.sun.corba.se.impl.iosetValueHandlersetValueHandler(javax.rmi.CORBA.ValueHandler)/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/io/FVDCodeBaseImpl.class/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/iovhandlerdescriptions? super ?Class<? super ?>?[]Class<Object>Copyright (c) 1999, 2011, Oracle and/or its affiliates. All rights reserved.This class acts as the remote interface to receivers wishing to retrievethe information of a remote Class. Contains rep. ids as keys to FullValueDescriptions Private ORBSingleton used when we need an ORB while not having a delegate set. backward compatability so that appropriate rep-id calculations can take place this needs to be transient to prevent serialization during marshalling/unmarshalling Operation to obtain the IR from the sending context Operations to obtain a URL to the implementation code default to using the current ORB version in case the vhandler is not set Util.getCodebase may return null which would cause a BAD_PARAM exception. the same information information/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/io/IIOPInputStream.javagetDeclaredField(java.lang.Class,java.lang.String)/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/io/IIOPInputStream.classsetDoubleFieldsetDoubleField(java.lang.Object,java.lang.Class,java.lang.String,double)setFloatFieldsetFloatField(java.lang.Object,java.lang.Class,java.lang.String,float)setLongFieldsetLongField(java.lang.Object,java.lang.Class,java.lang.String,long)setIntFieldsetIntField(java.lang.Object,java.lang.Class,java.lang.String,int)setShortFieldsetShortField(java.lang.Object,java.lang.Class,java.lang.String,short)setCharFieldsetCharField(java.lang.Object,java.lang.Class,java.lang.String,char)setByteFieldsetByteField(java.lang.Object,java.lang.Class,java.lang.String,byte)setBooleanFieldsetBooleanField(java.lang.Object,java.lang.Class,java.lang.String,boolean)setObjectFieldsetObjectField(java.lang.Object,java.lang.Class,java.lang.String,java.lang.Object)throwAwayDatathrowAwayData(org.omg.CORBA.ValueMember[],com.sun.org.omg.SendingContext.CodeBase)skipCustomUsingFVDskipCustomUsingFVD(org.omg.CORBA.ValueMember[],com.sun.org.omg.SendingContext.CodeBase)inputClassFieldsinputClassFields(java.lang.Object,java.lang.Class,com.sun.corba.se.impl.io.ObjectStreamClass,org.omg.CORBA.ValueMember[],com.sun.org.omg.SendingContext.CodeBase)ObjectStreamField[]inputClassFields(java.lang.Object,java.lang.Class,com.sun.corba.se.impl.io.ObjectStreamField[],com.sun.org.omg.SendingContext.CodeBase)inputCurrentClassFieldsForReadFieldsinputCurrentClassFieldsForReadFields(java.util.Map)inputRemoteMembersForReadFieldsinputRemoteMembersForReadFields(java.util.Map)readFieldsreadFields(java.util.Map)mustUseRemoteValueMembersmustUseRemoteValueMembers()inputObjectFieldinputObjectField(com.sun.corba.se.impl.io.ObjectStreamField)inputObjectField(org.omg.CORBA.ValueMember,com.sun.org.omg.SendingContext.CodeBase)inputPrimitiveFieldinputPrimitiveField(java.lang.Object,java.lang.Class,com.sun.corba.se.impl.io.ObjectStreamField)resetStreamresetStream()invokeObjectReaderinvokeObjectReader(com.sun.corba.se.impl.io.ObjectStreamClass,java.lang.Object,java.lang.Class)findNextClassfindNextClass(java.lang.String,java.lang.Class[],int,int)skipObjectUsingFVDskipObjectUsingFVD(java.lang.String,com.sun.org.omg.SendingContext.CodeBase)inputObjectUsingFVDinputObjectUsingFVD(java.lang.Class,java.lang.String,com.sun.org.omg.SendingContext.CodeBase,int)getOrderedDescriptionsgetOrderedDescriptions(java.lang.String,com.sun.org.omg.SendingContext.CodeBase)inputObjectinputObject(java.lang.Class,java.lang.String,com.sun.org.omg.SendingContext.CodeBase,int)handleOptionalDataMarshalExceptionhandleOptionalDataMarshalException(org.omg.CORBA.MARSHAL,boolean)defaultReadObjectDelegatedefaultReadObjectDelegate()simpleReadObjectsimpleReadObject(java.lang.Class,java.lang.String,com.sun.org.omg.SendingContext.CodeBase,int)decreaseRecursionDepthdecreaseRecursionDepth()increaseRecursionDepthincreaseRecursionDepth()getOrbStreamgetOrbStream()setOrbStreamsetOrbStream(org.omg.CORBA_2_3.portable.InputStream)readFormatVersionreadFormatVersion()createOptionalDataExceptioncreateOptionalDataException()getOptDataExceptionCtorgetOptDataExceptionCtor()readObjectArgListOPT_DATA_EXCEPTION_CTORuseFVDOnlykEmptyStrspClassclassesObjectStreamClass[]classdesccallbacksabortClassNotFoundExceptionabortIOExceptionactiveRecursionMgrsimpleReadDepthrecursionDepthcurrentClasscurrentClassDesccurrentObjectcbSenderorbStreamdefaultReadObjectFVDMembersutilWrapperbridge/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/io/IIOPInputStream$1.class/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/io/IIOPInputStream$2.classboolCtorConstructor<OptionalDataException>Class<OptionalDataException>Map<String,OptionalDataException>OptionalDataException[]? super OptionalDataExceptionClass<? super OptionalDataException>TypeVariable<Class<OptionalDataException>>TypeVariable<Class<OptionalDataException>>[]"Unable to find OptionalDataException constructor"Unable to find OptionalDataException constructornewInstance(java.lang.Object[])getAnnotatedReceiverTypegetAnnotatedReceiverType()getAnnotatedReturnTypegetAnnotatedReturnType()handleParameterNumberMismatchhandleParameterNumberMismatch(int,int)Annotation[][]getParameterAnnotationsgetParameterAnnotations()getRawParameterAnnotationsgetRawParameterAnnotations()getSignaturegetSignature()getSlotgetSlot()setConstructorAccessorsetConstructorAccessor(sun.reflect.ConstructorAccessor)getConstructorAccessorgetConstructorAccessor()isVarArgsisVarArgs()specificToGenericStringHeaderspecificToGenericStringHeader(java.lang.StringBuilder)specificToStringHeaderspecificToStringHeader(java.lang.StringBuilder)getGenericExceptionTypesgetGenericExceptionTypes()getExceptionTypesgetExceptionTypes()getGenericParameterTypesgetGenericParameterTypes()getParameterCountgetParameterCount()getParameterTypesgetParameterTypes()TypeVariable<Constructor>TypeVariable<Constructor>[]getAnnotationBytesgetAnnotationBytes()hasGenericInformationhasGenericInformation()copy()ConstructorConstructor(java.lang.Class,java.lang.Class[],java.lang.Class[],int,int,java.lang.String,byte[],byte[])Constructor<>(java.lang.Class,java.lang.Class[],java.lang.Class[],int,int,java.lang.String,byte[],byte[])getRootgetRoot()getGenericInfogetGenericInfo()"Created null OptionalDataException"Created null OptionalDataException"Couldn't create OptionalDataException"Couldn't create OptionalDataExceptionsysex"Unsupported format version: "Unsupported format version: "Not a ValueInputStream"Not a ValueInputStreamcbmarshalExceptioncdriesenderprevObjectprevClassDescprevClassoldStreamFormatVersionexIOEexCNFioe"defaultReadObjectDelegate""Object Type mismatch"Object Type mismatchfieldsnaeenableerr"Method readLine not supported"Method readLine not supported0x0000FFFFobjectRead"No more optional data"No more optional dataprio"Method registerValidation not supported"Method registerValidation not supported"Method resolveClass not supported"Method resolveClass not supported"Method resolveObject not supported"Method resolveObject not supportedClass<Enum<>>Map<String,Enum<>>Enum[]Enum<>[]Constructor<Enum<>>? super Enum<>Class<? super Enum<>>TypeVariable<Class<Enum<>>>TypeVariable<Class<Enum<>>>[]ext"InvocationTargetException accessing no-arg constructor"InvocationTargetException accessing no-arg constructor"UnsupportedOperationException accessing no-arg constructor"UnsupportedOperationException accessing no-arg constructor"InstantiationException accessing no-arg constructor"InstantiationException accessing no-arg constructorcurrdesccurrclassspBase"java.lang.String"java.lang.StringccnewlennewclassesnewclassdescoldStatecalledDefaultWriteObjectdescsaFVDfvdsListfvdrepIDForFVDrepIDForClass"java.lang.Object"java.lang.ObjectusedReadObjectclassname_spClass_spBaseoscaclass"internal error"internal error20fieldbyteValuebooleanValuecharValueshortValueintValuelongValuefloatValuedoubleValue'B'B'Z'Z'C'C'S''I'I'J'J'F'F"Assigning instance of class "Assigning instance of class " to field " to field '#'#objectValuesignature"Ljava/lang/Object;"Ljava/lang/Object;"Ljava/io/Serializable;"Ljava/io/Serializable;"Ljava/io/Externalizable;"Ljava/io/Externalizable;callType"Unknown callType: "Unknown callType: fieldTypeactualTypenarrowloadStubClassClass<Remote>Map<String,Remote>Remote[]Constructor<Remote>? super RemoteClass<? super Remote>TypeVariable<Class<Remote>>TypeVariable<Class<Remote>>[]Map<String,Object>Constructor<Object>Class<? super Object>TypeVariable<Class<Object>>TypeVariable<Class<Object>>[]stubTypefieldToValueMap"Unknown kind: "Unknown kind: primFieldsfieldCldeclaredClassFieldinputStreamFieldNamedeclaredFieldClass"Field mismatch"Field mismatchpaExsecExnpEx"Field Type mismatch"Field Type mismatchiaExobjectValueClassNamecurrentClassDescClassNamefieldNameccExscefieldFVDfld"null "null " object" object/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/io/IIOPInputStream$3.classPrivilegedExceptionAction<Field>Map<Integer,Object>offsetToObjectMap/Library/Java/JavaVirtualMachines/jdk1.8.0_251.jdk/Contents/Home/jre/lib/rt.jar/com/sun/corba/se/impl/io/Library/Java/JavaVirtualMachines/jdk1.8.0_251.jdk/Contents/Home/jre/lib/rt.jar/com/sun/corba/se/impl/io/IIOPInputStream$ActiveRecursionManager.classHashMap<Integer,Object>AbstractMap<Integer,Object>HashMap<Integer,Object>()merge(java.lang.Integer,java.lang.Object,java.util.function.BiFunction)? super IntegerBiFunction<? super Integer,? super Object,? extends Object>compute(java.lang.Integer,java.util.function.BiFunction)computeIfPresent(java.lang.Integer,java.util.function.BiFunction)Function<? super Integer,? extends Object>computeIfAbsent(java.lang.Integer,java.util.function.Function)replace(java.lang.Integer,java.lang.Object)replace(java.lang.Integer,java.lang.Object,java.lang.Object)putIfAbsent(java.lang.Integer,java.lang.Object)BiConsumer<? super Integer,? super Object>Entry<Integer,Object>Set<Entry<Integer,Object>>Collection<Entry<Integer,Object>>Iterable<Entry<Integer,Object>>Set<Integer>Collection<Integer>Iterable<Integer>? extends IntegerMap<? extends Integer,? extends Object>put(java.lang.Integer,java.lang.Object)AbstractMap<Integer,Object>()Node<Integer,Object>TreeNode<Integer,Object>newTreeNode(int,java.lang.Integer,java.lang.Object,java.util.HashMap.Node)newNode(int,java.lang.Integer,java.lang.Object,java.util.HashMap.Node)Node<Integer,Object>[]putVal(int,java.lang.Integer,java.lang.Object,boolean,boolean)HashMap<Integer,Object>(java.util.Map)HashMap<Integer,Object>(int)HashMap<Integer,Object>(int,float)"Invalid indirection to offset "Invalid indirection to offset Copyright (c) 1998, 2015, Oracle and/or its affiliates. All rights reserved.IIOPInputStream is used by the ValueHandlerImpl to handle Java serializationinput semantics.Stephen LewallenJDK1.1.6 Necessary to pass the appropriate fields into the defaultReadObjectDelegate method (which takes no parameters since it's called from java.io.ObjectInpuStream defaultReadObject() which we can't change). This is only used in the case where the fields had to be obtained remotely because of a serializable version difference.  Set in inputObjectUsingFVD. Part of serialization evolution fixes for Ladybird, bug 4365188.d4365188 The ActiveRecursionManager replaces the old RecursionManager which used to record how many recursions were made, and resolve them after an object was completely deserialized. That created problems (as in bug 4414154) because when custom unmarshaling in readObject, there can be recursive references to one of the objects currently being unmarshaled, and the passive recursion system failed.Remember the first exception that stopped this stream.Vector of validation callback objectsThe vector is created as needed. The vector is maintained inorder of highest (first) priority to lowest Serialization machinery fieldsArrays used to keep track of classes and ObjectStreamClassesas they are being merged; used in inputObject.spClass is the stack pointer for both. TCKind TypeCodes used in FVD inputClassFieldspublic static final TypeCode kRemoteTypeCode = new TypeCodeImpl(TCKind._tk_objref);public static final TypeCode kValueTypeCode =  new TypeCodeImpl(TCKind._tk_value); removed TypeCodeImpl dependency TESTING CODE - useFVDOnly should be made final before FCS in order to optimize out the check. Since java.io.OptionalDataException's constructors are package private, but we need to throw it in some special cases, we try to do it by reflection. Grab the OptionalDataException boolean ctor and make it accessible.  Note that any exceptions will be wrapped in ExceptionInInitializerErrors. XXX I18N, logging needed. Create a new OptionalDataException with the EOF marker set to true.  See handleOptionalDataMarshalException. Return the stream format version currently being used to deserialize an object At the beginning of data sent by a writeObject or writeExternal method there is a byte telling the reader the stream format version. XXX I18N?  Logging for IOException?  useFVDOnly = val;Dummy constructor; passes upper stream a dummy stream;added setSender and getSender 4365188 this is added to enable backward compatability w/ wrong rep-idsOverride the actions of the final method "readObject()"in ObjectInputStream.Read an object from the ObjectInputStream.The class of the object, the signature of the class, and the valuesof the non-transient and non-static fields of the class and allof its supertypes are read.  Default deserializing for a class can beoverriden using the writeObject and readObject methods.Objects referenced by this object are read transitively sothat a complete equivalent graph of objects is reconstructed by readObject. <p>The root object is completly restored when all of its fieldsand the objects it references are completely restored.  At thispoint the object validation callbacks are executed in orderbased on their registered priorities. The callbacks areregistered by objects (in the readObject special methods)as they are individually restored.Exceptions are thrown for problems with the InputStream and for classesthat should not be deserialized.  All exceptions are fatal to theInputStream and leave it in an indeterminate state; it is up to the callerto ignore or recover the stream state.java.lang.ClassNotFoundExceptionClass of a serialized objectcannot be found.InvalidClassExceptionSomething is wrong with a class used byserialization.StreamCorruptedExceptionControl information in thestream is inconsistent.OptionalDataExceptionPrimitive data was found in thestream instead of objects.IOExceptionAny of the usual Input/Output related exceptions.JDK1.1 The CDR stream had never seen the given offset before, so check the recursion manager (it will throw an IOException if it doesn't have a reference, either).throws OptionalDataException, ClassNotFoundException, IOExceptionSave the current state and get ready to read an object. EnteringCheck for reset, handle it before reading an object. d4365188: backward compatability System.out.println("CLZ = " + clz + "; " + ioe.toString());Check for thrown exceptions and re-throw them, clearing them ifthis is the last recursive call .///////////////This method is called by trusted subclasses of ObjectOutputStreamthat constructed ObjectOutputStream using theprotected no-arg constructor. The subclass is expected to providean override method with the modifier "final".the Object read from the stream.@see#ObjectInputStream()#readObjectJDK 1.2Override the actions of the final method "defaultReadObject()"Read the non-static and non-transient fields of the current classfrom this stream.  This may only be called from the readObject methodof the class being deserialized. It will throw the NotActiveExceptionif it is called otherwise.if the class of a serializedobject could not be found.if an I/O error occurs.NotActiveExceptionif the stream is not currently readingobjects.throws IOException, ClassNotFoundException, NotActiveException The array will be null unless fields were retrieved remotely because of a serializable version difference. Bug fix for 4365188.  See the definition of defaultReadObjectFVDMembers for more information. WARNING:  Be very careful!  What if some of these fields actually have to do this, too? This works because the defaultReadObjectFVDMembers reference is passed to inputClassFields, but there is no guarantee that defaultReadObjectFVDMembers will point to the same array after calling inputClassFields. Use the remote fields to unmarshal. Use the local fields to unmarshal.Override the actions of the final method "enableResolveObject()"Enable the stream to allow objects read from the stream to be replaced.If the stream is a trusted class it is allowed to enable replacment.Trusted classes are those classes with a classLoader equals null. <p>When enabled the resolveObject method is called for every objectbeing deserialized.SecurityExceptionThe classloader of this stream object is non-null.throws SecurityException The following three methods allow the implementing orbStream to provide mark/reset behavior as defined in java.io.InputStream. unreliable no op d11623 : implement readFully, required for serializing some core classesHelper method for correcting the Kestrel bug 4367783 (dealingwith larger than 8-bit chars).  The old behavior is preservedin orbutil.IIOPInputStream_1_3 in order to interoperate withour legacy ORBs. If the ORB stream detects an incompatibility between what's on the wire and what our Serializable's readObject wants, it throws a MARSHAL exception with a specific minor code. This is rethrown to the readObject as an OptionalDataException. So far in RMI-IIOP, this process isn't specific enough to tell the readObject how much data is available, so we always set the OptionalDataException's EOF marker to true. Java Object Serialization spec 3.4: "If the readObject method of the class attempts to read more data than is present in the optional part of the stream for this class, the stream will return -1 for bytewise reads, throw an EOFException for primitive data reads, or throw an OptionalDataException with the eof field set to true for object reads."Get the descriptor and then class of the incoming object.currentClassDesc.setClass(currentClass);If Externalizable,Create an instance and tell it to read its data.else,Handle it as a serializable class. Store this object and its beginning position since there might be indirections to it while it's been unmarshalled. Read format version end : if (currentClassDesc.isExternalizable())Count number of classes and descriptors we might haveto work on. current top of stackThe object's classes should be processed from supertype to subtypePush all the clases of the current object onto a stack.Note that only the serializable classes are representedin the descriptor list.Handle versioning where one or more supertypes ofhave been inserted or removed.  The stack willcontain pairs of descriptors and the correspondingclass.  If the object has a class that did not occur inthe original the descriptor will be null.  If theoriginal object had a descriptor for a class notpresent in the local hierarchy of the object the class will benull.This is your basic diff pattern, made simplerbecause reordering is not allowed. sun.4296963 ibm.11861 d11861 we should stop when we find the highest serializable class We need this so that when we allocate the new object below, we can call the constructor of the non-serializable superclass. Note that in the JRMP variant of this code the ObjectStreamClass.lookup() method handles this, but we've put this fix here rather than change lookup because the new behaviour is needed in other cases.sun.4296963 ibm.11861Search the classes to see if the class of thisdescriptor appears further up the hierarchy. Untilit's found assume its an inserted class.  If it'snot found, its the descriptor's class that has beenremoved. found a superclass that matches this descriptorIgnore a class that doesn't match.  Noaction is needed since it is alreadyinitialized. end : for (cl = currclass; cl != null; cl = cl.getSuperclass())Test if there is room for this new entry.If not, double the size of the arrays and copy the contents.Class not found corresponding to this descriptor.Pop off all the extra classes pushed.Push the descriptor and a null class.Current class descriptor matches current class.Some classes may have been inserted.Record the match and advance the class, continuewith the next descriptor. end : for (currdesc = currentClassDesc, currclass = currentClass;Allocate a new object.  The object is only constructedabove the highest serializable class and is set todefault values for all more specialized classes.For all the pushed descriptors and classes.if the class has its own writeObject and readObject methodscall the readObject methodinvoke the defaultReadObject methodSet current descriptor and corresponding classRead the data from the stream described by thedescriptor and store into the matching class. Changed since invokeObjectReader no longer does this. Read defaultWriteObject indicator Error case of no readObject and didn't call defaultWriteObject handled in default state _REVISIT_ : Can we ever get here?No local class for this descriptor,Skip over the data for this class.like defaultReadObject with a null currentObject.The code will read the values but discard them. Make sure we exit at the same stack level as when we started. We've completed deserializing this object.  Any future indirections will be handled correctly at the CDR level.  The ActiveRecursionManager only deals with objects currently being deserialized. This retrieves a vector of FVD's for the hierarchy of serializable classes stemming from repositoryID.  It is assumed that the sender will not provide base_value id's for non-serializable classes!This input method uses FullValueDescriptions retrieved from the sender's runtime toread in the data.  This method is capable of throwing out data not applicable to client's fields.This method handles instances where the reader has a class not sent by the sender, the sender senta class not present on the reader, and/or the reader's class does not match the sender's class.NOTE : If the local description indicates custom marshaling and the remote type's FVD alsoindicates custom marsahling than the local type is used to read the data off the wire.  However,if either says custom while the other does not, a MARSHAL error is thrown.  Externalizable isa form of custom marshaling.Allocate a new object. Read and throw away one level of the fvdslist This seems to mean that the sender had a superclass that we don't have WARNING: If stream format version is 1 and there's optional data, we'll get some form of exception down the line or data corruption. If the sender used custom marshaling, then it should have put the two bytes on the wire indicating stream format version and whether or not the writeObject method called defaultWriteObject/writeFields. Always use readObject if it exists, and fall back to default unmarshaling if it doesn't. See the definition of defaultReadObjectFVDMembers for more information.  This concerns making sure we use the remote FVD's members in defaultReadObject. Note that the !usedReadObject !calledDefaultWriteObject case is handled by the beginUnmarshalCustomValue method of the default state The remaining hierarchy of the local class does not match the sender's FVD. So, use remaining FVDs to read data off wire.  If any remaining FVDs indicate custom marshaling, throw MARSHAL error. end : while(fvdsList.hasMoreElements()) the line. Use default marshaling/////////////////Invoke the readObject method if present.  Assumes that in the case of custommarshaling, the format version and defaultWriteObject indicator were alreadyReset the stream to be just like it was after the constructor. discard any pending callbacksFactored out of inputClassFields  This reads a primitive value and sets itin the field of o described by the ObjectStreamField field.Note that reflection cannot be used here, because reflection cannot be usedto set final fields.reflective code: field.getField().setByte( o, byteValue ) ;reflective code: field.getField().setBoolean( o, booleanValue ) ;reflective code: field.getField().setChar( o, charValue ) ;reflective code: field.getField().setShort( o, shortValue ) ;reflective code: field.getField().setInt( o, intValue ) ;reflective code: field.getField().setLong( o, longValue ) ;reflective code: field.getField().setFloat( o, floatValue ) ;reflective code: field.getField().setDouble( o, doubleValue ) ;This case should never happen. If the field typesare not the same, InvalidClassException is raised whenmatching the local class to the serialized ObjectStreamClass. Make sure type = null Decide what method call to make based on the type. If it is a type for which we need to load a stub, convert the type to the correct stub type. NOTE : Since FullValueDescription does not allow us to ask whether something is an interface we do not have the ability to optimize this check. RMI Object reference... REVISIT.  If we don't have the local class, we should probably verify that it's an RMI type, query the remote FVD, and use is_abstract. Our FVD seems to get NullPointerExceptions for any non-RMI types. This uses the local class in the same way as inputObjectField(ObjectStreamField) does.  REVISIT inputObjectField(ObjectStreamField)'s loadStubClass logic.  Assumption is that the given type cannot evolve to become a CORBA abstract interface or a RMI abstract interface. Now that we have used the FVD of the field to determine the proper course of action, it is ok to use the type (Class) from this point forward since the rep. id for this read will also follow on the wire.Factored out of inputClassFields and reused ininputCurrentClassFieldsForReadFields.Reads the field (which of an Object type as opposed to a primitive)described by ObjectStreamField field and returns it. fields have an API to provide the actual class corresponding to the data type Class type = osc.forClass(); This may change if stub loaded. Decide what method call to make based on the fieldType. If IDL Object reference... IDL Abstract Object reference... RMI Abstract Object reference... Must have this local variable since defaultReadObjectFVDMembers may get mangled by recursion. Backwards compatibility.  Older Sun ORBs sent _tk_char even though they read and wrote wchars correctly. Fall through to the _tk_wchar case.Called from InputStreamHook.Reads the fields of the current class (could be the onesqueried from the remote FVD) and puts them inthe given Map, name to value.  Wraps primitives in thecorresponding java.lang Objects. Handle the primitives firstRead and set object fields from the input stream.Read the fields of the specified class from the input stream and setthe values of the fields in the specified object. If the specifiedobject is null, just consume the fields without setting any values. Ifany ObjectStreamField does not have a reflected Field, don't try to setthat field in the object.REVISIT -- This code doesn't do what the comment says to whengetField() is null! check input field type is a declared field type input field is a subclass of the declared field reflective code: fields[i].getField().set( o, objectValue ) ; end : for loop REVISIT.  Convert to a log message. This is a normal case when fields have been added as part of evolution, but silently skipping can make it hard to debug if there's an error                                 System.out.println("**** warning, not setting field: "                                                    + fields[i].name                                                    + " since not on class "                                                    + osc.getName());Read the fields of the specified class from the input stream throw data away.This must handle same switch logic as above. Read value Decide what method call to make based on the type. Since we are throwing this away, don't bother handling recursion.This class maintains a map of stream position toan Object currently being deserialized.  It is usedto handle the cases where the are indirections toan object on the recursion stack.  The CDR levelhandles indirections to objects previously seen(and completely deserialized) in the stream. A hash map is unsynchronized and allows null values Called right after allocating a new object. Offset is the starting position in the stream of the object. If the given starting position doesn't refer to the beginning of an object currently being deserialized, this throws an IOException. Otherwise, it returns a reference to the Called when an object has been completely deserialized, so it should no longer be in this mapping.  The CDR level can handle further indirections. If the given offset doesn't map to an Object, then it isn't an indirection to an object currently being deserialized./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/io/IIOPOutputStream.javaoutputClassFieldsoutputClassFields(java.lang.Object,java.lang.Class,com.sun.corba.se.impl.io.ObjectStreamField[])/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/io/IIOPOutputStream.classwriteObjectFieldwriteObjectField(com.sun.corba.se.impl.io.ObjectStreamField,java.lang.Object)writeFieldwriteField(com.sun.corba.se.impl.io.ObjectStreamField,java.lang.Object)invokeObjectWriterinvokeObjectWriter(com.sun.corba.se.impl.io.ObjectStreamClass,java.lang.Object)outputObject(java.lang.Object)checkSubstitutableSpecialClassescheckSubstitutableSpecialClasses(java.lang.Object)checkSpecialClassescheckSpecialClasses(java.lang.Object)getFieldsNoCopygetFieldsNoCopy()setOrbStream(org.omg.CORBA_2_3.portable.OutputStream)writeObjectArgListclassDescStacksimpleWriteDepth/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/io/IIOPOutputStream$1.classvoutformatVersionpendingee"defaultWriteObjectDelegate"defaultWriteObjectDelegate"Method annotateClass not supported"Method annotateClass not supportedioexc"Method replaceObject not supported"Method replaceObject not supported"Illegal call to reset"Illegal call to reset"Serialization of ObjectStreamClass not supported"Serialization of ObjectStreamClass not supportedstackMark"invokeObjectWriter internal error"invokeObjectWriter internal error'[''L'L"Nonexistent field "Nonexistent field Copyright (c) 1998, 2013, Oracle and/or its affiliates. All rights reserved.IIOPOutputStream is ... Used when calling an object's writeObject method If using RMI-IIOP stream format version 2, this tells the ORB stream (which must be a ValueOutputStream) to begin a new valuetype to contain the optional data of the writeObject method.Override the actions of the final method "writeObject()"in ObjectOutputStream.throws IOException if (!checkSpecialClasses(obj) && !checkSubstitutableSpecialClasses(obj))Restore state of previous call incase this is a nested callIf the recursion depth is 0, test for and clear the pending exception.If there is a pending exception throw it. Required by the superclass.Override the actions of the final method "defaultWriteObject()" XXX I18N, Logging needed.Override the actions of the final method "enableReplaceObject()"Reset will disregard the state of any objects already writtento the stream.  The state is reset to be the same as a newObjectOutputStream.  The current point in the stream is markedas reset so the corresponding ObjectInputStream will be resetat the same point.  Objects previously written to the streamwill not be refered to as already being in the stream.  Theywill be written to the stream again.orbStream.reset(); INTERNAL UTILITY METHODSCheck for special cases of serializing objects.These objects are not subject to replacement.If this is a class, don't allow substitutionif (obj instanceof Class) {    throw new IOException("Serialization of Class not supported");Check for special cases of substitutable serializing objects.These classes are replaceable.if (obj.getClass().isArray()) {    outputArray(obj);    return true;Write out the objectGet the Class descriptor for this class,Throw a NotSerializableException if there is none.If the object is externalizable,call writeExternal.else do Serializable processing. Write format versionRemember the stack pointer where this set of classes is being pushed.For currentClassDesc and all the pushed class descriptorsIf the class is writing its own dataset blockData = true; call the class writeObject methodIf notinvoke either the defaultWriteObject method.Invoke writer._REVISIT_ invokeObjectWriter and invokeObjectReader behave inconsistently with each other sincethe reader returns a boolean...fix later writeObject(obj, c, this); cannot happen What to do if it's null?Write the fields of the specified class by invoking the appropriatewrite* method on this class./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/io/InputStreamHook.java/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/io/InputStreamHook.classHookGetFieldsHookGetFields(java.util.Map)/Library/Java/JavaVirtualMachines/jdk1.8.0_251.jdk/Contents/Home/jre/lib/rt.jar/com/sun/corba/se/impl/io/InputStreamHook$HookGetFields.classdefvaluefieldValueMaphasReadObject"No default data sent"No default data sent"Default data already read"Default data already readclientOrbVersion"Default data must be read first"Default data must be read first"Default data not sent or already read/passed"Default data not sent or already read/passedCopyright (c) 1999, 2013, Oracle and/or its affiliates. All rights reserved. These should be visible in all the nested classesGet the ObjectStreamClass that describes the fields in the stream.REVISIT!  This doesn't work since we have our own ObjectStreamClass.Return true if the named field is defaulted and has no valuein this stream.Get the value of the named boolean field from the persistent field.Get the value of the named char field from the persistent fields.Get the value of the named byte field from the persistent fields.Get the value of the named short field from the persistent fields.Get the value of the named int field from the persistent fields.Get the value of the named long field from the persistent fields.Get the value of the named float field from the persistent fields.Get the value of the named double field from the persistent field.Get the value of the named Object field from the persistent field. See java.io.ObjectInputStream.GetField Remember that this is equivalent to defaultReadObject in RMI-IIOP We were treating readFields same as defaultReadObject. It is incorrect if the state is readOptionalData. If this line is uncommented, it will throw a stream corrupted exception. _REVISIT_: The ideal fix would be to add a new state. In writeObject user may do one of the following 1. Call defaultWriteObject() 2. Put out optional fields 3. Call writeFields We have the state defined for (1) and (2) but not for (3), so we should ideally introduce a new state for 3 and have the beginDefaultReadObject do nothing.readObjectState.beginDefaultReadObject(this); The following is a State pattern implementation of what should be done when the sender's Serializable has a writeObject method.  This was especially necessary for RMI-IIOP stream format version 2.  Please see the state diagrams in the docs directory of the workspace. On the reader's side, the main factors are whether or not we have a readObject method and whether or not the sender wrote default data Description of possible actions This will happen for Big Integer which uses writeFields in it's writeObject. We should be past start_value by now. NOTE: If we don't log any exception here we should be fine. If there is an error, it will be caught while reading the optional data. XXX I18N and logging needed. REVISIT.  If a readObject exits here without reading default data, we won't skip it.  This could be done automatically as in line 1492 in IIOPInputStream. This should never happen. In stream format version 2, we can skip over the optional data this way.  In stream format version 1, we will probably wind up with an error if we're unmarshaling a superclass. Read the fake valuetype header in stream format version 2 Fix Date interop bug. For older versions of the ORB don't do anything for readData(). Before this used to throw StreamCorruptedException for older versions of the ORB where calledDefaultWriteObject always returns true. Code should read default fields before calling this/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/io/ObjectStreamClass.javapackageEqualspackageEquals(java.lang.Class,java.lang.Class)/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/io/ObjectStreamClass.classgetInheritableMethodgetInheritableMethod(java.lang.Class,java.lang.String,java.lang.Class[],java.lang.Class)compareMemberByNamecompareObjStrFieldsByNamecompareClassByNamehasStaticInitializerhasStaticInitializer(java.lang.Class)hasStaticInitializerMethodlocalClassDescrmiiiopOptionalDataRepIdProtectionDomain[]domainsconsreadResolveObjectMethodwriteReplaceObjectMethodreadObjectMethodwriteObjectMethodhasExternalizableBlockDatainitializedobjFieldsprimBytesactualSuidStractualSuidsuidStrsuidforProxyClassofClassexternalizableserializablesuperclassgetDeclaredFields(java.lang.Class)insertDescriptorForinsertDescriptorFor(com.sun.corba.se.impl.io.ObjectStreamClass)findDescriptorForfindDescriptorFor(java.lang.Class)ObjectStreamClassEntry[]descriptorForgetSignature(java.lang.reflect.Constructor)getSignature(java.lang.reflect.Method)getSignature(java.lang.Class)computeStructuralUIDcomputeStructuralUID(com.sun.corba.se.impl.io.ObjectStreamClass,java.lang.Class)_computeSerialVersionUID_computeSerialVersionUID(java.lang.Class)msg(java.lang.String)computeFieldInfocomputeFieldInfo()isNonSerializableisNonSerializable()isExternalizableisExternalizable()isSerializableisSerializable()localClassDescriptorlocalClassDescriptor()getSerializableConstructorgetSerializableConstructor(java.lang.Class)getExternalizableConstructorgetExternalizableConstructor(java.lang.Class)hasExternalizableBlockDataModehasExternalizableBlockDataMode()isCustomMarshaledisCustomMarshaled()hasWriteObjecthasWriteObject()hasReadObject()setSuperclasssetSuperclass(com.sun.corba.se.impl.io.ObjectStreamClass)typeEqualstypeEquals(com.sun.corba.se.impl.io.ObjectStreamClass)compareClassNamescompareClassNames(java.lang.String,java.lang.String,char)setClasssetClass(java.lang.Class)ObjectStreamClassObjectStreamClass(java.lang.String,long)computeRMIIIOPOptionalDataRepIdcomputeRMIIIOPOptionalDataRepId()getPrivateMethodgetPrivateMethod(java.lang.Class,java.lang.String,java.lang.Class[],java.lang.Class)init()getProtectionDomainsgetProtectionDomains(java.lang.reflect.Constructor,java.lang.Class)noPermissionsDomainnoPermissionsDomain()persistentFieldsValueObjectStreamClass(java.lang.Class,com.sun.corba.se.impl.io.ObjectStreamClass,boolean,boolean)lookupInternallookupInternal(java.lang.Class)lookup(java.lang.Class)noTypesListnoArgsListDEBUG_SVUID/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/io/ObjectStreamClass$1.classPrivilegedAction<Bridge>616120832682080437368L6120832682080437368descClass<Serializable>Map<String,Serializable>Serializable[]Constructor<Serializable>? super SerializableClass<? super Serializable>TypeVariable<Class<Serializable>>TypeVariable<Class<Serializable>>[]superdescClass<Externalizable>Map<String,Externalizable>Externalizable[]Constructor<Externalizable>? super ExternalizableClass<? super Externalizable>TypeVariable<Class<Externalizable>>TypeVariable<Class<Externalizable>>[]theoscdup": static final long serialVersionUID = ": static final long serialVersionUID = "L;"L;serialexterntranslateFieldstranslateFields(java.io.ObjectStreamField[])/Library/Java/JavaVirtualMachines/jdk1.8.0_251.jdk/Contents/Home/jre/lib/rt.jar/com/sun/corba/se/impl/io/ObjectStreamClass$PersistentFieldsValue.classPersistentFieldsValuePersistentFieldsValue()ClassValue<ObjectStreamField[]>/Users/jettt/IdeaProjects/jdk_test/target/classes/java/lang/ClassValue.classpf"serialPersistentFields"serialPersistentFieldsmodstranslationpermsfnsclTypeVariable<Constructor<?>>TypeVariable<Constructor<?>>[]Constructor<?>(java.lang.Class,java.lang.Class[],java.lang.Class[],int,int,java.lang.String,byte[],byte[])Set<ProtectionDomain>Collection<ProtectionDomain>Iterable<ProtectionDomain>pdspdHashSet<ProtectionDomain>/Users/jettt/IdeaProjects/jdk_test/target/classes/java/util/HashSet.classAbstractSet<ProtectionDomain>/Users/jettt/IdeaProjects/jdk_test/target/classes/java/util/AbstractSet.classAbstractCollection<ProtectionDomain>HashSet<ProtectionDomain>()Spliterator<ProtectionDomain>? super ProtectionDomainConsumer<? super ProtectionDomain>Iterator<ProtectionDomain>Stream<ProtectionDomain>BaseStream<ProtectionDomain,Stream<ProtectionDomain>>Predicate<? super ProtectionDomain>? extends ProtectionDomainCollection<? extends ProtectionDomain>Iterable<? extends ProtectionDomain>add(java.security.ProtectionDomain)AbstractCollection<ProtectionDomain>()AbstractSetAbstractSet()AbstractSet<ProtectionDomain>()HashSetHashSet(int,float,boolean)HashSet<ProtectionDomain>(int,float,boolean)HashSet(int)HashSet<ProtectionDomain>(int)HashSet(int,float)HashSet<ProtectionDomain>(int,float)HashSet(java.util.Collection)HashSet<ProtectionDomain>(java.util.Collection)HashSet()/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/io/ObjectStreamClass$2.classget(java.lang.Class)Version<>/Library/Java/JavaVirtualMachines/jdk1.8.0_251.jdk/Contents/Home/jre/lib/rt.jar/java/lang/Library/Java/JavaVirtualMachines/jdk1.8.0_251.jdk/Contents/Home/jre/lib/rt.jar/java/lang/ClassValue$Version.class/Library/Java/JavaVirtualMachines/jdk1.8.0_251.jdk/Contents/Home/jre/lib/rt.jar/java/lang/ClassValue$Entry.classEntry<T>Version<T>WeakReference<Version<T>>Reference<Version<T>>makeEntrymakeEntry(java.lang.ClassValue.Version,java.lang.Object)bumpVersionbumpVersion()version()Version<ObjectStreamField[]>identityHASH_MASKhashCodeForCacheEntry<?>Version<?>WeakReference<Version<?>>Reference<Version<?>>matchmatch(java.lang.ClassValue.Entry)castEntrycastEntry(java.lang.ClassValue.Entry)Entry<ObjectStreamField[]>WeakReference<Version<ObjectStreamField[]>>Reference<Version<ObjectStreamField[]>>put(java.lang.Class,java.lang.Object)put(java.lang.Class,com.sun.corba.se.impl.io.ObjectStreamField[])remove(java.lang.Class)computeValuecomputeValue(java.lang.Class)ClassValueClassValue()ClassValue<ObjectStreamField[]>()actualfieldsnumFieldstempFieldsreflField0L/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/io/ObjectStreamClass$3.class"serialVersionUID""writeReplace"writeReplace"readResolve"readResolve"writeObject"Class<ObjectOutputStream>"readObject"Class<ObjectInputStream>meth"RMI:org.omg.custom."RMI:org.omg.custom.':':destfieldsrcfield"Local class not compatible"Local class not compatibleaddedSerialOrExternarraySUID"Local class not compatible:" +
                                                " stream classdesc serialVersionUID="Local class not compatible: stream classdesc serialVersionUID=" local class serialVersionUID=" local class serialVersionUID="Incompatible local class name. " +
                         "Expected class name compatible with "Incompatible local class name. Expected class name compatible with "Serialization incompatible with Externalization"Serialization incompatible with Externalizationnextsrc"The type of field "The type of field " of class " of class " is incompatible." is incompatible.streamNamelocalNamepkgSeparatorstreamNameIndexlocalNameIndex"Unexpected call when not initialized"Unexpected call when not initializedjsaPrivilegedAction<?>pea/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/io/ObjectStreamClass$4.classcauseinitCldevnull512h"Computing SerialVersionUID for "Computing SerialVersionUID for md"SHA"SHAmdoclassaccessMethodSignature[]constructorsMember[]methodshasharray"\twriteUTF( \""	writeUTF( ""\" )"" )"\twriteInt( "	writeInt( " ) " ) interfaces"\" ) "" ) m"\twriteUTF( \"<clinit>\" ) "	writeUTF( "<clinit>" ) "<clinit>"" )" )"\twriteUTF( \"()V\" )"	writeUTF( "()V" )"()V"()Vmname"<init>"<init>'/'ignorecomplaindimensions"I""B""J""F""D""S""C""Z""V"V"L""("(")V")V0x7FFFFFFF2147483647prev/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/io/ObjectStreamClass$5.classclassWithThisMethodClass<ObjectStreamClass>"hasStaticInitializer"Class<Class<>>"Can't find hasStaticInitializer method on "Can't find hasStaticInitializer method on retval"Error invoking hasStaticInitializer"Error invoking hasStaticInitializer/Library/Java/JavaVirtualMachines/jdk1.8.0_251.jdk/Contents/Home/jre/lib/rt.jar/com/sun/corba/se/impl/io/ObjectStreamClass$ObjectStreamClassEntry.classObjectStreamClassEntryObjectStreamClassEntry(com.sun.corba.se.impl.io.ObjectStreamClass)CompareClassByNameCompareClassByName()/Library/Java/JavaVirtualMachines/jdk1.8.0_251.jdk/Contents/Home/jre/lib/rt.jar/com/sun/corba/se/impl/io/ObjectStreamClass$CompareClassByName.classo1o2c1c2CompareObjStrFieldsByNameCompareObjStrFieldsByName()/Library/Java/JavaVirtualMachines/jdk1.8.0_251.jdk/Contents/Home/jre/lib/rt.jar/com/sun/corba/se/impl/io/ObjectStreamClass$CompareObjStrFieldsByName.classosf1osf2CompareMemberByNameCompareMemberByName()/Library/Java/JavaVirtualMachines/jdk1.8.0_251.jdk/Contents/Home/jre/lib/rt.jar/com/sun/corba/se/impl/io/ObjectStreamClass$CompareMemberByName.classs1s2MethodSignatureMethodSignature(java.lang.reflect.Member)/Library/Java/JavaVirtualMachines/jdk1.8.0_251.jdk/Contents/Home/jre/lib/rt.jar/com/sun/corba/se/impl/io/ObjectStreamClass$MethodSignature.classisConstructorisConstructor()removePrivateAndSortremovePrivateAndSort(java.lang.reflect.Member[])membernumNonPrivatecmcmidefClcl1cl2pkg1pkg2Copyright (c) 1998, 2014, Oracle and/or its affiliates. All rights reserved.Copyright IBM Corp. 1998 2012  All Rights ReservedA ObjectStreamClass describes a class that can be serialized to a streamor a class that was serialized to a stream.  It contains the nameand the serialVersionUID of the class.<br>The ObjectStreamClass for a specific class loaded in this Java VM canbe found using the lookup method.Roger Riggstrue if represents enum typeFind the descriptor for a class that can be serialized.  Nullis returned if the specified class does not implementjava.io.Serializable or java.io.Externalizable.Find the class descriptor for the specified class.Package access only so it can be called from ObjectIn/OutStream.Synchronize on the hashtable so no two threads will dothis at the same time.Find the matching descriptor if it already knownCheck if it's serializableIf the class is only Serializable,lookup the descriptor for the superclass.Check if its' externalizable.If it's Externalizable, clear the serializable flag.Only one or the other may be set in the protocol.Create a new version descriptor,it put itself in the known table. Must always call init.  See bug 4488137.  This code was incorrectly changed to return immediately on a non-null cache result.  That allowed threads to gain access to unintialized instances. History: Note, the following init() call was originally within the synchronization block, as it currently is now. Later, the init() call was moved outside the synchronization block, and the init() method used a private member variable lock, to avoid performance problems. See bug 4165204. But that lead to a deadlock situation, see bug 5104239. Hence, the init() method has now been moved back into the synchronization block. The right approach to solving these problems would be to rewrite this class, based on the latest java.io.ObjectStreamClass.The name of the class described by this descriptor.Return the serialVersionUID for this class.The serialVersionUID defines a set of classes all with the same namethat have evolved from a common root class and agree to be serializedand deserialized using a common format.Return the serialVersionUID string for this class.Return the actual (computed) serialVersionUID for this class.Return the class in the local VM that this version is mapped to.Null is returned if there is no corresponding local class.Return an array of the fields of this serializable class.an array containing an element for each persistentfield of this class. Returns an array of length zero ifthere are no fields. Return a copy so the caller can't change the fields. Ignore this; all we want to do is return false Note that ValueUtility.getSignature can throw checked exceptions.Avoid unnecessary allocations.Get the field of this class by name.The ObjectStreamField object of the named field or null if thereis no such named field.Binary search of fields by name.Return a string describing this ObjectStreamClass.Create a new ObjectStreamClass from a loaded class.Don't call this directly, call lookup instead.created from this class proxy classes are never externalizableEnter this class in the table of known descriptors.Otherwise, when the fields are read it may recursetrying to find the descriptor for itself.The remainder of initialization occurs in init(), which is calledafter the lock on the global class descriptor table has beenreleased.Creates a PermissionDomain that grants no permission.Aggregate the ProtectionDomains of all the classes that separatea concrete class {@code cl} from its ancestor's class declaringa constructor {@code cons}.If {@code cl} is defined by the boot loader, or the constructor{@code cons} is declared by {@code cl}, or if there is no securitymanager, then this method does nothing and {@code null} is returned.A constructor declared by {@code cl} or one of itsancestors.A concrete class, which is either the class declaringthe constructor {@code cons}, or a serializable subclassof that class.An array of ProtectionDomain representing the set ofProtectionDomain that separate the concrete class {@code cl}from its ancestor's declaring {@code cons}, or {@code null}. that's not supposed to happen make a ProtectionDomain with no permission. should we throw instead?Initialize class descriptor.  This method is only invoked on classdescriptors created via calls to lookupInternal().  This method is keptseparate from the ObjectStreamClass constructor so that lookupInternaldoes not have to hold onto a global class descriptor table lock while theclass descriptor is being initialized (see bug 4165204). See description at definition of initialized.Ask for permission to override field access checks.Fill in the list of persistent fields.If it is declared, use the declared serialPersistentFields.Otherwise, extract the fields from the class itself.Get all of the declared fields for thisClass. setAccessible on all fields so theycan be accessed later.  Create a temporaryObjectStreamField array to hold eachnon-static, non-transient field. Then copy thetemporary array into an array of the correctsize once the number of fields is known. For each declared persistent field, look for an actual reflected Field. If there is one, make sure it's the correct type and cache it in the ObjectStreamClass for that field. Nothing to doSet up field data for use while writing using the API api.Get the serialVersionUID from the class.It uses the access override mechanism so make surethe field objects is only used here.NonSerializable classes have a serialVerisonUID of 0L. Lookup special Serializable members using reflection. proxy classes always have serialVersionUID of 0L SerialBug 5:  static final SUID should be read SerialBug 2: should be computed after writeObject actualSuid = computeStructuralUID(cl);Look for the writeObject methodSet the accessible flag on it here. ObjectOutputStreamwill call it as necessary. This call depends on a lot of information computed above! If we have a write object method, precompute the RMI-IIOP stream format version 2 optional data repository ID. This must be done last.Returns non-static private method with given signature defined by givenclass, or null if none found.  Access checks are disabled on thereturned method (if any). Specific to RMI-IIOPJava to IDL ptc-02-01-12 1.5.1"The rep_id string passed to the start_value method must be'RMI:org.omg.custom.class:hashcode:suid' where class is thefully-qualified name of the class whose writeObject methodis being invoked and hashcode and suid are the class's hashcodeand SUID."This will return null if there is no writeObject method.Create an empty ObjectStreamClass for a class about to be read.This is separate from read so ObjectInputStream can assign thewire handle early, before any nested ObjectStreamClass mightbe read.Set the class this version descriptor matches.The base class name and serializable hash must match.Fill in the reflected Fields that will be usedfor reading. XXX I18N, logging neededCheck for exceptional cases that allow mismatched suid.Allow adding Serializable or Externalizableto a later release of the class.Disregard the serialVersionUID of an arraywhen name and cl.Name differ. If resolveClass() returnsan array with a different package name,the serialVersionUIDs will not match since the fullyqualified array class is used in thecomputation of the array's serialVersionUID. There isno way to set a permanent serialVersionUID for an array type.compare the class names, stripping off package names.Test that both implement either serializable or externalizable. The next check is more generic, since it covers the Proxy case, the JDK 1.3 serialization code has both checksif ((serializable && localClassDesc.externalizable) ||    (externalizable && localClassDesc.serializable))    throw new InvalidClassException(localCl.getName(),            "Serializable is incompatible with Externalizable");Set up the reflected Fields in the class where the value of eachfield in this descriptor should be stored.Each field in this ObjectStreamClass (the source) is located (byname) in the ObjectStreamClass of the class(the destination).In the usual (non-versioned case) the field is in bothdescriptors and the types match, so the reflected Field is copied.If the type does not match, a InvalidClass exception is thrown.If the field is not present in the class, the reflected Fieldremains null so the field will be read but discarded.If extra fields are present in the class they are ignored. Theirvalues will be set to the default value by the object allocator.Both the src and dest field list are sorted by type and name.Find this field in the destfound matchSkip over any fields in the dest that are not in the src go on to the next source fieldSet up field data for use while reading from the input stream.Remember the class this representsget the cache of these methods from the local classimplementation.Compare the base class names of streamName and localName.@return  Return true iff the base class name compare.@parameter streamName    Fully qualified class name.@parameter localName     Fully qualified class name.@parameter pkgSeparator  class names use either '.' or '/'.Only compare base class name to allow package renaming.Compare the types of two class descriptors.They match if they have the same class name and suidReturn the superclass descriptor of this descriptor.Return whether the class has a readObject methodReturn whether the class has a writeObject methodReturns when or not this class should be custommarshaled (use chunking).  This should happen ifit is Externalizable OR if it orany of its superclasses has a writeObject method,Return true if all instances of 'this' Externalizable classare written in block-data mode from the stream that 'this' was readfrom. <p>In JDK 1.1, all Externalizable instances are not writtenin block-data mode.In JDK 1.2, all Externalizable instances, by default, are writtenin block-data mode and the Externalizable instance is terminated withtag TC_ENDBLOCKDATA. Change enabled the ability to skip Externalizableinstances.IMPLEMENTATION NOTE:This should have been a mode maintained per stream; however,for compatibility reasons, it was only possible to recordthis change per class. All Externalizable classes withina given stream should either have this mode enabled ordisabled. This is enforced by not allowing the PROTOCOL_VERSIONof a stream to he changed after any objects have been written.@see ObjectOutputStream#useProtocolVersion@see ObjectStreamConstants#PROTOCOL_VERSION_1@see ObjectStreamConstants#PROTOCOL_VERSION_2@since JDK 1.2Creates a new instance of the represented class.  If the class isexternalizable, invokes its public no-arg constructor; otherwise, if theclass is serializable, invokes the no-arg constructor of the firstnon-serializable superclass.  Throws UnsupportedOperationException ifthis class descriptor is not associated with a class, if the associatedclass is non-serializable or if the appropriate no-arg constructor isinaccessible/unavailable. Can't use PrivilegedExceptionAction with jsa not supposed to happen should not occur, as access checks have been suppressedReturns public no-arg constructor of given class, or null if none found.Access checks are disabled on the returned constructor (if any), sincethe defining class may still be non-public.Returns subclass-accessible no-arg constructor of first non-serializablesuperclass, or null if none found.  Access checks are disabled on thereturned constructor (if any).Return the ObjectStreamClass of the local class this one is based on.Get the Serializability of the class.Get the externalizability of the class.Calculate the size of the array needed to store primitive data and thenumber of object references to read when reading from the inputstream.JDK 1.5 has introduced some new modifier bits (such as SYNTHETIC)that can affect the SVUID computation (see bug 4897937).  These bitsmust be ignored, as otherwise interoperability with ORBs in earlierJDK versions can be compromised.  I am adding these masks for thispurpose as discussed in the CCC for this bug (see http://ccc.sfbay/4897937).Compute a hash for the specified class.  Incrementally additems to the hash accumulating in the digest stream.Fold the hash into a long.  Use the SHA secure hash function.Workaround for javac bug that only set ABSTRACT forinterfaces if the interface had some methods.The ABSTRACT bit reflects that the number of methods > 0.This is required so correct hashes can be computedfor existing class files.Previously this hack was previously present in the VM. Mask out any post-1.4 attributesGet the list of interfaces supported,Accumulate their names their names in Lexical orderand add them to the hashIn 1.2fcs, getInterfaces() was modified to return{java.lang.Cloneable, java.io.Serializable} whencalled on array classes.  These values would upsetthe computation of the hash, so we explicitly omitthem from its computation.Sort the field names to get a deterministic orderInclude in the hash all fields except those that areprivate transient and private static. Mask out any post-1.4 bits TBD: what modifiers does it haveGet the list of constructors including name and signatureSort lexically, add all except the private constructorsto the hash with their access flags mask out post-1.4 modifiersInclude in the hash all methods except those that areCompute the hash value for this class.Use only the first 64 bits of the hash.can't happen, but be deterministic anyway. Get SUID of parent SerialBug 1; acc. to spec the one for java.lang.object should be computed and put     && (parent != java.lang.Object.class))data.writeLong(computeSerialVersionUID(null,parent)); CORBA formal 00-11-03 10.6.2:  For each field of the class that is mapped to IDL, sorted lexicographically by Java field name, in increasing order... ...Java field name in UTF encoding, field descriptor, as defined by the JVM spec... int minimum = Math.min(8, hasharray.length); SerialBug 3: SHA computation is wrong; for loop reversedfor (int i = minimum; i > 0; i--)Compute the JVM signature for the class.Compute the JVM method descriptor for the method. avoid cloneCompute the JVM constructor descriptor for the constructor.Cache of Class -> ClassDescriptor Mappings.findDescriptorFor a Class.  This looks in the cache for amapping from Class -> ObjectStreamClass mappings.  The hashCodeof the Class is used for the lookup since the Class is the key.The entries are extended from java.lang.ref.SoftReference so thegc will be able to free them if needed.Free any initial entries whose refs have been clearedTraverse the chain looking for a descriptor with ofClass == cl.unlink entries that are unresolved. This entry has been cleared,  unlink itinsertDescriptorFor a Class -> ObjectStreamClass mapping. Make sure not already presentThe name of this descriptorThe descriptor of the supertype.Flags for Serializable and Externalizable.Array of persistent fields of this class, sorted bytype and name.Class that is a descriptor for in this virtual machine.True if descriptor for a proxy class.SerialVersionUID for this class.Actual (computed) SerialVersionUID for this class.The total number of bytes of primitive fields.The total number of object fields.Flag indicating whether or not this instance hassuccessfully completed initialization.  This is totry to fix bug 4373844.  Working to move toreusing java.io.ObjectStreamClass for JDK 1.5.Internal lock object.In JDK 1.1, external data was not written in block mode.As of JDK 1.2, external data is written in block data mode. Thisflag enables JDK 1.2 to be able to read JDK 1.1 written external data.Beginning in Java to IDL ptc/02-01-12, RMI-IIOP has astream format version 2 which puts a fake valuetype arounda Serializable's optional custom data.  This valuetype hasa special repository ID made from the Serializable'sinformation which we are pre-computing andstoring here.ObjectStreamClass that this one was built from.Find out if the class has a static class initializer <clinit>Returns true if the given class defines a static initializer method,false otherwise.use serialVersionUID from JDK 1.1. for interoperabilitySet serialPersistentFields of a Serializable class to this value todenote that the class has no Serializable fields.Entries held in the Cache of known ObjectStreamClass objects.Entries are chained together with the same hash value (modulo array size). extends java.lang.ref.SoftReferencesuper(c);Comparator object for Classes and InterfacesComparator for ObjectStreamFields by nameComparator object for Members, Fields, and MethodsIt is expensive to recompute a method or constructor signaturemany times, so compute it only once using this data structure. cached parameter signatureGiven an array of Method or Constructor members,return a sorted array of the non-private members.A better implementation would be to implement the returned datastructure as an insertion sorted link list.Assumes that o1 and o2 are either both methodsor both constructors.Arrays.sort calls compare when o1 and o2 are equal. is a Method.Returns non-static, non-abstract method with given signature provided itis defined by or accessible (via inheritance) by the given class, ornull if no match found.  Access checks are disabled on the returnedmethod (if any).Copied from the Merlin java.io.ObjectStreamClass.Returns true if classes are defined in the same package, falseotherwise./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/io/ObjectStreamClassCorbaExt.javagetDeclaredMethods(java.lang.Class)/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/io/ObjectStreamClassCorbaExt.classisAnyisAny(java.lang.String)isAbstractInterfaceisAbstractInterface(java.lang.Class)ObjectStreamClassCorbaExtObjectStreamClassCorbaExt()exceptionMatchClass<RemoteException>Class<Throwable>Class<Exception>Class<IOException>typeString/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/io/ObjectStreamClassCorbaExt$1.class This file contains some utility methods that originally were in the OSC in the RMI-IIOP code delivered by IBM.  They don't make sense there, and hence have been put here so that they can be factored out in an attempt to eliminate redundant code from ObjectStreamClass.  Eventually the goal is to move to java.io.ObjectStreamClass, and java.io.ObjectStreamField. class is package private for security reasonsReturn true, iff,1. 'cl' is an interface, and2. 'cl' and all its ancestors do not implement java.rmi.Remote, and3. if 'cl' has no methods (including those of its ancestors), or,if all the methods (including those of its ancestors) throw anexception that is atleast java.rmi.RemoteException or one ofjava.rmi.RemoteException's super classes. #1 #2Returns TRUE if type is 'any'./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/io/ObjectStreamField.javafieldID/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/io/ObjectStreamField.classObjectStreamFieldObjectStreamField()setFieldsetField(java.lang.reflect.Field)getField()ObjectStreamField(java.lang.String,char,java.lang.reflect.Field,java.lang.String)ObjectStreamField(java.lang.reflect.Field)ObjectStreamField(java.lang.String,java.lang.Class)/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/io/ObjectStreamField$1.classtsf2thisprimotherprimA description of a field in a serializable class.A array of these is used to declare the persistent fields ofa class.Create a named field with the specified type. Compute the typecode for easy switchingCreate an ObjectStreamField containing a reflected Field.Get the name of this field.Get the type of the field.Default constructor creates an empty field.Usually used just to get to the sort functions.test if this field is a primitive or not.Compare this with another ObjectStreamField.return -1 if this is smaller, 0 if equal, 1 if greatertypes that are primitives are "smaller" than objects.if equal, the names are compared.The match if they have the same primitive types.or if they are both objects and the object types match.Return true if the primitive types matchedReturns the signature of the Field.Return a string describing this field.Returns the Field ID the name of the field type first byte of the type signature Reflected field iff object, typename the type of this field, if has been resolved the next 2 things are RMI-IIOP specific, it can be easily removed, if we can figure out all place where there are dependencies to this.  Signature is esentially equal to typestring. Then essentially we can use the java.io.ObjectStreamField as such. the signature of the field/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/io/OptionalDataException.javaOptionalDataException(boolean)/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/io/OptionalDataException.classOptionalDataException(int)endCopyright (c) 1998, 2002, Oracle and/or its affiliates. All rights reserved.Unexpected data appeared in an ObjectInputStream trying to readan Object.This exception occurs when the stream contains primitive datainstead of the object expected by readObject.The eof flag in the exception is true to indicate that no moreprimitive data is available.The count field contains the number of bytes available to read.unascribedCreate an <code>OptionalDataException</code> with a length.Create an <code>OptionalDataException</code> signifing nomore primitive data is available.The number of bytes of primitive data available to be readin the current buffer.True if there is no more data in the buffered part of the stream./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/io/OutputStreamHook.java/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/io/OutputStreamHook.classputFields/Library/Java/JavaVirtualMachines/jdk1.8.0_251.jdk/Contents/Home/jre/lib/rt.jar/com/sun/corba/se/impl/io/OutputStreamHook$HookPutFields.classHookPutFieldsHookPutFields()HashMap<String,Object>AbstractMap<String,Object>HashMap<String,Object>()merge(java.lang.String,java.lang.Object,java.util.function.BiFunction)? super StringBiFunction<? super String,? super Object,? extends Object>compute(java.lang.String,java.util.function.BiFunction)computeIfPresent(java.lang.String,java.util.function.BiFunction)Function<? super String,? extends Object>computeIfAbsent(java.lang.String,java.util.function.Function)replace(java.lang.String,java.lang.Object)replace(java.lang.String,java.lang.Object,java.lang.Object)putIfAbsent(java.lang.String,java.lang.Object)BiConsumer<? super String,? super Object>Entry<String,Object>Set<Entry<String,Object>>Collection<Entry<String,Object>>Iterable<Entry<String,Object>>Set<String>Collection<String>Iterable<String>? extends StringMap<? extends String,? extends Object>put(java.lang.String,java.lang.Object)AbstractMap<String,Object>()Node<String,Object>TreeNode<String,Object>newTreeNode(int,java.lang.String,java.lang.Object,java.util.HashMap.Node)newNode(int,java.lang.String,java.lang.Object,java.util.HashMap.Node)Node<String,Object>[]putVal(int,java.lang.String,java.lang.Object,boolean,boolean)HashMap<String,Object>(java.util.Map)HashMap<String,Object>(int)HashMap<String,Object>(int,float)hookosfields"no current PutField object"no current PutField object"Internal state failure: Entered writeObject twice"Internal state failure: Entered writeObject twice"Called defaultWriteObject/writeFields twice"Called defaultWriteObject/writeFields twice"Cannot call defaultWriteObject/writeFields after writing custom data in RMI-IIOP"Cannot call defaultWriteObject/writeFields after writing custom data in RMI-IIOPCopyright (c) 1999, 2015, Oracle and/or its affiliates. All rights reserved.Since ObjectOutputStream.PutField methods specify no exceptions,we are not checking for null parameters on put methods.Put the value of the named boolean field into the persistent field.Put the value of the named char field into the persistent fields.Put the value of the named byte field into the persistent fields.Put the value of the named short field into the persistent fields.Put the value of the named int field into the persistent fields.Put the value of the named long field into the persistent fields.Put the value of the named float field into the persistent fields.Put the value of the named double field into the persistent field.Put the value of the named Object field into the persistent field.Write the data and fields to the specified ObjectOutput stream. Write the fields to the stream in the order provided by the ObjectStreamClass.  (They should be sorted appropriately already.) Stream format version, saved/restored during recursive calls to serialize an object User uses PutFields to simulate default data. See java.io.ObjectOutputStream.PutFields should be done when a Serializable has a We didn't write any data, so write the called defaultWriteObject indicator as false If we're in stream format verison 2, we must put the "null" marker to say that there isn't any optional data The writeObject method called defaultWriteObject or writeFields, so put the called defaultWriteObject indicator as true The writeObject method first called a direct write operation.  Write the called defaultWriteObject indicator as false, put the special stream format version 2 header (if stream format version 2, of course), and write the data We only wrote default data, so if in stream format version 2, put the null indicator to say that there is no optional data The writeObject method called a direct write operation. If in stream format version 2, put the fake valuetype header. In stream format version 2, we must tell the ORB stream to close the fake custom valuetype. We don't have to do anything special here, just let the stream write the data./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/io/TypeMismatchException.javamssg/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/io/ValueHandlerImpl.javagetJavaCharTCKindgetJavaCharTCKind()/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/io/ValueHandlerImpl.classcreateCustomcreateCustom(java.lang.Class,java.lang.String)createInputStreamBuiltInNoPrivcreateInputStreamBuiltInNoPriv(java.lang.String)createInputStreamBuiltIncreateInputStreamBuiltIn(java.lang.String)createInputStreamcreateInputStream()getInputStreamClassNamegetInputStreamClassName()createOutputStreamBuiltInNoPrivcreateOutputStreamBuiltInNoPriv(java.lang.String)createOutputStreamBuiltIncreateOutputStreamBuiltIn(java.lang.String)createOutputStreamcreateOutputStream()getOutputStreamClassNamegetOutputStreamClassName()isArray(java.lang.String)read_Arrayread_Array(com.sun.corba.se.impl.io.IIOPInputStream,org.omg.CORBA_2_3.portable.InputStream,java.lang.Class,com.sun.org.omg.SendingContext.CodeBase,int)readCharArrayreadCharArray(org.omg.CORBA_2_3.portable.InputStream,char[],int,int)write_Arraywrite_Array(org.omg.CORBA_2_3.portable.OutputStream,java.io.Serializable,java.lang.Class)writeCharArraywriteCharArray(org.omg.CORBA_2_3.portable.OutputStream,char[],int,int)readValueInternalreadValueInternal(com.sun.corba.se.impl.io.IIOPInputStream,org.omg.CORBA_2_3.portable.InputStream,int,java.lang.Class,java.lang.String,com.sun.org.omg.SendingContext.CodeBase)writeValueInternalwriteValueInternal(com.sun.corba.se.impl.io.IIOPOutputStream,org.omg.CORBA_2_3.portable.OutputStream,java.io.Serializable,byte)writeValueWithVersionwriteValueWithVersion(org.omg.CORBA.portable.OutputStream,java.io.Serializable,byte)getInstancegetInstance(boolean)getInstance()ValueHandlerImplValueHandlerImpl(boolean)ValueHandlerImpl()inputStreamBridgeoutputStreamBridgeisInputStreamuseHashtablesoutputStreamPairsinputStreamPairsgetMaxStreamFormatVersiongetMaxStreamFormatVersion()MAX_STREAM_FORMAT_VERSIONSTREAM_FORMAT_VERSION_1MAX_SUPPORTED_FORMAT_VERSION"com.sun.CORBA.MaxStreamFormatVersion"com.sun.CORBA.MaxStreamFormatVersion/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/io/ValueHandlerImpl$1.class"Invalid stream format version: "Invalid stream format version: ".  Valid range is 1 through ".  Valid range is 1 through _outjdkToOrbOutputStreamBridge_in_senderjdkToOrbInputStreamBridgefvdImpl"Invalid primitive type : "Invalid primitive type : Map<String,? extends Serializable>? extends Serializable[]Constructor<? extends Serializable>? super ? extends SerializableClass<? super ? extends Serializable>TypeVariable<Class<? extends Serializable>>TypeVariable<Class<? extends Serializable>>[]componentType"Invalid primitive componentType : "Invalid primitive componentType : "com.sun.corba.se.impl.io.IIOPOutputStream"com.sun.corba.se.impl.io.IIOPOutputStreamClass<IIOPOutputStream>"Error loading "Error loading /Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/io/ValueHandlerImpl$2.classPrivilegedExceptionAction<IIOPOutputStream>Map<String,IIOPOutputStream>IIOPOutputStream[]Constructor<IIOPOutputStream>? super IIOPOutputStreamClass<? super IIOPOutputStream>TypeVariable<Class<IIOPOutputStream>>TypeVariable<Class<IIOPOutputStream>>[]"com.sun.corba.se.impl.io.IIOPInputStream"com.sun.corba.se.impl.io.IIOPInputStreamClass<IIOPInputStream>/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/io/ValueHandlerImpl$3.classPrivilegedExceptionAction<IIOPInputStream>Map<String,IIOPInputStream>IIOPInputStream[]Constructor<IIOPInputStream>? super IIOPInputStreamClass<? super IIOPInputStream>TypeVariable<Class<IIOPInputStream>>TypeVariable<Class<IIOPInputStream>>[]? extends TClass<? extends T>streamClassMap<String,? extends T>Constructor<? extends T>TypeVariable<Class<? extends T>>TypeVariable<Class<? extends T>>[]Copyright (c) 1998, 2012, Oracle and/or its affiliates. All rights reserved. Property to override our maximum stream format version The ValueHandler's maximum stream format version to advertise, set in a static initializer. Looks for the FORMAT_VERSION_PROPERTY system property to allow the user to override our default stream format version.  Note that this still only allows them to pick a supported version (1 through MAX_STREAM_FORMAT_VERSION). The property wasn't set REVISIT.  Just set to MAX_SUPPORTED_FORMAT_VERSION or really let the system shutdown with this Error? REVISIT.  Swallow this or really let the system shutdown with this Error? See javax.rmi.CORBA.ValueHandlerMultiFormatWrites the value to the stream using java semantics.The stream to write the value toThe value to be written to the streamReads a value from the stream using java semantics.The stream to read the value fromThe type of the value to be read inThe sending context runtime Must use narrow rather than a direct cast to a com.sun class.  Fix for bug 4379539. backward compatability 4365188 Indirections are resolved immediately since the change to the active recursion manager, so this will never happen. clazz == null indicates an FVD situation for a nonexistant classReturns the repository ID for the given RMI value Class.The class to return a repository ID for.the repository ID of the Class.Indicates whether the given Class performs custom ordefault marshaling.The class to test for custom marshaling.True if the class performs custom marshaling, falseif it does not.Returns the CodeBase for this ValueHandler.  This is used bythe ORB runtime.  The server sends the service context containingthe IOR for this CodeBase on the first GIOP reply.  The clientsdo the same on the first GIOP request.the SendingContext.CodeBase of this ValueHandler. set the valueHandler so that correct/incorrect RepositoryID calculations can be done based on the ORB version methods supported for backward compatability so that the appropriate Rep-id calculations take place based on the ORB versionReturns a boolean of whether or not RepositoryId indicatesFullValueDescriptor.used for backward compatabilityIf the value contains a writeReplace method then the resultis returned.  Otherwise, the value itself is returned.the true value to marshal on the wire. Read length of coming array The CDR stream had never seen the given offset before, so check the recursion manager (it will throw an IOException if it doesn't have a reference, either). Translate to a MARSHAL exception since ValueHandlers aren't allowed to throw IOExceptions Decide what method call to make based on the componentType. If it is a componentType for which we need to load a stub, convert the componentType to the correct stub type. String className = componentType.getName(); for better performance, load the stub class once instead of for each element of the array componentType = null; Throw exception under the carpet.Construct a built in implementation with priveleges.Returning null indicates a non-built is specified.Create a custom implementation without privileges. Note: We use the thread context or system ClassLoader here since we want to load classes outside of the core JDK when running J2EE Pure ORB and talking to Kestrel. Since the ClassLoader should cache the class, this isn't as expensive as it looks./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/io/ValueUtility.javaorg.omg.CORBA.TypeCodePackagecreateTypeCodeInternalcreateTypeCodeInternal(org.omg.CORBA.ORB,java.lang.Class,javax.rmi.CORBA.ValueHandler,java.lang.String,com.sun.corba.se.impl.io.ValueUtility.IdentityKeyValueStack)/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/io/ValueUtility.classcreateTypeCodeForClassInternalcreateTypeCodeForClassInternal(org.omg.CORBA.ORB,java.lang.Class,javax.rmi.CORBA.ValueHandler,com.sun.corba.se.impl.io.ValueUtility.IdentityKeyValueStack)existsexists(java.lang.String,java.lang.String[])translateMemberstranslateMembers(org.omg.CORBA.ORB,com.sun.corba.se.impl.io.ObjectStreamClass,javax.rmi.CORBA.ValueHandler,com.sun.corba.se.impl.io.ValueUtility.IdentityKeyValueStack)primitiveConstants/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/io/ValueUtility$1.classloadClassloadClass(java.lang.String)newValueHandlerImplnewValueHandlerImpl()createdIDsabstractCountsuperClassOperationDescription[]AttributeDescription[]Initializer[]interfaceIndexfieldsLengthvalRepId"1.0"1.0strsclzRepositoryId/Library/Java/JavaVirtualMachines/jdk1.8.0_251.jdk/Contents/Home/jre/lib/rt.jar/com/sun/corba/se/impl/io/ValueUtility$IdentityKeyValueStack.classpush(java.lang.Object,java.lang.Object)pairsIdentityKeyValueStackIdentityKeyValueStack()equals(com.sun.corba.se.impl.io.ValueUtility.IdentityKeyValueStack.KeyValuePair)/Library/Java/JavaVirtualMachines/jdk1.8.0_251.jdk/Contents/Home/jre/lib/rt.jar/com/sun/corba/se/impl/io/ValueUtility$IdentityKeyValueStack$KeyValuePair.classKeyValuePairKeyValuePair(java.lang.Object,java.lang.Object)pairbase"Value"ValueHolds utility methods for converting from ObjectStreamClass toFullValueDescription and generating typecodes from ObjectStreamClass. tk_null         0 tk_void         1 tk_short        2 tk_long         3 tk_ushort       4 tk_ulong        5 tk_float        6 tk_double       7 tk_boolean      8 tk_char         9 tk_octet        10 tk_any          11 tk_typecode     12 tk_principal    13 tk_objref       14 tk_struct       15 tk_union        16 tk_enum         17 tk_string       18 tk_sequence     19 tk_array        20 tk_alias        21 tk_except       22 tk_longlong     23 tk_ulonglong    24 tk_longdouble   25 tk_wchar        26 tk_wstring      27 tk_fixed        28 tk_value        29 tk_value_box    30 tk_native       31 tk_abstract_interface 32 REVISIT.  Can the type be something that is non-primitive yet not a value_box, value, or objref? If so, should use ObjectStreamClass or throw exception. Create FullValueDescription Set FVD name Set FVD id _REVISIT_ : Manglings Set FVD is_abstract Set FVD is_custom Set FVD defined_in _REVISIT_ : Manglings Set FVD version Skip FVD operations - N/A Skip FVD attributed - N/A Set FVD members Maps classes to repositoryIDs strings. This is used to detect recursive types. Stores all types created for resolving indirect types at the end. Skip FVD initializers - N/A Skip FVD supported_interfaces Skip FVD abstract_base_values - N/A Set FVD base_value Set FVD typeresult.type = createTypeCodeForClass(orb, osc.forClass());11638 Note : fields come out of ObjectStreamClass in correct order for writing.  So, we will create the same order in the members array. _REVISIT_ : Manglings _REVISIT_ : IDLType implementation missing When using serialPersistentFields, the class may no longer have an actual Field that corresponds to one of the items.  The Java to IDL spec ptc-00-01-06 1.3.5.6 says that the IDL field should be private in this case. 11638 case '[':      members[i].type = orb.get_primitive_tc(TCKind.tk_value_box); //11638      members[i].id = RepositoryId.createForAnyType(fields[i].getType());      break; end switch end for loop This wrapper method is the protection against infinite recursion. cache the rep id BEFORE creating a new typecode. so that recursive tc can look up the rep id. Maintains a stack of key-value pairs. Compares elements using == operator. type modifier REVISIT truncatable and abstract? concrete base members/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/ior/ByteBuffer.java/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/iorcom.sun.corba.se.impl.iordoAppenddoAppend(int)/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/ior/ByteBuffer.class/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/iorensureCapacityHelperensureCapacityHelper(int)initialCapacity"Illegal Capacity: "Illegal Capacity: 200oldCapacityoldDataminCapacitynewCapacityCopyright (c) 2001, 2002, Oracle and/or its affiliates. All rights reserved.The array buffer into which the components of the ByteBuffer arestored. The capacity of the ByteBuffer is the length of this array buffer,and is at least large enough to contain all the ByteBuffer's elements.<p>Any array elements following the last element in the ByteBuffer are 0.The number of valid components in this <tt>ByteBuffer</tt> object.Components <tt>elementData[0]</tt> through<tt>elementData[elementCount-1]</tt> are the actual items.@serialThe amount by which the capacity of the ByteBuffer is automaticallyincremented when its size becomes greater than its capacity.  Ifthe capacity increment is less than or equal to zero, the capacityof the ByteBuffer is doubled each time it needs to grow.Constructs an empty ByteBuffer with the specified initial capacity andcapacity increment.the initial capacity of the ByteBuffer.the amount by which the capacity isincreased when the ByteBuffer overflows.IllegalArgumentExceptionif the specified initial capacityis negativewith its capacity increment equal to zero.Constructs an empty ByteBuffer so that its internal data arrayhas size <tt>10</tt> and its standard capacity increment iszero.Trims the capacity of this ByteBuffer to be the ByteBuffer's currentsize. If the capacity of this cector is larger than its currentsize, then the capacity is changed to equal the size by replacingits internal data array, kept in the field <tt>elementData</tt>,with a smaller one. An application can use this operation tominimize the storage of a ByteBuffer.This implements the unsynchronized semantics of ensureCapacity.Synchronized methods in this class can internally call thismethod for ensuring capacity without incurring the cost of anextra synchronization.java.util.ByteBuffer#ensureCapacity(int)Returns the current capacity of this ByteBuffer.the current capacity (the length of its internaldata arary, kept in the field <tt>elementData</tt>of this ByteBuffer.Returns the number of components in this ByteBuffer.the number of components in this ByteBuffer.Tests if this ByteBuffer has no components.<code>true</code> if and only if this ByteBuffer hasno components, that is, its size is zero;<code>false</code> otherwise.Returns an array containing all of the elements in this ByteBufferin the correct order.1.2/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/ior/EncapsulationUtility.javaEncapsulationUtilityEncapsulationUtility()/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/ior/EncapsulationUtility.classcontaineristrdataStreamThis static utility class contains various utility methods for reading andwriting CDR encapsulations.Read the count from is, then read count Identifiables fromis using the factory.  Add each constructed Identifiable to container.Write all Identifiables that we contain to os.  The totallength must be written before this method is called.Helper method that is used to extract data from an outputstream and write the data to another output stream.  Definedas static so that it can be used in another class.Helper method to read the octet array from is, deencapsulate it,and returnas another InputStream.  This must be called inside theconstructor of a derived class to obtain the correct streamfor unmarshalling data.Helper method that reads an octet array from an input stream.Defined as static here so that it can be used in another class./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/ior/FreezableList.javaimmutable/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/ior/FreezableList.classfromIndextoIndexSimple class that delegates all List operations toanother list.  It also can be frozen, which means thata number of operations can be performed on the list,and then the list can be made immutable, so that nofurther changes are possible.  A FreezableList is frozenusing the makeImmutable method. Methods overridden from AbstractList We also override subList so that the result is a FreezableList./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/ior/GenericIdentifiable.java/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/ior/GenericIdentifiable.class"GenericIdentifiable[id="GenericIdentifiable[id=encaps17This is used for unknown components and profiles.  A TAG_MULTICOMPONENT_PROFILE will be represented this way./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/ior/GenericTaggedComponent.javaorg.omg.IOP.TaggedComponent/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/ior/GenericTaggedProfile.java/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/ior/GenericTaggedProfile.classprof NO-OP/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/ior/IORImpl.javainitializeIORTemplateListinitializeIORTemplateList()/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/ior/IORImpl.classaddTaggedProfilesaddTaggedProfiles(com.sun.corba.se.spi.ior.IORTemplate,com.sun.corba.se.spi.ior.ObjectId)iortempscachedHashValueisCachedHashValuetypeIdtypeidtemplateIteratorbsmyIteratorotherIteratormyProfileotherProfileoktempToIORTemplateoidiop XXX remove this once getProfile is goneAn IOR is represented as a list of profiles.Only objects that extend TaggedProfile should be added to an IOR.However, enforcing this restriction requires overriding allof the addXXX methods inherited from List, so no checkis included here.This variable is set directly from the constructors that takean IORTemplate or IORTemplateList as arguments; otherwise itis derived from the list of TaggedProfile instances on the firstcall to getIORTemplates.  Note that we assume that an IOR withmutiple TaggedProfile instances has the same ObjectId in eachTaggedProfile, as otherwise the IOR could never be created throughan ObjectReferenceFactory.Construct an empty IOR.  This is needed for null object references.Construct an IOR from an IORTemplate by applying the sameobject id to each TaggedProfileTemplate in the IORTemplate. The check for typeId length of 0 below is commented out as a workaround for a bug in ORBs which send a null objref with a non-empty typeId string.&& (typeId.length() == 0) Maps ObjectKeyTemplate to IORTemplate used to check that all profiles have the same oid. Check that all oids for all profiles are the same: if they are not, throw exception. Find or create the IORTemplate for oktemp.Return the IORTemplateList for this IOR.  Will throwexception if it is not possible to generate an IORfrom the IORTemplateList that is equal to this IOR,which can only happen if not every TaggedProfile in theIOR has the same ObjectId.Return the first IIOPProfile in this IOR.XXX THIS IS TEMPORARY FOR BACKWARDS COMPATIBILITY AND WILL BE REMOVEDSOON! if we come to this point then no IIOP Profile is present.  Therefore, throw an exception./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/ior/IORTemplateImpl.java/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/ior/IORTemplateImpl.classthisIteratorthisTemplatelistTemplateThis class is a container of TaggedProfileTemplates.Ensure that this IORTemplate and all of its profiles can not bemodified.  This overrides the method inherited fromFreezableList through IdentifiableContainerBase./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/ior/IORTemplateListImpl.javatlThis class must override add( int, Object ) and set( int, Object )so that adding an IORTemplateList to an IORTemplateList just resultsin a list of TaggedProfileTemplates./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/ior/IORTypeCheckRegistryImpl.javadprintTransportdprintTransport(java.lang.String)/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/ior/IORTypeCheckRegistryImpl.classdprintConfiguredIorTypeNamesdprintConfiguredIorTypeNames()Set<Class<?>>Collection<Class<?>>Iterable<Class<?>>initBuiltInCorbaStubTypesinitBuiltInCorbaStubTypes()initBuiltinIorTypeNamesinitBuiltinIorTypeNames()parseIorClassNameListparseIorClassNameList(java.lang.String)checkBuiltinClassNamescheckBuiltinClassNames(java.lang.String)checkIorTypeNamescheckIorTypeNames(java.lang.String)validateIorTypeByNamevalidateIorTypeByName(java.lang.String)builtinIorTypeNamesiorTypeNamesfilterPropertiesiorClassName".isValidIORType : iorClassName == ".isValidIORType : iorClassName == isValidType".validateIorTypeByName : iorClassName == ".validateIorTypeByName : iorClassName == ".validateIorTypeByName : isValidType == ".validateIorTypeByName : isValidType == theIorClassNameSpliterator<String>Consumer<? super String>Iterator<String>Stream<String>BaseStream<String,Stream<String>>Predicate<? super String>Collection<? extends String>Iterable<? extends String>add(java.lang.String)filterProperty_iorTypeNamestempIorClassNamesHashSet<String>AbstractSet<String>AbstractCollection<String>HashSet<E>AbstractSet<E>AbstractCollection<E>Set<E>List<String>HashSet<E>(java.util.Collection)AbstractCollection<E>()AbstractSet<E>()HashSet<E>(int,float,boolean)HashSet<E>(int)HashSet<E>(int,float)HashSet<E>()builtInCorbaStubTypestempBuiltinIorTypeNamesSpliterator<Class<?>>? super Class<?>Consumer<? super Class<?>>Iterator<Class<?>>Stream<Class<?>>BaseStream<Class<?>,Stream<Class<?>>>Predicate<? super Class<?>>? extends Class<?>Collection<? extends Class<?>>Iterable<? extends Class<?>>add(java.lang.Class)_stubClasstempBuiltinCorbaStubTypesClass<Activator>Class<_ServerStub>Class<BindingIterator>Class<_BindingIteratorStub>Class<NamingContextExt>Class<_NamingContextExtStub>Class<NamingContext>Class<_NamingContextStub>Class<DynAnyFactory>Class<_DynAnyFactoryStub>Class<DynAny>Class<_DynAnyStub>Class<DynArray>Class<_DynArrayStub>Class<DynEnum>Class<_DynEnumStub>Class<DynFixed>Class<_DynFixedStub>Class<DynSequence>Class<_DynSequenceStub>Class<DynStruct>Class<_DynStructStub>Class<DynUnion>Class<_DynUnionStub>Class<_DynValueStub>Class<DynValue>Class<ServantActivator>Class<_ServantActivatorStub>Class<ServantLocator>Class<_ServantLocatorStub>HashSet<Class<?>>AbstractSet<Class<?>>AbstractCollection<Class<?>>List<Class<?>>HashSet<Class<?>>(java.util.Collection)AbstractCollection<Class<?>>()AbstractSet<Class<?>>()HashSet<Class<?>>(int,float,boolean)HashSet<Class<?>>(int)HashSet<Class<?>>(int,float)HashSet<Class<?>>()iorTypeName".dprintConfiguredIorTypeNames: ".dprintConfiguredIorTypeNames: Copyright (c) 2017, Oracle and/or its affiliates. All rights reserved.A note on the validation flow:1. against the filter class name list2. against the builtin class name listcheck if the class name corresponding to an IOR Type nameis in the ior class name list as generated from the filter property.So if the IOR type is recorded in the registry then allow the creation of thestub factory and let it resolve and load the class. That is if currenttype check deliberation permits.IOR Type names are configured by the filter propertyCheck the IOR interface class name against the set ofclass names that correspond to the builtin JDK IDL stub classes./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/ior/IdentifiableFactoryFinderBase.java/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/ior/IdentifiableFactoryFinderBase.classident/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/ior/JIDLObjectKeyTemplate.javamagicscidoshThis constructor reads the template ONLY from the stream.This constructor reads a complete ObjectKey (template and Id)from the stream./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/ior/NewObjectKeyTemplateBase.javaorbid subclass must set the version, since we don't have the object key here./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/ior/ObjectAdapterIdArray.javaobjectAdapterId/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/ior/ObjectAdapterIdArray.classname1name2ListIterator<String>add(int,java.lang.String)set(int,java.lang.String)Comparator<? super String>UnaryOperator<String>Function<String,String>Special constructor used for OA IDs of length 2./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/ior/ObjectAdapterIdBase.javaObjectAdapterIdBaseObjectAdapterIdBase()/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/ior/ObjectAdapterIdBase.classtheOtheriter1iter2str1str2buff"ObjectAdapterID["ObjectAdapterID["/"/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/ior/ObjectAdapterIdNumber.javapoaid/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/ior/ObjectAdapterIdNumber.class"OldRootPOA"OldRootPOAObjectAdapterIdNumber is used to represent pre-JDK 1.4 POA adapterIDs.  The POA ID was simply represented as a single integer, which wasmapped to the actual POA instance.  Here, we just represent theseinternally as arrays of the form { "OldRootPOA", "<number>" },and provide an extra method to get the number back./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/ior/ObjectIdImpl.java/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/ior/ObjectIdImpl.class/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/ior/ObjectKeyFactoryImpl.javacreatecreate(org.omg.CORBA_2_3.portable.InputStream,com.sun.corba.se.impl.ior.Handler,org.omg.CORBA.OctetSeqHolder)/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/ior/ObjectKeyFactoryImpl.classvalidMagicvalidMagic(int)oktempOnlyfullKey/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/ior/ObjectKeyFactoryImpl$1.classhandlehandle(int,int,org.omg.CORBA_2_3.portable.InputStream,org.omg.CORBA.OctetSeqHolder)/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/ior/ObjectKeyFactoryImpl$2.class0xAFABCAFE-1347695874mexcBased on the magic and scid, return the appropriateObjectKeyTemplate.  Expects to be called with a validmagic.  If scid is not valid, null should be returned.Singleton used to manufacture ObjectKey and ObjectKeyTemplate Magic used in our object keys for JDK 1.2, 1.3, RMI-IIOP OP, J2EE 1.0-1.2.1. Magic used only in JDK 1.3.1.  No format changes in object keys. New magic used in our object keys for JDK 1.4, J2EE 1.3 and later. Format changes: all object keys have version string; POA key format is changed. Beginning in JDK 1.3.1_01, we introduced changes which required the ability to distinguish between JDK 1.3.1 FCS and the patch versions.  See OldJIDLObjectKeyTemplate. XXX The handlers still need to be made pluggable. I think this can be done as follows: 1. Move the Handler interface into the SPI as ObjectKeyHandler. 2. Add two methods to ObjectAdapterFactory:      ObjectKeyHandler getHandlerForObjectKey( ) ;      ObjectKeyHandler getHandlerForObjectKeyTemplate( ) ; 3. Move the implementation of the fullKey handler and the    oktempOnly handler into TOAFactory and POAFactory. 4. Move the ObjectKey impl classes into the impl/oa packages. 5. Create an internal interface      interface HandlerFinder {          ObjectKeyHandler get( int scid ) ;      }    and modify create(InputStream,Handler,OctetSeqHolder)    to take a HandlerFinder instead of a Handler. 6. Modify create( byte[] ) and createTemplate( InputStream )    to create an instance of HandlerFinder: something like:      new HandlerFinder() {          ObjectKeyHandler get( int scid )          {              return orb.getRequestDispatcherRegistry().                  getObjectAdapterFactory( scid ).getHandlerForObjectKey() ;          }      and similarly for getHandlerForObjectKeyTemplate.This handler reads the full object key, both the oktempand the ID.This handler reads only the oktemp.Returns true iff magic is in the range of valid magic numbersfor our ORB.Creates an ObjectKeyTemplate from the InputStream.  Most of thedecoding is done inside the handler. XXX log this error ignore this: error handled below because oktemp == null If we did not successfully construct a oktemp, reset the stream so that WireObjectKeyTemplate can correctly construct the object key. ignore this/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/ior/ObjectKeyImpl.java/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/ior/ObjectKeyImpl.class/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/ior/ObjectKeyTemplateBase.javacomputeAdapterIdcomputeAdapterId()/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/ior/ObjectKeyTemplateBase.classJIDL_OAID_STRINGS"TransientObjectAdapter"TransientObjectAdaptercomp Fixed constants for Java IDL object key template forms write out serverid, orbid, oaid All subclasses should set the version in their constructors. Public so it can be used in a white-box test./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/ior/ObjectReferenceFactoryImpl.javaiorTemplates/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/ior/ObjectReferenceFactoryImpl.class"IDL:com/sun/corba/se/impl/ior/ObjectReferenceFactoryImpl:1.0"IDL:com/sun/corba/se/impl/ior/ObjectReferenceFactoryImpl:1.0ostrThis is an implementation of the ObjectReferenceFactory abstract valuetype defined by the portable interceptors IDL.Note that this is a direct Java implementationof the abstract value type: there is no stateful value type defined in IDL,since defining the state in IDL is awkward and inefficient.  The best wayto define the state is to use internal data structures that can be writtento and read from CORBA streams. Note that this repository ID must reflect the implementation of the abstract valuetype (that is, this class), not the repository ID of the org.omg.PortableInterceptor.ObjectReferenceFactory class.  This allows for multiple independent implementations of the abstract valuetype, should that become necessary.Read the data into a (presumably) empty ObjectReferenceFactoryImpl.This sets the orb to the ORB of the InputStream.Write the state to the OutputStream./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/ior/ObjectReferenceProducerBase.java/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/ior/ObjectReferenceTemplateImpl.javaiorTemplate/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/ior/ObjectReferenceTemplateImpl.class"IDL:com/sun/corba/se/impl/ior/ObjectReferenceTemplateImpl:1.0"IDL:com/sun/corba/se/impl/ior/ObjectReferenceTemplateImpl:1.0This is an implementation of the ObjectReferenceTemplate abstract value repository ID of the org.omg.PortableInterceptor.ObjectReferenceTemplateRead the data into a (presumably) empty ORTImpl.  This sets theorb to the ORB of the InputStream./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/ior/OldJIDLObjectKeyTemplate.javapatchVersion/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/ior/OldJIDLObjectKeyTemplate.classHandles object keys created by JDK ORBs from before JDK 1.4.0.JDK 1.3.1 FCS did not include a version byte at the end ofits object keys.  JDK 1.3.1_01 included the byte with thevalue 1.  Anything below 1 is considered an invalid value.Beginning with JDK 1.3.1_01, a byte was placed at the end ofthe object key with a value indicating the patch version.JDK 1.3.1_01 had the value 1.  If other patches are necessarywhich involve ORB versioning changes, they should incrementthe patch version.Note that if we see a value greater than 1 in this code, wewill treat it as if we're talking to the most recent ORB version.WARNING: This code is sensitive to changes in CDRInputStreamgetPosition.  It assumes that the CDRInputStream is anencapsulation whose position can be compared to the objectkey array length./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/ior/OldObjectKeyTemplateBase.java set version based on magic any other magic should not be here/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/ior/OldPOAObjectKeyTemplate.javaThis constructor reads the template ONLY from the stream/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/ior/POAObjectKeyTemplate.java/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/ior/StubIORImpl.javaappendByteArrayappendByteArray(java.lang.StringBuffer,byte[])/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/ior/StubIORImpl.classbyte[][]equalArraysequalArrays(byte[][],byte[][])equalArrays(byte[],byte[])equalArrays(int[],int[])profileDataprofileTagstypeDatatypeLengthnumProfilesClass<byte[]>Class<int[]>data1data2"SimpleIORImpl["SimpleIORImpl[",(",(Copyright (c) 2003, 2018, Oracle and/or its affiliates. All rights reserved. Be very careful: com.sun.corba imports must not depend on PEORB internal classes in ways that prevent portability to other vendor's ORBs.This class implements a very simply IOR representationwhich must be completely ORBImpl free so that this classcan be used in the implementation of a portable StubDelegateImpl. cached hash code IOR components write the IOR to an OutputStream and get an InputStream read the IOR components back from the stream write the IOR components to an org.omg.CORBA.portable.OutputStream read the IOR back from the stream read the IOR from the ObjectInputStream write the IOR to the ObjectOutputStreamReturns a hash code value for the object which is the same for all stubsthat represent the same remote object.the hash code value. compute the hash codeReturns a string representation of this stub. Returns the same stringfor all stubs that represent the same remote object."SimpleIORImpl[<typeName>,[<profileID>]data, ...]"a string representation of this stub./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/ior/TaggedComponentFactoryFinderImpl.java Skip the component ID: we just wrote it out above/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/ior/TaggedProfileFactoryFinderImpl.java/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/ior/TaggedProfileTemplateFactoryFinderImpl.java/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/ior/WireObjectKeyTemplate.javainitORBinitORB(com.sun.corba.se.spi.orb.ORB)/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/ior/WireObjectKeyTemplate.classgetIdgetId(org.omg.CORBA_2_3.portable.InputStream)53cisbid All WireObjectKeyTemplates are the same, so they should have the same hashCode. Does nothingWhile it might make sense to throw an exception here, this causesproblems since we need to check whether unusual object referencesare local or not.  It seems that the easiest way to handle this isto return an invalid server id.Adapter ID is not available, since ourORB did not implement the object carrying this key./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/ior/iiop/AlternateIIOPAddressComponentImpl.java/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/ior/iiopcom.sun.corba.se.impl.ior.iiop/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/ior/iiop/AlternateIIOPAddressComponentImpl.class/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/ior/iiop"AlternateIIOPAddressComponentImpl[addr="AlternateIIOPAddressComponentImpl[addr= 3 in CORBA 2.3.1 13.6.3/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/ior/iiop/CodeSetsComponentImpl.javacsci/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/ior/iiop/CodeSetsComponentImpl.class"CodeSetsComponentImpl[csci="CodeSetsComponentImpl[csci= Uses our default code sets (see CodeSetComponentInfo) 1 in CORBA 2.3.1 13.6.3/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/ior/iiop/IIOPAddressBase.javaIIOPAddressBaseIIOPAddressBase()/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/ior/iiop/IIOPAddressBase.class3276765536"IIOPAddress["IIOPAddress[",", Ports are marshalled as shorts on the wire.  The IDL type is unsigned short, which lacks a convenient representation in Java in the 32768-65536 range.  So, we treat ports as ints throught this code, except that marshalling requires a scaling conversion.  intToShort and shortToInt are provided for this purpose./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/ior/iiop/IIOPAddressClosureImpl.java/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/ior/iiop/IIOPAddressClosureImpl.class/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/ior/iiop/IIOPAddressImpl.java/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/ior/iiop/IIOPAddressImpl.classthePort/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/ior/iiop/IIOPProfileImpl.javauncachedGetCodeBaseuncachedGetCodeBase()/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/ior/iiop/IIOPProfileImpl.classinit(org.omg.CORBA_2_3.portable.InputStream)IIOPProfileImplIIOPProfileImpl(com.sun.corba.se.spi.orb.ORB)cachedIsLocalcheckedIsLocalproftempLocalCodeBaseSingletonHolderLocalCodeBaseSingletonHolder()/Library/Java/JavaVirtualMachines/jdk1.8.0_251.jdk/Contents/Home/jre/lib/rt.jar/com/sun/corba/se/impl/ior/Library/Java/JavaVirtualMachines/jdk1.8.0_251.jdk/Contents/Home/jre/lib/rt.jar/com/sun/corba/se/impl/ior/iiop/Library/Java/JavaVirtualMachines/jdk1.8.0_251.jdk/Contents/Home/jre/lib/rt.jar/com/sun/corba/se/impl/ior/iiop/IIOPProfileImpl$LocalCodeBaseSingletonHolder.classlocalCodebaseprimaryjccjcbcscroafboid Cached lookups First, read all of the IIOP IOR data Handle any tagged components (if applicable) If there is no codebase in this IOR and there IS a java.rmi.server.codebase property set, we need to update the IOR with the local codebase.  Note that there is only one instance of the local codebase, but it can be safely shared in multiple IORs since it is immutable. Whether codebase is null or not, we have it, and so getCodebase ned never call uncachedGetCodebase.the ORBVersion associated with the object key in the IOR.Return the servant for this IOR, if it is local AND if the OA thatimplements this objref supports direct access to servants outside of aninvocation.XXX revisit: do we want this at all?  If we do, it might move to theObjectKeyTemplate instead. Could not find the OA, so just return null. This usually happens when POAs are being deleted, and the POA always return null for getLocalServant anyway.Return GIOPVersion for this IOR.Requests created against this IOR will be of thereturn Version./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/ior/iiop/IIOPProfileTemplateImpl.java/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/ior/iiop/IIOPProfileTemplateImpl.classokeyTemplateencapsulatedOStempimpIf getMinorVersion==0, this does not contain any tagged components Adding tagged components is not allowed for IIOP 1.0, so this template is complete and should be made immutable. Note that this is NOT an encapsulation: do not marshal the endianness flag.  However, the length is required. Note that this cannot be accomplished with a codec! Use the byte order of the given streamWrite out this IIOPProfileTemplateImpl only./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/ior/iiop/JavaCodebaseComponentImpl.javaURLs/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/ior/iiop/JavaCodebaseComponentImpl.class"JavaCodebaseComponentImpl[URLs="JavaCodebaseComponentImpl[URLs= 25 in CORBA 2.3.1 13.6.3/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/ior/iiop/JavaSerializationComponent.javasingleton/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/ior/iiop/JavaSerializationComponent.classClass<JavaSerializationComponent>Tagged component that contains a value that indicates the Javaserialization version supported by the ORB.ORB Java serialization uses IIOP as the transport protocol, but usesJava serialization mechanism and its accompanying encodings, insteadof IIOP CDR serialization mechanism. Java serialization is generallyobserved to be faster than CDR./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/ior/iiop/MaxStreamFormatVersionComponentImpl.java/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/ior/iiop/MaxStreamFormatVersionComponentImpl.class"MaxStreamFormatVersionComponentImpl[version="MaxStreamFormatVersionComponentImpl[version=Copyright (c) 2002, 2004, Oracle and/or its affiliates. All rights reserved. Java to IDL ptc 02-01-12 1.4.11 TAG_RMI_CUSTOM_MAX_STREAM_FORMAT/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/ior/iiop/ORBTypeComponentImpl.javaORBType/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/ior/iiop/ORBTypeComponentImpl.class"ORBTypeComponentImpl[ORBType="ORBTypeComponentImpl[ORBType= 0 in CORBA 2.3.1 13.6.3/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/ior/iiop/RequestPartitioningComponentImpl.javapartitionToUse/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/ior/iiop/RequestPartitioningComponentImpl.class"RequestPartitioningComponentImpl[partitionToUse="RequestPartitioningComponentImpl[partitionToUse=thePartitionToUse/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/javax/rmi/CORBA/StubDelegateImpl.java/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/javax/rmi/CORBA/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/javax/rmi/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/javaxcom.sun.corba.se.impl.javax.rmi.CORBAinit(javax.rmi.CORBA.Stub)/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/javax/rmi/CORBA/StubDelegateImpl.class/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/javax/rmi/CORBA/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/javax/rmi/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/javaxselfBase class from which all static RMI-IIOP stubs must inherit.Sets the IOR components if not already set. If the Stub is not connected to an ORB, BAD_OPERATION exception will be raised by the code below.Compares two stubs for equality. Returns <code>true</code> when used to compare stubsthat represent the same remote object, and <code>false</code> otherwise.the reference object with which to compare.<code>true</code> if this object is the same as the <code>obj</code>argument; <code>false</code> otherwise. no need to call init() because of calls to hashCode() below hashCodes being the same does not mean equality. The stubs still could be pointing to different IORs. So, do a literal comparison. Apparently the ONLY way to do this (other than using private reflection)  toString, because it is not possible to directly access the StubDelegateImpl from the Stub.Connects this stub to an ORB. Required after the stub is deserializedbut not after it is demarshalled by an ORB stream. If an unconnectedstub is passed to an ORB stream for marshalling, it is implicitlyconnected to that ORB. Application code should not call this methoddirectly, but should call the portable wrapper method{@link javax.rmi.PortableRemoteObject#connect}.the ORB to connect to.RemoteExceptionif the stub is already connected to a differentORB, or if the stub does not represent an exported remote or local object.Serialization method to restore the IOR state.Serialization method to save the IOR state.@serialDataThe length of the IOR type ID (int), followed by the IOR type ID(byte array encoded using ISO8859-1), followed by the number of IOR profiles(int), followed by the IOR profiles.  Each IOR profile is written as aprofile tag (int), followed by the length of the profile data (int), followedby the profile data (byte array)./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/javax/rmi/CORBA/Util.javalookupTielookupTie(java.rmi.Remote)/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/javax/rmi/CORBA/Util.classcreateTypeCodeForNullcreateTypeCodeForNull(org.omg.CORBA.ORB)createTypeCodecreateTypeCode(java.io.Serializable,org.omg.CORBA.Any,org.omg.CORBA.ORB)setInstancesetInstance(com.sun.corba.se.impl.javax.rmi.CORBA.Util)valueHandlerSingletonexportedServantskeepAliveutil"Instance already defined"Instance already defined? extends SystemExceptionClass<? extends SystemException>Map<String,? extends SystemException>SystemException[]? extends SystemException[]Constructor<? extends SystemException>? super ? extends SystemExceptionClass<? super ? extends SystemException>TypeVariable<Class<? extends SystemException>>TypeVariable<Class<? extends SystemException>>[]corbaNamestatusmessage"CORBA "CORBA orig"Error occurred in server thread"Error occurred in server thread"RemoteException occurred in server thread"RemoteException occurred in server thread"Yes"Yes"No"No"Maybe"MaybenewExinner"javax.activity.ActivityRequiredException"javax.activity.ActivityRequiredExceptioncr"javax.activity.ActivityCompletedException"javax.activity.ActivityCompletedException"javax.activity.InvalidActivityException"javax.activity.InvalidActivityExceptionnewObjourORBabstractBaseID"IDL:omg.org/CORBA/AbstractBase:1.0"IDL:omg.org/CORBA/AbstractBase:1.0tie/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/javax/rmi/CORBA/Util$1.classcachedTie"Tie not found"Tie not foundremoteCodebaseloadercdelcilccillcscompTypeClass<? extends Object[]>Map<String,? extends Object[]>Object[][]? extends Object[][]Constructor<? extends Object[]>? super ? extends Object[]Class<? super ? extends Object[]>TypeVariable<Class<? extends Object[]>>TypeVariable<Class<? extends Object[]>>[]lorbcopierrexc/Library/Java/JavaVirtualMachines/jdk1.8.0_251.jdk/Contents/Home/jre/lib/rt.jar/com/sun/corba/se/impl/javax/Library/Java/JavaVirtualMachines/jdk1.8.0_251.jdk/Contents/Home/jre/lib/rt.jar/com/sun/corba/se/impl/javax/rmi/Library/Java/JavaVirtualMachines/jdk1.8.0_251.jdk/Contents/Home/jre/lib/rt.jar/com/sun/corba/se/impl/javax/rmi/CORBA/Library/Java/JavaVirtualMachines/jdk1.8.0_251.jdk/Contents/Home/jre/lib/rt.jar/com/sun/corba/se/impl/javax/rmi/CORBA/KeepAlive.class Util (sed marker, don't remove!) This class must be able to function with non-Sun ORBs. This means that any of the following com.sun.corba classes must only occur in contexts that also handle the non-Sun case.Provides utility methods that can be used by stubs and ties toperform common operations. Runs as long as there are exportedServants Maps targets to ties. Used by TOAFactory.shutdown to unexport all targets for this particular ORB.  This happens during ORB shutdown. Bug 4476347: BAD_OPERATION is thrown if the ties delegate isn't set. We can ignore this because it means the tie is not connected to an ORB. We neglect this exception if at all if it is raised. It is not harmful.IgnoreMaps a SystemException to a RemoteException.the SystemException to map.the mapped exception. Build the message string... Now map to the correct RemoteException type... Pre-Merlin Sun ORBs used the incorrect minor code for this case.  See Java to IDL ptc-00-01-08 1.4.8. Just map to a generic RemoteException...Writes any java.lang.Object as a CORBA any.the stream in which to write the any.the object to write as an any. Create Any Make sure we have a connected object... Handle the null case, including backwards compatibility issues If they're our Any and ORB implementations, we may want to do type code related versioning.When using our own ORB and Any implementations, we need to getthe ORB version and create the type code appropriately.  This isto overcome a bug in which the JDK 1.3.x ORBs used a tk_charrather than a tk_wchar to describe a Java char field.This only works in RMI-IIOP with Util.writeAny since we actuallyknow what ORB and stream we're writing with when we insertthe value.Returns null if it wasn't possible to create the TypeCode (meansit wasn't our ORB or Any implementation).This does not handle null objs.This is used to create the TypeCode for a null reference.It also handles backwards compatibility with JDK 1.3.x.This method will not return null. Preserve backwards compatibility with Kestrel and Ladybird by not fully implementing interop issue resolution 3857, and returning a null TypeCode with a tk_value TCKind. If we're not talking to Kestrel or Ladybird, fall through to the abstract interface case (also used for foreign ORBs). Use tk_abstract_interface as detailed in the resolution REVISIT: Define this in IDL and get the ID in generated codeReads a java.lang.Object as a CORBA any.the stream from which to read the any.the object read from the stream.Writes a java.lang.Object as a CORBA Object. If <code>obj</code> isan exported RMI-IIOP server object, the tie is foundand wired to <code>obj</code>, then written to <code>out.write_Object(org.omg.CORBA.Object)</code>.If <code>obj</code> is a CORBA Object, it is written to<code>out.write_Object(org.omg.CORBA.Object)</code>.the stream in which to write the object.the object to write. Make sure we have a connected object, then write it out...Writes a java.lang.Object as either a value or a CORBA Object.If <code>obj</code> is a value object or a stub object, it is written to<code>out.write_abstract_interface(java.lang.Object)</code>. If <code>obj</code> is an exportedRMI-IIOP server object, the tie is found and wired to <code>obj</code>,then written to <code>out.write_abstract_interface(java.lang.Object)</code>.Registers a target for a tie. Adds the tie to an internal table and calls{@link Tie#setTarget} on the tie object.the tie to register.the target for the tie. Do we already have this target registered? No, so register it and set the target... Do we need to instantiate our keep-alive thread? Yes. Instantiate our keep-alive thread and start it up...Removes the associated tie from an internal table and calls {@link Tie#deactivate}to deactivate the object.the object to unexport. ignore This can happen when the target was never associated with a POA. We can safely ignore this case. Is it time to shut down our keep alive thread?Returns the tie (if any) for a given target object.the tie or null if no tie is registered for the given target.An unsynchronized version of getTie() for internal use.Returns a singleton instance of a class that implements the{@link ValueHandler} interface.a class which implements the ValueHandler interface.Returns the codebase, if any, for the given class.the class to get a codebase for.a space-separated list of URLs, or null.Returns a class instance for the specified class.the name of the class.a space-separated list of URLs at whichthe class might be found. May be null.loadingContexta class whose ClassLoader may be used toload the class if all other methods fail.the <code>Class</code> object representing the loaded class.ClassNotFoundExceptionif class cannot be loaded.The <tt>isLocal</tt> method has the same semantics as theObjectImpl._is_local method, except that it can throw a RemoteException.(no it doesn't but the spec says it should.)The <tt>_is_local()</tt> method is provided so that stubs may determineif a particular object is implemented by a local servant and hence localinvocation APIs may be used.the stub to test.The <tt>_is_local()</tt> method returns true ifthe servant incarnating the object is located in the same process asthe stub and they both share the same ORB instance.  The <tt>_is_local()</tt>method returns false otherwise. The default behavior of <tt>_is_local()</tt> isto return false.The Java to IDL specification does tospecify the conditions that cause a RemoteException to be thrown. For the Sun ORB For a non-Sun ORBWraps an exception thrown by an implementationmethod.  It returns the corresponding client-side exception.the exception to wrap.the wrapped exception.Copies or connects an array of objects. Used by local stubsto copy any number of actual parameters, preserving sharingacross parameters as necessary to support RMI semantics.the objects to copy or connect.the ORB.the copied or connected objects.if any object could not be copied or connected. Bug fix for 5018613: JCK test expects copyObjects to throw NPE when obj==null.  This is actually not in the spec, since obj is not really an RMI-IDL data type, but we follow our test here, and force this error to be thrown. obj is an array of remote impl types.  This causes problems with stream copier, so we copy it over to an array of Remotes instead.Copies or connects an object. Used by local stubs to copyan actual parameter, result object, or exception.the object to copy.the copy or connected object.if the object could not be copied or connected. This gets the copier for the current invocation, which was previously set by preinvoke. copyObject was invoked outside of an invocation, probably by a test.  Get the default copier from the ORB. XXX should we just make the default copier available directly and avoid constructing one on each call?/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/javax/rmi/PortableRemoteObject.javacom.sun.corba.se.impl.javax.rmitheTie"invalid argument"invalid argument? extends RemoteClass<? extends Remote>Map<String,? extends Remote>? extends Remote[]Constructor<? extends Remote>? super ? extends RemoteClass<? super ? extends Remote>TypeVariable<Class<? extends Remote>>TypeVariable<Class<? extends Remote>>[]" already exported" already exported"object not exported"object not exported"Can only unexport a server object."Can only unexport a server object."Object not exported."Object not exported.narrowFromnarrowTonarrowObj"Object is not of remote type "Object is not of remote type "Class "Class " is not a valid remote interface" is not a valid remote interfaceerrorsourcetargetIsIIOPtargetTie"'source' object not connected"'source' object not connected"'source' object exported to IIOP, 'target' is JRMP"'source' object exported to IIOP, 'target' is JRMP"'source' object is JRMP, 'target' is IIOP"'source' object is JRMP, 'target' is IIOPexistingOrb"'target' object was already connected"'target' object was already connectedServer implementation objects may either inherit fromjavax.rmi.PortableRemoteObject or they may implement a remote interfaceand then use the exportObject method to register themselves as a server object.The toStub method takes a server implementation and returns a stub thatcan be used to access that server object.The connect method makes a Remote object ready for remote communication.The unexportObject method is used to deregister a server object, allowing it to becomeavailable for garbage collection.The narrow method takes an object reference or abstract interface type andattempts to narrow it to conform tothe given interface. If the operation is successful the result will be anobject of the specified type, otherwise an exception will be thrown.Makes a server object ready to receive remote calls. Notethat subclasses of PortableRemoteObject do not need to call thismethod, as it is called by the constructor.the server object to export.if export fails. Has this object already been exported to IIOP? Yes, so this is an error... Can we load a Tie? Yes, so export it to IIOP... No, so export to JRMP. If this is called twice for the same object, it will throw an ExportException...Returns a stub for the given server object.the server object for which a stub is required. Must either be a subclassof PortableRemoteObject or have been previously the target of a call to{@link #exportObject}.the most derived stub for the object.NoSuchObjectExceptionif a stub cannot be located for the given server object. If the class is already an IIOP stub then return it. If the class is already a JRMP stub then return it. Has it been exported to IIOP?Deregisters a server object from the runtime, allowing the object to becomeif the remote object is notcurrently exported.Checks to ensure that an object of a remote or abstract interface typecan be cast to a desired type.the object to check.the desired type.an object which can be cast to the desired type.ClassCastExceptionif narrowFrom cannot be cast to narrowTo. Is narrowTo an interface that might be implemented by a servant running on iiop? Create an id from the narrowTo type...Makes a Remote object ready for remote communication. This normallyhappens implicitly when the object is sent or received as an argumenton a remote method call, but in some circumstances it is useful toperform this action by making an explicit call.  See the{@link Stub#connect} method for more information.the object to connect.a previously connected object.if <code>source</code> is not connectedor if <code>target</code> is already connected to a different ORB than<code>source</code>. Is this a servant that was exported to iiop?loadTie always succeeds for dynamic RMI-IIOP// No, can we get a tie for it?  If not,// assume that source is a JRMP object...if (Utility.loadTie(source) != null) {// Yes, so it is an iiop object which// has not been exported...throw new RemoteException("'source' object not exported");if (Utility.loadTie(target) != null) {throw new RemoteException("'target' servant not exported"); Yes. Do we have an ORB from the source object? If not, we're done - there is nothing to do to connect a JRMP object. If so, it is an error because the caller mixed JRMP and IIOP... The target object is IIOP. Make sure we have a valid ORB from the source object... And, finally, connect it up... Is the tie already connected? Yes. Is it the same orb? Yes, so nothing to do... No, so this is an error... No, so do it... The stub or tie was already connected.../Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/legacy/connection/DefaultSocketFactory.java/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/legacy/connection/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/legacycom.sun.corba.se.impl.legacy.connection/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/legacy/connection/DefaultSocketFactory.class/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/legacy/connection/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/legacyserverSocketserverSocketChannelsocketInfosocketaddresssocketChannel REVISIT - this is done in SocketOrChannelConnectionImpl/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/legacy/connection/EndPointInfoImpl.java/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/legacy/connection/LegacyServerSocketManagerImpl.java/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/legacy/connection/LegacyServerSocketManagerImpl.classgetAcceptorIteratorgetAcceptorIterator()legacyGetServerPortlegacyGetServerPort(java.lang.String,boolean)socketType"No acceptor for: "No acceptor for: isPersistentendpointsepacceptors"LegacyServerSocketManagerImpl"LegacyServerSocketManagerImpl////////////////////////////////////////////////// LegacyServerSocketManager Only used in ServerManagerImpl. Only used by POAPolicyMediatorBase. this server is activated by orbd this is a user-activated server Only used by PI IORInfoImpl. Used in RepositoryImpl, ServerManagerImpl, POAImpl, POAPolicyMediatorBase, TOAImpl. To get either default or bootnaming endpoint. Check to see if the given port is equal to any of the ORB Server Ports. XXX Does this need to change for the multi-homed case? Used in IIOPProfileImpl, ORBImpl. Implementation./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/legacy/connection/SocketFactoryAcceptorImpl.java"initialize: "initialize: "SocketFactoryAcceptorImpl"SocketFactoryAcceptorImplCopyright (c) 2003, 2004, Oracle and/or its affiliates. All rights reserved. pept Acceptor/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/legacy/connection/SocketFactoryConnectionImpl.javacontactInfouseSelectThreadToWaituseWorkerThreadisBlocking".initialize: connection created: ".initialize: connection created: "SocketFactoryConnectionImpl[" + " "SocketFactoryConnectionImpl[ "SocketFactoryConnectionImpl"SocketFactoryConnectionImpl Socket-factory client constructor. REVISIT - probably need a contact info for both client and server for removing connections from cache? REVISIT - case - needs interface method IMPORTANT: non-channel-backed sockets must use dedicated reader threads. Note: public to override parent./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/legacy/connection/SocketFactoryContactInfoImpl.javaeffectiveTargetIORaddressingDispositioncookie"SocketFactoryContactInfoImpl["SocketFactoryContactInfoImpl[ See SocketOrChannelAcceptorImpl.createMessageMediator See SocketFactoryContactInfoImpl.constructor() See SocketOrChannelContactInfoImpl.constructor() pept.transport.ContactInfo java.lang.Object/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/legacy/connection/SocketFactoryContactInfoListImpl.javatargetIOR XREVISIT - is this used? pept.transport.ContactInfoList/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/legacy/connection/SocketFactoryContactInfoListIteratorImpl.javasocketInfoCookie/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/legacy/connection/SocketFactoryContactInfoListIteratorImpl.classcorbaContactInfoList java.util.Iterator REVISIT: on comm_failure maybe need to give IOR instead of located. pept.ContactInfoListIterator retry from root ior/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/legacy/connection/USLPort.java/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/legacy/connection/USLPort.class":"/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/logging/ActivationSystemException.java/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/loggingcom.sun.corba.se.impl.logging/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/logging/ActivationSystemException.class/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/logging/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/logging/ActivationSystemException$1.classcreate(java.util.logging.Logger)logger401402403404406logDomain"ACTIVATION"ACTIVATIONcsparametersClass<ActivationSystemException>"ACTIVATION.cannotReadRepositoryDb"ACTIVATION.cannotReadRepositoryDb"ACTIVATION.cannotAddInitialNaming"ACTIVATION.cannotAddInitialNaming"ACTIVATION.cannotWriteRepositoryDb"ACTIVATION.cannotWriteRepositoryDb"ACTIVATION.serverNotExpectedToRegister"ACTIVATION.serverNotExpectedToRegister"ACTIVATION.unableToStartProcess"ACTIVATION.unableToStartProcess"ACTIVATION.serverNotRunning"ACTIVATION.serverNotRunning"ACTIVATION.errorInBadServerIdHandler"ACTIVATION.errorInBadServerIdHandler Log wrapper class for Sun private system exceptions in group ACTIVATION Generated by MC.java version 1.0, DO NOT EDIT BY HAND! Generated from input file /jenkins/workspace/8-2-build-macosx-x86_64/jdk8u251/737/corba/src/share/classes/com/sun/corba/se/spi/logging/data/Activation.mc on Thu Mar 12 02:38:09 PDT 2020///////////////////////////////////////////////////////// INITIALIZE INTERNAL OBJECT_NOT_EXIST/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/logging/IORSystemException.java/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/logging/IORSystemException.class/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/logging/IORSystemException$1.class1201120212031204120512061207"IOR"IORClass<IORSystemException>"IOR.ortNotInitialized"IOR.ortNotInitialized"IOR.nullPoa"IOR.nullPoaarg0"IOR.badMagic"IOR.badMagic"IOR.stringifyWriteError"IOR.stringifyWriteError"IOR.taggedProfileTemplateFactoryNotFound"IOR.taggedProfileTemplateFactoryNotFound"IOR.invalidJdk131PatchLevel"IOR.invalidJdk131PatchLevel"IOR.getLocalServantFailure"IOR.getLocalServantFailure"IOR.adapterIdNotAvailable"IOR.adapterIdNotAvailable"IOR.serverIdNotAvailable"IOR.serverIdNotAvailable"IOR.orbIdNotAvailable"IOR.orbIdNotAvailable"IOR.objectAdapterIdNotAvailable"IOR.objectAdapterIdNotAvailable"IOR.badOidInIorTemplateList"IOR.badOidInIorTemplateList"IOR.invalidTaggedProfile"IOR.invalidTaggedProfile"IOR.badIiopAddressPort"IOR.badIiopAddressPort"IOR.iorMustHaveIiopProfile"IOR.iorMustHaveIiopProfile Log wrapper class for Sun private system exceptions in group IOR Generated from input file /jenkins/workspace/8-2-build-macosx-x86_64/jdk8u251/737/corba/src/share/classes/com/sun/corba/se/spi/logging/data/IOR.mc on Thu Mar 12 02:38:09 PDT 2020 BAD_OPERATION BAD_PARAM INV_OBJREF/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/logging/InterceptorsSystemException.java/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/logging/InterceptorsSystemException.class/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/logging/InterceptorsSystemException$1.class801802803804805806807808809810811812813814815816817818819820821822"INTERCEPTORS"INTERCEPTORSClass<InterceptorsSystemException>"INTERCEPTORS.typeOutOfRange"INTERCEPTORS.typeOutOfRange"INTERCEPTORS.nameNull"INTERCEPTORS.nameNull"INTERCEPTORS.rirInvalidPreInit"INTERCEPTORS.rirInvalidPreInitarg1"INTERCEPTORS.badState1"INTERCEPTORS.badState1arg2"INTERCEPTORS.badState2"INTERCEPTORS.badState2"INTERCEPTORS.ioexceptionDuringCancelRequest"INTERCEPTORS.ioexceptionDuringCancelRequest"INTERCEPTORS.exceptionWasNull"INTERCEPTORS.exceptionWasNull"INTERCEPTORS.objectHasNoDelegate"INTERCEPTORS.objectHasNoDelegate"INTERCEPTORS.delegateNotClientsub"INTERCEPTORS.delegateNotClientsub"INTERCEPTORS.objectNotObjectimpl"INTERCEPTORS.objectNotObjectimpl"INTERCEPTORS.exceptionInvalid"INTERCEPTORS.exceptionInvalid"INTERCEPTORS.replyStatusNotInit"INTERCEPTORS.replyStatusNotInit"INTERCEPTORS.exceptionInArguments"INTERCEPTORS.exceptionInArguments"INTERCEPTORS.exceptionInExceptions"INTERCEPTORS.exceptionInExceptions"INTERCEPTORS.exceptionInContexts"INTERCEPTORS.exceptionInContexts"INTERCEPTORS.exceptionWasNull2"INTERCEPTORS.exceptionWasNull2"INTERCEPTORS.servantInvalid"INTERCEPTORS.servantInvalid"INTERCEPTORS.cantPopOnlyPicurrent"INTERCEPTORS.cantPopOnlyPicurrent"INTERCEPTORS.cantPopOnlyCurrent2"INTERCEPTORS.cantPopOnlyCurrent2"INTERCEPTORS.piDsiResultIsNull"INTERCEPTORS.piDsiResultIsNull"INTERCEPTORS.piDiiResultIsNull"INTERCEPTORS.piDiiResultIsNull"INTERCEPTORS.exceptionUnavailable"INTERCEPTORS.exceptionUnavailable"INTERCEPTORS.clientInfoStackNull"INTERCEPTORS.clientInfoStackNull"INTERCEPTORS.serverInfoStackNull"INTERCEPTORS.serverInfoStackNull"INTERCEPTORS.markAndResetFailed"INTERCEPTORS.markAndResetFailed"INTERCEPTORS.slotTableInvariant"INTERCEPTORS.slotTableInvariant"INTERCEPTORS.interceptorListLocked"INTERCEPTORS.interceptorListLocked"INTERCEPTORS.sortSizeMismatch"INTERCEPTORS.sortSizeMismatch"INTERCEPTORS.piOrbNotPolicyBased"INTERCEPTORS.piOrbNotPolicyBased"INTERCEPTORS.orbinitinfoInvalid"INTERCEPTORS.orbinitinfoInvalid"INTERCEPTORS.unknownRequestInvoke"INTERCEPTORS.unknownRequestInvoke Log wrapper class for Sun private system exceptions in group INTERCEPTORS Generated from input file /jenkins/workspace/8-2-build-macosx-x86_64/jdk8u251/737/corba/src/share/classes/com/sun/corba/se/spi/logging/data/Interceptors.mc on Thu Mar 12 02:38:09 PDT 2020 BAD_INV_ORDER COMM_FAILURE NO_IMPLEMENT UNKNOWN/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/logging/NamingSystemException.java/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/logging/NamingSystemException.class/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/logging/NamingSystemException$1.class600601602603604650651700701702703705707708"NAMING"NAMINGClass<NamingSystemException>"NAMING.transientNameServerBadPort"NAMING.transientNameServerBadPort"NAMING.transientNameServerBadHost"NAMING.transientNameServerBadHost"NAMING.objectIsNull"NAMING.objectIsNull"NAMING.insBadAddress"NAMING.insBadAddress"NAMING.bindUpdateContextFailed"NAMING.bindUpdateContextFailed"NAMING.bindFailure"NAMING.bindFailure"NAMING.resolveConversionFailure"NAMING.resolveConversionFailure"NAMING.resolveFailure"NAMING.resolveFailure"NAMING.unbindFailure"NAMING.unbindFailure"NAMING.transNsCannotCreateInitialNcSys"NAMING.transNsCannotCreateInitialNcSys"NAMING.transNsCannotCreateInitialNc"NAMING.transNsCannotCreateInitialNc"NAMING.namingCtxRebindAlreadyBound"NAMING.namingCtxRebindAlreadyBound"NAMING.namingCtxRebindctxAlreadyBound"NAMING.namingCtxRebindctxAlreadyBound"NAMING.namingCtxBadBindingtype"NAMING.namingCtxBadBindingtype"NAMING.namingCtxResolveCannotNarrowToCtx"NAMING.namingCtxResolveCannotNarrowToCtx"NAMING.namingCtxBindingIteratorCreate"NAMING.namingCtxBindingIteratorCreate"NAMING.transNcBindAlreadyBound"NAMING.transNcBindAlreadyBound"NAMING.transNcListGotExc"NAMING.transNcListGotExc"NAMING.transNcNewctxGotExc"NAMING.transNcNewctxGotExc"NAMING.transNcDestroyGotExc"NAMING.transNcDestroyGotExc"NAMING.insBadSchemeName"NAMING.insBadSchemeName"NAMING.insBadSchemeSpecificPart"NAMING.insBadSchemeSpecificPart"NAMING.insOther"NAMING.insOther Log wrapper class for Sun private system exceptions in group NAMING Generated from input file /jenkins/workspace/8-2-build-macosx-x86_64/jdk8u251/737/corba/src/share/classes/com/sun/corba/se/spi/logging/data/Naming.mc on Thu Mar 12 02:38:09 PDT 2020/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/logging/OMGSystemException.java/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/logging/OMGSystemException.class/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/logging/OMGSystemException$1.class181921222526272829303133343536383941"OMG"OMGClass<OMGSystemException>"OMG.idlContextNotFound"OMG.idlContextNotFound"OMG.noMatchingIdlContext"OMG.noMatchingIdlContext"OMG.depPreventDestruction"OMG.depPreventDestruction"OMG.destroyIndestructible"OMG.destroyIndestructible"OMG.shutdownWaitForCompletionDeadlock"OMG.shutdownWaitForCompletionDeadlock"OMG.badOperationAfterShutdown"OMG.badOperationAfterShutdown"OMG.badInvoke"OMG.badInvoke"OMG.badSetServantManager"OMG.badSetServantManager"OMG.badArgumentsCall"OMG.badArgumentsCall"OMG.badCtxCall"OMG.badCtxCall"OMG.badResultCall"OMG.badResultCall"OMG.badSend"OMG.badSend"OMG.badPollBefore"OMG.badPollBefore"OMG.badPollAfter"OMG.badPollAfter"OMG.badPollSync"OMG.badPollSync"OMG.invalidPiCall1"OMG.invalidPiCall1"OMG.invalidPiCall2"OMG.invalidPiCall2"OMG.invalidPiCall3"OMG.invalidPiCall3"OMG.invalidPiCall4"OMG.invalidPiCall4"OMG.serviceContextAddFailed"OMG.serviceContextAddFailed"OMG.policyFactoryRegFailed"OMG.policyFactoryRegFailed"OMG.createPoaDestroy"OMG.createPoaDestroy"OMG.priorityReassign"OMG.priorityReassign"OMG.xaStartOutsize"OMG.xaStartOutsize"OMG.xaStartProto"OMG.xaStartProto"OMG.badServantManagerType"OMG.badServantManagerType"OMG.operationUnknownToTarget"OMG.operationUnknownToTarget"OMG.unableRegisterValueFactory"OMG.unableRegisterValueFactory"OMG.ridAlreadyDefined"OMG.ridAlreadyDefined"OMG.nameUsedIfr"OMG.nameUsedIfr"OMG.targetNotContainer"OMG.targetNotContainer"OMG.nameClash"OMG.nameClash"OMG.notSerializable"OMG.notSerializable"OMG.soBadSchemeName"OMG.soBadSchemeName"OMG.soBadAddress"OMG.soBadAddress"OMG.soBadSchemaSpecific"OMG.soBadSchemaSpecific"OMG.soNonSpecific"OMG.soNonSpecific"OMG.irDeriveAbsIntBase"OMG.irDeriveAbsIntBase"OMG.irValueSupport"OMG.irValueSupport"OMG.incompleteTypecode"OMG.incompleteTypecode"OMG.invalidObjectId"OMG.invalidObjectId"OMG.typecodeBadName"OMG.typecodeBadName"OMG.typecodeBadRepid"OMG.typecodeBadRepid"OMG.typecodeInvMember"OMG.typecodeInvMember"OMG.tcUnionDupLabel"OMG.tcUnionDupLabel"OMG.tcUnionIncompatible"OMG.tcUnionIncompatible"OMG.tcUnionBadDisc"OMG.tcUnionBadDisc"OMG.setExceptionBadAny"OMG.setExceptionBadAny"OMG.setExceptionUnlisted"OMG.setExceptionUnlisted"OMG.noClientWcharCodesetCtx"OMG.noClientWcharCodesetCtx"OMG.illegalServiceContext"OMG.illegalServiceContext"OMG.enumOutOfRange"OMG.enumOutOfRange"OMG.invalidServiceContextId"OMG.invalidServiceContextId"OMG.rirWithNullObject"OMG.rirWithNullObject"OMG.invalidComponentId"OMG.invalidComponentId"OMG.invalidProfileId"OMG.invalidProfileId"OMG.policyTypeDuplicate"OMG.policyTypeDuplicate"OMG.badOnewayDefinition"OMG.badOnewayDefinition"OMG.diiForImplicitOperation"OMG.diiForImplicitOperation"OMG.xaCallInval"OMG.xaCallInval"OMG.unionBadDiscriminator"OMG.unionBadDiscriminator"OMG.ctxIllegalPropertyName"OMG.ctxIllegalPropertyName"OMG.ctxIllegalSearchString"OMG.ctxIllegalSearchString"OMG.ctxIllegalName"OMG.ctxIllegalName"OMG.ctxNonEmpty"OMG.ctxNonEmpty"OMG.invalidStreamFormatVersion"OMG.invalidStreamFormatVersion"OMG.notAValueoutputstream"OMG.notAValueoutputstream"OMG.notAValueinputstream"OMG.notAValueinputstream"OMG.marshallIncompleteTypecode"OMG.marshallIncompleteTypecode"OMG.badMemberTypecode"OMG.badMemberTypecode"OMG.illegalParameter"OMG.illegalParameter"OMG.charNotInCodeset"OMG.charNotInCodeset"OMG.priorityMapFailre"OMG.priorityMapFailre"OMG.noUsableProfile"OMG.noUsableProfile"OMG.priorityRangeRestrict"OMG.priorityRangeRestrict"OMG.noServerWcharCodesetCmp"OMG.noServerWcharCodesetCmp"OMG.codesetComponentRequired"OMG.codesetComponentRequired"OMG.iorPolicyReconcileError"OMG.iorPolicyReconcileError"OMG.policyUnknown"OMG.policyUnknown"OMG.noPolicyFactory"OMG.noPolicyFactory"OMG.xaRmerr"OMG.xaRmerr"OMG.xaRmfail"OMG.xaRmfail"OMG.noIr"OMG.noIr"OMG.noInterfaceInIr"OMG.noInterfaceInIr"OMG.unableLocateValueFactory"OMG.unableLocateValueFactory"OMG.setResultBeforeCtx"OMG.setResultBeforeCtx"OMG.badNvlist"OMG.badNvlist"OMG.notAnObjectImpl"OMG.notAnObjectImpl"OMG.wcharBadGiopVersionSent"OMG.wcharBadGiopVersionSent"OMG.wcharBadGiopVersionReturned"OMG.wcharBadGiopVersionReturned"OMG.unsupportedFormatVersion"OMG.unsupportedFormatVersion"OMG.rmiiiopOptionalDataIncompatible1"OMG.rmiiiopOptionalDataIncompatible1"OMG.rmiiiopOptionalDataIncompatible2"OMG.rmiiiopOptionalDataIncompatible2"OMG.rmiiiopOptionalDataIncompatible3"OMG.rmiiiopOptionalDataIncompatible3"OMG.missingLocalValueImpl"OMG.missingLocalValueImpl"OMG.incompatibleValueImpl"OMG.incompatibleValueImpl"OMG.noUsableProfile2"OMG.noUsableProfile2"OMG.diiLocalObject"OMG.diiLocalObject"OMG.bioReset"OMG.bioReset"OMG.bioMetaNotAvailable"OMG.bioMetaNotAvailable"OMG.bioGenomicNoIterator"OMG.bioGenomicNoIterator"OMG.piOperationNotSupported1"OMG.piOperationNotSupported1"OMG.piOperationNotSupported2"OMG.piOperationNotSupported2"OMG.piOperationNotSupported3"OMG.piOperationNotSupported3"OMG.piOperationNotSupported4"OMG.piOperationNotSupported4"OMG.piOperationNotSupported5"OMG.piOperationNotSupported5"OMG.piOperationNotSupported6"OMG.piOperationNotSupported6"OMG.piOperationNotSupported7"OMG.piOperationNotSupported7"OMG.piOperationNotSupported8"OMG.piOperationNotSupported8"OMG.noConnectionPriority"OMG.noConnectionPriority"OMG.xaRb"OMG.xaRb"OMG.xaNota"OMG.xaNota"OMG.xaEndTrueRollbackDeferred"OMG.xaEndTrueRollbackDeferred"OMG.poaRequestDiscard"OMG.poaRequestDiscard"OMG.noUsableProfile3"OMG.noUsableProfile3"OMG.requestCancelled"OMG.requestCancelled"OMG.poaDestroyed"OMG.poaDestroyed"OMG.unregisteredValueAsObjref"OMG.unregisteredValueAsObjref"OMG.noObjectAdaptor"OMG.noObjectAdaptor"OMG.bioNotAvailable"OMG.bioNotAvailable"OMG.objectAdapterInactive"OMG.objectAdapterInactive"OMG.adapterActivatorException"OMG.adapterActivatorException"OMG.badServantType"OMG.badServantType"OMG.noDefaultServant"OMG.noDefaultServant"OMG.noServantManager"OMG.noServantManager"OMG.badPolicyIncarnate"OMG.badPolicyIncarnate"OMG.piExcCompEstablished"OMG.piExcCompEstablished"OMG.nullServantReturned"OMG.nullServantReturned"OMG.unknownUserException"OMG.unknownUserException"OMG.unsupportedSystemException"OMG.unsupportedSystemException"OMG.piUnknownUserException"OMG.piUnknownUserException Log wrapper class for standard exceptions Generated from input file /jenkins/workspace/8-2-build-macosx-x86_64/jdk8u251/737/corba/src/share/classes/com/sun/corba/se/spi/logging/data/OMG.mc on Thu Mar 12 02:38:10 PDT 2020 BAD_CONTEXT BAD_TYPECODE DATA_CONVERSION IMP_LIMIT INV_POLICY INTF_REPOS MARSHAL NO_RESOURCES TRANSACTION_ROLLEDBACK TRANSIENT OBJ_ADAPTER/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/logging/ORBUtilSystemException.java/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/logging/ORBUtilSystemException.class/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/logging/ORBUtilSystemException$1.class202203204205206207208211212213223224225226227228229230231232233234235236237238239241242243244245246209215216217218219220221222247248249250251252253254257259261262263264265266267268269270271272273274275276277278279280282283284286287288289290291292293294295296297298304309310311312313314316326327328329330331258260"ORBUTIL"ORBUTILClass<ORBUtilSystemException>"ORBUTIL.adapterIdNotAvailable"ORBUTIL.adapterIdNotAvailable"ORBUTIL.serverIdNotAvailable"ORBUTIL.serverIdNotAvailable"ORBUTIL.orbIdNotAvailable"ORBUTIL.orbIdNotAvailable"ORBUTIL.objectAdapterIdNotAvailable"ORBUTIL.objectAdapterIdNotAvailable"ORBUTIL.connectingServant"ORBUTIL.connectingServant"ORBUTIL.extractWrongType"ORBUTIL.extractWrongType"ORBUTIL.extractWrongTypeList"ORBUTIL.extractWrongTypeList"ORBUTIL.badStringBounds"ORBUTIL.badStringBounds"ORBUTIL.insertObjectIncompatible"ORBUTIL.insertObjectIncompatible"ORBUTIL.insertObjectFailed"ORBUTIL.insertObjectFailed"ORBUTIL.extractObjectIncompatible"ORBUTIL.extractObjectIncompatible"ORBUTIL.fixedNotMatch"ORBUTIL.fixedNotMatch"ORBUTIL.fixedBadTypecode"ORBUTIL.fixedBadTypecode"ORBUTIL.setExceptionCalledNullArgs"ORBUTIL.setExceptionCalledNullArgs"ORBUTIL.setExceptionCalledBadType"ORBUTIL.setExceptionCalledBadType"ORBUTIL.contextCalledOutOfOrder"ORBUTIL.contextCalledOutOfOrder"ORBUTIL.badOrbConfigurator"ORBUTIL.badOrbConfigurator"ORBUTIL.orbConfiguratorError"ORBUTIL.orbConfiguratorError"ORBUTIL.orbDestroyed"ORBUTIL.orbDestroyed"ORBUTIL.negativeBounds"ORBUTIL.negativeBounds"ORBUTIL.extractNotInitialized"ORBUTIL.extractNotInitialized"ORBUTIL.extractObjectFailed"ORBUTIL.extractObjectFailed"ORBUTIL.methodNotFoundInTie"ORBUTIL.methodNotFoundInTie"ORBUTIL.classNotFound1"ORBUTIL.classNotFound1"ORBUTIL.classNotFound2"ORBUTIL.classNotFound2"ORBUTIL.classNotFound3"ORBUTIL.classNotFound3"ORBUTIL.getDelegateServantNotActive"ORBUTIL.getDelegateServantNotActive"ORBUTIL.getDelegateWrongPolicy"ORBUTIL.getDelegateWrongPolicy"ORBUTIL.setDelegateRequiresStub"ORBUTIL.setDelegateRequiresStub"ORBUTIL.getDelegateRequiresStub"ORBUTIL.getDelegateRequiresStub"ORBUTIL.getTypeIdsRequiresStub"ORBUTIL.getTypeIdsRequiresStub"ORBUTIL.getOrbRequiresStub"ORBUTIL.getOrbRequiresStub"ORBUTIL.connectRequiresStub"ORBUTIL.connectRequiresStub"ORBUTIL.isLocalRequiresStub"ORBUTIL.isLocalRequiresStub"ORBUTIL.requestRequiresStub"ORBUTIL.requestRequiresStub"ORBUTIL.badActivateTieCall"ORBUTIL.badActivateTieCall"ORBUTIL.ioExceptionOnClose"ORBUTIL.ioExceptionOnClose"ORBUTIL.nullParam"ORBUTIL.nullParam"ORBUTIL.unableFindValueFactory"ORBUTIL.unableFindValueFactory"ORBUTIL.abstractFromNonAbstract"ORBUTIL.abstractFromNonAbstract"ORBUTIL.invalidTaggedProfile"ORBUTIL.invalidTaggedProfile"ORBUTIL.objrefFromForeignOrb"ORBUTIL.objrefFromForeignOrb"ORBUTIL.localObjectNotAllowed"ORBUTIL.localObjectNotAllowed"ORBUTIL.nullObjectReference"ORBUTIL.nullObjectReference"ORBUTIL.couldNotLoadClass"ORBUTIL.couldNotLoadClass"ORBUTIL.badUrl"ORBUTIL.badUrl"ORBUTIL.fieldNotFound"ORBUTIL.fieldNotFound"ORBUTIL.errorSettingField"ORBUTIL.errorSettingField"ORBUTIL.boundsErrorInDiiRequest"ORBUTIL.boundsErrorInDiiRequest"ORBUTIL.persistentServerInitError"ORBUTIL.persistentServerInitError"ORBUTIL.couldNotCreateArray"ORBUTIL.couldNotCreateArrayarg3arg4"ORBUTIL.couldNotSetArray"ORBUTIL.couldNotSetArray"ORBUTIL.illegalBootstrapOperation"ORBUTIL.illegalBootstrapOperation"ORBUTIL.bootstrapRuntimeException"ORBUTIL.bootstrapRuntimeException"ORBUTIL.bootstrapException"ORBUTIL.bootstrapException"ORBUTIL.stringExpected"ORBUTIL.stringExpected"ORBUTIL.invalidTypecodeKind"ORBUTIL.invalidTypecodeKind"ORBUTIL.socketFactoryAndContactInfoListAtSameTime"ORBUTIL.socketFactoryAndContactInfoListAtSameTime"ORBUTIL.acceptorsAndLegacySocketFactoryAtSameTime"ORBUTIL.acceptorsAndLegacySocketFactoryAtSameTime"ORBUTIL.badOrbForServant"ORBUTIL.badOrbForServant"ORBUTIL.invalidRequestPartitioningPolicyValue"ORBUTIL.invalidRequestPartitioningPolicyValue"ORBUTIL.invalidRequestPartitioningComponentValue"ORBUTIL.invalidRequestPartitioningComponentValue"ORBUTIL.invalidRequestPartitioningId"ORBUTIL.invalidRequestPartitioningId"ORBUTIL.errorInSettingDynamicStubFactoryFactory"ORBUTIL.errorInSettingDynamicStubFactoryFactory"ORBUTIL.dsimethodNotcalled"ORBUTIL.dsimethodNotcalled"ORBUTIL.argumentsCalledMultiple"ORBUTIL.argumentsCalledMultiple"ORBUTIL.argumentsCalledAfterException"ORBUTIL.argumentsCalledAfterException"ORBUTIL.argumentsCalledNullArgs"ORBUTIL.argumentsCalledNullArgs"ORBUTIL.argumentsNotCalled"ORBUTIL.argumentsNotCalled"ORBUTIL.setResultCalledMultiple"ORBUTIL.setResultCalledMultiple"ORBUTIL.setResultAfterException"ORBUTIL.setResultAfterException"ORBUTIL.setResultCalledNullArgs"ORBUTIL.setResultCalledNullArgs"ORBUTIL.badRemoteTypecode"ORBUTIL.badRemoteTypecode"ORBUTIL.unresolvedRecursiveTypecode"ORBUTIL.unresolvedRecursiveTypecode"ORBUTIL.connectFailure"ORBUTIL.connectFailure"ORBUTIL.connectionCloseRebind"ORBUTIL.connectionCloseRebind"ORBUTIL.writeErrorSend"ORBUTIL.writeErrorSend"ORBUTIL.getPropertiesError"ORBUTIL.getPropertiesError"ORBUTIL.bootstrapServerNotAvail"ORBUTIL.bootstrapServerNotAvail"ORBUTIL.invokeError"ORBUTIL.invokeError"ORBUTIL.defaultCreateServerSocketGivenNonIiopClearText"ORBUTIL.defaultCreateServerSocketGivenNonIiopClearText"ORBUTIL.connectionAbort"ORBUTIL.connectionAbort"ORBUTIL.connectionRebind"ORBUTIL.connectionRebind"ORBUTIL.recvMsgError"ORBUTIL.recvMsgError"ORBUTIL.ioexceptionWhenReadingConnection"ORBUTIL.ioexceptionWhenReadingConnection"ORBUTIL.selectionKeyInvalid"ORBUTIL.selectionKeyInvalid"ORBUTIL.exceptionInAccept"ORBUTIL.exceptionInAccept"ORBUTIL.securityExceptionInAccept"ORBUTIL.securityExceptionInAccept"ORBUTIL.transportReadTimeoutExceeded"ORBUTIL.transportReadTimeoutExceeded"ORBUTIL.createListenerFailed"ORBUTIL.createListenerFailed"ORBUTIL.bufferReadManagerTimeout"ORBUTIL.bufferReadManagerTimeout"ORBUTIL.badStringifiedIorLen"ORBUTIL.badStringifiedIorLen"ORBUTIL.badStringifiedIor"ORBUTIL.badStringifiedIor"ORBUTIL.badModifier"ORBUTIL.badModifier"ORBUTIL.codesetIncompatible"ORBUTIL.codesetIncompatible"ORBUTIL.badHexDigit"ORBUTIL.badHexDigit"ORBUTIL.badUnicodePair"ORBUTIL.badUnicodePair"ORBUTIL.btcResultMoreThanOneChar"ORBUTIL.btcResultMoreThanOneChar"ORBUTIL.badCodesetsFromClient"ORBUTIL.badCodesetsFromClient"ORBUTIL.invalidSingleCharCtb"ORBUTIL.invalidSingleCharCtb"ORBUTIL.badGiop11Ctb"ORBUTIL.badGiop11Ctb"ORBUTIL.badSequenceBounds"ORBUTIL.badSequenceBounds"ORBUTIL.illegalSocketFactoryType"ORBUTIL.illegalSocketFactoryType"ORBUTIL.badCustomSocketFactory"ORBUTIL.badCustomSocketFactory"ORBUTIL.fragmentSizeMinimum"ORBUTIL.fragmentSizeMinimum"ORBUTIL.fragmentSizeDiv"ORBUTIL.fragmentSizeDiv"ORBUTIL.orbInitializerFailure"ORBUTIL.orbInitializerFailure"ORBUTIL.orbInitializerType"ORBUTIL.orbInitializerType"ORBUTIL.orbInitialreferenceSyntax"ORBUTIL.orbInitialreferenceSyntax"ORBUTIL.acceptorInstantiationFailure"ORBUTIL.acceptorInstantiationFailure"ORBUTIL.acceptorInstantiationTypeFailure"ORBUTIL.acceptorInstantiationTypeFailure"ORBUTIL.illegalContactInfoListFactoryType"ORBUTIL.illegalContactInfoListFactoryType"ORBUTIL.badContactInfoListFactory"ORBUTIL.badContactInfoListFactory"ORBUTIL.illegalIorToSocketInfoType"ORBUTIL.illegalIorToSocketInfoType"ORBUTIL.badCustomIorToSocketInfo"ORBUTIL.badCustomIorToSocketInfo"ORBUTIL.illegalIiopPrimaryToContactInfoType"ORBUTIL.illegalIiopPrimaryToContactInfoType"ORBUTIL.badCustomIiopPrimaryToContactInfo"ORBUTIL.badCustomIiopPrimaryToContactInfo"ORBUTIL.badCorbalocString"ORBUTIL.badCorbalocString"ORBUTIL.noProfilePresent"ORBUTIL.noProfilePresent"ORBUTIL.cannotCreateOrbidDb"ORBUTIL.cannotCreateOrbidDb"ORBUTIL.cannotReadOrbidDb"ORBUTIL.cannotReadOrbidDb"ORBUTIL.cannotWriteOrbidDb"ORBUTIL.cannotWriteOrbidDb"ORBUTIL.getServerPortCalledBeforeEndpointsInitialized"ORBUTIL.getServerPortCalledBeforeEndpointsInitialized"ORBUTIL.persistentServerportNotSet"ORBUTIL.persistentServerportNotSet"ORBUTIL.persistentServeridNotSet"ORBUTIL.persistentServeridNotSet"ORBUTIL.nonExistentOrbid"ORBUTIL.nonExistentOrbid"ORBUTIL.noServerSubcontract"ORBUTIL.noServerSubcontract"ORBUTIL.serverScTempSize"ORBUTIL.serverScTempSize"ORBUTIL.noClientScClass"ORBUTIL.noClientScClass"ORBUTIL.serverScNoIiopProfile"ORBUTIL.serverScNoIiopProfile"ORBUTIL.getSystemExReturnedNull"ORBUTIL.getSystemExReturnedNull"ORBUTIL.peekstringFailed"ORBUTIL.peekstringFailed"ORBUTIL.getLocalHostFailed"ORBUTIL.getLocalHostFailed"ORBUTIL.badLocateRequestStatus"ORBUTIL.badLocateRequestStatus"ORBUTIL.stringifyWriteError"ORBUTIL.stringifyWriteError"ORBUTIL.badGiopRequestType"ORBUTIL.badGiopRequestType"ORBUTIL.errorUnmarshalingUserexc"ORBUTIL.errorUnmarshalingUserexc"ORBUTIL.requestdispatcherregistryError"ORBUTIL.requestdispatcherregistryError"ORBUTIL.locationforwardError"ORBUTIL.locationforwardError"ORBUTIL.wrongClientsc"ORBUTIL.wrongClientsc"ORBUTIL.badServantReadObject"ORBUTIL.badServantReadObject"ORBUTIL.multIiopProfNotSupported"ORBUTIL.multIiopProfNotSupported"ORBUTIL.giopMagicError"ORBUTIL.giopMagicError"ORBUTIL.giopVersionError"ORBUTIL.giopVersionError"ORBUTIL.illegalReplyStatus"ORBUTIL.illegalReplyStatus"ORBUTIL.illegalGiopMsgType"ORBUTIL.illegalGiopMsgType"ORBUTIL.fragmentationDisallowed"ORBUTIL.fragmentationDisallowed"ORBUTIL.badReplystatus"ORBUTIL.badReplystatus"ORBUTIL.ctbConverterFailure"ORBUTIL.ctbConverterFailure"ORBUTIL.btcConverterFailure"ORBUTIL.btcConverterFailure"ORBUTIL.wcharArrayUnsupportedEncoding"ORBUTIL.wcharArrayUnsupportedEncoding"ORBUTIL.illegalTargetAddressDisposition"ORBUTIL.illegalTargetAddressDisposition"ORBUTIL.nullReplyInGetAddrDisposition"ORBUTIL.nullReplyInGetAddrDisposition"ORBUTIL.orbTargetAddrPreferenceInExtractObjectkeyInvalid"ORBUTIL.orbTargetAddrPreferenceInExtractObjectkeyInvalid"ORBUTIL.invalidIsstreamedTckind"ORBUTIL.invalidIsstreamedTckind"ORBUTIL.invalidJdk131PatchLevel"ORBUTIL.invalidJdk131PatchLevel"ORBUTIL.svcctxUnmarshalError"ORBUTIL.svcctxUnmarshalError"ORBUTIL.nullIor"ORBUTIL.nullIor"ORBUTIL.unsupportedGiopVersion"ORBUTIL.unsupportedGiopVersion"ORBUTIL.applicationExceptionInSpecialMethod"ORBUTIL.applicationExceptionInSpecialMethod"ORBUTIL.statementNotReachable1"ORBUTIL.statementNotReachable1"ORBUTIL.statementNotReachable2"ORBUTIL.statementNotReachable2"ORBUTIL.statementNotReachable3"ORBUTIL.statementNotReachable3"ORBUTIL.statementNotReachable4"ORBUTIL.statementNotReachable4"ORBUTIL.statementNotReachable5"ORBUTIL.statementNotReachable5"ORBUTIL.statementNotReachable6"ORBUTIL.statementNotReachable6"ORBUTIL.unexpectedDiiException"ORBUTIL.unexpectedDiiException"ORBUTIL.methodShouldNotBeCalled"ORBUTIL.methodShouldNotBeCalled"ORBUTIL.cancelNotSupported"ORBUTIL.cancelNotSupported"ORBUTIL.emptyStackRunServantPostInvoke"ORBUTIL.emptyStackRunServantPostInvoke"ORBUTIL.problemWithExceptionTypecode"ORBUTIL.problemWithExceptionTypecode"ORBUTIL.illegalSubcontractId"ORBUTIL.illegalSubcontractId"ORBUTIL.badSystemExceptionInLocateReply"ORBUTIL.badSystemExceptionInLocateReply"ORBUTIL.badSystemExceptionInReply"ORBUTIL.badSystemExceptionInReply"ORBUTIL.badCompletionStatusInLocateReply"ORBUTIL.badCompletionStatusInLocateReply"ORBUTIL.badCompletionStatusInReply"ORBUTIL.badCompletionStatusInReply"ORBUTIL.badkindCannotOccur"ORBUTIL.badkindCannotOccur"ORBUTIL.errorResolvingAlias"ORBUTIL.errorResolvingAlias"ORBUTIL.tkLongDoubleNotSupported"ORBUTIL.tkLongDoubleNotSupported"ORBUTIL.typecodeNotSupported"ORBUTIL.typecodeNotSupported"ORBUTIL.boundsCannotOccur"ORBUTIL.boundsCannotOccur"ORBUTIL.numInvocationsAlreadyZero"ORBUTIL.numInvocationsAlreadyZero"ORBUTIL.errorInitBadserveridhandler"ORBUTIL.errorInitBadserveridhandler"ORBUTIL.noToa"ORBUTIL.noToa"ORBUTIL.noPoa"ORBUTIL.noPoa"ORBUTIL.invocationInfoStackEmpty"ORBUTIL.invocationInfoStackEmpty"ORBUTIL.badCodeSetString"ORBUTIL.badCodeSetString"ORBUTIL.unknownNativeCodeset"ORBUTIL.unknownNativeCodeset"ORBUTIL.unknownConversionCodeSet"ORBUTIL.unknownConversionCodeSet"ORBUTIL.invalidCodeSetNumber"ORBUTIL.invalidCodeSetNumber"ORBUTIL.invalidCodeSetString"ORBUTIL.invalidCodeSetString"ORBUTIL.invalidCtbConverterName"ORBUTIL.invalidCtbConverterName"ORBUTIL.invalidBtcConverterName"ORBUTIL.invalidBtcConverterName"ORBUTIL.couldNotDuplicateCdrInputStream"ORBUTIL.couldNotDuplicateCdrInputStream"ORBUTIL.bootstrapApplicationException"ORBUTIL.bootstrapApplicationException"ORBUTIL.duplicateIndirectionOffset"ORBUTIL.duplicateIndirectionOffset"ORBUTIL.badMessageTypeForCancel"ORBUTIL.badMessageTypeForCancel"ORBUTIL.duplicateExceptionDetailMessage"ORBUTIL.duplicateExceptionDetailMessage"ORBUTIL.badExceptionDetailMessageServiceContextType"ORBUTIL.badExceptionDetailMessageServiceContextType"ORBUTIL.unexpectedDirectByteBufferWithNonChannelSocket"ORBUTIL.unexpectedDirectByteBufferWithNonChannelSocket"ORBUTIL.unexpectedNonDirectByteBufferWithChannelSocket"ORBUTIL.unexpectedNonDirectByteBufferWithChannelSocket"ORBUTIL.invalidContactInfoListIteratorFailureException"ORBUTIL.invalidContactInfoListIteratorFailureException"ORBUTIL.remarshalWithNowhereToGo"ORBUTIL.remarshalWithNowhereToGo"ORBUTIL.exceptionWhenSendingCloseConnection"ORBUTIL.exceptionWhenSendingCloseConnection"ORBUTIL.invocationErrorInReflectiveTie"ORBUTIL.invocationErrorInReflectiveTie"ORBUTIL.badHelperWriteMethod"ORBUTIL.badHelperWriteMethod"ORBUTIL.badHelperReadMethod"ORBUTIL.badHelperReadMethod"ORBUTIL.badHelperIdMethod"ORBUTIL.badHelperIdMethod"ORBUTIL.writeUndeclaredException"ORBUTIL.writeUndeclaredException"ORBUTIL.readUndeclaredException"ORBUTIL.readUndeclaredException"ORBUTIL.unableToSetSocketFactoryOrb"ORBUTIL.unableToSetSocketFactoryOrb"ORBUTIL.unexpectedException"ORBUTIL.unexpectedException"ORBUTIL.noInvocationHandler"ORBUTIL.noInvocationHandler"ORBUTIL.invalidBuffMgrStrategy"ORBUTIL.invalidBuffMgrStrategy"ORBUTIL.javaStreamInitFailed"ORBUTIL.javaStreamInitFailed"ORBUTIL.duplicateOrbVersionServiceContext"ORBUTIL.duplicateOrbVersionServiceContext"ORBUTIL.duplicateSendingContextServiceContext"ORBUTIL.duplicateSendingContextServiceContext"ORBUTIL.workQueueThreadInterrupted"ORBUTIL.workQueueThreadInterrupted"ORBUTIL.workerThreadCreated"ORBUTIL.workerThreadCreated"ORBUTIL.workerThreadThrowableFromRequestWork"ORBUTIL.workerThreadThrowableFromRequestWork"ORBUTIL.workerThreadNotNeeded"ORBUTIL.workerThreadNotNeeded"ORBUTIL.workerThreadDoWorkThrowable"ORBUTIL.workerThreadDoWorkThrowable"ORBUTIL.workerThreadCaughtUnexpectedThrowable"ORBUTIL.workerThreadCaughtUnexpectedThrowable"ORBUTIL.workerThreadCreationFailure"ORBUTIL.workerThreadCreationFailure"ORBUTIL.workerThreadSetNameFailure"ORBUTIL.workerThreadSetNameFailure"ORBUTIL.workQueueRequestWorkNoWorkFound"ORBUTIL.workQueueRequestWorkNoWorkFound"ORBUTIL.threadPoolCloseError"ORBUTIL.threadPoolCloseError"ORBUTIL.threadGroupIsDestroyed"ORBUTIL.threadGroupIsDestroyed"ORBUTIL.threadGroupHasActiveThreadsInClose"ORBUTIL.threadGroupHasActiveThreadsInClose"ORBUTIL.threadGroupHasSubGroupsInClose"ORBUTIL.threadGroupHasSubGroupsInClose"ORBUTIL.threadGroupDestroyFailed"ORBUTIL.threadGroupDestroyFailed"ORBUTIL.interruptedJoinCallWhileClosingThreadPool"ORBUTIL.interruptedJoinCallWhileClosingThreadPool"ORBUTIL.chunkOverflow"ORBUTIL.chunkOverflow"ORBUTIL.unexpectedEof"ORBUTIL.unexpectedEof"ORBUTIL.readObjectException"ORBUTIL.readObjectException"ORBUTIL.characterOutofrange"ORBUTIL.characterOutofrange"ORBUTIL.dsiResultException"ORBUTIL.dsiResultException"ORBUTIL.iiopinputstreamGrow"ORBUTIL.iiopinputstreamGrow"ORBUTIL.endOfStream"ORBUTIL.endOfStream"ORBUTIL.invalidObjectKey"ORBUTIL.invalidObjectKey"ORBUTIL.malformedUrl"ORBUTIL.malformedUrl"ORBUTIL.valuehandlerReadError"ORBUTIL.valuehandlerReadError"ORBUTIL.valuehandlerReadException"ORBUTIL.valuehandlerReadException"ORBUTIL.badKind"ORBUTIL.badKind"ORBUTIL.cnfeReadClass"ORBUTIL.cnfeReadClass"ORBUTIL.badRepIdIndirection"ORBUTIL.badRepIdIndirection"ORBUTIL.badCodebaseIndirection"ORBUTIL.badCodebaseIndirection"ORBUTIL.unknownCodeset"ORBUTIL.unknownCodeset"ORBUTIL.wcharDataInGiop10"ORBUTIL.wcharDataInGiop10"ORBUTIL.negativeStringLength"ORBUTIL.negativeStringLength"ORBUTIL.expectedTypeNullAndNoRepId"ORBUTIL.expectedTypeNullAndNoRepId"ORBUTIL.readValueAndNoRepId"ORBUTIL.readValueAndNoRepId"ORBUTIL.unexpectedEnclosingValuetype"ORBUTIL.unexpectedEnclosingValuetype"ORBUTIL.positiveEndTag"ORBUTIL.positiveEndTag"ORBUTIL.nullOutCall"ORBUTIL.nullOutCall"ORBUTIL.writeLocalObject"ORBUTIL.writeLocalObject"ORBUTIL.badInsertobjParam"ORBUTIL.badInsertobjParam"ORBUTIL.customWrapperWithCodebase"ORBUTIL.customWrapperWithCodebase"ORBUTIL.customWrapperIndirection"ORBUTIL.customWrapperIndirection"ORBUTIL.customWrapperNotSingleRepid"ORBUTIL.customWrapperNotSingleRepid"ORBUTIL.badValueTag"ORBUTIL.badValueTag"ORBUTIL.badTypecodeForCustomValue"ORBUTIL.badTypecodeForCustomValue"ORBUTIL.errorInvokingHelperWrite"ORBUTIL.errorInvokingHelperWrite"ORBUTIL.badDigitInFixed"ORBUTIL.badDigitInFixed"ORBUTIL.refTypeIndirType"ORBUTIL.refTypeIndirType"ORBUTIL.badReservedLength"ORBUTIL.badReservedLength"ORBUTIL.nullNotAllowed"ORBUTIL.nullNotAllowed"ORBUTIL.unionDiscriminatorError"ORBUTIL.unionDiscriminatorError"ORBUTIL.cannotMarshalNative"ORBUTIL.cannotMarshalNative"ORBUTIL.cannotMarshalBadTckind"ORBUTIL.cannotMarshalBadTckind"ORBUTIL.invalidIndirection"ORBUTIL.invalidIndirection"ORBUTIL.indirectionNotFound"ORBUTIL.indirectionNotFound"ORBUTIL.recursiveTypecodeError"ORBUTIL.recursiveTypecodeError"ORBUTIL.invalidSimpleTypecode"ORBUTIL.invalidSimpleTypecode"ORBUTIL.invalidComplexTypecode"ORBUTIL.invalidComplexTypecode"ORBUTIL.invalidTypecodeKindMarshal"ORBUTIL.invalidTypecodeKindMarshal"ORBUTIL.unexpectedUnionDefault"ORBUTIL.unexpectedUnionDefault"ORBUTIL.illegalUnionDiscriminatorType"ORBUTIL.illegalUnionDiscriminatorType"ORBUTIL.couldNotSkipBytes"ORBUTIL.couldNotSkipBytes"ORBUTIL.badChunkLength"ORBUTIL.badChunkLength"ORBUTIL.unableToLocateRepIdArray"ORBUTIL.unableToLocateRepIdArray"ORBUTIL.badFixed"ORBUTIL.badFixed"ORBUTIL.readObjectLoadClassFailure"ORBUTIL.readObjectLoadClassFailure"ORBUTIL.couldNotInstantiateHelper"ORBUTIL.couldNotInstantiateHelper"ORBUTIL.badToaOaid"ORBUTIL.badToaOaid"ORBUTIL.couldNotInvokeHelperReadMethod"ORBUTIL.couldNotInvokeHelperReadMethod"ORBUTIL.couldNotFindClass"ORBUTIL.couldNotFindClass"ORBUTIL.badArgumentsNvlist"ORBUTIL.badArgumentsNvlist"ORBUTIL.stubCreateError"ORBUTIL.stubCreateError"ORBUTIL.javaSerializationException"ORBUTIL.javaSerializationException"ORBUTIL.genericNoImpl"ORBUTIL.genericNoImpl"ORBUTIL.contextNotImplemented"ORBUTIL.contextNotImplemented"ORBUTIL.getinterfaceNotImplemented"ORBUTIL.getinterfaceNotImplemented"ORBUTIL.sendDeferredNotimplemented"ORBUTIL.sendDeferredNotimplemented"ORBUTIL.longDoubleNotImplemented"ORBUTIL.longDoubleNotImplemented"ORBUTIL.noServerScInDispatch"ORBUTIL.noServerScInDispatch"ORBUTIL.orbConnectError"ORBUTIL.orbConnectError"ORBUTIL.adapterInactiveInActivation"ORBUTIL.adapterInactiveInActivation"ORBUTIL.locateUnknownObject"ORBUTIL.locateUnknownObject"ORBUTIL.badServerId"ORBUTIL.badServerId"ORBUTIL.badSkeleton"ORBUTIL.badSkeleton"ORBUTIL.servantNotFound"ORBUTIL.servantNotFound"ORBUTIL.noObjectAdapterFactory"ORBUTIL.noObjectAdapterFactory"ORBUTIL.badAdapterId"ORBUTIL.badAdapterId"ORBUTIL.dynAnyDestroyed"ORBUTIL.dynAnyDestroyed"ORBUTIL.requestCanceled"ORBUTIL.requestCanceled"ORBUTIL.unknownCorbaExc"ORBUTIL.unknownCorbaExc"ORBUTIL.runtimeexception"ORBUTIL.runtimeexception"ORBUTIL.unknownServerError"ORBUTIL.unknownServerError"ORBUTIL.unknownDsiSysex"ORBUTIL.unknownDsiSysex"ORBUTIL.unknownSysex"ORBUTIL.unknownSysex"ORBUTIL.wrongInterfaceDef"ORBUTIL.wrongInterfaceDef"ORBUTIL.noInterfaceDefStub"ORBUTIL.noInterfaceDefStub"ORBUTIL.unknownExceptionInDispatch"ORBUTIL.unknownExceptionInDispatch Log wrapper class for Sun private system exceptions in group ORBUTIL Generated from input file /jenkins/workspace/8-2-build-macosx-x86_64/jdk8u251/737/corba/src/share/classes/com/sun/corba/se/spi/logging/data/ORBUtil.mc on Thu Mar 12 02:38:10 PDT 2020/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/logging/POASystemException.java/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/logging/POASystemException.class/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/logging/POASystemException$1.class1001100210031004100510061007100810091010101110121013101410151016101710181019102010211022102310251026"POA"POAClass<POASystemException>"POA.servantManagerAlreadySet"POA.servantManagerAlreadySet"POA.destroyDeadlock"POA.destroyDeadlock"POA.servantOrb"POA.servantOrb"POA.badServant"POA.badServant"POA.illegalForwardRequest"POA.illegalForwardRequest"POA.badTransactionContext"POA.badTransactionContext"POA.badRepositoryId"POA.badRepositoryId"POA.invokesetup"POA.invokesetup"POA.badLocalreplystatus"POA.badLocalreplystatus"POA.persistentServerportError"POA.persistentServerportError"POA.servantDispatch"POA.servantDispatch"POA.wrongClientsc"POA.wrongClientsc"POA.cantCloneTemplate"POA.cantCloneTemplate"POA.poacurrentUnbalancedStack"POA.poacurrentUnbalancedStack"POA.poacurrentNullField"POA.poacurrentNullField"POA.poaInternalGetServantError"POA.poaInternalGetServantError"POA.makeFactoryNotPoa"POA.makeFactoryNotPoa"POA.duplicateOrbVersionSc"POA.duplicateOrbVersionSc"POA.preinvokeCloneError"POA.preinvokeCloneError"POA.preinvokePoaDestroyed"POA.preinvokePoaDestroyed"POA.pmfCreateRetain"POA.pmfCreateRetain"POA.pmfCreateNonRetain"POA.pmfCreateNonRetain"POA.policyMediatorBadPolicyInFactory"POA.policyMediatorBadPolicyInFactory"POA.servantToIdOaa"POA.servantToIdOaa"POA.servantToIdSaa"POA.servantToIdSaa"POA.servantToIdWp"POA.servantToIdWp"POA.cantResolveRootPoa"POA.cantResolveRootPoa"POA.servantMustBeLocal"POA.servantMustBeLocal"POA.noProfilesInIor"POA.noProfilesInIor"POA.aomEntryDecZero"POA.aomEntryDecZero"POA.addPoaInactive"POA.addPoaInactive"POA.illegalPoaStateTrans"POA.illegalPoaStateTrans"POA.unexpectedException"POA.unexpectedException"POA.singleThreadNotSupported"POA.singleThreadNotSupported"POA.methodNotImplemented"POA.methodNotImplemented"POA.poaLookupError"POA.poaLookupError"POA.poaInactive"POA.poaInactive"POA.poaNoServantManager"POA.poaNoServantManager"POA.poaNoDefaultServant"POA.poaNoDefaultServant"POA.poaServantNotUnique"POA.poaServantNotUnique"POA.poaWrongPolicy"POA.poaWrongPolicy"POA.findpoaError"POA.findpoaError"POA.poaServantActivatorLookupFailed"POA.poaServantActivatorLookupFailed"POA.poaBadServantManager"POA.poaBadServantManager"POA.poaServantLocatorLookupFailed"POA.poaServantLocatorLookupFailed"POA.poaUnknownPolicy"POA.poaUnknownPolicy"POA.poaNotFound"POA.poaNotFound"POA.servantLookup"POA.servantLookup"POA.localServantLookup"POA.localServantLookup"POA.servantManagerBadType"POA.servantManagerBadType"POA.defaultPoaNotPoaimpl"POA.defaultPoaNotPoaimpl"POA.wrongPoliciesForThisObject"POA.wrongPoliciesForThisObject"POA.thisObjectServantNotActive"POA.thisObjectServantNotActive"POA.thisObjectWrongPolicy"POA.thisObjectWrongPolicy"POA.noContext"POA.noContext"POA.incarnateReturnedNull"POA.incarnateReturnedNull"POA.jtsInitError"POA.jtsInitError"POA.persistentServeridNotSet"POA.persistentServeridNotSet"POA.persistentServerportNotSet"POA.persistentServerportNotSet"POA.orbdError"POA.orbdError"POA.bootstrapError"POA.bootstrapError"POA.poaDiscarding"POA.poaDiscarding"POA.otshookexception"POA.otshookexception"POA.unknownServerException"POA.unknownServerException"POA.unknownServerappException"POA.unknownServerappException"POA.unknownLocalinvocationError"POA.unknownLocalinvocationError"POA.adapterActivatorNonexistent"POA.adapterActivatorNonexistent"POA.adapterActivatorFailed"POA.adapterActivatorFailed"POA.badSkeleton"POA.badSkeleton"POA.nullServant"POA.nullServant"POA.adapterDestroyed"POA.adapterDestroyed Log wrapper class for Sun private system exceptions in group POA Generated from input file /jenkins/workspace/8-2-build-macosx-x86_64/jdk8u251/737/corba/src/share/classes/com/sun/corba/se/spi/logging/data/POA.mc on Thu Mar 12 02:38:10 PDT 2020/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/logging/UtilSystemException.java/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/logging/UtilSystemException.class/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/logging/UtilSystemException$1.class140114021403140414051406140714081409141014111412"UTIL"UTILClass<UtilSystemException>"UTIL.stubFactoryCouldNotMakeStub"UTIL.stubFactoryCouldNotMakeStub"UTIL.errorInMakeStubFromRepositoryId"UTIL.errorInMakeStubFromRepositoryId"UTIL.classCastExceptionInLoadStub"UTIL.classCastExceptionInLoadStub"UTIL.exceptionInLoadStub"UTIL.exceptionInLoadStub"UTIL.noPoa"UTIL.noPoa"UTIL.connectWrongOrb"UTIL.connectWrongOrb"UTIL.connectNoTie"UTIL.connectNoTie"UTIL.connectTieWrongOrb"UTIL.connectTieWrongOrb"UTIL.connectTieNoServant"UTIL.connectTieNoServant"UTIL.loadTieFailed"UTIL.loadTieFailed"UTIL.badHexDigit"UTIL.badHexDigit"UTIL.unableLocateValueHelper"UTIL.unableLocateValueHelper"UTIL.invalidIndirection"UTIL.invalidIndirection"UTIL.objectNotConnected"UTIL.objectNotConnected"UTIL.couldNotLoadStub"UTIL.couldNotLoadStub"UTIL.objectNotExported"UTIL.objectNotExported"UTIL.errorSetObjectField"UTIL.errorSetObjectField"UTIL.errorSetBooleanField"UTIL.errorSetBooleanField"UTIL.errorSetByteField"UTIL.errorSetByteField"UTIL.errorSetCharField"UTIL.errorSetCharField"UTIL.errorSetShortField"UTIL.errorSetShortField"UTIL.errorSetIntField"UTIL.errorSetIntField"UTIL.errorSetLongField"UTIL.errorSetLongField"UTIL.errorSetFloatField"UTIL.errorSetFloatField"UTIL.errorSetDoubleField"UTIL.errorSetDoubleField"UTIL.illegalFieldAccess"UTIL.illegalFieldAccess"UTIL.badBeginUnmarshalCustomValue"UTIL.badBeginUnmarshalCustomValue"UTIL.classNotFound"UTIL.classNotFound"UTIL.unknownSysex"UTIL.unknownSysex Log wrapper class for Sun private system exceptions in group UTIL Generated from input file /jenkins/workspace/8-2-build-macosx-x86_64/jdk8u251/737/corba/src/share/classes/com/sun/corba/se/spi/logging/data/Util.mc on Thu Mar 12 02:38:10 PDT 2020/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/monitoring/MonitoredAttributeInfoFactoryImpl.java/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/monitoringcom.sun.corba.se.impl.monitoringdescriptionisWritableisStatistic/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/monitoring/MonitoredAttributeInfoImpl.javaMonitoredAttributeInfoImplMonitoredAttributeInfoImpl(java.lang.String,java.lang.Class,boolean,boolean)/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/monitoring/MonitoredAttributeInfoImpl.class/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/monitoringstatisticFlagwritableFlag/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/monitoring/MonitoredObjectFactoryImpl.java/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/monitoring/MonitoredObjectImpl.javaMonitoredObjectImplMonitoredObjectImpl(java.lang.String,java.lang.String)/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/monitoring/MonitoredObjectImpl.classmonitoredAttributeschildren List of all child Monitored Objects All the Attributes of this Monitored Object instance Constructorcalls clearState() on all the registered children MonitoredObjects andMonitoredAttributes. First call clearState on all the local attributes next call clearState on all the children MonitoredObjects/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/monitoring/MonitoringManagerFactoryImpl.javamonitoringManagerTable/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/monitoring/MonitoringManagerFactoryImpl.classnameOfTheRoot/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/monitoring/MonitoringManagerImpl.javaMonitoringManagerImplMonitoringManagerImpl(java.lang.String,java.lang.String)/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/monitoring/MonitoringManagerImpl.classrootMonitoredObject/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/naming/cosnaming/BindingIteratorImpl.java/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/naming/cosnaming/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/namingcom.sun.corba.se.impl.naming.cosnaminghow_manyblh" 'how_many' parameter is set to 0 which is" +
            " invalid" 'how_many' parameter is set to 0 which is invalidnumberToGetBinding[]blbh Import general CORBA classes Import org.omg.CosNaming classesClass BindingIteratorImpl implements the org.omg.CosNaming::BindingIteratorinterface, but does not implement the method to retrieve the nextbinding in the NamingContext for which it was created. This is leftto a subclass, which is why this class is abstract; BindingIteratorImplprovides an implementation of the interface operations on top of twosubclass methods, allowing multiple implementations of iterators thatdiffer in storage and access to the contents of a NamingContextThe operation next_one() is implemented by the subclass, whereasnext_n() is implemented on top of the next_one() implementation.Destroy must also be implemented by the subclass.A subclass must implement NextOne() and Destroy(); thesemethods are invoked from synchronized methods and need thereforenot be synchronized themselves.Create a binding iterator servant.runs the super constructor.an ORB object.java.lang.Exceptiona Java exception.Return the next binding. It also returns true or false, indicatingwhether there were more bindings.The Binding as an out parameter.true if there were more bindings.org.omg.CORBA.SystemExceptionOne of a fixed set of CORBAsystem exceptions.NextOne NextOne actually returns the next oneReturn the next n bindings. It also returns true or false, indicatingThe number of requested bindings in the BindingList.The BindingList as an out parameter.lists next n bindings. It returns true or false, indicatingwhether there were more bindings. This method has the package privatescope, It will be called from NamingContext.list() operation orthis.next_n(). Take the smallest of what's left and what's being asked for Create a resulting BindingList Keep iterating as long as there are entries Found any at all? No Set into holderDestroy this BindingIterator object. The object corresponding to thisobject reference is destroyed.Destroy Destroy actually destroysAbstract method for returning the next binding in the NamingContextfor which this BindingIterator was created.Abstract method for destroying this BindingIterator.Abstract method for returning the remaining number of elements.the remaining number of elements in the iterator./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/naming/cosnaming/InterOperableNamingImpl.javaorg.omg.CosNaming.NamingContextExtPackageencodeencode(java.lang.String)/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/naming/cosnaming/InterOperableNamingImpl.class/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/naming/cosnaming/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/namingcleanEscapeCharactercleanEscapeCharacter(java.lang.String)createNameComponentFromStringcreateNameComponentFromString(java.lang.String)StringComponentsFromIndicesStringComponentsFromIndices(int[],int,java.lang.String)breakStringToNameComponentsbreakStringToNameComponents(java.lang.String)addEscapeaddEscape(java.lang.String)convertNameComponentToStringconvertNameComponentToString(org.omg.CosNaming.NameComponent)NameComponent[]theNameComponentstheConvertedStringtheNameComponenttheNewValue'\\'\theStringifiedNametheStringifiedNameComponentstheIndices100theIndicesIndextempStringindicesCounttheStringComponentsfirstIndexlastIndextheStringifiedNameComponentkindfoundtheStringdesttheurl"corbaname:"corbaname:"#"stringToEncodetheStringAfterEscapebyteCount';''?''@'@'&'&'=''$'$'_'_'!'!'~'~'*''('')'hexString'%'% Import org.omg.CosNaming typesClass InteroperableNamingImpl implements the methods definedfor NamingContextExt which is part of Interoperable NamingService specifications. This class is added for doing moreof Parsing and Building of Stringified names according to INSSpec.Method which stringifies the Name Components given as the inputArray of Name Components (Simple or Compound Names)string which is the stringified reference.This method converts a single Namecomponent to String, By adding EscapesIf neccessary.This method adds escape '\' for the Namecomponent if neccessary Adding escape for the "."Method which converts the Stringified name into Array of Name Components.which is the stringified name.Step1 in converting Stringified name into  array of Name Componentis breaking the String into multiple name components This is the end of all the occurence of '/' and hence come out of the loop If the '/' is found, first check whether it is preceded by escape '\' If not then set theIndices and increment theIndicesIndex and also set the index else just ignore the '/'This method breaks one big String into multiple substrings basedon the array of index passed in. This is done for the last componentStep 2: After Breaking the Stringified name into set of NameComponentStrings, The next step is to create Namecomponents from the substringby removing the escapes if there are any. If any of the above is true, then we create an invalid Name Component to indicate that it is an invalid name. The format could be XYZ (Without kind) The format is .XYZ (Without ID) This check is for the Namecomponent which is just "." meaning Id and Kinds are null No more '.', which means there is no KindThis method cleans the escapes in the Stringified name and returns thecorrect String If there is a AlphaNumeric character after a \ then include slash, as it is not intended as an escape character.Method which converts the Stringified name  and Host Name Address intoa URL based Namewhich is ip based host nameurl based Name.Encodes the string according to RFC 2396 IETF spec required by INS. Do no Escape for characters in this list RFC 2396 Add escape/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/naming/cosnaming/InternalBindingKey.javahashVal/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/naming/cosnaming/InternalBindingKey.classkindLenidLenClass InternalBindingKey implements the necessary wrapper codearound the org.omg.CosNaming::NameComponent class to implement the properequals() method and the hashCode() method for use in a hash table.It computes the hashCode once and stores it, and also precomputesthe lengths of the id and kind strings for faster comparison. A key contains a name Default Constructor Normal constructor Setup the object Precompute lengths and values since they will not change Compare the keys by comparing name's id and kind Both lengths must match If id is set is must be equal If kind is set it must be equal Must be the same Return precomputed value/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/naming/cosnaming/InternalBindingValue.javaClass InternalBindingKey acts as a container for two objects, namelya org.omg.CosNaming::Binding and an CORBA object reference, which are the twocomponents associated with the binding. Default constructor/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/naming/cosnaming/NamingContextDataStore.javabtbthbiThis interface defines a set of methods that must be implemented by the"data store" associated with a NamingContext implementation.It allows for different implementations of naming contexts thatsupport the same API but differ in storage mechanism.Method which implements binding a name to an object asthe specified binding type.a NameComponent which is the name under which the objectwill be bound.the object reference to be bound.Type of binding (as object or as context).One of a fixed set of CORBA system exceptions.Method which implements resolving the specified name,returning the type of the binding and the bound object reference.If the id and kind of the NameComponent are both empty, the initialnaming context (i.e., the local root) must be returned.a NameComponent which is the name to be resolved.the BindingType as an out parameter.the object reference bound under the supplied name.Method which implements unbinding a name.the object reference bound to the name, or null if not found.Method which implements listing the contents of thisNamingContext and return a binding list and a binding iterator.The BindingIterator as an out parameter.Method which implements creating a new NamingContext.an object reference for a new NamingContext object implementedby this Name Server.Method which implements destroying this NamingContext.Method which returns whether this NamingContext is emptyor not.true if this NamingContext contains no bindings./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/naming/cosnaming/NamingContextImpl.javaorg.omg.CosNaming.NamingContextPackage/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/naming/cosnaming/NamingContextImpl.classinsImplstaticWrapperlifecycleLoggerupdateLoggerreadLoggerpoa" unsuccessful because NULL Object cannot be Bound " unsuccessful because NULL Object cannot be Bound " Name = " Name = nc" NULL Context cannot be Bound " NULL Context cannot be Bound "Naming Context should not be null "Naming Context should not be null " NULL Object cannot be Bound " NULL Object cannot be Bound " is already bound to a Naming Context" is already bound to a Naming Context" is already bound to a CORBA Object" is already bound to a CORBA Object" Name: " Name: "list("list(") -> bindings[") -> bindings["] + iterator: "] + iterator: "Creating New Naming Context "Creating New Naming Context nctxrnc"bind_new_context "bind_new_context "New Context Bound To "New Context Bound To "Destroying Naming Context "Destroying Naming Context " NamingContext children are not destroyed still.." NamingContext children are not destroyed still..rebindtailobjContexttopRefsnurlBasedAddress"{""NamingContextImpl("NamingContextImpl(" at " at " ems): " ems):  Imports for LoggingClass NamingContextImpl implements the org.omg.CosNaming::NamingContextinterface, but does not implement the methods associated withmaintaining the "table" of current bindings in a NamingContext.Instead, this implementation assumes that the derived implementationimplements the NamingContextDataStore interface, which has the necessarymethods. This allows multipleNamingContext implementations that differ in storage of the bindings,as well as implementations of interfaces derived fromCosNaming::NamingContext that still reuses the implementation.The operations bind(), rebind(), bind_context() and rebind_context()are all really implemented by doBind(). resolve() is really implementedby doResolve(), unbind() by doUnbind(). list(), new_context() anddestroy() uses the NamingContextDataStore interface directly. All thedoX() methods are public static.They synchronize on the NamingContextDataStore object.An implementation a NamingContext must extend this class and implementthe NamingContextDataStore interface with the operations:Bind(), Resolve(),Unbind(), List(), NewContext() and Destroy(). Callsto these methods are synchronized; these methods shouldtherefore not be synchronized. The grammer for Parsing and Building Interoperable Stringified Names are implemented in this classCreate a naming context servant.Runs the super constructor.Bind an object under a name in this NamingContext. If the namecontains multiple (n) components, n-1 will be resolved in thisNamingContext and the object bound in resulting NamingContext.An exception is thrown if a binding with the supplied name alreadyexists. If theobject to be bound is a NamingContext it will not participate ina recursive resolve.a sequence of NameComponents which is the name under whichthe object will be bound.org.omg.CosNaming.NamingContextPackage.NotFoundA name withmultiple components was supplied, but the first component could not beresolved.org.omg.CosNaming.NamingContextPackage.CannotProceedCouldnot proceed in resolving the n-1 components of the supplied name.org.omg.CosNaming.NamingContextPackage.InvalidNameThesupplied name is invalid (i.e., has length less than 1).org.omg.CosNaming.NamingContextPackage.AlreadyBoundAn objectis already bound under the supplied name.doBind doBind implements all four flavors of binding isLoggable call to make sure that we save some precious processor cycles, if there is no need to log.Bind a NamingContext under a name in this NamingContext. If the nameexists. The NamingContext will participate in recursive resolving.the NamingContect object reference to be bound.If a binding under the supplied name already exists it will beunbound first. If theCould notproceed in resolving the n-1 components of the supplied name. This should not happencontains multiple (n) components, the first n-1 components will beresolved in this NamingContext and the object bound in resultingNamingContext. If a binding under the supplied name already exists itwill be unbound first. The NamingContext will participate in recursiveresolving.Resolve a name in this NamingContext and return the object referencebound to the name. If the name contains multiple (n) components,the first component will be resolved in this NamingContext and theremaining components resolved in the resulting NamingContext, providedthat the NamingContext bound to the first component of the name wasbound with bind_context().a sequence of NameComponents which is the name to be resolved.doResolve doResolve actually resolvesRemove a binding from this NamingContext. If the name containsmultiple (n) components, the first n-1 components will be resolvedfrom this NamingContext and the final component unbound inthe resulting NamingContext.a sequence of NameComponents which is the name to be unbound.doUnbind doUnbind actually unbindsList the contents of this NamingContest. A sequence of bindingsis returned (a BindingList) containing up to the number of requestedbindings, and a BindingIterator object reference is returned foriterating over the remaining bindings.BindingListHolderBindingIteratorImpl List actually generates the listCreate a NamingContext object and return its object reference. Create actually creates a new naming context If naming context is null, then that must be a serious error.Create a new NamingContext, bind it in this Naming Context and returnits object reference. This is equivalent to using new_context() followedby bind_context() with the supplied name and the object reference forthe newly created NamingContext.by this Name Server, bound to the supplied name.new_contextbind_context The obvious solution:Destroy this NamingContext object. If this NamingContext containsno bindings, the NamingContext is deleted.org.omg.CosNaming.NamingContextPackage.NotEmptyThisNamingContext is not empty (i.e., contains bindings). The context is empty so it can be destroyed This context is not empty! Not a fatal error, warning should do.Implements all four flavors of binding. It uses Resolve() tocheck if a binding already exists (for bind and bind_context), andunbind() to ensure that a binding does not already exist.If the length of the name is 1, then Bind() is called withthe name and the object to bind. Otherwise, the first componentof the name is resolved in this NamingContext and the appropriateform of bind passed to the resulting NamingContext.This method is static for maximal reuse - even for extended namingcontext implementations where the recursive semantics still apply.an implementation of NamingContextDataStoreReplace an existing binding or not.Could not     * proceedin resolving the first component of the supplied name.resolveunbindrebind_context Valid name? At bottom level? The identifier must be set Ensure synchronization of backend Yes: bind object in this context under the name Refer Naming Service Doc:00-11-01 section 2.2.3.4 If there is an object already bound with the name and the binding type is not ncontext a NotFound Exception with a reason of not a context has to be raised. Fix for bug Id: 4384628 Previously a Context was bound and now trying to bind Object. It is invalid. "Resistence is futile." [Borg pickup line] Now there are no other bindings under this name No: bind in a different context Compute tail How should we propagate the bind Bind as object Narrow to a naming context using Java casts. It must work. Bind as contextImplements resolving names in this NamingContext. The first componentof the supplied name is resolved in this NamingContext by callingResolve(). If there are no more components in the name, theresulting object reference is returned. Otherwise, the resulting objectreference must have been bound as a context and be narrowable toa NamingContext. If this is the case, the remainingcomponents of the name is resolved in the resulting NamingContext.proceedThe suppliedname is invalid (i.e., has length less than 1).One of a fixed set of CORBA systemexceptions. Length must be greater than 0 Resolve first level in this context Object was not found n.length > 1 Compute restOfName = name[1..length] Resolve rest of name in context First try to resolve using the local call, this should work most of the time unless there are federated naming contexts.Implements unbinding bound names in this NamingContext. If thename contains only one component, the name is unbound in thisNamingContext using Unbind(). Otherwise, the first componentof the name is resolved in this NamingContext andunbind passed to the resulting NamingContext.A name with multiplecomponents was supplied, but the first component could not beCould not proceedin resolving the n-1 components of the supplied name.The supplied nameis invalid (i.e., has length less than 1). Name valid? Unbind here? Yes: unbind in this context It was not bound Done No: unbind in a different context Resolve first  - must be resolveable Propagate unbind to this contextImplements resolving a NameComponent in this context andnarrowing it to CosNaming::NamingContext. It will throw appropriateexceptions if not found or not narrowable.a NameComponents which is the name to be found.first component could not be resolved. Was it bound as a context? It was not a context Narrow to a naming context Hmm. must be okThis operation creates a stringified name from the array of Namecomponents.Name of the object <p>org.omg.CosNaming.NamingContextExtPackage.InvalidNameIndicates the name does not identify a binding.<p>This operation  converts a Stringified Name into an  equivalent arrayof Name Components.Stringified Name of the object <p> If there is a name component whose id and kind null or zero length string, then an invalid name exception needs to beThis operation creates a URL based "iiopname://" format namefrom the Stringified Name of the object.internet based address of the host machine whereName Service is running <p>org.omg.CosNaming.NamingContextPackage.InvalidAddressIndicates the internet based address of the host machine isincorrect <p> Extra check to see that corba name url created is valid as per INS spec grammer.This operation resolves the Stringified name into the objectreference.Indicates there is no object reference for the given name. <p>Indicates that the given compound name is incorrect <p>Indicates the name is already bound.<p> Debugging aids./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/naming/cosnaming/NamingUtils.javagetDirectoryStructuredNamegetDirectoryStructuredName(org.omg.CosNaming.NameComponent[])/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/naming/cosnaming/NamingUtils.classNamingUtilsNamingUtils()logFilelogOStreamlogDStream"Debug Stream Enabled."Debug Stream Enabled.errFileerrOStreamerrDStream"Error stream setup completed."Error stream setup completed.directoryStructuredName Do not instantiate this classDebug flag which must be true for debug streams to be created anddprint output to be generated.Prints the message to the debug stream if debugging is enabled.the debug message to print.Prints the message to the error stream (System.err is default).the error message to print.Prints the stacktrace of the supplied exception to the error stream.any Java exception.Create a debug print stream to the supplied log file.the file to which debug output will go.thrown if the file cannot be opened for output. Create an outputstream for debugging Emit first messageCreate a error print stream to the supplied file.the file to which error messages will go. Create an outputstream for errorsA utility method that takes Array of NameComponent and convertsinto a directory structured name in the format of /id1.kind1/id2.kind2..This is used mainly for Logging.The debug printstream.The error printstream./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/naming/cosnaming/TransientBindingIterator.javatheEnumeration/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/naming/cosnaming/TransientBindingIterator.classtheHashtablecurrentSizensPOAaTablethePOAhasMore"BindingIterator.Destroy():caught exception:"BindingIterator.Destroy():caught exception: Get org.omg.CosNaming Types Get base implementation Get a hash tableClass TransientBindingIterator implements the abstract methodsdefined by BindingIteratorImpl, to use with the TransientNamingContextimplementation of the NamingContextImpl. The TransientBindingIteratorimplementation receives a hash table of InternalBindingValues, and usesan Enumeration to iterate over the contents of the hash table.TransientNamingContext There is only one POA used for both TransientNamingContext and TransientBindingIteraor servants.Constructs a new TransientBindingIterator object.a org.omg.CORBA.ORB object.A hashtable containing InternalBindingValues which isthe content of the TransientNamingContext.Exceptiona Java exception thrown of the base class cannotinitialize.Returns the next binding in the NamingContext. Uses the enumerationobject to determine if there are more bindings and if so, returnsthe next binding from the InternalBindingValue. If there are more elements get the next element Return empty but marshalable bindingDestroys this BindingIterator by disconnecting from the ORB Remove the object from the Active Object Map.Returns the remaining number of elements in the iterator./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/naming/cosnaming/TransientNameServer.javaTransientNameServerTransientNameServer()/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/naming/cosnaming/TransientNameServer.classinitializeRootNamingContextinitializeRootNamingContext(org.omg.CORBA.ORB)coreORBtnsinvalidHostOptionorbInitialPort0corbnsstringifiedIORsync"Transient name server started with args "Transient name server started with args ipshostName"-ORBInitialPort"-ORBInitialPort"-ORBInitialHost"-ORBInitialHost"ORB object returned from init: "ORB object returned from init: "NamingService"NamingService"tnameserv.exception"tnameserv.exception"tnameserv.usage"tnameserv.usage"name service created"name service created"tnameserv.hs1"tnameserv.hs1"tnameserv.hs2"tnameserv.hs2"tnameserv.hs3"tnameserv.hs3"tnameserv.invalidhostoption"tnameserv.invalidhostoption"tnameserv.orbinitialport0"tnameserv.orbinitialport0Class TransientNameServer is a standalone application whichimplements a transient name service. It uses the TransientNameServiceclass for the name service implementation, and the BootstrapServerfor implementing bootstrapping, i.e., to get the initial NamingContext.The BootstrapServer uses a Properties object specify the initial serviceobject references supported; such as Properties object is created containingonly a "NameService" entry together with the stringified object referencefor the initial NamingContext. The BootstrapServer's listening portis set by first checking the supplied arguments to the name server(-ORBInitialPort), and if not set, defaults to the standard port number.The BootstrapServer is created supplying the Properties object, using noexternal File object for storage, and the derived initial port number.TransientNameServiceBootstrapServer If debug was compiled to be true for testing purposes, don't change it.Main startup routine. It instantiates a TransientNameServiceobject and a BootstrapServer object, and then allows invocations tohappen.an array of strings representing the startup arguments. Determine the initial bootstrap port to use Create an ORB object Try environment -Dorg.omg.CORBA.ORBInitialPort=0 is invalid do nothing Let arguments override Was the initial port specified? -ORBInitialPort 0 is invalid If initialPort is not set, then we need to set the Default Initial Port Property for the ORB Set -ORBInitialPort = Persistent Server Port so that ORBImpl will start Boot Strap. This is used for handshaking by the IBM test framework! Do not modify, unless another synchronization protocol is used to replace this hack! Serve objects. Let the User Know that -ORBInitialHost is not valid for tnameserver Let the User Know that -ORBInitialPort 0 is not valid forPrivate constructor since no object of this type should be instantiated./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/naming/cosnaming/TransientNameService.javatheInitialNamingContext/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/naming/cosnaming/TransientNameService.classinitializeinitialize(com.sun.corba.se.spi.orb.ORB,java.lang.String)"NameService"NameServiceserviceNamenameServiceNamerootPOApoaPolicy"TNameService"TNameServiceinitialContextrootContextId Get CORBA type Get org.omg.CosNaming types Import transient naming contextClass TransientNameService implements a transient name serviceusing TransientNamingContexts and TransientBindingIterators, whichimplement the org.omg.CosNaming::NamingContext and org.omg.CosNaming::BindingIteratorinterfaces specfied by the OMG Common Object Services Specification.The TransientNameService creates the initial NamingContext object.NamingContextImplTransientBindingIteratorConstructs a new TransientNameService, and creates an initialNamingContext, whose objectreference can be obtained by the initialNamingContext method.The ORB objectorg.omg.CORBA.INITIALIZEThrown ifthe TransientNameService cannot initialize. Default constructor uses "NameService" as the key for the Root Naming Context. If default constructor is used then INS's object key for Transient Name Service is "NameService"nameserviceNameStringified key used for INS Service registry This constructor gives the flexibility of providing the Object Key for the Root Naming Context that is registered with INS.This method initializes Transient Name Service by associating Rootcontext with POA and registering the root context with INS Object Keymap. Create an initial contextReturn the initial NamingContext.the object reference for the initial NamingContext. The initial naming context for this name service/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/naming/cosnaming/TransientNamingContext.java/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/naming/cosnaming/TransientNamingContext.classgetName(org.omg.CosNaming.NameComponent)initial"Root TransientNamingContext LIFECYCLE.CREATED"Root TransientNamingContext LIFECYCLE.CREATEDoldValue"Name "Name " Was Already Bound" Was Already Bound"Name Component: "Name Component: "Namecomponent :"Namecomponent :" There was no binding with the name " There was no binding with the name " to Unbind " to Unbind " NameComponent:  " NameComponent:  bindingIteratorbindingReftransContext"TransientNamingContext " +
                "LIFECYCLE.CREATE SUCCESSFUL"TransientNamingContext LIFECYCLE.CREATE SUCCESSFULClass TransientNamingContext implements the methods definedby NamingContextDataStore, and extends the NamingContextImpl class toprovide a servant implementation of CosNaming::NamingContext.The TransientNamingContext uses a hash tableto store the mappings between bindings and object references and thehash table is not persistent; thereby the name "transient".This class should not be used directly; instead, the classTransientNameService should be instantiated.The keys in the hash table are InternalBindingKey objects, containinga single NameComponent and implementing the proper functions, i.e.,equals() and hashCode() in an efficient manner. The values in the hashtable are InternalBindingValues and store a org.omg.CosNaming::Binding andthe object reference associated with the binding. For iteration,TransientBindingIterator objects are created, which are passed a clonedcopy of the hashtable. Since elements are inserted and deleted andnever modified, this provides stable iterators at the cost of cloningthe hash table.To create and destroy object references, the TransientNamingContextuses the orb.connect() and orb.disconnect() methods.NamingContextDataStore XXX: the wrapper calls are all preceded by logger updates. These can be combined, and then we simply use 3 NamingSystemException wrappers, for read, update, and lifecycl.Constructs a new TransientNamingContext object.an orb object.the initial naming context.Binds the object to the name component as the specified binding type.It creates a InternalBindingKey object and a InternalBindingValueobject and inserts them in the hash table.A single org.omg.CosNaming::NameComponent under which theobject will be bound.An object reference to be bound under the supplied name.The type of the binding (i.e., as object or as context). Create a key and a value insert itResolves the supplied name to an object reference and returnsthe type of the resolved binding. It creates a InternalBindingKeyand uses the key for looking up in the hash table. If nothingis found an exception is thrown, otherwise the object referenceis returned and the binding type set.the object reference bound under the supplied name, null if notfound. Is the initial naming context requested? Create a key and lookup the value Copy out binding type and object referenceDeletes the binding with the supplied name. It creates aInternalBindingKey and uses it to remove the value associatedwith the key. If nothing is found an exception is thrown, otherwisethe element is removed from the hash table.a NameComponent which is the name to unbind Create a key and remove it from the hashtable Return what was foundList the contents of this NamingContext. It creates a newTransientBindingIterator object and passes it a clone of thehash table and an orb object. It then uses thenewly created object to return the required number of bindings. Create a new binding iterator servant with a copy of this hashtable. nsPOA is passed to the object so that it can de-activate itself from the Active Object Map when Binding Iterator.destroy is called. Have it set the binding list Get the object reference for the binding iterator servant Convert to a CORBA system exceptionCreate a new NamingContext. It creates a new TransientNamingContextobject, passing it the orb object. Create a new servantDestroys this NamingContext by disconnecting from the ORB. Destroy the object reference by disconnecting from the ORBA Utility Method For Logging..Return whether this NamingContext contains any bindings. It forwardsthis request to the hash table. A hashtable to store the bindingsThe local root naming context./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/naming/namingutil/CorbalocURL.java/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/naming/namingutilcom.sun.corba.se.impl.naming.namingutilgetIPV6HostgetIPV6Host(java.lang.String)/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/naming/namingutil/CorbalocURL.class/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/naming/namingutilgetIPV6PortgetIPV6Port(java.lang.String)handleRIRColonhandleRIRColon(java.lang.String)handleColonhandleColon(java.lang.String)handleIIOPColonhandleIIOPColon(java.lang.String)badAddressbadAddress(java.lang.Throwable)aURLendIndexendpointInfoiiopEndpointInfo"iiop:"iiop:"rir:"rir:iiopInfohostandporttokenizer"@"tokenCountdotsquareBracketBeginIndexipv6PortrirInfosquareBracketEndIndex']'"Host and Port is not separated by ':'"Host and Port is not separated by ':'ipv6HostThe corbaloc: URL definitions from the -ORBInitDef and -ORBDefaultInitDef'swill be parsed and converted to  this object. This object is capable ofstoring multiple  Host profiles as defined in the CorbaLoc grammer.HemanthThis constructor parses the URL and initializes all the variables. Oncethe URL Object is constructed it is immutable. URL parameter is acorbaloc: URL string with 'corbaloc:' prefix stripped. First Clean the URL Escapes if there are any There is something wrong with the URL escapes used so throw an exception If there is no '/' then the endIndex is at the end of the URL _REVISIT_: Add a testcase to check 'corbaloc:/' The url starts with a '/', it's an error Anything between corbaloc: and / is the host,port information of the server where the Service Object is located There should be atleast one token, because there are checks to make sure that there is host information before the delimiter '/'. So no need to explicitly check for number of tokens != 0 Right now we are not allowing any other protocol other than iiop:, rir: so raise exception indicating that the URL is malformed Add the Host information if RIR flag is set, If RIR is set then it means use the internal Boot Strap protocol for Key String resolution If there is something after corbaloc:endpointInfo/ then that is the keyStringA Utility method to throw BAD_PARAM exception to signal malformedINS URL.If there is 'iiop:' token in the URL, this method will parsesand  validates that host and port information. Check the iiop syntaxThis is to handle the case of host information with no 'iiop:' prefix.instead if ':' is specified then iiop is assumed. String after ":" The format can be 1.2@<host>:<port> There can be 1 or 2 tokens with '@' as the delimiter  - if there is only 1 token then there is no GIOP version    information.  A Default GIOP version of 1.2 is used.  - if there are 2 tokens then there is GIOP version is specified  - if there are no tokens or more than 2 tokens, then that's an    error There is VersionInformation after iiop: There is a version without ., which means Malformed list A Hack to differentiate IPV6 address from IPV4 address, Current Resolution is to use [ ] to differentiate ipv6 host ipv6Host should be enclosed in [ ], if not it will result in a BAD_PARAM exception There are three possible cases here 1. Host and Port is explicitly specified by using ":" as a    a separator 2. Only Host is specified without the port 3. HostAndPort info is null Case 1: There is Host and Port Info Case 2: Only Host is specified. iiopEndpointInfo is initialized to use the default INS port, if no port is specified Case 3: If no Host and Port info is provided then we use the the default LocalHost and INSPort. iiopEndpointInfo is already initialized with this info. Any kind of Exception is bad here. Possible causes: A Number Format exception because port info is malformedValidate 'rir:' case.Returns an IPV6 Port that is after [<ipv6>]:. There is no validationdone here, if it is an incorrect port then the request throughthis URL results in a COMM_FAILURE, otherwise malformed list willresult in BAD_PARAM exception thrown in checkcorbalocGrammer. If there is port information, then it has to be after ] bracket indexOf returns the count from the index of zero as the base, so equality check requires squareBracketEndIndex + 1. PortInformation  should be after ']:' delimiter If there is an exception then it will be caught in checkcorbaGrammer method and rethrown as BAD_PARAMReturns an IPV6 Host that is inside [ ] tokens. There is no validationdone here, if it is an incorrect IPV6 address then the request through get the host between [ ]Will be true only in CorbanameURL class./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/naming/namingutil/CorbanameURL.javacopyINSURLcopyINSURL(com.sun.corba.se.impl.naming.namingutil.INSURL)/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/naming/namingutil/CorbanameURL.classdelimiterIndexcorbalocString"corbaloc:"corbaloc:insURLThe corbaname: URL definitions from the -ORBInitDef and -ORBDefaultInitDef'swill be stored in this object. This object is capable of storing CorbaLocprofiles as defined in the CorbaName grammer.@AuthorThis constructor takes a corbaname: url with 'corbaname:' prefix strippedand initializes all the variables accordingly. If there are any parsingerrors then BAD_PARAM exception is raised. Append corbaloc: for Grammar check, Get the string between corbaname: and # which forms the corbaloc string Build a corbaloc string to check the grammar. 10 is the length of corbaname: If the string doesnot end with a / then add one to end the URL correctly Check the corbaloc grammar and set the returned corbaloc object to the CorbaName Object String after '#' is the Stringified name used to resolve the Object reference from the rootnaming context. If the String is null then the Root Naming context is passed backA Utility method to throw BAD_PARAM exception.A Utility method to copy all the variables from CorbalocURL object tothis instance./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/naming/namingutil/IIOPEndpointInfo.javaIIOPEndpointInfoIIOPEndpointInfo()/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/naming/namingutil/IIOPEndpointInfo.classtheHosttheMajortheMinor" Major -> " Major -> " Minor -> " Minor -> "host -> "host -> "port -> "port -> EndpointInfo is used internally by CorbaLoc object to store thehost information used in creating the Service Object referencefrom the -ORBInitDef and -ORBDefaultInitDef definitions. Version information Host Name and Port Number Default IIOP Version Default host is localhost Default INS PortInternal Debug Method./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/naming/namingutil/INSURL.javaINS URL is a generic interface for two different types of URL's specifiedin INS spec. There can be one or more Endpoint's in the URL, so the return value is a List This method will return true only in CorbanameURL, It is provided because corbaname: URL needs special handling. A debug method, which is not required for normal operation/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/naming/namingutil/INSURLBase.java"URL Dump..."URL Dump..."Key String = "Key String = "RIR Flag = "RIR Flag = "isCorbanameURL = "isCorbanameURL = "Stringified Name = "Stringified Name = will be stored in this object. This object is capable of storing multipleHost profiles as defined in the CorbaLoc grammer. If rirFlag is set to true that means internal boot strapping technique will be used. If set to false then the EndpointInfo will be used to create the Service Object reference./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/naming/namingutil/INSURLHandler.javaINSURLHandlerINSURLHandler()/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/naming/namingutil/INSURLHandler.classCORBANAME_PREFIX_LENGTHCORBALOC_PREFIX_LENGTHinsURLHandleraUrlThis class is the entry point to parse different types of INS URL's. Length of corbaloc: Length of corbaname:/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/naming/namingutil/NamingConstants.javaConstants specific to INS parsing and validation. iiop length rir: length/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/naming/namingutil/Utility.javavalidateGIOPVersionvalidateGIOPVersion(com.sun.corba.se.impl.naming.namingutil.IIOPEndpointInfo)/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/naming/namingutil/Utility.classhexOfhexOf(char)cleanEscapescleanEscapes(java.lang.String)UtilityUtility()stringToDecodetheStringWithoutEscapeHex1Hex2'a''A'Utility methods for Naming.cleanEscapes removes URL escapes as per IETF 2386 RFP. Get the two hexadecimal digits and convert that into int Convert the integer to ASCIIConverts an Ascii Character into Hexadecimal digitNOTE: THIS METHOD IS DUPLICATED TO DELIVER NAMING AS A SEPARATECOMPONENT TO RI.If GIOP Version is not correct, This method throws a BAD_PARAMException./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/naming/pcosnaming/InternalBindingKey.java/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/naming/pcosnamingcom.sun.corba.se.impl.naming.pcosnaming/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/naming/pcosnaming/InternalBindingKey.class/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/naming/pcosnaming5410796631793704055L5410796631793704055 computed by serialver tool If One is Null and the other is not then it's a mismatch So, return false We have checked all the possibilities, so return true/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/naming/pcosnaming/InternalBindingValue.javatheObjectRef/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/naming/pcosnaming/InternalBindingValue.classObjectRef The value stores both Stringified Object Reference and Non-Stringified Object Reference. This is done to avoid calling orb.string_to_object( ) everytime. Instead it will be set once and then the result will be used everytime. Objectreference or Context/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/naming/pcosnaming/NameServer.javadbName/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/naming/pcosnaming/NameServer.class"names.db"names.dbins"pnameserv.success"pnameserv.successClass NameServer is a standalone application whichimplements a persistent and a transient name service.It uses the PersistentNameService and TransientNameServiceclasses for the name service implementation. name server database directory create the ORB Object set up the database directory create the persistent name service add root naming context to initial naming wait for invocations/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/naming/pcosnaming/NameService.javaorg.omg.PortableServergetObjectKeygetObjectKey(org.omg.CORBA.Object)/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/naming/pcosnaming/NameService.classgetObjectReferenceFromKeygetObjectReferenceFromKey(java.lang.String)getNSPOAgetNSPOA()theorbcontextMgrrootKeynewKeytheContexttempContexttheNewContextreferencetheIdtheKeyCreate NameService which starts the Root Naming Context in Persistent CosNaminga File Moved this to the creation of the ORB that is passed into this constructor. This is required for creating Persistent Servants under this ORB Right now the Persistent NameService and ORBD are launched together Find out a better way of doing this, Since ORBD is an important process which should not be killed because of some external process orb.setPersistentServerId( (int) 1000 ); get and activate the root naming POA create a new POA for persistent Naming Contexts With Non-Retain policy, So that every time Servant Manager will be contacted when the reference is made for the context The id assignment is made by the NameServer, The Naming Context id's will be in the format NC<Index> create and set the servant manager The RootObject key will be NC0 initialize the root Naming ContextThis method returns the Root Naming ContextThis method returns nsPOA which is the only POA that we use forPersistent Naming Contexts.This method  creates a NewContext, This will internally invoked fromNamingContextImpl. It is not a public API. NewContext is in this classbecause a Persiten reference has to be created with Persistent NameServicePOA. Get the new Naming Context Key from the ServantManager Create the new Naming context and create the Persistent reference If the context is read from the File, The following three entries will be null. So a fresh setup may be required.throw e;getObjectReferenceFromKey returns the Object reference from the objectkey using POA.create_reference_with_id methodKey as String@returnsreference an CORBA.Object.getObjectKey gets the Object Key from the reference using POA.reference_to_id methodan CORBA.Object.Object Key as String/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/naming/pcosnaming/NamingContextImpl.javaorg.omg.CosNamingcreatebiPOAcreatebiPOA()/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/naming/pcosnaming/NamingContextImpl.classdoBind(com.sun.corba.se.impl.naming.cosnaming.NamingContextDataStore,org.omg.CosNaming.NameComponent[],org.omg.CORBA.Object,boolean,org.omg.CosNaming.BindingType)getINSImplgetINSImpl()biPOAupdateWrapperreadWrappertheServantManagerImplHandletheNameServiceHandleobjKeytheNameServicetheServantManagerImpl"bind "bind " to " to "rebind "rebind "rebind_context "rebind_context "resolve "resolve "unbind "unbind "new_context()"new_context()"destroy "destroy theNCKeytheObjectFromStringifiedReference"NC"NCtheObjectFromStringfiedReference"BindingIteratorPOA"BindingIteratorPOA"Hashtable Size = "Hashtable Size = thevalue"value = "value = Class NamingContextImpl implements the org.omg.CosNaming::NamingContext andNamingContextExt interface.None of the methods here are Synchronized because These methods will beinvoked from Super class's doBind( ), doResolve( ) which are alreadySynchronized. The ORB is required to do string_to_object() operations All the references are stored in the files in the form of IOR strings The ObjectKey will be in the format NC<Index> which uniquely identifies The NamingContext internaly Hash table contains all the entries in the NamingContexts. The CORBA.Object references will be stored in the form of IOR strings and the Child Naming Contexts will have it's key as the entry in the table. This table is written into File everytime an update is made on this context. The NameServiceHandle is required to get the ObjectId from the NamingContext's references. These references are created using POA in the NameService. ServantManager is the single point of contact to Read, Write and Update the NamingContextFile All the INS (Interoperable Naming Service) methods are defined in this class All the calls to INS will be delegated to this class.as StringTheNameServiceas NameServiceTheServantManagerImplas ServantManagerImpl orb.namingDebugFlag ; insImpl will be null if the NamingContext graph is rebuilt from the persistence store.is already bound.An object isalready bound under the supplied name.resolved in thisunbound first. The NamingContext will participate in recursive resolving.This NamingContextis not empty (i.e., contains bindings). Narrow to a naming context using Java casts. It must work.Implements all flavors of binding( bind and bindcontext)This method will be called from the superclass's doBind( ) methodwhich takes care of all the conditions before calling this method.i.e., It checks whether the Name is already Bounded, Then in thecase of rebind it calls Unbind first.This method does one level binding only, To have n-level bindingwith compound names, doBind( ) calls this method recursively.raisedif the NameComoponent list is invalidCould not proceed in resolving the Name from the given NameComponentsystem exceptionsResolveUnbind Raise a Valid Exception and Return If the BindingType is an ObjectRef then Stringify this ref and Store it in InternalBindingValue instance. This is required because the Object References has to be stored in file If the BindingType is a NamingContext then get it's object key from the NameService and store it in the Internal Binding Value instance There was an entry with this name in the Hashtable and hence throw CTX_ALREADY_BOUND exception Everything went smooth so update the NamingContext file with the latest Hashtable image Something went wrong while updating the context so speak the error Something went wrong while Binding the Object Reference Speak the error again.This method resolves the NamingContext or Object Reference for one levelThe doResolve( ) method calls Resolve( ) recursively to resolve n levelNames.Neither a NamingContextor a Corba Object reference not found under this Namein resolving the the supplied name.Bind If the NameComponent list has no entry then it means the current context was requested No entry was found for the given name and hence return NULL NamingContextDataStore throws appropriate exception if required. Check whether the entry found in the Hashtable starts with NC Which means it's a name context. So get the NamingContext reference from ServantManager, which would either return from the cache or read it from the File. Else, It is a Object Reference. Check whether Object Reference can be obtained directly, If not then convert the stringified reference to object and return.This method Unbinds the NamingContext or Object Reference for one levelThe doUnbind( ) method from superclass calls Unbind() to recursivelyUnbind using compound Names. Ignore the exception in Hashtable.removePersistentBindingIterator object and passes it a clone of theDestroys the NamingContext. XXX note that orb.disconnect is illegal here, since the POA is used.  However, there may be some associated state that needs to be cleaned up in ServerManagerImpl which we will look into further at another time.// XXX This needs to be replaced by cleaning up the// file that backs up the naming context.  No explicit// action is necessary at the POA level, since this is// created with the non-retain policy./*try { orb.disconnect(theNameServiceHandle.getObjectReferenceFromKey( this.objKey ) );} catch( org.omg.CORBA.SystemException e ) {} catch( Exception e ) {throw updateWrapper.transNcDestroyGotEx( e ) ;This is a Debugging Method/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/naming/pcosnaming/PersistentBindingIterator.java/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/naming/pcosnaming/PersistentBindingIterator.classtheBindingKeytheElementnlisttheType"Exception in BindingIterator.Destroy "Exception in BindingIterator.Destroy Constructs a new PersistentBindingIterator object.the content of the PersistentNamingContext./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/naming/pcosnaming/ServantManagerImpl.javaServantManagerImplServantManagerImpl(com.sun.corba.se.spi.orb.ORB,java.io.File,com.sun.corba.se.impl.naming.pcosnaming.NameService)/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/naming/pcosnaming/ServantManagerImpl.classobjKeyPrefixcountercounterDb4028710359865748280L4028710359865748280aNameServicecontextFilecounterFile/Library/Java/JavaVirtualMachines/jdk1.8.0_251.jdk/Contents/Home/jre/lib/rt.jar/com/sun/corba/se/impl/naming/Library/Java/JavaVirtualMachines/jdk1.8.0_251.jdk/Contents/Home/jre/lib/rt.jar/com/sun/corba/se/impl/naming/pcosnaming/Library/Java/JavaVirtualMachines/jdk1.8.0_251.jdk/Contents/Home/jre/lib/rt.jar/com/sun/corba/se/impl/naming/pcosnaming/CounterDB.classcounterFileNamewriteCounterwriteCounter()readCounterreadCounter()CounterDBCounterDB(java.io.File)"counter"counterVal computed using serialver tool initialize the counter database nada Returning Context from Cache/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/oa/NullServantImpl.java/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/oacom.sun.corba.se.impl.oa/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/oa/NullServantImpl.class/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/oa/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/oa/poa/AOMEntry.java/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/oa/poacom.sun.corba.se.impl.oa.poaengine/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/oa/poa/AOMEntry.class/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/oa/poaoneGuardgreaterOneGuardzeroGuardgreaterZeroGuardwaitGuardoaaActionthrowIllegalStateExceptionActiondecrementActionincrementActionEXITENTERACTIVATEINC_FAILINC_DONEETH_DONESTART_ETHwaitThread[]etherealizer"Invalid"Invalid/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/oa/poa/AOMEntry$1.classpostActionpostAction(com.sun.corba.se.spi.orbutil.fsm.FSM)(java.lang.String)"Incarnating"Incarnatingfsm"Valid"Valid"EtherealizePending"EtherealizePending/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/oa/poa/AOMEntry$2.classpreActionpreAction(com.sun.corba.se.spi.orbutil.fsm.FSM)"Etherealizing"Etherealizing"Destroyed"Destroyed"startEtherealize"startEtherealize"etherealizeDone"etherealizeDone"incarnateDone"incarnateDone"incarnateFailure"incarnateFailure"activateObject"activateObject"enter"enter"exit"exit/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/oa/poa/AOMEntry$3.classdoItdoIt(com.sun.corba.se.spi.orbutil.fsm.FSM,com.sun.corba.se.spi.orbutil.fsm.Input)"increment"increment/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/oa/poa/AOMEntry$4.class"decrement"decrement/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/oa/poa/AOMEntry$5.class"throwIllegalStateException"throwIllegalStateException"No transitions allowed from the DESTROYED state"No transitions allowed from the DESTROYED state/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/oa/poa/AOMEntry$6.class"throwObjectAlreadyActive"throwObjectAlreadyActive/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/oa/poa/AOMEntry$7.classevaluateevaluate(com.sun.corba.se.spi.orbutil.fsm.FSM,com.sun.corba.se.spi.orbutil.fsm.Input)"wait"/Library/Java/JavaVirtualMachines/jdk1.8.0_251.jdk/Contents/Home/jre/lib/rt.jar/com/sun/corba/se/impl/oa/Library/Java/JavaVirtualMachines/jdk1.8.0_251.jdk/Contents/Home/jre/lib/rt.jar/com/sun/corba/se/impl/oa/poa/Library/Java/JavaVirtualMachines/jdk1.8.0_251.jdk/Contents/Home/jre/lib/rt.jar/com/sun/corba/se/impl/oa/poa/AOMEntry$CounterGuard.class"counter>"counter>thrCopyright (c) 2002, 2010, Oracle and/or its affiliates. All rights reserved.AOMEntry represents a Servant or potential Servant in the ActiveObjectMap.It may be in several states to allow for long incarnate or etherealize operations.The methods on this class mostly represent input symbols to the state machinethat controls the lifecycle of the entry.  A library is used to build the statemachine rather than the more usual state pattern so that the state machinetransitions are explicitly visible. The actual etherealize operation for this entry.  It is represented as a Thread because the POA.deactivate_object never waits for the completion. single element holder for counter accessed in actions XXX Log this          State,   Input,     Guard,                  Action,             new State Methods that drive the FSM: the real interface to this class Most just call the doIt method, but startEtherealize needs the etherealizer./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/oa/poa/ActiveObjectMap.javaservantToEntry/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/oa/poa/ActiveObjectMap.classentryToServantkeyToEntryKeyKey(byte[])/Library/Java/JavaVirtualMachines/jdk1.8.0_251.jdk/Contents/Home/jre/lib/rt.jar/com/sun/corba/se/impl/oa/poa/ActiveObjectMap$Key.classmultipleIDsAllowedentryToKey/Library/Java/JavaVirtualMachines/jdk1.8.0_251.jdk/Contents/Home/jre/lib/rt.jar/com/sun/corba/se/impl/oa/poa/SingleObjectMap.classentryToKeys/Library/Java/JavaVirtualMachines/jdk1.8.0_251.jdk/Contents/Home/jre/lib/rt.jar/com/sun/corba/se/impl/oa/poa/MultipleObjectMap.classHashSet<>AbstractSet<>HashSet<>()AbstractSet<>()HashSet<>(int,float,boolean)HashSet<>(int)HashSet<>(int,float)HashSet<>(java.util.Collection)The ActiveObjectMap maintains associations between servants andtheir keys.  There are two variants, to support whether or notmultiple IDs per servant are allowed.  This class suppots bidirectionaltraversal of the key-servant association.  Access to an instance of thisclass is serialized by the POA mutex. Use the same hash function as for String Map< Key, AOMEntry > Map< AOMEntry, Servant > Map< Servant, AOMEntry >get Returbs the entry assigned to the key, or creates a newentry in state INVALID if none is present. Map< AOMEntry, Key > This case does not need the key. Map< AOMEntry, Set< Key > >/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/oa/poa/BadServerIdHandler.javaobjectKeyThe bad server id handler is used to locate persistent objects.The Locator object registers the BadServerIdHandler with the ORBand when requests for persistent objects for servers (other thanitself) comes, it throws a ForwardException with the IOR pointingto the active server./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/oa/poa/DelegateImpl.java/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/oa/poa/DelegateImpl.classnotInInvocationEdefaultPOArepositoryIdsSelfNot within an invocation contextREVISIT The get_interface() method has been replaced by get_interface_def()/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/oa/poa/IdAssignmentPolicyImpl.javaorg.omg.CORBA/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/oa/poa/IdAssignmentPolicyImpl.class"IdAssignmentPolicy["IdAssignmentPolicy["USER_ID"USER_ID"SYSTEM_ID" + "]"SYSTEM_ID]/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/oa/poa/IdUniquenessPolicyImpl.java/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/oa/poa/IdUniquenessPolicyImpl.class"IdUniquenessPolicy["IdUniquenessPolicy["UNIQUE_ID"UNIQUE_ID"MULTIPLE_ID" + "]"MULTIPLE_ID]/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/oa/poa/ImplicitActivationPolicyImpl.java/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/oa/poa/ImplicitActivationPolicyImpl.class"ImplicitActivationPolicy["ImplicitActivationPolicy["IMPLICIT_ACTIVATION"IMPLICIT_ACTIVATION"NO_IMPLICIT_ACTIVATION" + "]"NO_IMPLICIT_ACTIVATION]/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/oa/poa/LifespanPolicyImpl.java/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/oa/poa/LifespanPolicyImpl.class"LifespanPolicy["LifespanPolicy["TRANSIENT"TRANSIENT"PERSISTENT" + "]"PERSISTENT]/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/oa/poa/POACurrent.javathrowInternalIfNullthrowInternalIfNull(java.lang.Object)/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/oa/poa/POACurrent.classthrowNoContextIfNullthrowNoContextIfNull(java.lang.Object)peekThrowInternalpeekThrowInternal()peekThrowNoContextpeekThrowNoContext()setServantsetServant(org.omg.PortableServer.Servant)getCookieHoldergetCookieHolder()getServantgetServant()"IDL:omg.org/PortableServer/Current:1.0"IDL:omg.org/PortableServer/Current:1.0objectidcookieHolderinvocationInfo XXX Needs to be turned into LocalObjectImpl. Standard OMG operations. Implementation operations used by POA package. If is OK for the servant to be null. This could happen if POAImpl.getServant is called but POAImpl.internalGetServant throws an exception. This is public so we can test the stack balance. It is not a security hole since this same info can be obtained from PortableInterceptors. Class utilities. The completion status is maybe because this could happen after the servant has been invoked./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/oa/poa/POAFactory.javaisShuttingDown/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/oa/poa/POAFactory.classdelegateImplpoaIdpoaManagerIdpoaManagersexportedServantsToPOApoaCurrentwaitForCompletionmanagersrpClosure/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/oa/poa/POAFactory$1.classevaluate()invCopyright (c) 2002, 2009, Oracle and/or its affiliates. All rights reserved. Maps servants to POAs for deactivating servants when unexportObject is called. Maintained by POAs activate_object and deactivate_object.All object adapter factories must have a no-arg constructor. Implementation of ObjectAdapterFactory interface It is important to copy the list of POAManagers first because pm.deactivate removes itself from poaManagers! Special methods used to manipulate global POA related state We delay the evaluation of makeRootPOA until a call to resolve_initial_references( "RootPOA" ). The Future guarantees that makeRootPOA is only called once. See if we are trying to getRootPOA while shutting down the ORB./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/oa/poa/POAImpl.javaetherealizeAlletherealizeAll()/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/oa/poa/POAImpl.classinternalReferenceToIdinternalReferenceToId(org.omg.CORBA.Object)destroyIfNotInitDonedestroyIfNotInitDone()waitUntilRunningwaitUntilRunning()initialize(com.sun.corba.se.impl.oa.poa.POAManagerImpl,com.sun.corba.se.impl.oa.poa.Policies)POAImplPOAImpl(java.lang.String,com.sun.corba.se.impl.oa.poa.POAImpl,com.sun.corba.se.spi.orb.ORB,int)getPoliciesgetPolicies()unlockunlock()getPOAIdgetPOAId()makeRootPOAmakeRootPOA(com.sun.corba.se.spi.orb.ORB)getPOAFactorygetPOAFactory(com.sun.corba.se.spi.orb.ORB)getDebuggetDebug()beingDestroyedCVinvokeCVadapterActivatorCVpoaMutexinvocationCountuniquePOAIdnumLevelsstateToStringstateToString()STATE_DESTROYEDSTATE_DESTROYINGSTATE_RUNSTATE_INIT_DONESTATE_INITSTATE_START"START"START"INIT"INIT"INIT_DONE"INIT_DONE"RUN"RUN"DESTROYING"DESTROYING"DESTROYED"DESTROYED"POA["POA[", uniquePOAId=", uniquePOAId=", state=", state=", invocationCount=", invocationCount=poaManager"LOCKED poa "LOCKED poa "UNLOCKED poa "UNLOCKED poa initialStatepoaImpl"Creating POA with name="Creating POA with name=" parent=" parent=/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/oa/poa/POAImpl$1.class"Initializing poa "Initializing poa " with POAManager=" with POAManager=" policies=" policies="Initializing poa: oktemp="Initializing poa: oktemp="Calling waitUntilRunning on poa "Calling waitUntilRunning on poa "Exiting waitUntilRunning on poa "Exiting waitUntilRunning on poa success"Calling destroyIfNotInitDone on poa "Calling destroyIfNotInitDone on poa destroyer"Exiting destroyIfNotInitDone on poa "Exiting destroyIfNotInitDone on poa orfcompleteDestructioncompleteDestruction(com.sun.corba.se.impl.oa.poa.POAImpl,com.sun.corba.se.impl.oa.poa.POAImpl,java.util.Set)/Library/Java/JavaVirtualMachines/jdk1.8.0_251.jdk/Contents/Home/jre/lib/rt.jar/com/sun/corba/se/impl/oa/poa/POAImpl$DestroyThread.classprepareForDestructionprepareForDestruction(com.sun.corba.se.impl.oa.poa.POAImpl,java.util.Set)thePoaetherealize"Calling DestroyThread.doIt(thePOA="Calling DestroyThread.doIt(thePOA=" wait=" wait=" etherealize=" etherealize=destroyedPOATemplatesortsPOAImpl[]childPoas"Calling performDestroy on poa "Calling performDestroy on poa isRoot"Calling completeDestruction on poa "Calling completeDestruction on poa "Exiting completeDestruction on poa "Exiting completeDestruction on poa "Calling etheralizeAll on poa "Calling etheralizeAll on poa "Exiting etheralizeAll on poa "Exiting etheralizeAll on poa theManager"Calling create_POA(name="Calling create_POA(name=" theManager=" theManager=") on poa ") on poa newManagerdefaultCopierIdPOAPolicies"Calling create_POA: new poa is "Calling create_POA: new poa is act"Calling find_POA(name="Calling find_POA(name=" activate=" activate="Calling find_POA: found poa "Calling find_POA: found poa "Calling find_POA: no poa found"Calling find_POA: no poa found"Calling find_POA: created poa "Calling find_POA: created poa adapterResult"Calling find_POA: calling AdapterActivator"Calling find_POA: calling AdapterActivator"Calling find_POA: AdapterActivator returned false"Calling find_POA: AdapterActivator returned falsewait_for_completionPOA[]coll"Calling the_activator on poa "Calling the_activator on poa " activator=" activator=servantManager"Calling set_servant_manager on poa "Calling set_servant_manager on poa " servantManager=" servantManager=defaultServant"Calling set_servant on poa "Calling set_servant on poa " defaultServant=" defaultServant="Calling activate_object on poa "Calling activate_object on poa " (servant=" (servant=oaa"Exiting activate_object on poa "Exiting activate_object on poa idClone"Calling activate_object_with_id on poa "Calling activate_object_with_id on poa " id=" id="Exiting activate_object_with_id on poa "Exiting activate_object_with_id on poa "Calling deactivate_object on poa "Calling deactivate_object on poa " (id=" (id="Exiting deactivate_object on poa "Exiting deactivate_object on poa "Calling create_reference(repId="Calling create_reference(repId="Calling create_reference_with_id(oid="Calling create_reference_with_id(oid=" repId=" repId="Calling servant_to_id(servant="Calling servant_to_id(servant="Calling servant_to_reference(servant="Calling servant_to_reference(servant="Calling reference_to_servant(reference="Calling reference_to_servant(reference="Calling reference_to_id(reference="Calling reference_to_id(reference="Calling id_to_servant(id="Calling id_to_servant(id="Calling id_to_reference(id="Calling id_to_reference(id=servcopierId"Calling enter on poa "Calling enter on poa "Exiting enter on poa "Exiting enter on poa "Calling exit on poa "Calling exit on poa "Exiting exit on poa "Exiting exit on poa "Calling getInvocationServant on poa "Calling getInvocationServant on poa freq"Exiting getInvocationServant on poa "Exiting getInvocationServant on poa "Calling returnServant on poa "Calling returnServant on poa "Exception "Exception " in returnServant on poa " in returnServant on poa "Exiting returnServant on poa "Exiting returnServant on poa POAImpl is the implementation of the Portable Object Adapter. Itcontains an implementation of the POA interfaces specified inCOBRA 2.3.1 chapter 11 (formal/99-10-07).  This implementationis moving to comply with CORBA 3.0 due to the many clarificationsthat have been made to the POA semantics since CORBA 2.3.1.Specific comments have been added where 3.0 applies, but note thatwe do not have the new 3.0 APIs yet.POA creation takes place in 2 stages: first, the POAImpl constructor iscalled, then the initialize method is called.  This separation isneeded because an AdapterActivator does not know the POAManager orthe policies whenthe unknown_adapter method is invoked.  However, the POA must be createdbefore the unknown_adapter method is invoked, so that the parent knowswhen concurrent attempts are made to create the same POA.Calling the POAImpl constructor results in a new POA in state STATE_START.Calling initialize( POAManager, Policies ) results in state STATE_RUN.Calling destroy results in STATE_DESTROY, which marks the beginning ofPOA destruction. Notes on concurrency. The POA requires careful design for concurrency management to correctly implement the specification and avoid deadlocks.  The order of acquiring locks must respect the following locking hierarchy: 1. Lock POAs before POAManagers 2. Lock a POA before locking its child POA Also note that there are 3 separate conditions on which threads may wait in the POA, as defined by invokeCV, beingDestroyedCV, and adapterActivatorCV.  This means that (for this reason as well as others) we cannot simply use the standard Java synchronized primitive. This implementation uses a modified version of Doug Lea's util.concurrent (version 1.3.0) that supports reentrant mutexes to handle the locking.  This will all be replaced by the new JSR 166 concurrency primitives in J2SE 1.5 and later once the ORB moves to J2SE 1.5. POA state constants Note that ordering is important here: we must have the state defined in this order so that ordered comparison is possible. DO NOT CHANGE THE VALUES OF THE STATE CONSTANTS!!!  In particular, the initialization related states must be lower than STATE_RUN. POA is created in STATE_START Valid state transitions: START to INIT                        after find_POA constructor call START to RUN                         after initialize completes INIT to INIT_DONE                    after initialize completes INIT to DESTROYED                    after failed unknown_adapter INIT_DONE to RUN                     after successful unknown_adapter STATE_RUN to STATE_DESTROYING        after start of destruction STATE_DESTROYING to STATE_DESTROYED  after destruction completes. constructor complete waiting for adapter activator adapter activator called create_POA initialized and running being destroyed destruction complete Current state of the POA The POA request handler that performs all policy specific operations Note that POAImpl handles all synchronization, so mediator is (mostly) unsynchronized. Representation of object adapter ID counts depth of tree.  Root = 1. the actual object adapter ID for this POA the name of this POA This POA's POAManager ID for this POA that is unique relative to the POAFactory, which has the same lifetime as the ORB. The POA that created this POA. Map from name to POA of POAs created by this POA. pending invocations on this POA. Data used to control POA concurrency XXX revisit for JSR 166 Master lock for all POA synchronization.  See lock and unlock. package private for access by AOMEntry. Wait on this CV for AdapterActivator upcalls to complete Wait on this CV for all active invocations to complete Wait on this CV for the destroy method to complete doing its work thread local variable to store a boolean to detect deadlock in POA.destroy(). This includes the most important information for debugging POA problems. package private for mediator implementations. package private for access to servant to POA map package private so that POAFactory can access it. package private so that POAPolicyMediatorBase can access it. package private so that POAPolicyMediator can access it. package private so that DelegateImpl can access it. Note that the parent POA must be locked when this constructor is called. This was done in initialize, but I moved it here to get better searchability when tracing. This is the root POA, which counts as 1 level My level is one more than that of my parent Get an array of all of the POA names in order to create the poaid. The POA lock must be held when this method is called. Construct the object key template Note that parent == null iff this is the root POA. This was used to avoid executing interceptors on the RootPOA. That is no longer necessary. parent != null ; XXX extract codebase from policies and pass into initializeTemplate after the codebase policy change is finalized. codebase manager id The poaMutex must be held when this method is called Note that a POA could be destroyed while in STATE_INIT due to a failure in the AdapterActivator upcall. This method checks that the AdapterActivator finished the initialization of a POA activated in find_POA.  This is determined by checking the state of the POA.  If the state is STATE_INIT, the AdapterActivator did not complete the inialization.  In this case, we destroy the POA that was partially created and return false.  Otherwise, we return true. In any case, we must wake up all threads waiting for the adapter activator, either to continue their invocations, or to return errors to their client. The poaMutex must NOT be held when this method is called. Don't just use destroy, because the check for deadlock is too general, and can prevent this from functioning properly. Extract the ObjectId from the first TaggedProfile in the IOR. If ior was created in this POA, the same ID was used for every profile through the profile templates in the currentFactory, so we will get the same result from any profile. Converted from anonymous class to local class so that we can call performDestroy() directly. Catch exceptions since setDaemon can cause a security exception to be thrown under netscape in the Applet mode Returns true if destruction must be completed, false if not, which means that another thread is already destroying poa. Note that we do not synchronize on this, since this is the PerformDestroy instance, not the POA. destroy may be called multiple times, and each call is allowed to proceed with its own setting of the wait flag, but the etherealize value is used from the first call to destroy.  Also all children should be destroyed before the parent POA.  If the poa is already destroyed, we can just return.  If the poa has started destruction, but not completed, and wait is true, we need to wait until destruction is complete, then just return. Make a copy since we can't hold the lock while destroying the children, and an iterator is not deletion-safe. We are not holding the POA mutex here to avoid holding it while destroying the POA's children, since this may involve upcalls to etherealize methods. NOTE: If we are here, poa is in STATE_DESTROYING state. All other state checks are taken care of in prepareForDestruction. No other threads may either be starting new invocations by calling enter or starting to destroy poa.  There may still be pending invocations. Note that we must lock the parent before the child. The parent lock is required (if poa is not the root) to safely remove poa from parent's children Map. We have just destroyed the root POA, so we need to make sure that the next call to resolve_initial_reference( "RootPOA" ) will recreate a valid root POA.******************************************************************* Public POA API<code>create_POA</code><b>Section 3.3.8.2</b> We cannot create children of a POA that is (being) destroyed. This has been added to the CORBA 3.0 spec.<code>find_POA</code><b>Section 3.3.8.3</b> Do not hold the parent POA lock while waiting for child to complete initialization. Make sure that the child has completed its initialization, if it was created by an AdapterActivator, otherwise throw a standard TRANSIENT exception with minor code 4 (see CORBA 3.0 11.3.9.3, in reference to unknown_adapter) Note that found may be in state DESTROYING or DESTROYED at this point.  That's OK, since destruction could start at any time. Create a child, but don't initialize it.  The newly created POA will be in state STATE_START, which will cause other calls to find_POA that are creating the same POA to block on the waitUntilRunning call above. Initialization must be completed by a call to create_POA inside the unknown_adapter upcall.  Note that this.poaMutex must be held here so that this.children can be safely updated.  The state is set to STATE_INIT so that initialize can make the correct state transition when create_POA is called inside the AdapterActivator. This avoids activating the new POA too soon by transitioning to STATE_RUN after unknown_adapter returns. assert (found != null) assert not holding this.poaMutex OR found.poaMutex We must not hold either this.poaMutex or found.poaMutex here while waiting for intialization of found to complete to prevent possible deadlocks. Prevent more than one thread at a time from executing in act in case act is shared between multiple POAs. ignore most non-system exceptions, but log them for diagnostic purposes. At this point, we have completed adapter activation. Whether this was successful or not, we must call destroyIfNotInitDone so that calls to enter() and create_POA() that are waiting can execute again.  Failing to do this will cause the system to hang in complex tests. OMG Issue 3740 is resolved to throw AdapterNonExistent if unknown_adapter() returns false.<code>destroy</code><b>Section 3.3.8.4</b> This is to avoid deadlock<code>create_thread_policy</code><b>Section 3.3.8.5</b><code>create_lifespan_policy</code><code>create_id_uniqueness_policy</code><code>create_id_assignment_policy</code><code>create_implicit_activation_policy</code><code>create_servant_retention_policy</code><code>create_request_processing_policy</code><code>the_name</code><b>Section 3.3.8.6</b><code>the_parent</code><b>Section 3.3.8.7</b><code>the_children</code><code>the_POAManager</code><b>Section 3.3.8.8</b><code>the_activator</code><b>Section 3.3.8.9</b><code>get_servant_manager</code><b>Section 3.3.8.10</b><code>set_servant_manager</code><code>get_servant</code><b>Section 3.3.8.12</b><code>set_servant</code><b>Section 3.3.8.13</b><code>activate_object</code><b>Section 3.3.8.14</b> Allocate a new system-generated object-id. This will throw WrongPolicy if not SYSTEM_ID policy. This exception can not occur in this case, since id is always brand new.<code>activate_object_with_id</code><b>Section 3.3.8.15</b> Clone the id to avoid possible errors due to aliasing (e.g. the client passes the id in and then changes it later).<code>deactivate_object</code><b>3.3.8.16</b><code>create_reference</code><b>3.3.8.17</b><code>create_reference_with_id</code><b>3.3.8.18</b><code>servant_to_id</code><b>3.3.8.19</b><code>servant_to_reference</code><b>3.3.8.20</b><code>reference_to_servant</code><b>3.3.8.21</b> reference_to_id should throw WrongAdapter if the objref was not created by this POA<code>reference_to_id</code><b>3.3.8.22</b><code>id_to_servant</code><b>3.3.8.23</b><code>id_to_reference</code><b>3.3.8.24</b><code>id</code><b>11.3.8.26 in ptc/00-08-06</b>***************************************************************Implementation of ObjectAdapter interface Avoid deadlock if this is the thread that is processing the POA.destroy because this is the only thread that can notify waiters on beingDestroyedCV.  This can happen if an etherealize upcall invokes a method on a colocated object served by this POA.Called from the subcontract to let this POA cleanup after aninvocation. Note: If getServant was called, then returnServantMUST be called, even in the case of exceptions.  This may becalled multiple times for a single request./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/oa/poa/POAManagerImpl.javaexit()/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/oa/poa/POAManagerImpl.classenter()checkState()checkIfActivecheckIfActive()removePOAremovePOA(org.omg.PortableServer.POA)addPOAaddPOA(org.omg.PortableServer.POA)POAManagerImplPOAManagerImpl(com.sun.corba.se.impl.oa.poa.POAFactory,com.sun.corba.se.spi.protocol.PIHandler)notifyWaitersnotifyWaiters()countedWaitcountedWait()getPIHandlergetPIHandler()getFactorygetFactory()stateToString(org.omg.PortableServer.POAManagerPackage.State)explicitStateChangemyIdnWaitersnInvocationspoaspihandler"State[HOLDING]"State[HOLDING]"State[ACTIVE]"State[ACTIVE]"State[DISCARDING]"State[DISCARDING]"State[INACTIVE]"State[INACTIVE]"State[UNKNOWN]"State[UNKNOWN]"POAManagerImpl[myId="POAManagerImpl[myId=" state=" state=" nInvocations=" nInvocations=" nWaiters=" nWaiters="Calling countedWait on POAManager "Calling countedWait on POAManager "Exiting countedWait on POAManager "Exiting countedWait on POAManager "Calling notifyWaiters on POAManager "Calling notifyWaiters on POAManager "Creating POAManagerImpl "Creating POAManagerImpl "Calling activate on POAManager "Calling activate on POAManager "Exiting activate on POAManager "Exiting activate on POAManager "Calling hold_requests on POAManager "Calling hold_requests on POAManager "Exiting hold_requests on POAManager "Exiting hold_requests on POAManager etherealize_objectsdeactivator"Calling deactivate on POAManager "Calling deactivate on POAManager "Exiting deactivate on POAManager "Exiting deactivate on POAManager POAManagerDeactivatorPOAManagerDeactivator(com.sun.corba.se.impl.oa.poa.POAManagerImpl,boolean,boolean)/Library/Java/JavaVirtualMachines/jdk1.8.0_251.jdk/Contents/Home/jre/lib/rt.jar/com/sun/corba/se/impl/oa/poa/POAManagerImpl$POAManagerDeactivator.classpmi"Calling run with etherealize_objects="Calling run with etherealize_objects=" pmi=" pmi="run: Preparing to etherealize with pmi="run: Preparing to etherealize with pmi="run: removing POAManager and clearing poas " +
                                "with pmi="run: removing POAManager and clearing poas with pmi="Exiting run"Exiting run"Calling checkIfActive for POAManagerImpl "Calling checkIfActive for POAManagerImpl "Exiting checkIfActive for POAManagerImpl "Exiting checkIfActive for POAManagerImpl "Calling enter for POAManagerImpl "Calling enter for POAManagerImpl "Exiting enter for POAManagerImpl "Exiting enter for POAManagerImpl "Calling exit for POAManagerImpl "Calling exit for POAManagerImpl "Exiting exit for POAManagerImpl "Exiting exit for POAManagerImpl aiPOAManagerImpl is the implementation of the POAManager interface.Its public methods are activate(), hold_requests(), discard_requests()and deactivate(). factory which contains global state for all POAManagers for adapterManagerStateChanged current state of this POAManager all poas controlled by this POAManager Number of invocations in progress Number of threads waiting for invocations to complete This POAManager's ID initially false, set true as soon as one of activate, hold_request, discard_request, or deactivate is called. NOP XXX This is probably not the correct error**************************************************************************The following four public methods are used to change the POAManager's state.A note on the design of synchronization code:There are 4 places where a thread would need to wait for a condition:- in hold_requests, discard_requests, deactivate, enterThere are 5 places where a thread notifies a condition:- in activate, hold_requests, discard_requests, deactivate, exitSince each notify needs to awaken waiters in several of the 4 places,and since wait() in Java has the nice property of releasing the lockon its monitor before sleeping, it seemed simplest to have just onemonitor object: "this". Thus all notifies will awaken all waiters.On waking up, each waiter verifies that the condition it was waitingfor is satisfied, otherwise it goes back into a wait().<code>activate</code><b>Spec: pages 3-14 thru 3-18</b> set the state to ACTIVE Notify any invocations that were waiting because the previous state was HOLDING, as well as notify any threads that were waiting inside hold_requests() or discard_requests().<code>hold_requests</code> set the state to HOLDING Notify any threads that were waiting in the wait() inside discard_requests. This will cause discard_requests to return (which is in conformance with the spec).<code>discard_requests</code> set the state to DISCARDING state was HOLDING. Those invocations will henceforth be rejected with a TRANSIENT exception. Also notify any threads that were waiting inside hold_requests().<code>deactivate</code>Note: INACTIVE is a permanent state. state was HOLDING. Those invocations will then be rejected with an OBJ_ADAPTER exception. Also notify any threads that were waiting Make sure that poas cannot change while we copy it! Each RETAIN+USE_SERVANT_MGR poa must call etherealize for all its objectsAdded according to the spec CORBA V2.3; this returns thestate of the POAManagerThe following methods are used on the invocation path. called from POA.find_POA before calling AdapterActivator.unknown_adapter. This notifies any threads that were in the wait_for_completion loop in hold/discard/deactivate().Activate the POAManager if no explicit state change has ever beenpreviously invoked. ignore the exception./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/oa/poa/POAPolicyMediator.javaPOAPolicyMediator defines an interface to which the POA delegates allpolicy specific operations.  This permits code paths for differentpolicies to be optimized by creating the correct code at POA creationtime.  Also note that as much as possible, this interface does notdo any concurrency control, except as noted.  The POA is responsiblefor concurrency control.Return the policies object that was used to create thisPOAPolicyMediator.Return the subcontract ID to use in the IIOP profile in IORscreated by this POAPolicyMediator's POA.  This is initializedaccording to the policies and the POA used to construct thisPOAPolicyMediator in the POAPolicyMediatorFactory.Return the server ID to use in the IIOP profile in IORsGet the servant to use for an invocation with thegiven id and operation.the object ID for which we are requesting a servantthe name of the operation to be performed onthe servantthe resulting Servant.Release a servant that was obtained from getInvocationServant.Etherealize all servants associated with this POAPolicyMediator.Does nothing if the retention policy is non-retain.Delete everything in the active object map.Return the servant manager.  Will throw WrongPolicyif the request processing policy is not USE_SERVANT_MANAGER.Set the servant manager.  Will throw WrongPolicyReturn the default servant.   Will throw WrongPolicyif the request processing policy is not USE_DEFAULT_SERVANT.Set the default servant.   Will throw WrongPolicyDeactivate the object that is associated with the given id.Returns the servant for id.Allocate a new, unique system ID.  Requires the ID assignment policyto be SYSTEM./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/oa/poa/POAPolicyMediatorBase.javaPOAPolicyMediatorBasePOAPolicyMediatorBase(com.sun.corba.se.impl.oa.poa.Policies,com.sun.corba.se.impl.oa.poa.POAImpl)/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/oa/poa/POAPolicyMediatorBase.classsysIdCounterpoampoafImplementation of POARequesHandler that provides policy specificoperations on the POA. Create a delegate and stick it in the servant. This delegate is needed during dispatch for the ObjectImpl._orb() method to work.This new servant delegate no longer needs the id for its initialization./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/oa/poa/POAPolicyMediatorBase_R.javaPOAPolicyMediatorBase_RPOAPolicyMediatorBase_R(com.sun.corba.se.impl.oa.poa.Policies,com.sun.corba.se.impl.oa.poa.POAImpl)/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/oa/poa/POAPolicyMediatorBase_R.class"Activating object "Activating object " with POA " with POA pm"Calling deactivateObject for key "Calling deactivateObject for key "Deactivating object "Deactivating object "Exiting deactivateObject"Exiting deactivateObjectwCopyright (c) 2002, 2012, Oracle and/or its affiliates. All rights reserved. assert policies.retainServants() && policies.useActiveObjectMapOnly() Check for an ObjectAlreadyActive error Default does nothing, but the USE_SERVANT_MANAGER case must handle etherealization XXX needs to handle call from an invocation on this POA assert !isUnique || (servant not in activateObjectMap) This can't occur here, since id is always brand new./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/oa/poa/POAPolicyMediatorFactory.javacreate(com.sun.corba.se.impl.oa.poa.Policies,com.sun.corba.se.impl.oa.poa.POAImpl)/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/oa/poa/POAPolicyMediatorFactory.classPOAPolicyMediatorFactoryPOAPolicyMediatorFactory() create an appropriate policy mediator based on the policies. Note that the policies object has already been validated before this call, so it can only contain valid combinations of POA policies./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/oa/poa/POAPolicyMediatorImpl_NR_UDS.javaPOAPolicyMediatorImpl_NR_UDSPOAPolicyMediatorImpl_NR_UDS(com.sun.corba.se.impl.oa.poa.Policies,com.sun.corba.se.impl.oa.poa.POAImpl)/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/oa/poa/POAPolicyMediatorImpl_NR_UDS.class"DefaultServant"DefaultServantImplementation of POAPolicyMediator that provides policy specific assert !policies.retainServants() && policies.useDefaultServant()/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/oa/poa/POAPolicyMediatorImpl_NR_USM.javaPOAPolicyMediatorImpl_NR_USMPOAPolicyMediatorImpl_NR_USM(com.sun.corba.se.impl.oa.poa.Policies,com.sun.corba.se.impl.oa.poa.POAImpl)/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/oa/poa/POAPolicyMediatorImpl_NR_USM.class assert !policies.retainServants() && policies.useServantManager() Try - finally is J2EE requirement./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/oa/poa/POAPolicyMediatorImpl_R_AOM.javaPOAPolicyMediatorImpl_R_AOMPOAPolicyMediatorImpl_R_AOM(com.sun.corba.se.impl.oa.poa.Policies,com.sun.corba.se.impl.oa.poa.POAImpl)/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/oa/poa/POAPolicyMediatorImpl_R_AOM.classoperations on the POA in the case:<li>retain</li><li>useActiveObjectMapOnly</li> assert policies.retainServants() policies.useActiveObjectMapOnly()/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/oa/poa/POAPolicyMediatorImpl_R_UDS.javaPOAPolicyMediatorImpl_R_UDSPOAPolicyMediatorImpl_R_UDS(com.sun.corba.se.impl.oa.poa.Policies,com.sun.corba.se.impl.oa.poa.POAImpl)/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/oa/poa/POAPolicyMediatorImpl_R_UDS.class policies.useDefaultServant()/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/oa/poa/POAPolicyMediatorImpl_R_USM.javaenterEntryenterEntry(com.sun.corba.se.impl.oa.poa.ActiveObjectMap.Key)/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/oa/poa/POAPolicyMediatorImpl_R_USM.classPOAPolicyMediatorImpl_R_USMPOAPolicyMediatorImpl_R_USM(com.sun.corba.se.impl.oa.poa.Policies,com.sun.corba.se.impl.oa.poa.POAImpl)failed"Calling POAPolicyMediatorImpl_R_USM.internalGetServant " +
                "for poa "Calling POAPolicyMediatorImpl_R_USM.internalGetServant for poa " operation=" operation="internalGetServant: servant already activated"internalGetServant: servant already activated"internalGetServant: no servant activator in POA"internalGetServant: no servant activator in POA"internalGetServant: upcall to incarnate"internalGetServant: upcall to incarnate"internalGetServant: incarnate threw ForwardRequest"internalGetServant: incarnate threw ForwardRequest"internalGetServant: incarnate threw SystemException "internalGetServant: incarnate threw SystemException "internalGetServant: incarnate threw Throwable "internalGetServant: incarnate threw Throwable "internalGetServant: incarnate failed"internalGetServant: incarnate failed"internalGetServant: servant already assigned to ID"internalGetServant: servant already assigned to ID"internalGetServant: incarnate complete"internalGetServant: incarnate complete"Exiting POAPolicyMediatorImpl_R_USM.internalGetServant " +
                    "for poa "Exiting POAPolicyMediatorImpl_R_USM.internalGetServant for poa Key[]remainingActivations/Library/Java/JavaVirtualMachines/jdk1.8.0_251.jdk/Contents/Home/jre/lib/rt.jar/com/sun/corba/se/impl/oa/poa/POAPolicyMediatorImpl_R_USM$Etherealizer.class"Calling Etherealizer.run on key "Calling Etherealizer.run on key "Exiting Etherealizer.run"Exiting Etherealizer.runethThis handles a rather subtle bug (4939892).  The problem is thatenter will wait on the entry if it is being etherealized.  When thedeferred state transition completes, the entry is no longer in theAOM, and so we need to get a new entry, otherwise activator.incarnatewill be called twice, once for the old entry, and again when a newentry is created.  This fix also required extending the FSM StateEngineto allow actions to throw exceptions, and adding a new state in theAOMEntry FSM to detect this condition. Drop the POA lock during the incarnate call and re-acquire it afterwards.  The entry state machine prevents more than one thread from executing the incarnate method at a time within the same POA. servant == null means incarnate threw an exception, while servant instanceof NullServant means incarnate returned a null servant.  Either case is an incarnate failure to the entry state machine. XXX Does the AOM leak in this case? Yes, but the problem is hard to fix.  There may be a number of threads waiting for the state to change from INCARN to something else, which is VALID or INVALID, depending on the incarnate result. The activeObjectMap.get() call above creates an ActiveObjectMap.Entry if one does not already exist, and stores it in the keyToEntry map in the AOM. here check for unique_id policy, and if the servant is already registered for a different ID, then throw OBJ_ADAPTER exception, else activate it. Section 11.3.5.1 99-10-07.pdf check if the servant already is associated with some id Copy the elements in the set to an array to avoid changes in the set due to concurrent modification Here we etherealize in the thread that called this method, rather than etherealizing in a new thread as in the deactivate case.  We still inform the entry state machine so that only one thread at a time can call the etherealize method. ignore all exceptions/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/oa/poa/Policies.javaorg.omg.PortableServer.POAPackagePoliciesPolicies(org.omg.CORBA.Policy[],int)/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/oa/poa/Policies.classaddToErrorSetaddToErrorSet(org.omg.CORBA.Policy[],int,java.util.BitSet)checkForPolicyErrorcheckForPolicyError(java.util.BitSet)getPOAPolicyValuegetPOAPolicyValue(org.omg.CORBA.Policy)Policies()Policies(int,int,int,int,int,int,int)setPolicyValuesetPolicyValue(int,int)getPolicyValuegetPolicyValue(int)poaPolicyValuespolicyMapdefaultObjectCopierFactoryIdPOLICY_TABLE_SIZEMAX_POA_POLICY_IDMIN_POA_POLICY_IDthreadModellifespanidUniquenessidAssignmentimplicitActivationretentionrequestProcessing"Policies["Policies[errorSetpolicyIdPOAPolicyValueOrder of *POLICY_ID :THREAD_LIFESPAN_ID_UNIQUENESS_ID_ASSIGNMENT_IMPLICIT_ACTIVATION_SERvANT_RETENTION_REQUEST_PROCESSING_The code in this class depends on this order! Maps Integer(policy type) to PolicyReturns the integer value of the POA policy, if this is aPOA policy, otherwise returns -1.If any errors were found, throw INVALID_POLICY with the smallestindex of any offending policy.Add the first index in policies at which the policy is of typepolicyId to errorSet, if the polictId is in policies (it may not be).Main constructor used from POA::create_POA.  This need only be visiblewithin the POA package. Make sure the defaults are set according to the POA spec Set to record all indices in policies for which errors were observed. Save the policy in policyMap to support POA.get_effective_policy, if it was not already saved in policyMap. if the value of this POA policy was previously set to a different value than the current value given in POAPolicyValue, record an error. Check for bad policy combinations NON_RETAIN requires USE_DEFAULT_SERVANT or USE_SERVANT_MANAGER IMPLICIT_ACTIVATION requires SYSTEM_ID and RETAINThread PoliciesLifespanID UniquenessID AssignmentServant RententionRequest ProcessingImplicit Activationproprietary servant caching policy/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/oa/poa/RequestProcessingPolicyImpl.java/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/oa/poa/RequestProcessingPolicyImpl.class"USE_ACTIVE_OBJECT_MAP_ONLY"USE_ACTIVE_OBJECT_MAP_ONLY"USE_DEFAULT_SERVANT"USE_DEFAULT_SERVANT"USE_SERVANT_MANAGER"USE_SERVANT_MANAGER"RequestProcessingPolicy["RequestProcessingPolicy[/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/oa/poa/ServantRetentionPolicyImpl.java/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/oa/poa/ServantRetentionPolicyImpl.class"ServantRetentionPolicy["ServantRetentionPolicy["RETAIN"RETAIN"NON_RETAIN" + "]"NON_RETAIN]/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/oa/poa/ThreadPolicyImpl.java/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/oa/poa/ThreadPolicyImpl.class"ThreadPolicy["ThreadPolicy["SINGLE_THREAD_MODEL"SINGLE_THREAD_MODEL"ORB_CTRL_MODEL" + "]"ORB_CTRL_MODEL]/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/oa/toa/TOA.java/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/oa/toacom.sun.corba.se.impl.oa.toaThe Transient Object Adapter is used for standard RMI-IIOP and Java-IDL(legacy JDK 1.2) object implementations.  Its protocol for managing objects is verysimple: just connect and disconnect.  There is only a single TOA instance per ORB,and its lifetime is the same as the ORB.  The TOA instance is always ready to receivemessages except when the ORB is shutting down.Connect the given servant to the ORB by allocating a transient object keyand creating an IOR and object reference using the current factory.Disconnect the object from this ORB./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/oa/toa/TOAFactory.javatom/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/oa/toa/TOAFactory.class/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/oa/toacodebaseToTOAtoa Return the dispatch-only TOA, which can dispatch request for objects created by any TOA. The dispatch-only TOA is not used for creating objrefs, so its codebase can be null (and must be, since we do not have a servant at this point)/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/oa/toa/TOAImpl.javaservants/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/oa/toa/TOAImpl.classjlcs"TOAImpl.connect can not be called on "TOAImpl.connect can not be called on "TOAImpl.disconnect can not be called on "TOAImpl.disconnect can not be called on The Transient Object Adapter (TOA) represents the OA for purely transientobjects.  It is used for standard RMI-IIOP as well as backwards compatibleserver support (i.e. the ORB.connect() method)Its characteristics include:<UL><LI>There is only one OA instance of the TOA.  Its OAId is { "TOA" }</LI><LI>There is not adapter manager.  The TOA manager ID is fixed.<LI><LI>State is the same as ORB state (TBD)</LI></UL>Other requirements:<LI>All object adapters must invoke ORB.adapterCreated when they are created.</LI><LI>All adapter managers must invoke ORB.adapterManagerStateChanged whentheir state changes, mapping the internal state to an ORT state.</LI><LI>AdapterStateChanged must be invoked (from somewhere) wheneveran adapter state changes that is not due to an adapter manager state change.</LI> Make the object key template REVISIT - POA specific REVISIT - absorb codebase into a policy Methods required for dispatching requestsGet the servant for the request given by the parameters.This will update thread Current, so that subsequent calls toreturnServant and removeCurrent from the same thread are for thesame request.is the request containing the rest of the request This is expected to result in an RMI-IIOP NoSuchObjectException. See bug 4973160.Return the most derived interface for the given servant and objectId. XXX For now, this does nothing. This will need fixing once we support ORB and thread level policies, but for now, there is no way to associate policies with the TOA, so getEffectivePolicy must always return null. Methods unique to the TOA Store the objref and get a userkey allocated by the transient object manager. Find out the repository ID for this objref. Create the new objref Copy the delegate from the new objref to the argument XXX handle the case of an attempt to connect a local object. Get the delegate, then ior, then transientKey, then delete servant/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/oa/toa/TransientObjectManager.javadoubleSizedoubleSize()/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/oa/toa/TransientObjectManager.classfreeListElement[]elementArraymaxSize128servantDataelem"storeServant returns key for element "storeServant returns key for element transientKey"lookupServant called with index="lookupServant called with index=", counter=", counter="\tcounter is valid"	counter is valid"\tcounter is invalid"	counter is invalid"lookupServantData called with index="lookupServantData called with index="deleting servant at index="deleting servant at index=olddeletedelete(com.sun.corba.se.impl.oa.toa.Element)/Library/Java/JavaVirtualMachines/jdk1.8.0_251.jdk/Contents/Home/jre/lib/rt.jar/com/sun/corba/se/impl/oa/toa/Library/Java/JavaVirtualMachines/jdk1.8.0_251.jdk/Contents/Home/jre/lib/rt.jar/com/sun/corba/se/impl/oa/toa/Element.classtoBytestoBytes()getKeygetKey(java.lang.Object,java.lang.Object)ElementElement(int,java.lang.Object)valid"Element["Element[ servant not found if we come here Object does not exist Assume caller is synchronized also stores "next pointer" in free list valid=true if this Element contains a valid servant Convert the index+counter into an 8-byte (big-endian) key. prevent double deletion add this to freeList/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/orb/AppletDataCollector.java/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/orbcom.sun.corba.se.impl.orbAppletDataCollectorAppletDataCollector(java.applet.Applet,java.util.Properties,java.lang.String,java.lang.String)/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/orb/AppletDataCollector.class/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/orbappletapplocalHostNameconfigurationHostNameCopyright (c) 2002, Oracle and/or its affiliates. All rights reserved. We do not use system properties for applets in order to avoid security exceptions./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/orb/DataCollectorBase.javagetCORBAPrefixesgetCORBAPrefixes(java.util.Set)/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/orb/DataCollectorBase.classhasCORBAPrefixhasCORBAPrefix(java.lang.String)getFilePropertiesgetFileProperties()getPropertiesFromFilegetPropertiesFromFile(java.util.Properties,java.lang.String)getSystemPropertyNamesgetSystemPropertyNames()makeIteratormakeIterator(java.util.Enumeration)findMatchingPropertyNamefindMatchingPropertyName(java.util.Set,java.lang.String)getSystemPropertygetSystemProperty(java.lang.String)findPropertiesByNamefindPropertiesByName(java.util.Iterator,com.sun.corba.se.impl.orb.PropertyCallback)findPropertiesByPrefixfindPropertiesByPrefix(java.util.Set,java.util.Iterator,com.sun.corba.se.impl.orb.PropertyCallback)checkSetParserCalledcheckSetParserCalled()setPropertysetProperty(java.lang.String,java.lang.String)doPropertiesdoProperties(java.util.Properties)resultPropsoriginalPropssetParserCalledURLPropertyNamespropertyPrefixespropertyNamesparserpaserverHost"0.0.0.0"0.0.0.0"::"::"::ffff:0.0.0.0"::ffff:0.0.0.0"-ORB"-ORBargNamecallback/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/orb/DataCollectorBase$1.classget(java.lang.String)URLCallback/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/orb/DataCollectorBase$2.class/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/orb/DataCollectorBase$3.classEnumeration<?>filePropsnormalNamesprefixNames/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/orb/DataCollectorBase$4.classrefNamerefValue"setParser not called."setParser not called.prefixesgetPropertyprefixsuffix/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/orb/DataCollectorBase$5.class/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/orb/DataCollectorBase$6.classfileNamedefaults"lib""orb.properties"orb.propertiesuserHome"user.home"user.homePropertyCallbackPropertyCallback()/Library/Java/JavaVirtualMachines/jdk1.8.0_251.jdk/Contents/Home/jre/lib/rt.jar/com/sun/corba/se/impl/orb/Library/Java/JavaVirtualMachines/jdk1.8.0_251.jdk/Contents/Home/jre/lib/rt.jar/com/sun/corba/se/impl/orb/PropertyCallback.class XXX This is fully initialized here.  So do we ever want to generalize this (or perhaps this is the wrong place for this?) Make sure that we are ready to handle -ORBInitRef.  This is special due to the need to handle multiple -ORBInitRef args as prefix parsing.//////////////////////////////////////////////////////// Public interface defined in DataCollector public interface from DataCollector that must be defined in subclasses Implementation methods needed in subclasses methods for use by subclasses All command-line args are of the form "-ORBkey value". The key is mapped to <prefix>.ORBkey. Cannot use propertyPrefixes here, since there is no way to fetch properties by prefix from an Applet. Special Case: Convert any applet parameter relative URLs to an absolute URL based on the Document Root. This is so HTML URLs can be kept relative which is sometimes useful for managing the Document Root layout. Just preserve the original (malformed) value: the error will be handled later. Map System properties to ORB properties. Security bug fix 4278205: Only allow reading of system properties with ORB prefixes. Previously a malicious subclass was able to read ANY system property. Note that other prefixes are fine in other contexts; it is only system properties that should impose a restriction. internal implementation Store name, value in resultProps, with special treatment of ORBInitRef.  All updates to resultProps must happen through this method. Value is <name>=<URL> For each prefix in prefixes, For each name in propertyNames, if (prefix is a prefix of name) get value from getProperties and setProperty (name, value). Note: do a put even if value is null since just the presence of the property may be significant. For each prefix in names, get the corresponding property value from the callback, and store the name/value pair in the result. Map command-line arguments to ORB properties. This will not throw a SecurityException because this class was loaded from rt.jar using the bootstrap classloader. if (ORBInitDebug) dprint( "ORB properties file " + fileName + " not found: " + exc) ; Return only those element of prefixes for which hasCORBAPrefix is true. Used to collect properties from various sources./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/orb/DataCollectorFactory.javaDataCollectorFactoryDataCollectorFactory()/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/orb/DataCollectorFactory.classappletHostappletCodeBase/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/orb/NormalDataCollector.java/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/orb/NormalDataCollector.class/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/orb/NormalParserAction.javapropertyNameCreate a String[] of all suffixes of property names thatmatch the propertyName prefix, pass this to op, and return theresult./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/orb/NormalParserData.javatestData/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/orb/NormalParserData.classdefaultValuetestValue/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/orb/ORBConfiguratorImpl.javainitRequestDispatcherRegistryinitRequestDispatcherRegistry(com.sun.corba.se.spi.orb.ORB)/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/orb/ORBConfiguratorImpl.classinitIORFindersinitIORFinders(com.sun.corba.se.spi.orb.ORB)initObjectCopiersinitObjectCopiers(com.sun.corba.se.spi.orb.ORB)ORB_STREAMregisterInitialReferencesregisterInitialReferences(com.sun.corba.se.spi.orb.ORB)initServiceContextRegistryinitServiceContextRegistry(com.sun.corba.se.spi.orb.ORB)initializeNaminginitializeNaming(com.sun.corba.se.spi.orb.ORB)setLegacySocketFactoryORBsetLegacySocketFactoryORB(com.sun.corba.se.spi.orb.ORB,com.sun.corba.se.spi.legacy.connection.ORBSocketFactory)createAndRegisterAcceptorcreateAndRegisterAcceptor(com.sun.corba.se.spi.orb.ORB,com.sun.corba.se.spi.legacy.connection.ORBSocketFactory,int,java.lang.String,java.lang.String)initializeTransportinitializeTransport(com.sun.corba.se.spi.orb.ORB)persistentServerInitializationpersistentServerInitialization(com.sun.corba.se.spi.orb.ORB)runUserConfiguratorsrunUserConfigurators(com.sun.corba.se.spi.orb.DataCollector,com.sun.corba.se.spi.orb.ORB)action"ORBUserConfigurators"ORBUserConfigurators"userConfigurators"userConfiguratorscollectorconfigserverEndpoints"ORBD must support IIOP_CLEAR_TEXT"ORBD must support IIOP_CLEAR_TEXTodcontactInfoListFactoryAcceptor[]legacySocketFactoryUSLPort[]uslPorts/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/orb/ORBConfiguratorImpl$1.classcreate(com.sun.corba.se.spi.ior.IOR)setORBsetORB(com.sun.corba.se.spi.orb.ORB)/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/orb/ORBConfiguratorImpl$2.class? extends ORBSocketFactoryClass<? extends ORBSocketFactory>Map<String,? extends ORBSocketFactory>ORBSocketFactory[]? extends ORBSocketFactory[]Constructor<? extends ORBSocketFactory>? super ? extends ORBSocketFactoryClass<? super ? extends ORBSocketFactory>TypeVariable<Class<? extends ORBSocketFactory>>TypeVariable<Class<? extends ORBSocketFactory>>[]"setORB"rtelocalResolverbootResolverurlOperationirResolverStringPair[]dirResolverresolverClass<UEInfoServiceContext>Class<CodeSetServiceContext>Class<SendingContextServiceContext>Class<ORBVersionServiceContext>Class<MaxStreamFormatVersionServiceContext>closure/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/orb/ORBConfiguratorImpl$3.classfutureprofFinderprofTempFindercompFindercsublcsfbootsd"TINI"TINI XXX This should go away once we get rid of the port exchange for ORBD XXX These should move to SPI XXX This needs an SPI REVISIT: this should be ProtocolDefault. Run any pluggable configurators.  This is a lot like ORBInitializers, only it uses the internal ORB and has access to all data for parsing. XXX Log this exception ignore this for now: a bad user configurator does nothing determine the ORBD port so that persistent objrefs can be REVISIT - use exception instead of -1.This is made somewhat complex because we are currently supportingthe ContactInfoList/Acceptor *AND* the legacy SocketFactorytransport architecture. BEGIN Legacy END Legacy Check for incorrect configuration. Client and Server side setup. Set up client side. Since the user specified a legacy socket factory we need to use a ContactInfoList that will use the legacy socket factory. The user specified an explicit ContactInfoListFactory. Use the default. Set up server side. Maybe allocate the Legacy default listener. If old legacy properties set, or there are no explicit acceptors then register a default listener.  Type of default listener depends on presence of legacy socket factory. Note: this must happen *BEFORE* registering explicit acceptors. Allocate user listeners.Legacy: name. REVISIT: see ORBD. make factory in TransportDefault. Note: the createServerSocket and createSocket methods on the DefaultSocketFactory need to get data from the ORB but we cannot change the interface.  So set the ORB (if it's ours) by reflection. NOTE: If there is no method then it is not ours - so ignore it. Register the Dynamic Any factory No optimization or policy selection here. Register the ValueFactory instances for ORT Register an ObjectKeyFactory register client subcontracts register server delegates register local client subcontractsRegister the server delegate that implements the ancient bootstrapnaming protocol.  This takes an object key of either "INIT" or"TINI" to allow for big or little endian implementations. Register object adapter factories/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/orb/ORBDataParserImpl.java/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/orb/ORBDataParserImpl.classenableJavaSerializationdisableDirectByteBufferUsereadTimeoutsconnectionSocketUseWorkerThreadForEventconnectionSocketUseSelectThreadToWaitconnectionSocketTypeacceptorSocketUseWorkerThreadForEventacceptorSocketUseSelectThreadToWaitacceptorSocketTypecorbaContactInfoListFactorydebugFlagsdefaultInitReforbInitialReferencesorbInitializersbadServerIdHandlerClassserverIsORBActivatedpersistentServerIdpersistentServerIdInitializedpersistentServerPortpersistentPortInitializedalwaysSendCodeSetCtxuseByteOrderMarkersInEncapsgiopAddressDispositiongiopTargetAddressPreferencegiop12BuffMgrgiop11BuffMgrgiopBufferSizegiopFragmentSizenumberToReclaimlowWaterMarkhighWaterMarkallowLocalOptimizationpropertyInitRefservicesURLorbServerIdPropertySpecifiediiopPrimaryToContactInfoiorToSocketInfouserSpecifiedListenPortssocketFactorylistenOnAllInterfacesORBServerPortORBServerHostORBInitialPortORBInitialHostgvParserData[] This is not initialized from ParserTable. Public accessor methods ========================================================================Always grow for 1.0If a "faulty" GIOPVersion is passed, it's going to return 0;the GIOP Target Addressing preference of the ORB.This ORB by default supports all addressing dispositions unless specifiedotherwise via a java system property ORBConstants.GIOP_TARGET_ADDRESSINGpublic void setPersistentServerPort(int sp)persistentServerPort = sp;persistentPortInitialized = true;Set the persistent-server-id of this server. This id is the sameacross multiple activations of this server. The id can be set to anyinteger value other than 0. This id must be set before any persistentobjects can be created.public void setPersistentServerId(int id)persistentServerId = id;persistentServerIdInitialized = true;Return the persistent-server-id of this server. This id is the sameacross multiple activations of this server. This is in contrast tocom.sun.corba.se.impl.iiop.ORB.getTransientServerId() whichreturns a transient id that is guaranteed to be differentacross multiple activations ofthis server. The user/environment is required to supply thepersistent-server-id every time this server is started, inthe ORBServerId parameter, System properties, or other means.The user is also required to ensure that no two persistent serverson the same host have the same server-id.Get the prefered code sets for connections. Should the client send the code set service context on everyrequest? Methods for constructing and initializing this object ===========================================/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/orb/ORBImpl.javathreadPoolManagerAccessLock/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/orb/ORBImpl.classlegacyServerSocketManagerAccessLocktransportManagerAccessorLockobjectKeyFactoryAccessLockcorbaContactInfoListFactoryAccessLockclientDelegateFactoryAccessorLockgetLocalHostNamegetLocalHostName()localHostStringgetHostNamegetHostName(java.lang.String)badServerIdHandlerAccessLockgetTOAFactorygetTOAFactory()getPOAFactory()postInitpostInit(java.lang.String[],com.sun.corba.se.spi.orb.DataCollector)initIORTypeCheckRegistryinitIORTypeCheckRegistry()preInitpreInit(java.lang.String[],java.util.Properties)threadpoolMgrorbOwnsThreadPoolManagerobjectKeyFactorytaggedProfileTemplateFactoryFindertaggedProfileFactoryFindertaggedComponentFactoryFinderIORTYPECHECKREGISTRY_FILTER_PROPNAMEresolverLockinsNamingDelegateurlOperationLockclientDelegateFactorybadServerIdHandlerconfigDatapoaFactorytoaFactoryiorTypeCheckRegistryserviceContextRegistrytransientServerIdcopierManagerrequestDispatcherRegistryorbVersionThreadLocalvalueFactoryCachetypeCodeForClassMapisProcessingInvocationnumInvocationsinvocationObjSTATUS_DESTROYEDSTATUS_SHUTDOWNSTATUS_SHUTTING_DOWNSTATUS_OPERATINGwaitForCompletionObjshutdownObjrunObjsvResponseReceiveddynamicRequestscodeBaseIORclientInvocationInfoStackOAInvocationInfoStack/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/orb/ORBImpl$1.class"com.sun.CORBA.ORBIorTypeCheckRegistryFilter"com.sun.CORBA.ORBIorTypeCheckRegistryFilterverObj/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/orb/ORBImpl$2.class/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/orb/ORBImpl$3.class/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/orb/ORBImpl$4.classfilterProps/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/orb/ORBImpl$5.classPrivilegedAction<String>".initIORTypeCheckRegistry, IORTypeCheckRegistryImpl created for properties == ".initIORTypeCheckRegistry, IORTypeCheckRegistryImpl created for properties == ".initIORTypeCheckRegistry, IORTypeCheckRegistryImpl NOT created for properties == ".initIORTypeCheckRegistry, IORTypeCheckRegistryImpl NOT created for properties == token? extends ORBImplClass<? extends ORBImpl>Map<String,? extends ORBImpl>ORBImpl[]? extends ORBImpl[]Constructor<? extends ORBImpl>? super ? extends ORBImplClass<? super ? extends ORBImpl>TypeVariable<Class<? extends ORBImpl>>TypeVariable<Class<? extends ORBImpl>>[]"DebugFlag"DebugFlagmodConfigParserConfigParser()/Library/Java/JavaVirtualMachines/jdk1.8.0_251.jdk/Contents/Home/jre/lib/rt.jar/com/sun/corba/se/impl/orb/ORBImpl$ConfigParser.classClass<ORBConfiguratorImpl>"ORBConfigurator"ORBConfigurator"configurator"configuratordataCollectoriexcoperRequest[]currRequestveelemsbpoptcKindboxed_typeidentifierinsndobj2" already registered" already registeredSet<ObjectAdapterFactory>Collection<ObjectAdapterFactory>Iterable<ObjectAdapterFactory>oasetHashSet<ObjectAdapterFactory>AbstractSet<ObjectAdapterFactory>AbstractCollection<ObjectAdapterFactory>? extends ObjectAdapterFactoryCollection<? extends ObjectAdapterFactory>Iterable<? extends ObjectAdapterFactory>HashSet<ObjectAdapterFactory>(java.util.Collection)Spliterator<ObjectAdapterFactory>? super ObjectAdapterFactoryConsumer<? super ObjectAdapterFactory>Iterator<ObjectAdapterFactory>Stream<ObjectAdapterFactory>BaseStream<ObjectAdapterFactory,Stream<ObjectAdapterFactory>>Predicate<? super ObjectAdapterFactory>add(com.sun.corba.se.spi.oa.ObjectAdapterFactory)AbstractCollection<ObjectAdapterFactory>()AbstractSet<ObjectAdapterFactory>()HashSet<ObjectAdapterFactory>(int,float,boolean)HashSet<ObjectAdapterFactory>(int)HashSet<ObjectAdapterFactory>(int,float)HashSet<ObjectAdapterFactory>()shutdownFirststacksubcontractIdinvocationInfoStackclientInvocationInfostringToObjectsdelmgrSynchVariableSynchVariable()/Library/Java/JavaVirtualMachines/jdk1.8.0_251.jdk/Contents/Home/jre/lib/rt.jar/com/sun/corba/se/impl/orb/SynchVariable.classCopyright (c) 2002, 2017, Oracle and/or its affiliates. All rights reserved.The JavaIDL ORB implementation. pure java orb, caching the servant IOR per ORB Vector holding deferred Requests XXX Should we move invocation tracking to the first level server dispatcher? ORB.shutdown(true). This map is caching TypeCodes created for a certain class (key) and is used in Util.writeAny() Cache to hold ValueFactories (Helper classes) keyed on repository ids thread local variable to store the current ORB version. default ORB version is the version of ORB with correct Rep-id changes Needed here to implement connect/disconnect Needed here for set_delegate The interceptor handler, which provides portable interceptor services for subcontracts and object adapters. All access to resolver, localResolver, and urlOperation must be protected using resolverLock.  Do not hold the ORBImpl lock while accessing resolver, or deadlocks may occur. Note that we now have separate locks for each resolver type.  This is due to bug 6980681 and 6238477, which was caused by a deadlock while resolving a corbaname: URL that contained a reference to the same ORB as the ORB making the call to string_to_object.  This caused a deadlock between the client thread holding the single lock for access to the urlOperation, and the server thread handling the client is_a request waiting on the same lock to access the localResolver. Used for resolver_initial_references and list_initial_services Used for register_initial_references Converts strings to object references for resolvers and string_to_object resolverLock must be used for all access to either resolver or localResolver, since it is possible for the resolver to indirectly refer to the localResolver.  Also used to protect access to insNamingDelegate. Methods that are synchronized MUST stay synchronized. Methods that are NOT synchronized must stay that way to avoid deadlock. checkShutDownState - lock on different object - and normalize usage. starting/FinishDispatch and ShutdownCreate a new ORB. Should be followed by the appropriateset_parameters() call. All initialization is done through set_parameters().The following methods are ORB initialization preInit initializes all non-pluggable ORB data that is independent of the property parsing. Before ORBConfiguration we need to set a PINoOpHandlerImpl, because PersisentServer Initialization inside configurator will invoke orb.resolve_initial_references( ) which will result in a check on piHandler to invoke Interceptors. We do not want any Interceptors to be invoked before the complete ORB initialization. piHandler will be replaced by a real PIHandler implementation at the end of this method. This is the unique id of this server (JVM). Multiple incarnations of this server will get different ids. Compute transientServerId = milliseconds since Jan 1, 1970 Note: transientServerId will wrap in about 2^32 / 86400000 = 49.7 days. If two ORBS are started at the same time then there is a possibility of having the same transientServerId. This may result in collision and may be a problem in ior.isLocal() check to see if the object belongs to the current ORB. This problem is taken care of by checking to see if the IOR port matches ORB server port in legacyIsLocalServerPort() XXX need to move server ID to a string for CORBA 3.0.  At that point, make this more unique (possibly use java.rmi.server.UID). set default to version of the ORB with correct Rep-ids If there is a public boolean data member in this class named token + "DebugFlag", set it to true. ignore it XXX log this as info Class that defines a parser that gets the name of the ORBConfigurator class. The default here is the ORBConfiguratorImpl that we define, but this can be replaced. First, create the standard ORB config data. This must be initialized before the ORBConfigurator is executed. Set the debug flags early so they can be used by other parts of the initialization. REVISIT: this should go away after more transport init cleanup and going to ORT based ORBD. Create a parser to get the configured ORBConfigurator. Finally, run the configurator.  Note that the default implementation allows other configurators with their own parsers to run, using the same DataCollector. Last of all, create the PIHandler and run the ORB initializers. Initialize the thread manager pool and byte buffer pool so they may be initialized & accessed without synchronizationThe following methods are standard public CORBA ORB APIsGet a Current pseudo-object.The Current interface is used to manage thread-specificinformation for use by the transactions, security and otherservices. This method is deprecated,and replaced by ORB.resolve_initial_references("NameOfCurrentObject");a Current pseudo-object._REVISIT_The implementation of get_current is not clear. How wouldORB know whether the caller wants a Current for transactionsor security ?? Or is it assumed that there is just oneimplementation for both ? If Current is thread-specific,then it should not be instantiated; so where does theORB get a Current ?This should probably be deprecated.Create an NVListsize of list to createNVList createdNVListCreate an NVList corresponding to an OperationDefoperation def to use to create listCreate a NamedValueNamedValue createdCreate an ExceptionListExceptionList createdCreate a ContextListContextList createdGet the default Context objectthe default Context objectCreate an EnvironmentEnvironment created Invoke the send_oneway on each new RequestSend multiple dynamic requests asynchronously.an array of request objects. add the new Requests to pending dynamic Requests Invoke the send_deferred on each new RequestFind out if any of the deferred invocations have a response yet. poll on each pending requestGet the next request that has gotten a response.the next request ready with a response. check if there already is a response get the response for this successfully polled Request wait for a response reinitialize the response flagNotify response to ORB for get_next_responseConvert an object ref to a string.The object to stringify.A stringified object reference. Handle the null objref case Throw MARSHAL instead if this is a LOCAL_OBJECT_NOT_ALLOWED error. Not a local object problem: just rethrow the exception. Do not wrap and log this, since it was already logged at its point of origin.Convert a stringified object reference to the object it represents.The stringified object reference.The unstringified object reference. pure java orb support, moved this method from FVDCodeBaseImpl. Note that we connect this if we have not already done so. i.e. We are already connected to itGet the TypeCode for a primitive type.the integer kind for the primitive typethe requested TypeCodeCreate a TypeCode for a structure.the logical id for the typecode.the name for the typecode.an array describing the members of the TypeCode.the requested TypeCode.Create a TypeCode for a union.the type of the union discriminator.Create a TypeCode for an enum.Create a TypeCode for an alias.the type this is an alias for.Create a TypeCode for an exception.Create a TypeCode for an interface.Create a TypeCode for a string.the bound for the string.Create a TypeCode for a wide string.Create a TypeCode for a sequence.the bound for the sequence.the type of elements of the sequence.Create a recursive TypeCode in a sequence.the index to the enclosing TypeCode that isbeing referenced.Create a TypeCode for an array.the length of the array.the type of elements of the array.Create a new Anythe new Any created. TypeCodeFactory interface methods. Keeping track of type codes by repository id. Keeping a cache of TypeCodes associated with the class they got created from in Util.writeAny(). Store only one TypeCode per class.The following methods deal with listing and resolving the initial(bootstrap) object references such as "NameService".Get a list of the initially available CORBA services.This does not work unless an ORBInitialHost is specified duringinitialization (or unless there is an ORB running on the AppletHost)since the localhostnameis inaccessible to applets. If a service properties URL was specified,then it is used, otherwise the bootstrapping protocol is used.A list of the initial services available.Resolve the stringified reference of one of the initiallyavailable CORBA services.The stringified object reference of thedesired service.An object reference for the desired service.InvalidNameThe supplied identifier is not associatedwith a known service.SystemExceptionOne of a fixed set of Corba system exceptions.If this operation is called with an id, <code>"Y"</code>, and anobject, <code>YY</code>, then a subsequent call to<code>ORB.resolve_initial_references( "Y" )</code> willreturn object <code>YY</code>.The ID by which the initial reference will be known.The initial reference itself.if this operation is called with an empty string idor this operation is called with an id that is already registered,including the default names defined by OMG.BAD_PARAMif the obj parameter is null. Make all remote object references available for INS.The following methods (introduced in POA / CORBA2.1) deal withshutdown / single threading. This is to avoid deadlock: don't allow a thread that is processing a request to call shutdown( true ), because the shutdown would block waiting for the request to complete, while the request would block waiting for shutdown to complete. Avoid more than one thread performing shutdown at a time. At this point, the ORB status is certainly STATUS_SHUTTING_DOWN. If wait is true, another thread already called shutdown( true ), and so we wait for completion NOP: just loop and wait until state is changed perform the actual shutdown Cause all ObjectAdapaterFactories to clean up all of their internal state, which may include activated objects that have associated state and callbacks that must complete in order to shutdown.  This will cause new request to be rejected. Note that the caller must hold the ORBImpl lock.formal/99-10-07 p 159: "If destroy is called on an ORB that hasnot been shut down, it will start the shutdown process and block untilthe ORB has shut down before it destroys the ORB."Registers a value factory for a particular repository ID.the repository ID.the factory.the previously registered factory for the given repository ID,or null if no such factory was previously registered.org.omg.CORBA.BAD_PARAMif the registration fails.Unregisters a value factory for a particular repository ID.Finds and returns a value factory for the given repository ID.The value factory returned was previously registered by a call to{@link #register_value_factory} or is the default factory.the value factory.if unable to locate a factory.The bad server id handler is used by the Locator tosend back the location of a persistant server to the client.This is the implementation of the public API used to connecta servant-skeleton to the ORB. ORBServerId is specified then use that value XXX All of the isLocalXXX checking needs to be revisited. First of all, all three of these methods are called from only one place in impl.ior.IORImpl.  Second, we have problems both with multi-homed hosts and with multi-profile IORs. A possible strategy: like the LocalClientRequestDispatcher, we need to determine this more abstractly at the ContactInfo level. This level should probably just get the CorbaContactInfoList from the IOR, then iterator over ContactInfo.  If any ContactInfo is local, the IOR is local, and we can pick one to create the LocalClientRequestDispatcher as well.  Bottom line: this code needs to move. XXX What about multi-homed host? XXX isTransient info should be stored in subcontract registry***********************************************************************The following public methods are for ORB shutdown.keeping a copy of the getLocalHostName so that it can only be calledinternally and the unauthorized clients cannot have access to thelocalHost information, originally, the above code was callinggetLocalHostName from Connection.java.  If the hostname is cached inConnection.java, thenit is a security hole, since any unauthorized client has access tothe host information.  With this change it is used internally so thesecurity problem is resolved.  Also in Connection.java, thegetLocalHost() implementation has changed to always call theInetAddress.getLocalHost().getHostAddress()The above mentioned method has been removed from the connection class****************************************************************************This method always returns false because the ORB never needs themain thread to do work.This method does nothing. It is not required by the spec to do anything! pept.broker.Broker This is a new call - not a retry. Reset retry so recursive calls will get a new info object. 6763340: don't pop if this is a retry!Set the resolver used in this ORB.  This resolver will be used for list_initial_servicesand resolve_initial_references.Get the resolver used in this ORB.  This resolver will be used for list_initial_servicesSet the LocalResolver used in this ORB.  This LocalResolver is used forregister_initial_reference only.Get the LocalResolver used in this ORB.  This LocalResolver is used forSet the operation used in string_to_object calls.  The Operation must expect aString and return an org.omg.CORBA.Object.Get the operation used in string_to_object calls.  The Operation must expect a Class ORBImpl/////////////////////////////////////////////////////////////////////// Helper class for a Synchronization Variable Synchronization Variable set Flag to true get value reset Flag to true/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/orb/ORBSingleton.javagetFullORBgetFullORB()/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/orb/ORBSingleton.classstaticStubFactoryFactoryfullORBtckind"ORBSingleton: access denied"ORBSingleton: access deniedThe restricted singleton ORB implementation.For now, this class must implement just enough functionality to beused as a factory for immutable TypeCode instances.See ORBImpl.java for the real ORB implementation. This is used to support read_Object. orbos 98-01-18: Objects By Value -- beginNot strictly needed for TypeCode factory duty but these seemharmless enough.Things that aren't allowed.These are methods from com.sun.corba.se.impl.se.core.ORB To enable read_Object.Return the service context registryGet the transient server IDReturn the bootstrap naming port specified in the ORBInitialPort param.Return the bootstrap naming host specified in the ORBInitialHost param.Things from corba.ORB. Always use our latest ORB version (latest fixes, etc) NOTE: REMOVE THIS METHOD ONCE WE HAVE A ORT BASED ORBD/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/orb/ORBVersionImpl.javaorbType/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/orb/ORBVersionImpl.class"ORBVersionImpl["ORBVersionImpl[ The Comparable interface says that this method throws a ClassCastException if the given object's type prevents it from being compared./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/orb/ParserAction.javaReturn the property name or prefix for which this actionis applied.Return whether this action is for an exact match or a prefixmatch (true).Return the field name in an object that is set with the resultApply this action to props and return the result./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/orb/ParserActionBase.java/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/orb/ParserActionBase.class/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/orb/ParserActionFactory.javaParserActionFactoryParserActionFactory()/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/orb/ParserActionFactory.class/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/orb/ParserDataBase.java/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/orb/ParserDataBase.class/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/orb/ParserTable.javamakeInitRefOperationmakeInitRefOperation()/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/orb/ParserTable.classmakeAcceptorInstantiationOperationmakeAcceptorInstantiationOperation()makeROIOperationmakeROIOperation()makeGVOperationmakeGVOperation()makeFSOperationmakeFSOperation()makeADOperationmakeADOperation()makeCSOperationmakeCSOperation()makeContactInfoListFactoryOperationmakeContactInfoListFactoryOperation()makeIIOPPrimaryToContactInfoOperationmakeIIOPPrimaryToContactInfoOperation()makeIORToSocketInfoOperationmakeIORToSocketInfoOperation()makeSocketFactoryOperationmakeSocketFactoryOperation()makeLegacySocketFactoryOperationmakeLegacySocketFactoryOperation()makeBMGROperationmakeBMGROperation()makeMapOperationmakeMapOperation(java.util.Map)makeUSLOperationmakeUSLOperation()makeTTCPRTOperationmakeTTCPRTOperation()ParserTableParserTable()parserDatamyInstanceMY_CLASS_NAMEClass<ParserTable>Map<String,ParserTable>ParserTable[]Constructor<ParserTable>? super ParserTableClass<? super ParserTable>TypeVariable<Class<ParserTable>>TypeVariable<Class<ParserTable>>[]parserArraycodeSetTestStringdebugTestData"subcontract"subcontract"poa""transport"transportUSLPorts"FOO"FOO2701"BAR"BAR3333TestORBInitializersTestORBInitData"foo.bar.blech.NonExistent"foo.bar.blech.NonExistent"dummy"dummy"$TestORBInitializer1"$TestORBInitializer1"$TestORBInitializer2"$TestORBInitializer2TestAcceptorsTestAcceptorData"$TestAcceptor1"$TestAcceptor1"$TestAcceptor2"$TestAcceptor2TestORBInitRefData"Foo"Foo"ior:930492049394"ior:930492049394"Bar"Bar"ior:3453465785633576"ior:3453465785633576testServicesURLtestServicesString"corbaloc::camelot/NameService"corbaloc::camelot/NameService"debugFlags""subcontract,poa,transport"subcontract,poa,transport"ORBInitialHost""ORBInitialPort"27314"27314""ORBServerHost""camelot"camelot"ORBServerPort"38143"38143""listenOnAllInterfaces""foo"foo"persistentServerId"1234"1234""persistentServerIdInitialized""orbServerIdPropertySpecified""highWaterMark"3745"3745""lowWaterMark""12""numberToReclaim""231""giopVersion""2.3"2.3"giopFragmentSize""65536""giopBufferSize"234000"234000""giop11BuffMgr""CLCT"CLCT"giop12BuffMgr""GROW"GROW"giopTargetAddressPreference""2""giopAddressDisposition""alwaysSendCodeSetCtx""useByteOrderMarkers""useByteOrderMarkersInEncaps""charData""wcharData""allowLocalOptimization""true""legacySocketFactory""$TestLegacyORBSocketFactory"$TestLegacyORBSocketFactory"socketFactory""$TestORBSocketFactory"$TestORBSocketFactory"userSpecifiedListenPorts""FOO:2701,BAR:3333"FOO:2701,BAR:3333"iorToSocketInfo""$TestIORToSocketInfo"$TestIORToSocketInfo"iiopPrimaryToContactInfo""$TestIIOPPrimaryToContactInfo"$TestIIOPPrimaryToContactInfo"corbaContactInfoListFactory""$TestContactInfoListFactory"$TestContactInfoListFactory"persistentServerPort"2743"2743""persistentPortInitialized""294""serverIsORBActivated"Class<TestBadServerIdHandler>"badServerIdHandlerClass""$TestBadServerIdHandler"$TestBadServerIdHandlerClass<ORBInitializer>"orbInitializers"Class<Acceptor>"acceptors""acceptorSocketType""acceptorSocketUseSelectThreadToWait""acceptorSocketUseWorkerThreadForEvent""connectionSocketType""connectionSocketUseSelectThreadToWait""connectionSocketUseWorkerThreadForEvent""disableDirectByteBufferUse""readTimeouts""100:3000:300:20"100:3000:300:20"enableJavaSerialization""useRepId"Class<StringPair>"orbInitialReferences"Operation[]fourIopop2rtOp/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/orb/ParserTable$1.classoperateoperate(java.lang.Object)initialTimemaxGIOPHdrTimemaxGIOPBodyTimebackoffPercentttcprtOpsiopuslop/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/orb/ParserTable$2.classop3listenopcontactInfos/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/orb/ParserTable$3.class"STRM"STRMsfop/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/orb/ParserTable$4.classparamlegacySocketFactoryClassClass<ORBSocketFactory>Map<String,ORBSocketFactory>Constructor<ORBSocketFactory>? super ORBSocketFactoryClass<? super ORBSocketFactory>TypeVariable<Class<ORBSocketFactory>>TypeVariable<Class<ORBSocketFactory>>[]/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/orb/ParserTable$5.classsocketFactoryClass/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/orb/ParserTable$6.classiorToSocketInfoClassClass<IORToSocketInfo>Map<String,IORToSocketInfo>IORToSocketInfo[]Constructor<IORToSocketInfo>? super IORToSocketInfoClass<? super IORToSocketInfo>TypeVariable<Class<IORToSocketInfo>>TypeVariable<Class<IORToSocketInfo>>[]/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/orb/ParserTable$7.classiiopPrimaryToContactInfoClassClass<IIOPPrimaryToContactInfo>Map<String,IIOPPrimaryToContactInfo>IIOPPrimaryToContactInfo[]Constructor<IIOPPrimaryToContactInfo>? super IIOPPrimaryToContactInfoClass<? super IIOPPrimaryToContactInfo>TypeVariable<Class<IIOPPrimaryToContactInfo>>TypeVariable<Class<IIOPPrimaryToContactInfo>>[]/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/orb/ParserTable$8.classcontactInfoListFactoryClassClass<CorbaContactInfoListFactory>Map<String,CorbaContactInfoListFactory>CorbaContactInfoListFactory[]Constructor<CorbaContactInfoListFactory>? super CorbaContactInfoListFactoryClass<? super CorbaContactInfoListFactory>TypeVariable<Class<CorbaContactInfoListFactory>>TypeVariable<Class<CorbaContactInfoListFactory>>[]csop/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/orb/ParserTable$9.classadmap/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/orb/ParserTable$10.classInteger[]rangeopop1fschecker/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/orb/ParserTable$11.classgvHelpergvMain/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/orb/ParserTable$12.classnumsclsopindexOpmopmkinst/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/orb/ParserTable$13.classinitClassMap<String,ORBInitializer>Constructor<ORBInitializer>? super ORBInitializerClass<? super ORBInitializer>TypeVariable<Class<ORBInitializer>>TypeVariable<Class<ORBInitializer>>[]initializer/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/orb/ParserTable$13$1.classconnectionCachexbrokerxconnectionbroker/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/orb/ParserTable$14.classMap<String,Acceptor>Constructor<Acceptor>? super AcceptorClass<? super Acceptor>TypeVariable<Class<Acceptor>>TypeVariable<Class<Acceptor>>[]/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/orb/ParserTable$14$1.class/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/orb/ParserTable$15.classInitialize the parser data for the standard ORB parser.  This is used bothto implement ORBDataParserImpl and to provide the basic testing frameworkfor ORBDataParserImpl. REVISIT: The test data gets put into a Properties object where order is not guaranteed.  Thus the above array is in reverse. propertyName, operation, fieldName, defaultValue, testValue, testData (string or Pair[]) Where did this come from?ParserDataFactory.make( ORBConstants.INITIAL_PORT_PROPERTY,OperationFactory.booleanAction(),"ORBInitialPortInitialized", Boolean.FALSE,Boolean.TRUE, "27314" ), NOTE: We are putting SERVER_HOST_NAME configuration info into DataCollectorBase to avoid a security hole.  However, that forces us to also set LISTEN_ON_ALL_INTERFACES at the same time. This all needs to be cleaned up for two reasons: to get configuration out of DataCollectorBase and to correctly support multihoming. REVISIT after switch ParserDataFactory.make( ORBConstants.INITIAL_SERVICES_PROPERTY, OperationFactory.URLAction(), "servicesURL", null, testServicesURL, testServicesString ), ParserDataFactory.make( ORBConstants.DEFAULT_INIT_REF_PROPERTY, OperationFactory.stringAction(), "defaultInitRef", null, "Fooref", "Fooref" ), Note that the same property is used to set two different fields here.  This requires that both entries use the same test data, or the test will fail. No default - must be set by user if they are using legacy socket factory. Socket/Channel control Acceptor: useNIOSelector == true   useSelectThreadToWait = true   useWorkerThreadForEvent = false else   useSelectThreadToWait = false   useWorkerThreadForEvent = true Connection: For security reasons avoid creating an instance if this socket factory class is not one that would fail the class cast anyway. ClassNotFoundException, IllegalAccessException, InstantiationException, SecurityException or ClassCastException For security reasons avoid creating an instance if this class is one that would fail the class cast to ORBInitializer anyway. Now that we have a class object, instantiate one and remember it: Unwrap the exception, as we don't care exc here REVISIT - this is a cut and paste modification of makeROIOperation. Object is String[] of length 2./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/orb/PrefixParserAction.java/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/orb/PrefixParserAction.classprefixLengthmatchesIterator<Object>Spliterator<Object>Consumer<? super Object>Stream<Object>BaseStream<Object,Stream<Object>>Predicate<? super Object>Collection<? extends Object>Iterable<? extends Object>For each String s that matches the prefix given by getPropertyName(),apply getOperation() to { suffix( s ), value }and add the result to an Object[]which forms the result of apply.  Returns null if there are nomatches. Find all keys in props that start with propertyName Convert the list into an array of the proper type. An Object[] as a result does NOT work.  Also report any errors carefully, as errors here or in parsers that use this Operation often show up at ORB.init()./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/orb/PrefixParserData.java/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/orb/PrefixParserData.classsp/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/orb/PropertyOnlyDataCollector.java/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/orbutil/CacheTable.java/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/orbutilcom.sun.corba.se.impl.orbutilput_tableput_table(java.lang.Object,int)/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/orbutil/CacheTable.class/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/orbutilhash(int)moduloTableSizemoduloTableSize(int)growgrow()initTablesinitTables()CacheTableCacheTable()rmapMAX_SIZEINITIAL_SIZEnoReverseMaprnext/Library/Java/JavaVirtualMachines/jdk1.8.0_251.jdk/Contents/Home/jre/lib/rt.jar/com/sun/corba/se/impl/orbutil/Library/Java/JavaVirtualMachines/jdk1.8.0_251.jdk/Contents/Home/jre/lib/rt.jar/com/sun/corba/se/impl/orbutil/CacheTable$Entry.classuoldMapnewEntryrindex this chains the collision list of table "map" this chains the collision list of table "rmap" size must be power of 2System.out.println("using new cache table"); now rehash the entries into the new table these are the "supplemental hash function" copied from java.util.HashMap, supposed to be "critical" if we get here we are trying to put in the same key/val pair this is a no-op, so we just return this means the key is not present in our table then it shouldnt be present in our reverse table either/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/orbutil/CorbaResourceUtil.javainitResourcesinitResources()/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/orbutil/CorbaResourceUtil.classresourcesresourcesInitialized"no text found: \""no text found: ""\"""format"no text found: key = \""no text found: key = ""\", " +
                "arguments = \"{0}\", \"{1}\", \"{2}\""", arguments = "{0}", "{1}", "{2}""com.sun.corba.se.impl.orbutil.resources.sunorb"com.sun.corba.se.impl.orbutil.resources.sunorb"fatal: missing resource bundle: "fatal: missing resource bundle: /Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/orbutil/DenseIntMapImpl.javaextendextend(int)/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/orbutil/DenseIntMapImpl.classcheckKeycheckKey(int)"Key must be >= 0."Key must be >= 0.maxUtility for managing mappings from densely allocated integerkeys to arbitrary objects.  This should only be used forkeys in the range 0..max such that "most" of the key space is actuallyused.If key >= 0, return the value bound to key, or null if none.Throws IllegalArgumentException if key <0.If key >= 0, bind value to the key./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/orbutil/GetPropertyAction.javadefaultVal/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/orbutil/GetPropertyAction.classthePropA convenience class for retrieving the string value of a systemproperty as a privileged action.  This class is directly copiedfrom sun.security.action.GetPropertyAction in order to avoiddepending on the sun.security.action package.<p>An instance of this class can be used as the argument of<code>AccessController.doPrivileged</code>.<p>The following code retrieves the value of the systemproperty named <code>"prop"</code> as a privileged action: <p><pre>String s = (String) java.security.AccessController.doPrivileged(new GetPropertyAction("prop"));</pre>Roland Schemersjava.security.PrivilegedActionjava.security.AccessControllerConstructor that takes the name of the system property whosestring value needs to be determined.the name of the system property.Constructor that takes the name of the system property and the defaultvalue of that property.defaulValthe default value.Determines the string value of the system property whosename was specified in the constructor.the string value of the system property,or the default value if there is no property with that key./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/orbutil/HexOutputStream.javawriter/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/orbutil/HexOutputStream.class'1''2''3''4''5''6''7''8''9''b''c''e''f'0xFWrites each input byte as a 2 byte hexidecimal output pair making itpossible to turn arbitrary binary data into an ASCII format.The high 4 bits of the byte is translated into the first byte.Jeff NisewangerCreates a new HexOutputStream.The underlying StringWriter.Writes a byte. Will block until the byte is actuallywritten.param b The byte to write out.java.io.IOExceptionI/O error occurred./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/orbutil/LegacyHookGetFields.javaLegacyHookGetFieldsLegacyHookGetFields(java.util.Hashtable)/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/orbutil/LegacyHookGetFields.class/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/orbutil/LegacyHookPutFields.java/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/orbutil/LegacyHookPutFields.classLegacyHookPutFieldsLegacyHookPutFields()/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/orbutil/LogKeywords.java"<<LIFECYCLE CREATE>>"<<LIFECYCLE CREATE>>"<<LIFECYCLE INITIALIZE>>"<<LIFECYCLE INITIALIZE>>"<<LIFECYCLE SHUTDOWN>>"<<LIFECYCLE SHUTDOWN>>"<<LIFECYCLE DESTROY>>"<<LIFECYCLE DESTROY>>"<<SUCCESS>>"<<SUCCESS>>"<<FAILURE>>"<<FAILURE>>"<<NAMING RESOLVE>>"<<NAMING RESOLVE>>"<<NAMING LIST>>"<<NAMING LIST>>"<<NAMING BIND>>"<<NAMING BIND>>"<<NAMING UNBIND>>"<<NAMING UNBIND>>"<<NAMING REBIND>>"<<NAMING REBIND>>All the Keywords that will be used in Logging Messages for CORBA need tobe defined here. The LogKeywords will be useful for searching log messagesbased on the standard keywords, it is also useful to work with LogAnalyzingtools.We will try to standardize these keywords in JSR 117 Logging* Keywords for Lifecycle Loggers.* _REVISIT_ After it is clearly defined in JSR 117* Keywords for Naming Read Loggers.* Keywords for Naming Update Loggers./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/orbutil/ORBConstants.javaORBConstantsORBConstants()/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/orbutil/ORBConstants.class"IOR:"IOR:0x4e454f0013131650560x53554e001398099456"org.omg."org.omg."org.omg.CORBA."org.omg.CORBA."ORBInitialServices"ORBInitialServices"ORBDefaultInitRef"ORBDefaultInitRef"ORBInitRef"ORBInitRef"com.sun.CORBA."com.sun.CORBA."ORBAllowLocalOptimization"ORBAllowLocalOptimization"ORBid"ORBid"ORBServerId"ORBServerId"ORBDebug"ORBDebug"ORBUseRepId"ORBUseRepId"INTERNAL USE ONLY: listen on all interfaces"INTERNAL USE ONLY: listen on all interfaces"giop.ORBGIOPVersion"giop.ORBGIOPVersion"giop.ORBFragmentSize"giop.ORBFragmentSize"giop.ORBBufferSize"giop.ORBBufferSize"giop.ORBGIOP11BuffMgr"giop.ORBGIOP11BuffMgr"giop.ORBGIOP12BuffMgr"giop.ORBGIOP12BuffMgr"giop.ORBTargetAddressing"giop.ORBTargetAddressing"connection.ORBHighWaterMark"connection.ORBHighWaterMark"connection.ORBLowWaterMark"connection.ORBLowWaterMark"connection.ORBNumberToReclaim"connection.ORBNumberToReclaim"transport.ORBAcceptor"transport.ORBAcceptor"transport.ORBContactInfoList"transport.ORBContactInfoList"legacy.connection.ORBSocketFactoryClass"legacy.connection.ORBSocketFactoryClass"transport.ORBSocketFactoryClass"transport.ORBSocketFactoryClass"transport.ORBListenSocket"transport.ORBListenSocket"transport.ORBIORToSocketInfoClass"transport.ORBIORToSocketInfoClass"transport.ORBIIOPPrimaryToContactInfoClass"transport.ORBIIOPPrimaryToContactInfoClass"transport.ORBTCPReadTimeouts"transport.ORBTCPReadTimeouts3000300"transport.ORBUseNIOSelectToWait"transport.ORBUseNIOSelectToWait"transport.ORBAcceptorSocketType"transport.ORBAcceptorSocketType"transport.ORBAcceptorSocketUseWorkerThreadForEvent"transport.ORBAcceptorSocketUseWorkerThreadForEvent"transport.ORBConnectionSocketType"transport.ORBConnectionSocketType"transport.ORBConnectionSocketUseWorkerThreadForEvent"transport.ORBConnectionSocketUseWorkerThreadForEvent"transport.ORBDisableDirectByteBufferUse"transport.ORBDisableDirectByteBufferUse"Socket"Socket"SocketChannel"SocketChannel"POA.ORBPersistentServerPort"POA.ORBPersistentServerPort"POA.ORBServerId"POA.ORBServerId"POA.ORBBadServerIdHandlerClass"POA.ORBBadServerIdHandlerClass"POA.ORBActivated"POA.ORBActivated"POA.ORBServerName"POA.ORBServerName"activation.ORBServerVerify"activation.ORBServerVerify"com.sun.corba."com.sun.corba."com.sun.corba.se."com.sun.corba.se."CosTransactions.ORBJTSClass"CosTransactions.ORBJTSClass"encoding.ORBEnableJavaSerialization"encoding.ORBEnableJavaSerialization"org.omg.PortableInterceptor.ORBInitializerClass."org.omg.PortableInterceptor.ORBInitializerClass."ORBUseDynamicStub"ORBUseDynamicStub"ORBDynamicStubFactoryFactoryClass"ORBDynamicStubFactoryFactoryClass900"localhost"localhost2089"activation.DbDir"activation.DbDir"activation.db"activation.db"activation.Port"activation.Port"activation.ServerPollingTime"activation.ServerPollingTime"activation.ServerStartupDelay"activation.ServerStartupDelay10491050"ORBLogLevel"ORBLogLevel"com.sun.corba.se.impl.logging.LogStrings"com.sun.corba.se.impl.logging.LogStrings"1000000"1000000"RootPOA"RootPOA"POACurrent"POACurrent"ServerActivator"ServerActivator"ServerLocator"ServerLocator"ServerRepository"ServerRepository"TransactionCurrent"TransactionCurrent"DynAnyFactory"DynAnyFactory"PICurrent""CodecFactory"CodecFactory"orb.db"orb.db"db""initial.db"initial.db"logs"logs"orbids"orbids"orbids.db"orbids.db120000"default-threadpool"default-threadpool"default-workqueue"default-workqueue"codeset.AlwaysSendCodeSetCtx"codeset.AlwaysSendCodeSetCtx"codeset.UseByteOrderMarkers"codeset.UseByteOrderMarkers"codeset.UseByteOrderMarkersInEncaps"codeset.UseByteOrderMarkersInEncaps"codeset.charsets"codeset.charsets"codeset.wcharsets"codeset.wcharsetsTAGStag-request@omg.orgFAQ on tags and tag allocation: http://doc.omg.org/ptc/99-02-01.http://doc.omg.org/standard-tagshttp://doc.omg.org/vendor-tagsLast update:  19th August 2003 (ptc/03-08-14)// Legacy1 profile tag      0x4f4e4300              ("ONC\x00")1 profile tag      0x4e454f00              ("NEO\x00")1 profile tag      0x434f4f4c              ("COOL")16 service tags    0x4e454f00 - 0x4e454f0f ("NEO\x00" - "NEO\x0f")// Current16 VMCID           0x5355xxxx              ("SU\x00\x00" - "SU\xff\xff")16 profile tags    0x53554e00 - 0x53554e0f ("SUN\x00" - "SUN\x0f")16 ORB Type IDs    0x53554e00 - 0x53554e0f ("SUN\x00" - "SUN\x0f")64 service tags    0x53554e00 - 0x53554e3f ("SUN\x00" - "SUN\x3f")64 component tags  0x53554e00 - 0x53554e3f ("SUN\x00" - "SUN\x3f") All NEO service contexts must be in the range NEO_FIRST_SERVICE_CONTEXT to NEO_FIRST_SERVICE_CONTEXT + NUM_NEO_SERVICE_CONTEXTS - 1 Tagged Components Ids Used by AS 7 for IIOP failover. Used by AS 8.1 for Request Partioning TaggedComponentId for Java serialization tagged component. Service Context Ids All Sun policies are allocated using the SUNVMCID, which is also used for minor codes.  This allows 12 bits of offset, so the largest legal Sun policy is SUNVMCID.value + 4095. These are the subcontract IDs for various qualities of service/implementation. Persistent SCIDs have the second bit as 1. SCIDs less than FIRST_POA_SCID are JavaIDL SCIDs. Constants for ORB properties ************************************************************** All ORB properties must follow the following rules: 1. Property names must start with either    ORG_OMG_CORBA_PREFIX or SUN_PREFIX. 2. Property names must have unique suffixes after the last ".". 3. Property names must have "ORB" as the first 3 letters    in their suffix. 4. proprietary property names should have a subsystem    where appropriate after the prefix. org.omg.CORBA properties must be defined by OMG standards The well known org.omg.CORBA.ORBClass and org.omg.CORBA.ORBSingletonClass are not included here since they occur in org.omg.CORBA.ORB. All of our proprietary properties must start with com.sun.CORBA general properties This property is provided for backward compatibility reasons Property for setting use of repository Ids during serialization. NOTE: This is an internal property.  It should never be set by a user.  That is the reason it has spaces in its name - to make it harder to use. giop related properties - default settings in decimal formGrowingStreaming object key used for target addressing iop profile used for target addressing ior used for target addressing accept all target addressing dispositions (default) CORBA formal 00-11-03 sections 15.4.2.2, 15.4.3.2, 15.4.6.2 state that the GIOP 1.2 RequestMessage, ReplyMessage, and LocateReply message bodies must begin on 8 byte boundaries. The GIOP 1.2 fragments must be divisible by 8.  We generalize this to GIOP 1.1 fragments, as well. connection management properties Legacy: Request partitioning maximum and minimum thread pool id constants. transport read tcp timeout property, colon separated property with syntax <initial time to wait:max read giop header time to wait: max read message time to wait:backoff factor> initial time to wait in milliseconds if a transport tcp read returns 0 bytes max time to spend in cumulative waits in milliseconds if a transport tcp read returns 0 bytes if a transport tcp read of GIOP header returns 0 bytes A backoff percentage used to compute the next amount of time to wait on a subsequent transport tcp read of 0 bytes "Socket" | "SocketChannel" Note: Connections accepted by SocketChannel will be SocketChannel. Applicable if using SocketChannel and using select thread. Applicable on client-side. "Socket" | "SocketChannel" Applicable if using SocketChannel and using select thread Used to disable the use of direct byte buffers.  This enables much easier debugging, because the contents of a direct byte buffer cannot be viewed in most (all?) debuggers. POA related policies Server Properties; e.g. when properties passed to ORB activated servers This one is an exception, but it may be externally visible Necessary for package renaming to work correctly Property for enabling ORB's use of Java serialization. Constants for ORB prefixes ************************************************************** Constants for NameService properties ************************************ http://www.omg.org/cgi-bin/doc?ptc/00-08-07 [ Section 13.6.7.3 ] defines the default GIOP minor version to be 0. Constants for INS properties ******************************************** GIOP Version number for validation of INS URL format addresses Subcontract's differentiation using the TRANSIENT and PERSISTENT Name Service Property. Constants for ORBD properties **************************************************************** These properties are never passed on ORB init: they are only passed to ORBD. If RI is starting the NameService then they would indicate that by passing the RI flag. That would start a Persistent Port to listen to INS request.***************** Constants for Logging **************** Constants for initial references ************************************************************* A large Number to make sure that other ServerIds doesn't collide with NameServer Persistent Server Id New for Portable Interceptors Constants for ORBD DB *********************************************************************** Constants for ThreadPool ******************************************************************** Default value for when inactive threads in the pool can stop running (ms) Default name of the threadpool Default name of the workqueue Constants for minor code bases ************************************************************** This is the value that pre-Merlin Sun ORBs incorrectly used.  We preserve this here for backwards compatibility, but note that the current ORB must never create a BAD_PARAM system exception with this minor code. Code Set related ******************************************************* If we don't always send the code set context, there's a possibility of failure when fragments of a smaller request are interleved with those of a first request with other large service contexts. Use byte order markers in streams when applicable?  This won't apply to GIOP 1.1 due to limitations in the CDR encoding. Use byte order markers in encapsulations when applicable? The CHAR_CODESETS and WCHAR_CODESETS allow the user to override the default connection code sets.  The value should be a comma separated list of OSF registry numbers.  The first number in the list will be the native code Number can be specified as hex if preceded by 0x, otherwise they are interpreted as decimal. Code sets that we accept currently (see core/OSFCodeSetRegistry): char/string: ISO8859-1 (Latin-1)     0x00010001 ISO646 (ASCII)          0x00010020 UTF-8                   0x05010001 wchar/string: UTF-16                  0x00010109 UCS-2                   0x00010100 Note:  The ORB will let you assign any of the above values to either of the following properties, but the above assignments are the only ones that won't get you into trouble. Constants to make stream format version code easier to read/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/orbutil/ORBUtility.javaStackTraceElement[]printStackTraceprintStackTrace(java.lang.StackTraceElement[])/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/orbutil/ORBUtility.classformatStackTraceElementformatStackTraceElement(java.lang.StackTraceElement)compressClassNamecompressClassName(java.lang.String)exceptionRepositoryIdsexceptionClassNamesisSystemExceptionTypeCodeisSystemExceptionTypeCode(org.omg.CORBA.TypeCode,com.sun.corba.se.spi.orb.ORB)getSystemExceptionTypeCodegetSystemExceptionTypeCode(com.sun.corba.se.spi.orb.ORB,java.lang.String,java.lang.String)systemExceptionMemberssystemExceptionMembers(com.sun.corba.se.spi.orb.ORB)ORBUtilityORBUtility()rIdcName"IDL:omg.org/CORBA/BAD_CONTEXT:1.0"IDL:omg.org/CORBA/BAD_CONTEXT:1.0"org.omg.CORBA.BAD_CONTEXT"org.omg.CORBA.BAD_CONTEXT"IDL:omg.org/CORBA/BAD_INV_ORDER:1.0"IDL:omg.org/CORBA/BAD_INV_ORDER:1.0"org.omg.CORBA.BAD_INV_ORDER"org.omg.CORBA.BAD_INV_ORDER"IDL:omg.org/CORBA/BAD_OPERATION:1.0"IDL:omg.org/CORBA/BAD_OPERATION:1.0"org.omg.CORBA.BAD_OPERATION"org.omg.CORBA.BAD_OPERATION"IDL:omg.org/CORBA/BAD_PARAM:1.0"IDL:omg.org/CORBA/BAD_PARAM:1.0"org.omg.CORBA.BAD_PARAM""IDL:omg.org/CORBA/BAD_TYPECODE:1.0"IDL:omg.org/CORBA/BAD_TYPECODE:1.0"org.omg.CORBA.BAD_TYPECODE"org.omg.CORBA.BAD_TYPECODE"IDL:omg.org/CORBA/COMM_FAILURE:1.0"IDL:omg.org/CORBA/COMM_FAILURE:1.0"org.omg.CORBA.COMM_FAILURE"org.omg.CORBA.COMM_FAILURE"IDL:omg.org/CORBA/DATA_CONVERSION:1.0"IDL:omg.org/CORBA/DATA_CONVERSION:1.0"org.omg.CORBA.DATA_CONVERSION"org.omg.CORBA.DATA_CONVERSION"IDL:omg.org/CORBA/IMP_LIMIT:1.0"IDL:omg.org/CORBA/IMP_LIMIT:1.0"org.omg.CORBA.IMP_LIMIT"org.omg.CORBA.IMP_LIMIT"IDL:omg.org/CORBA/INTF_REPOS:1.0"IDL:omg.org/CORBA/INTF_REPOS:1.0"org.omg.CORBA.INTF_REPOS"org.omg.CORBA.INTF_REPOS"IDL:omg.org/CORBA/INTERNAL:1.0"IDL:omg.org/CORBA/INTERNAL:1.0"org.omg.CORBA.INTERNAL"org.omg.CORBA.INTERNAL"IDL:omg.org/CORBA/INV_FLAG:1.0"IDL:omg.org/CORBA/INV_FLAG:1.0"org.omg.CORBA.INV_FLAG"org.omg.CORBA.INV_FLAG"IDL:omg.org/CORBA/INV_IDENT:1.0"IDL:omg.org/CORBA/INV_IDENT:1.0"org.omg.CORBA.INV_IDENT"org.omg.CORBA.INV_IDENT"IDL:omg.org/CORBA/INV_OBJREF:1.0"IDL:omg.org/CORBA/INV_OBJREF:1.0"org.omg.CORBA.INV_OBJREF"org.omg.CORBA.INV_OBJREF"IDL:omg.org/CORBA/MARSHAL:1.0"IDL:omg.org/CORBA/MARSHAL:1.0"org.omg.CORBA.MARSHAL"org.omg.CORBA.MARSHAL"IDL:omg.org/CORBA/NO_MEMORY:1.0"IDL:omg.org/CORBA/NO_MEMORY:1.0"org.omg.CORBA.NO_MEMORY"org.omg.CORBA.NO_MEMORY"IDL:omg.org/CORBA/FREE_MEM:1.0"IDL:omg.org/CORBA/FREE_MEM:1.0"org.omg.CORBA.FREE_MEM"org.omg.CORBA.FREE_MEM"IDL:omg.org/CORBA/NO_IMPLEMENT:1.0"IDL:omg.org/CORBA/NO_IMPLEMENT:1.0"org.omg.CORBA.NO_IMPLEMENT"org.omg.CORBA.NO_IMPLEMENT"IDL:omg.org/CORBA/NO_PERMISSION:1.0"IDL:omg.org/CORBA/NO_PERMISSION:1.0"org.omg.CORBA.NO_PERMISSION"org.omg.CORBA.NO_PERMISSION"IDL:omg.org/CORBA/NO_RESOURCES:1.0"IDL:omg.org/CORBA/NO_RESOURCES:1.0"org.omg.CORBA.NO_RESOURCES"org.omg.CORBA.NO_RESOURCES"IDL:omg.org/CORBA/NO_RESPONSE:1.0"IDL:omg.org/CORBA/NO_RESPONSE:1.0"org.omg.CORBA.NO_RESPONSE"org.omg.CORBA.NO_RESPONSE"IDL:omg.org/CORBA/OBJ_ADAPTER:1.0"IDL:omg.org/CORBA/OBJ_ADAPTER:1.0"org.omg.CORBA.OBJ_ADAPTER"org.omg.CORBA.OBJ_ADAPTER"IDL:omg.org/CORBA/INITIALIZE:1.0"IDL:omg.org/CORBA/INITIALIZE:1.0"org.omg.CORBA.INITIALIZE""IDL:omg.org/CORBA/PERSIST_STORE:1.0"IDL:omg.org/CORBA/PERSIST_STORE:1.0"org.omg.CORBA.PERSIST_STORE"org.omg.CORBA.PERSIST_STORE"IDL:omg.org/CORBA/TRANSIENT:1.0"IDL:omg.org/CORBA/TRANSIENT:1.0"org.omg.CORBA.TRANSIENT"org.omg.CORBA.TRANSIENT"IDL:omg.org/CORBA/UNKNOWN:1.0"IDL:omg.org/CORBA/UNKNOWN:1.0"org.omg.CORBA.UNKNOWN"org.omg.CORBA.UNKNOWN"IDL:omg.org/CORBA/OBJECT_NOT_EXIST:1.0"IDL:omg.org/CORBA/OBJECT_NOT_EXIST:1.0"org.omg.CORBA.OBJECT_NOT_EXIST"org.omg.CORBA.OBJECT_NOT_EXIST"IDL:omg.org/CORBA/INVALID_TRANSACTION:1.0"IDL:omg.org/CORBA/INVALID_TRANSACTION:1.0"org.omg.CORBA.INVALID_TRANSACTION"org.omg.CORBA.INVALID_TRANSACTION"IDL:omg.org/CORBA/TRANSACTION_REQUIRED:1.0"IDL:omg.org/CORBA/TRANSACTION_REQUIRED:1.0"org.omg.CORBA.TRANSACTION_REQUIRED"org.omg.CORBA.TRANSACTION_REQUIRED"IDL:omg.org/CORBA/TRANSACTION_ROLLEDBACK:1.0"IDL:omg.org/CORBA/TRANSACTION_ROLLEDBACK:1.0"org.omg.CORBA.TRANSACTION_ROLLEDBACK"org.omg.CORBA.TRANSACTION_ROLLEDBACK"IDL:omg.org/CORBA/INV_POLICY:1.0"IDL:omg.org/CORBA/INV_POLICY:1.0"org.omg.CORBA.INV_POLICY"org.omg.CORBA.INV_POLICY"IDL:omg.org/CORBA/TRANSACTION_UNAVAILABLE:1.0"IDL:omg.org/CORBA/TRANSACTION_UNAVAILABLE:1.0"org.omg.CORBA.TRANSACTION_UNAVAILABLE"org.omg.CORBA.TRANSACTION_UNAVAILABLE"IDL:omg.org/CORBA/TRANSACTION_MODE:1.0"IDL:omg.org/CORBA/TRANSACTION_MODE:1.0"org.omg.CORBA.TRANSACTION_MODE"org.omg.CORBA.TRANSACTION_MODE"IDL:omg.org/CORBA/CODESET_INCOMPATIBLE:1.0"IDL:omg.org/CORBA/CODESET_INCOMPATIBLE:1.0"org.omg.CORBA.CODESET_INCOMPATIBLE"org.omg.CORBA.CODESET_INCOMPATIBLE"IDL:omg.org/CORBA/REBIND:1.0"IDL:omg.org/CORBA/REBIND:1.0"org.omg.CORBA.REBIND"org.omg.CORBA.REBIND"IDL:omg.org/CORBA/TIMEOUT:1.0"IDL:omg.org/CORBA/TIMEOUT:1.0"org.omg.CORBA.TIMEOUT"org.omg.CORBA.TIMEOUT"IDL:omg.org/CORBA/BAD_QOS:1.0"IDL:omg.org/CORBA/BAD_QOS:1.0"org.omg.CORBA.BAD_QOS"org.omg.CORBA.BAD_QOS"IDL:omg.org/CORBA/INVALID_ACTIVITY:1.0"IDL:omg.org/CORBA/INVALID_ACTIVITY:1.0"org.omg.CORBA.INVALID_ACTIVITY"org.omg.CORBA.INVALID_ACTIVITY"IDL:omg.org/CORBA/ACTIVITY_COMPLETED:1.0"IDL:omg.org/CORBA/ACTIVITY_COMPLETED:1.0"org.omg.CORBA.ACTIVITY_COMPLETED"org.omg.CORBA.ACTIVITY_COMPLETED"IDL:omg.org/CORBA/ACTIVITY_REQUIRED:1.0"IDL:omg.org/CORBA/ACTIVITY_REQUIRED:1.0"org.omg.CORBA.ACTIVITY_REQUIRED"org.omg.CORBA.ACTIVITY_REQUIRED"id""minor""completed"completed/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/orbutil/ORBUtility$1.classPrivilegedExceptionAction<ValueHandler>strmprofTempjcjcVersionv1v2"(ORB)."(ORB).numTokenstokens"SelectReaderThread"SelectReaderThread"SelectReaderThread["SelectReaderThread[ste"(Native Method)"(Native Method)"(Unknown Source)"(Unknown Source)trace"    Stack Trace:"    Stack Trace:"        >"        >"): "): callerarr1arr2/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/orbutil/ORBUtility$2.classobjectImplbop"op/"op/" id/" id//Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/orbutil/ORBUtility$3.class500pc"\nPermissionCollection "
PermissionCollection Copyright (c) 2000, 2016, Oracle and/or its affiliates. All rights reserved.Handy class full of static functions that don't belong in util.Utility for pure ORB reasons.Static method for writing a CORBA standard exception to an Any.The Any to write the SystemException into.Return default ValueHandlerReturns true if it was accurately determined that the remote ORB isa foreign (non-JavaSoft) ORB.  Note:  If passed the ORBSingleton, thiswill return false.Unmarshal a byte array to an integer.Assume the bytes are in BIGENDIAN order.i.e. array[offset] is the most-significant-byteand  array[offset+3] is the least-significant-byte.The array of bytes.The offset from which to start unmarshalling.Marshal an integer to a byte array.The bytes are in BIGENDIAN order.The offset from which to start marshalling. method moved from util.UtilityStatic method for writing a CORBA standard exception to a stream.The OutputStream to use for marshaling.Static method for reading a CORBA standard exception from a stream.The InputStream to use for unmarshaling.Get the class name corresponding to a particular repository Id.This is used by the system to unmarshal (instantiate) theappropriate exception class for an marshaled as the value ofits repository Id.The repository Id for which we want a class name.Return true if this repositoryId is a SystemException.The repository Id to check.the Java serialization encoding version. Is Java serialization enabled? Check the JavaSerializationComponent (tagged component) in the IIOPProfile. If present, the peer ORB's GIOP is capable of using Java serialization instead of CDR serialization. In such a case, use Java serialization, iff the java serialization versions match. throw error? Since encodingVersion is <= 0 (CDR_ENC_VERSION). defaultGet the repository id corresponding to a particular class.This is used by the system to write theappropriate repository id for a system exception.The class name of the system exception. construct repositoryId -> className hashtable SystemExceptions from OMG Transactions Service Spec from portability RTF 98-07-01.txt from orbrev/00-09-01 (CORBA 2.4 Draft Specification) Exception types introduced between CORBA 2.4 and 3.0 Exception types introduced in CORBA 3.0 construct className -> repositoryId hashtableParse a version string such as "1.1.6" or "jdk1.2fcs" intoa version array of integers {1, 1, 6} or {1, 2}.A string of "n." or "n..m" is equivalent to "n.0" or "n.0.m" respectively.find the maximum span of the string "n.n.n..." where n is an integerno digit foundcases like "n." or "n..m"convert equivalent to "n.0" or "n.0.m"Compare two version arrays.Return 1, 0 or -1 if v1 is greater than, equal to, or less than v2.v1 is longer or greater than v2Compare two version strings. Note that this must end in . in order to be renamed correctly. Return a compressed representation of the thread name.  This is particularly useful on the server side, where there are many SelectReaderThreads, and we need a short unambiguous name for such threads. This depends on the formatting in SelectReaderThread and CorbaConnectionImpl. Pattern for SelectReaderThreads: SelectReaderThread CorbaConnectionImpl[ <host> <post> <state>] Any other pattern in the Thread's name is just returned. print the stack trace, ommitting the zeroth element, which is always this method. Implements all dprint calls in this package.Throws the CORBA equivalent of a java.io.NotSerializableExceptionDuplicated from util/Utility for Pure ORB reasons.  There are tworeasons for this:1) We can't introduce dependencies on the util version from outsideof the io/util packages since it will not exist in the pure ORBbuild running on JDK 1.3.x.2) We need to pick up the correct minor code from OMGSystemException.Returns the maximum stream format version supported by ourValueHandler.This method is used to create untyped object references.This method obtains an IOR from a CORBA object reference.It will return null if obj is a local object, a null object,or an object implemented by a different ORB.  It willthrow BAD_OPERATION if obj is an unconnected RMI-IIOP object.IOR the IOR that represents this objref.  This willnever be null.BAD_OPERATION(from oi._get_delegate) if obj is anormal objref, but does not have a delegate set.if obj is a local object, or else wascreated by a foreign ORB. This is our code, but the ContactInfoList is not a CorbaContactInfoList.  This should not happen, because we are in the CORBA application of the DCSA framework. This is a coding error, and thus an INTERNAL exception should be thrown. XXX needs minor code obj is implemented by a foreign ORB, because the Delegate is not a ClientDelegate. XXX this case could be handled by marshalling and unmarshalling.  However, object_to_string cannot be used here, as it is implemented with getIOR.  Note that this will require access to an ORB, so that we can create streams as needed.  The ORB is available simply as io._orb().Obtains an IOR for the object reference obj, first connecting it tothe ORB if necessary.if the object could not be connected,if a connection attempt was needed. Letters and $ _ ` ^ - = ~ + | < > !@#%&*;':",./? ( [ { ) ] } Returns a String which looks similar to: PermissionCollection java.security.Permissions@1053693 ... (java.io.FilePermission <<ALL FILES>> ....) (java.io.FilePermission /export0/sunwappserv/lib/- ...) ... other permissions ... Domain ProtectionDomain  (file:/export0/sunwappserv/lib-) java.security.Permissions@141fedb ( (java.io.FilePermission <<ALL FILES>> ...) (java.io.FilePermission /var/tmp//- ...) Don't need to add 'Protection Domain' string, it's in ProtectionDomain.toString() already./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/orbutil/ObjectStreamClassUtil_1_3.javagetDeclaredMethod(java.lang.Class,java.lang.String,java.lang.Class[],int,int)/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/orbutil/ObjectStreamClassUtil_1_3.classgetSerialVersiongetSerialVersion(long,java.lang.Class)csuid/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/orbutil/ObjectStreamClassUtil_1_3$1.classminimumhasWriteObjectFlaghasWriteObjectMethod/Library/Java/JavaVirtualMachines/jdk1.8.0_251.jdk/Contents/Home/jre/lib/rt.jar/com/sun/corba/se/impl/orbutil/ObjectStreamClassUtil_1_3$CompareClassByName.class/Library/Java/JavaVirtualMachines/jdk1.8.0_251.jdk/Contents/Home/jre/lib/rt.jar/com/sun/corba/se/impl/orbutil/ObjectStreamClassUtil_1_3$CompareMemberByName.class/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/orbutil/ObjectStreamClassUtil_1_3$2.class/Library/Java/JavaVirtualMachines/jdk1.8.0_251.jdk/Contents/Home/jre/lib/rt.jar/com/sun/corba/se/impl/orbutil/ObjectStreamClassUtil_1_3$MethodSignature.class"Error invoking hasStaticInitializer: "Error invoking hasStaticInitializer: requiredModifierMaskdisallowedModifierMask/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/orbutil/ObjectStreamClassUtil_1_3$3.classCopyright (c) 2000, 2014, Oracle and/or its affiliates. All rights reserved. for computing the structural UID maintained here for backward compatability with JDK 1.3, where writeObject method was not being checked at all, so there is no need to lookup the ObjectStreamClass for non-serializable/proxy classes to maintain same suid as the JDK 1.3, we pick up suid only for classes with private,static,final declarations, and compute it for all others} catch (IllegalAccessException ex) {     suid = _computeSerialVersionUID(cl);In the old case, for the caller class, the write Method wasn't considered for rep-id calculations correctly, but for parent classes it was taken into account.  That is the reason there is the klude of getting the write Object method in theretransient or static. need to find the java replacement for hasStaticInitializer use java.io.ObjectStream's hasStaticInitializer method private static native boolean hasStaticInitializer(Class cl);if (!Modifier.isPrivate(mods) ||    Modifier.isStatic(mods)) {    method = null; Since it is alright if methodName does not exist, no need to do anything special here./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/orbutil/ObjectStreamClass_1_3_1.java/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/orbutil/ObjectStreamClass_1_3_1.classinsertDescriptorFor(com.sun.corba.se.impl.orbutil.ObjectStreamClass_1_3_1)computeStructuralUID(com.sun.corba.se.impl.orbutil.ObjectStreamClass_1_3_1,java.lang.Class)setSuperclass(com.sun.corba.se.impl.orbutil.ObjectStreamClass_1_3_1)typeEquals(com.sun.corba.se.impl.orbutil.ObjectStreamClass_1_3_1)translateFields(java.lang.Object[])ObjectStreamClass_1_3_1ObjectStreamClass_1_3_1(java.lang.String,long)ObjectStreamClass_1_3_1(java.lang.Class,com.sun.corba.se.impl.orbutil.ObjectStreamClass_1_3_1,boolean,boolean)translatedFields/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/orbutil/ObjectStreamClass_1_3_1$1.class/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/orbutil/ObjectStreamClass_1_3_1$2.classe2objsosfClassClass<ObjectStreamField>typesconstructornumNonNullFieldsfieldNum/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/orbutil/ObjectStreamClass_1_3_1$3.class/Library/Java/JavaVirtualMachines/jdk1.8.0_251.jdk/Contents/Home/jre/lib/rt.jar/com/sun/corba/se/impl/orbutil/ObjectStreamClass_1_3_1$ObjectStreamClassEntry.classObjectStreamClassEntry(com.sun.corba.se.impl.orbutil.ObjectStreamClass_1_3_1)/Library/Java/JavaVirtualMachines/jdk1.8.0_251.jdk/Contents/Home/jre/lib/rt.jar/com/sun/corba/se/impl/orbutil/ObjectStreamClass_1_3_1$CompareClassByName.class/Library/Java/JavaVirtualMachines/jdk1.8.0_251.jdk/Contents/Home/jre/lib/rt.jar/com/sun/corba/se/impl/orbutil/ObjectStreamClass_1_3_1$CompareMemberByName.class/Library/Java/JavaVirtualMachines/jdk1.8.0_251.jdk/Contents/Home/jre/lib/rt.jar/com/sun/corba/se/impl/orbutil/ObjectStreamClass_1_3_1$MethodSignature.classCopyright (c) 2001, 2014, Oracle and/or its affiliates. All rights reserved.This is duplicated here to preserve the JDK 1.3.1FCS behaviorof calculating the OMG hash code incorrectly when serialPersistentFieldsis used, but some of the fields no longer exist in the class itself.We have to duplicate it since we aren't allowed to modify thecom.sun.corba.se.impl.io version further, and can't make itpublic outside of its package for security reasons.A ObjectStreamClass_1_3_1 describes a class that can be serialized to a streamThe ObjectStreamClass_1_3_1 for a specific class loaded in this Java VM canReturn a string describing this ObjectStreamClass_1_3_1.Create a new ObjectStreamClass_1_3_1 from a loaded class.separate from the ObjectStreamClass_1_3_1 constructor so that lookupInternal already initialized serial bug 7; the serialPersistentFields were not being read and stored as Accessible bit was not set serial bug 7; need to find if the field is of type java.io.ObjectStreamFieldThrown if a field serialPersistentField existsbut it is not of type ObjectStreamField. type and cache it in the ObjectStreamClass_1_3_1 for that field. reflField.setAccessible(true); get rid of native code suid = getSerialVersionUIDField(cl);Cache lookup of writeObject and readObject forSerializable classes. (Do not lookup forExternalizable) Method must be private and non-staticLook for the readObject methodset the access override and save the reference forObjectInputStream so it can all the method directly. Compute the structural UID.  This must be done after the calculation for writeObject.  Fixed 4/20/2000, eea1 SerialBug 2: to have correct value in RepIdCreate an empty ObjectStreamClass_1_3_1 for a class about to be read.wire handle early, before any nested ObjectStreamClass_1_3_1 mightReturn the ObjectStreamClass_1_3_1 of the local class this one is based on. Field[] field = ObjectStreamClass_1_3_1.getDeclaredFields(cl); Must make sure that the Field array we allocate below is exactly the right size.  Bug fix for 4397133.Serial 6if (Modifier.isTransient(m) || Modifier.isStatic(m)) spec reference 00-01-06.pdf, 1.3.5.6, states non-static non-transient, public fields are mapped to Java IDL. Here's the quote from the first paragraph: Java non-static non-transient public fields are mapped to OMG IDL public data members, and other Java fields are not mapped. if (Modifier.isTransient(m) || Modifier.isStatic(m))     continue;insertDescriptorFor a Class -> ObjectStreamClass_1_3_1 mapping.True if this class has/had a writeObject methodObjectStreamClass_1_3_1 that this one was built from.Get the private static final field for serial version UID private static native long getSerialVersionUIDField(Class cl);Entries held in the Cache of known ObjectStreamClass_1_3_1 objects./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/orbutil/ObjectStreamField.java/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/orbutil/ObjectStreamField.classThis is duplicated here somewhat in haste since we can'texpose this class outside of the com.sun.corba.se.impl.iopackage for security reasons.NOT USED, since this class is used only in ObjectStreamClass_1_3_1,which is used only in RepositoryId_1_3_1.public long getFieldID( Class cl ) {if (fieldID == -1) {if (typeString != null)fieldID = getFieldIDNative( cl, getName(), typeString );fieldID = getFieldIDNative( cl, getName(), getSignature() );return fieldID; the next 3 things are RMI-IIOP specific, it can be easily private static native long getFieldIDNative(Class c, String fieldName, String fieldSig);/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/orbutil/ObjectUtility.javaObjectUtilityObjectUtility()/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/orbutil/ObjectUtility.classcomp1comp2len1len2"Arguments must be arrays"Arguments must be arrays"Arguments must be arrays with the same component type"Arguments must be arrays with the same component typeIf arr1 and arr2 are both arrays of the same component type,return an array of that component type that consists of theelements of arr1 followed by the elements of arr2.Throws IllegalArgumentException otherwise./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/orbutil/ObjectWriter.javaisIndentinginitialLevelcompClass"<"<">">startLinestartLine()/Library/Java/JavaVirtualMachines/jdk1.8.0_251.jdk/Contents/Home/jre/lib/rt.jar/com/sun/corba/se/impl/orbutil/ObjectWriter$IndentingObjectWriter.classfillSimpleObjectWriterSimpleObjectWriter()/Library/Java/JavaVirtualMachines/jdk1.8.0_251.jdk/Contents/Home/jre/lib/rt.jar/com/sun/corba/se/impl/orbutil/ObjectWriter$SimpleObjectWriter.class================================================================================================= Implementation array of objectExpected patterns:startObject endObject( str )header( elem )\nstartObject ( startElement append* endElement ) * endObjectheader(\nappend*\n *)\n/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/orbutil/RepIdDelegator.java/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/orbutil/RepIdDelegator.classRepIdDelegatorRepIdDelegator(com.sun.corba.se.impl.util.RepositoryId)serrepIdString_delegate? extends RepIdDelegatorClass<? extends RepIdDelegator>Map<String,? extends RepIdDelegator>RepIdDelegator[]? extends RepIdDelegator[]Constructor<? extends RepIdDelegator>? super ? extends RepIdDelegatorClass<? super ? extends RepIdDelegator>TypeVariable<Class<? extends RepIdDelegator>>TypeVariable<Class<? extends RepIdDelegator>>[]Delegates to the current RepositoryId implementation incom.sun.corba.se.impl.util.  This is necessary toovercome the fact that many of RepositoryId's methodsare static. RepositoryIdFactory methods RepositoryIdUtility methods RepositoryIdInterface methods Constructor used for factory/utility cases Constructor used by getIdFromString.  All non-static RepositoryId methods will use the provided delegate./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/orbutil/RepositoryIdFactory.javacurrentDelegator/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/orbutil/RepositoryIdFactory.classReturns the latest version RepositoryIdStrings instanceReturns the latest version RepositoryIdUtility instance/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/orbutil/RepositoryIdInterface.javaCopyright (c) 2000, 2002, Oracle and/or its affiliates. All rights reserved.Methods on specific instances of RepositoryId.  Hidesversioning of our RepositoryId class./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/orbutil/RepositoryIdStrings.javaFactory methods for creating various repository ID stringsand instances./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/orbutil/RepositoryIdUtility.javaUtility methods for working with repository IDs. These are currently the same in both RepositoryId and RepositoryId_1_3, but provide the constants again here to eliminate awkardness when using this interface. Determine how many (if any) repository IDs follow the value tag. Accessors for precomputed value tags/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/orbutil/StackImpl.javaensureensure()/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/orbutil/StackImpl.classtopnewSizenewData We implement a Stack here instead of using java.util.Stack because java.util.Stack is thread-safe, negatively impacting performance. The stack for RequestInfo objects. Tests if this stack is empty. Looks at the object at the top of this stack without removing it Removes the object at the top of this stack and returns that object as the value of this function. Pushes an item onto the top of the stack/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/orbutil/closure/Constant.java/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/orbutil/closurecom.sun.corba.se.impl.orbutil.closure/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/orbutil/closure/Constant.class/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/orbutil/closure/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/orbutil/closure/Future.java/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/orbutil/closure/Future.classevaluated/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/orbutil/concurrent/CondVar.java/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/orbutil/concurrentcom.sun.corba.se.impl.orbutil.concurrentacquireMutexacquireMutex(int)/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/orbutil/concurrent/CondVar.class/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/orbutil/concurrentreleaseMutexreleaseMutex()mutex"await enter"await enter"await exit"await exitmsecs"timedwait enter"timedwait enter"timedwait exit"timedwait exitFile: ConditionVariable.javaOriginally written by Doug Lea and released into the public domain.This may be used for any purposes whatsoever without acknowledgment.Thanks for the assistance and support of Sun Microsystems Labs,and everyone contributing, testing, and using this code.History:Date       Who                What11Jun1998  dl               Create public version08dec2001  kmc              Added support for Reentrant MutexesThis class is designed for fans of POSIX pthreads programming.If you restrict yourself to Mutexes and CondVars, you canuse most of your favorite constructions. Don't randomly mix themwith synchronized methods or blocks though.Method names and behavior are as close as is reasonable tothose in POSIX.<b>Sample Usage.</b> Here is a full version of a bounded bufferthat implements the BoundedChannel interface, written ina style reminscent of that in POSIX programming books.class CVBuffer implements BoundedChannel {private final Mutex mutex;private final CondVar notFull;private final CondVar notEmpty;private int count = 0;private int takePtr = 0;private int putPtr = 0;private final Object[] array;public CVBuffer(int capacity) {array = new Object[capacity];mutex = new Mutex();notFull = new CondVar(mutex);notEmpty = new CondVar(mutex);public int capacity() { return array.length; }public void put(Object x) throws InterruptedException {mutex.acquire();while (count == array.length) {notFull.await();array[putPtr] = x;putPtr = (putPtr + 1) % array.length;++count;notEmpty.signal();finally {mutex.release();public Object take() throws InterruptedException {Object x = null;while (count == 0) {notEmpty.await();x = array[takePtr];array[takePtr] = null;takePtr = (takePtr + 1) % array.length;--count;notFull.signal();return x;public boolean offer(Object x, long msecs) throws InterruptedException {if (count == array.length) {notFull.timedwait(msecs);if (count == array.length)public Object poll(long msecs) throws InterruptedException {if (count == 0) {notEmpty.timedwait(msecs);if (count == 0)return null;Mutex<p>[<a href="http://gee.cs.oswego.edu/dl/classes/EDU/oswego/cs/dl/util/concurrent/intro.html"> Introduction to this package. </a>]The mutex *Create a new CondVar that relies on the given mutualexclusion lock.A mutual exclusion lock which must either be non-reentrant,or else be ReentrantMutex.Standard usage is to supply an instance of <code>Mutex</code>,but, for example, a Semaphore initialized to 1 also works.On the other hand, many other Sync implementations would notwork here, so some care is required to supply a sensiblesynchronization object.In normal use, the mutex should be one that is used for <em>all</em>synchronization of the object using the CondVar. Generally,to prevent nested monitor lockouts, thisobject should not use any native Java synchronized blocks.Wait for notification. This operation at least momentarilyreleases the mutex. The mutex is always held upon return,even if interrupted.InterruptedExceptionif the thread was interruptedbefore or during the wait. However, if the thread is interruptedafter the wait but during mutex re-acquisition, the interruptionis ignored, while still ensuringthat the currentThread's interruption state stays true, so canbe probed by callers. Must ignore interrupt on re-acquireWait for at most msecs for notification.This operation at least momentarilyThe time to wait. A value less than or equal to zerocauses a momentarily releaseand re-acquire of the mutex, and always returns false.false if at least msecs have elapsedupon resumption; else true. Afalse return does NOT necessarily imply that the thread wasnot notified. For example, it might have been notifiedafter the time elapsed but just before resuming.before or during the wait.Notify a waiting thread.If one exists, a non-interrupted thread will returnnormally (i.e., not via InterruptedException) from await or timedwait.Notify all waiting threads */Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/orbutil/concurrent/DebugMutex.java"Attempt to acquire Mutex by thread holding the Mutex"Attempt to acquire Mutex by thread holding the Mutex"Attempt to release Mutex by thread not holding the Mutex"Attempt to release Mutex by thread not holding the MutexFile: Mutex.javaA simple non-reentrant mutual exclusion lock.The lock is free upon construction. Each acquire gets thelock, and each release frees it. Releasing a lock thatis already free has no effect.This implementation makes no attempt to provide any fairnessor ordering guarantees. If you need them, consider using one ofthe Semaphore implementations as a locking mechanism.<b>Sample usage</b><br>Mutex can be useful in constructions that cannot beexpressed using java synchronized blocks because theacquire/release pairs do not occur in the same method orcode block. For example, you can use them for hand-over-handlocking across the nodes of a linked list. This allowsextremely fine-grained locking,  and so increasespotential concurrency, at the cost of additional complexity andoverhead that would normally make this worthwhile only in cases ofextreme contention.class Node {Object item;Node next;Mutex lock = new Mutex(); // each node keeps its own lockNode(Object x, Node n) { item = x; next = n; }class List {protected Node head; // pointer to first node of list// Use plain java synchronization to protect head field.//  (We could instead use a Mutex here too but there is no//  reason to do so.)protected synchronized Node getHead() { return head; }boolean search(Object x) throws InterruptedException {Node p = getHead();if (p == null) return false;//  (This could be made more compact, but for clarity of illustration,//  all of the cases that can arise are handled separately.)p.lock.acquire();              // Prime loop by acquiring first lock.//    (If the acquire fails due to//    interrupt, the method will throw//    InterruptedException now,//    so there is no need for any//    further cleanup.)for (;;) {if (x.equals(p.item)) {p.lock.release();          // release current before returnelse {Node nextp = p.next;if (nextp == null) {p.lock.release();       // release final lock that was heldnextp.lock.acquire(); // get next lock before releasing currentcatch (InterruptedException ex) {p.lock.release();    // also release current if acquire failsthrow ex;p.lock.release();      // release old lock now that new one heldp = nextp;synchronized void add(Object x) { // simple prepend// The use of `synchronized'  here protects only head field.// The method does not need to wait out other traversers// who have already made it past head.head = new Node(x, head);// ...  other similar traversal and update methods ...<p>This version adds some debugging capability: it will detect an attempt by a threadthat holds the lock to acquire it for a second time, and also an attempt by a thread thatdoes not hold the mutex to release it.SemaphoreThe lock status */Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/orbutil/concurrent/Mutex.java/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/orbutil/concurrent/ReentrantMutex.javareleaseAllreleaseAll()/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/orbutil/concurrent/ReentrantMutex.classacquireAllacquireAll(int)"acquire enter: holder_="acquire enter: holder_=" counter_=" counter_="counter not 0 when first acquiring mutex"counter not 0 when first acquiring mutex"acquire exit: holder_="acquire exit: holder_="acquireAll enter: count="acquireAll enter: count=" holder_=" holder_="Cannot acquireAll while holding the mutex"Cannot acquireAll while holding the mutex"acquireAll exit: count="acquireAll exit: count="release enter: " +
                    " holder_="release enter:  holder_="release exit: " +
                    " holder_="release exit:  holder_="releaseAll enter: " +
                    " holder_="releaseAll enter:  holder_="Attempt to releaseAll Mutex by thread not holding the Mutex"Attempt to releaseAll Mutex by thread not holding the Mutex"releaseAll exit: " +
                    " holder_="releaseAll exit:  holder_="attempt enter: msecs="attempt enter: msecs="attempt exit: " +
                        " holder_="attempt exit:  holder_=A simple reentrant mutual exclusion lock.<p>This version adds some debugging capability: it will detectan attempt by a thread that does not hold the mutex to release it.This version is reentrant: the same thread may acquire a mutex multipletimes, in which case it must release the mutex the same number of timesas it was acquired before another thread can acquire the mutex.The thread holding the lock *number of times thread has acquired the lock * This can't happen, but make sure anyway/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/orbutil/concurrent/Sync.java60365.2425File: Sync.java5Aug1998  dl               Added some convenient time constantsMain interface for locks, gates, and conditions.Sync objects isolate waiting and notification for particularlogical states, resource availability, events, and the like that areshared across multiple threads. Use of Syncs sometimes(but by no means always) adds flexibility and efficiencycompared to the use of plain java monitor methodsand locking, and are sometimes (but by no means always)simpler to program with.Most Syncs are intended to be used primarily (althoughnot exclusively) in  before/after constructions such as:class X {Sync gate;// ...public void m() {gate.acquire();  // block until condition holds// ... method bodygate.release()// ... evasive actionpublic void m2(Sync cond) { // use supplied conditionif (cond.attempt(10)) {         // try the condition for 10 mscond.release()Syncs may be used in somewhat tedious but more flexible replacementsfor built-in Java synchronized blocks. For example:class HandSynched {private double state_ = 0.0;private final Sync lock;  // use lock type supplied in constructorpublic HandSynched(Sync l) { lock = l; }public void changeState(double d) {lock.acquire();try     { state_ = updateFunction(d); }finally { lock.release(); }catch(InterruptedException ex) { }public double getState() {double d = 0.0;try     { d = accessFunction(state_); }catch(InterruptedException ex){}return d;private double updateFunction(double d) { ... }private double accessFunction(double d) { ... }If you have a lot of such methods, and they take a commonform, you can standardize this using wrappers. Some of thesewrappers are standardized in LockedExecutor, but you can make others.For example:class HandSynchedV2 {public HandSynchedV2(Sync l) { lock = l; }protected void runSafely(Runnable r) {try { r.run(); }catch (InterruptedException ex) { // propagate without throwingThread.currentThread().interrupt();runSafely(new Runnable() {public void run() { state_ = updateFunction(d); }});One reason to bother with such constructions is to use deadlock-avoiding back-offs when dealing with locks involving multiple objects.For example, here is a Cell class that uses attempt to back-offand retry if two Cells are trying to swap values with each otherat the same time.class Cell {long value;Sync lock = ... // some sync implementation classvoid swapValue(Cell other) {if (other.lock.attempt(100)) {long t = value;value = other.value;other.value = t;return;finally { other.lock.release(); }catch (InterruptedException ex) { return; }Here is an even fancier version, that uses lock re-orderingupon conflict:Sync lock = ...;private static boolean trySwap(Cell a, Cell b) {a.lock.acquire();if (!b.lock.attempt(0))long t = a.value;a.value = b.value;b.value = t;while (!trySwap(this, other) &&!tryswap(other, this))Thread.sleep(1);Interruptions are in general handled as early as possible.Normally, InterruptionExceptions are thrownin acquire and attempt(msec) if interruptionis detected upon entry to the method, as well as in anylater context surrounding waits.However, interruption status is ignored in release();Timed versions of attempt report failure via return value.If so desired, you can transform such constructions to use exceptionthrows viaif (!c.attempt(timeval)) throw new TimeoutException(timeval);The TimoutSync wrapper class can be used to automate such usages.All time values are expressed in milliseconds as longs, which have a maximumvalue of Long.MAX_VALUE, or almost 300,000 centuries. It is notknown whether JVMs actually deal correctly with such extreme values.For convenience, some useful time values are defined as static constants.All implementations of the three Sync methods guarantee tosomehow employ Java <code>synchronized</code> methods or blocks,and so entail the memory operations described in JLSchapter 17 which ensure that variables are loaded and flushedwithin before/after constructions.Syncs may also be used in spinlock constructions. Althoughit is normally best to just use acquire(), various formsof busy waits can be implemented. For a simple example(but one that would probably never be preferable to using acquire()):Sync lock = ...void spinUntilAcquired() throws InterruptedException {// Two phase.// First spin without pausing.int purespins = 10;for (int i = 0; i < purespins; ++i) {if (lock.attempt(0))// Second phase - use timed waitslong waitTime = 1; // 1 millisecondif (lock.attempt(waitTime))waitTime = waitTime * 3 / 2 + 1; // increase 50%In addition pure synchronization control, Syncsmay be useful in any context requiring before/after methods.For example, you can use an ObservableSync(perhaps as part of a LayeredSync) in order to obtain callbacksbefore and after each method invocation for a given class.Wait (possibly forever) until successful passage.Fail only upon interuption. Interruptions always result in`clean' failures. On failure,  you can be sure that it has notbeen acquired, and that nocorresponding release should be performed. Conversely,a normal return guarantees that the acquire was successful.Wait at most msecs to pass; report whether passed.The method has best-effort semantics:The msecs bound cannotbe guaranteed to be a precise upper bound on wait time in Java.Implementations generally can only attempt to return as soon as possibleafter the specified bound. Also, timers in Java do not stop during garbagecollection, so timeouts can occur just because a GC intervened.So, msecs arguments should be used ina coarse-grained manner. Further,implementations cannot always guarantee that this methodwill return at all without blocking indefinitely when used inunintended ways. For example, deadlocks may be encounteredwhen called in an unintended context.the number of milleseconds to wait.An argument less than or equal to zero means not to wait at all.However, this may still requireaccess to a synchronization lock, which can impose unboundeddelay if there is a lot of contention among threads.true if acquiredPotentially enable others to pass.Because release does not raise exceptions,it can be used in `finally' clauses without requiring extraembedded try/catch blocks. But keep in mind thatas with any java method, implementations maystill throw unchecked exceptions such as Error or NullPointerExceptionwhen faced with uncontinuable errors. However, these should normallyonly be caught by higher-level error handlers.One second, in milliseconds; convenient as a time-out value *One minute, in milliseconds; convenient as a time-out value *One hour, in milliseconds; convenient as a time-out value *One day, in milliseconds; convenient as a time-out value *One week, in milliseconds; convenient as a time-out value *One year in milliseconds; convenient as a time-out value  * Not that it matters, but there is some variation across standard sources about value at msec precision. The value used is the same as in java.util.GregorianCalendarOne century in milliseconds; convenient as a time-out value */Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/orbutil/concurrent/SyncUtil.javaSyncUtilSyncUtil()/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/orbutil/concurrent/SyncUtil.classheldMethod to acquire a Sync without ever throwing anInterruptedException.  Useful when a mutex is beingused in place of Java synchronization./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/orbutil/fsm/GuardedAction.java/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/orbutil/fsmcom.sun.corba.se.impl.orbutil.fsmnextState/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/orbutil/fsm/GuardedAction.class/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/orbutil/fsmguardtrueGuard/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/orbutil/fsm/GuardedAction$1.class"GuardedAction[action="GuardedAction[action=" guard=" guard=" nextState=" nextState=/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/orbutil/fsm/NameBase.javagetPreferredClassNamegetPreferredClassName()/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/orbutil/fsm/NameBase.classgetClassNamegetClassName()toStringNamefqn? extends NameBaseClass<? extends NameBase>Map<String,? extends NameBase>NameBase[]? extends NameBase[]Constructor<? extends NameBase>? super ? extends NameBaseClass<? super ? extends NameBase>TypeVariable<Class<? extends NameBase>>TypeVariable<Class<? extends NameBase>>[]"Action"Action"State"State"Guard"Guard"Input"Input Return just the name of the class, not the full qualified name./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/orbutil/fsm/StateEngineImpl.javamustNotBeInitializingmustNotBeInitializing()/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/orbutil/fsm/StateEngineImpl.classmustBeInitializingmustBeInitializing()performStateTransitionperformStateTransition(com.sun.corba.se.spi.orbutil.fsm.FSM,com.sun.corba.se.spi.orbutil.fsm.Input,com.sun.corba.se.spi.orbutil.fsm.StateImpl,com.sun.corba.se.spi.orbutil.fsm.Action,boolean)innerDoItinnerDoIt(com.sun.corba.se.spi.orbutil.fsm.FSM,com.sun.corba.se.spi.orbutil.fsm.Input,boolean)getDefaultActiongetDefaultAction(com.sun.corba.se.spi.orbutil.fsm.StateImpl)getDefaultNextStategetDefaultNextState(com.sun.corba.se.spi.orbutil.fsm.StateImpl)defaultActioninitializingemptyAction/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/orbutil/fsm/StateEngineImpl$1.class"Empty"Empty/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/orbutil/fsm/StateEngineImpl$2.class"Invalid Transition"Invalid Transition"Invalid transition attempted from "Invalid transition attempted from " under " under oldStateImplgata"doIt enter: currentState = "doIt enter: currentState = " in = " in = "doIt exit"doIt exitcurrentStatedeferral"Calling innerDoIt with input "Calling innerDoIt with input gas"currentState      = "currentState      = "in                = "in                = "default nextState = "default nextState = "default action    = "default action    = gr"doIt: evaluated "doIt: evaluated " with result " with result "nextState = "nextState = "action    = "action    = different"doIt: executing postAction for state "doIt: executing postAction for state "doIt: postAction threw "doIt: postAction threw "doIt: executing preAction for state "doIt: executing preAction for state "doIt: preAction threw "doIt: preAction threw "doIt: state is now "doIt: state is now startState"Invalid method call after initialization completed"Invalid method call after initialization completed"Invalid method call before initialization completed"Invalid method call before initialization completedEncodes the state transition function for a finite state machine. An action that does nothing at all. optimize FSM here if desired.  For example, we could choose different strategies for implementing the state transition function based on the distribution of values for states and input labels. This method is present only for debugging. innerDoIt does the actual transition. Use the currentState defaults if set, otherwise use the state engine default. The state engine default never changes the state Locals needed for performing the state transition, once we determine the required transition. Do until no guard has deferred. clear this after each deferral! Search for a guard that is not DISABLED. All DISABLED means use defaults. ga has the next state and action. Perform the state transition.  Pre and post actions are only performed if the state changes (see UML hidden transitions). Note that action may be null in a transition, which simply means that no action is needed.  Note that action.doIt may throw an exception, in which case the exception is propagated after making sure that the transition is properly end of StateEngineImpl.java/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/orbutil/graph/Graph.java/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/orbutil/graphcom.sun.corba.se.impl.orbutil.graph Set<Node>Set<Node>/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/orbutil/graph/GraphImpl.javacollectRootSetcollectRootSet()/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/orbutil/graph/GraphImpl.class/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/orbutil/graphmarkNonRootsmarkNonRoots()visitAllvisitAll(com.sun.corba.se.impl.orbutil.graph.GraphImpl.NodeVisitor)clearNodeDataclearNodeData()nodeToData"Graphs must contain only Node instances"Graphs must contain only Node instancesndgetValuegetValue()KComparator<Entry<K,V>>comparingByValuecomparingByValue(java.util.Comparator)Comparator<? super V>comparingByKeycomparingByKey(java.util.Comparator)Comparator<? super K>Comparable<? super V>comparingByValue()Comparable<? super K>comparingByKey()setValuesetValue(java.lang.Object)getKey()graphdoneEntry<>[]entries/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/orbutil/graph/GraphImpl$1.classvisitvisit(com.sun.corba.se.impl.orbutil.graph.Graph,com.sun.corba.se.impl.orbutil.graph.Node,com.sun.corba.se.impl.orbutil.graph.NodeData)childcndMap<Node,NodeData>****************************************************************************************** AbstractSet implementation ****************************************** Required for AbstractSet obj must be a Node Clear every node This visits every node in the graph exactly once.  A visitor is allowed to modify the graph during the traversal. Repeat the traversal until every node has been visited.  Since it takes one pass to determine whether or not each node has already been visited, this loop always runs at least once. Copy entries to array to avoid concurrent modification problem with iterator if the visitor is updating the graph. Visit each node in the graph that has not already been visited. If any node is visited in this pass, we must run at least one more pass. Iterator<Node> Make sure the child is in the graph so it can be visited later if necessary. Mark the child as a non-root, since a child is never a root./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/orbutil/graph/Node.javaNode in a graph.Get all the children of this node./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/orbutil/graph/NodeData.javanotRootnotRoot()/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/orbutil/graph/NodeData.classisRoot()visitedvisited()isVisitedisVisited()Data about a node in a graph.Return whether this node has been visited in a traversal.Note that we only support a single traversal at a time.Return whether this node is a root./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/orbutil/threadpool/ThreadPoolImpl.java/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/orbutil/threadpoolcom.sun.corba.se.impl.orbutil.threadpoolincrementNumberOfAvailableThreadsincrementNumberOfAvailableThreads()/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/orbutil/threadpool/ThreadPoolImpl.class/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/orbutil/threadpooldecrementNumberOfAvailableThreadsdecrementNumberOfAvailableThreads()getUniqueThreadIdgetUniqueThreadId()incrementCurrentNumberOfThreadsincrementCurrentNumberOfThreads()decrementCurrentNumberOfThreadsdecrementCurrentNumberOfThreads()createWorkerThreadcreateWorkerThread()createWorkerThreadHelpercreateWorkerThreadHelper(java.lang.String)notifyForAvailableWorknotifyForAvailableWork(com.sun.corba.se.spi.orbutil.threadpool.WorkQueue)getMonitoredObjectgetMonitoredObject()initializeMonitoringinitializeMonitoring()List<WorkerThread>Collection<WorkerThread>Iterable<WorkerThread>workersworkersLockthreadGroupthreadpoolMonitoredObjecttotalTimeTakenprocessedCountboundedThreadPoolinactivityTimeoutmaxWorkerThreadsminWorkerThreadscurrentThreadCountavailableWorkerThreadsworkQueuethreadCounterArrayList<WorkerThread>AbstractList<WorkerThread>AbstractCollection<WorkerThread>ArrayList<WorkerThread>()Spliterator<WorkerThread>? super WorkerThreadConsumer<? super WorkerThread>Iterator<WorkerThread>Stream<WorkerThread>BaseStream<WorkerThread,Stream<WorkerThread>>Predicate<? super WorkerThread>? extends WorkerThreadCollection<? extends WorkerThread>Iterable<? extends WorkerThread>add(com.sun.corba.se.impl.orbutil.threadpool.ThreadPoolImpl.WorkerThread)AbstractCollection<WorkerThread>()ListIterator<WorkerThread>add(int,com.sun.corba.se.impl.orbutil.threadpool.ThreadPoolImpl.WorkerThread)set(int,com.sun.corba.se.impl.orbutil.threadpool.ThreadPoolImpl.WorkerThread)Comparator<? super WorkerThread>UnaryOperator<WorkerThread>Function<WorkerThread,WorkerThread>AbstractList<WorkerThread>()ArrayList<WorkerThread>(java.util.Collection)ArrayList<WorkerThread>(int)tgthreadpoolNameminSizetimeoutwtthreadPoolMonitoringObjectRoot/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/orbutil/threadpool/ThreadPoolImpl$1.class(java.lang.String,java.lang.String)/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/orbutil/threadpool/ThreadPoolImpl$2.class/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/orbutil/threadpool/ThreadPoolImpl$3.class/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/orbutil/threadpool/ThreadPoolImpl$4.classb5/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/orbutil/threadpool/ThreadPoolImpl$5.classqueueIdaWorkQueuethread/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/orbutil/threadpool/ThreadPoolImpl$6.classcomposeWorkerThreadNamecomposeWorkerThreadName(java.lang.String,java.lang.String)/Library/Java/JavaVirtualMachines/jdk1.8.0_251.jdk/Contents/Home/jre/lib/rt.jar/com/sun/corba/se/impl/orbutil/threadpool/Library/Java/JavaVirtualMachines/jdk1.8.0_251.jdk/Contents/Home/jre/lib/rt.jar/com/sun/corba/se/impl/orbutil/threadpool/ThreadPoolImpl$WorkerThread.classperformWorkperformWork()resetClassLoaderresetClassLoader()WorkerThreadWorkerThread(java.lang.ThreadGroup,java.lang.String)workerThreadNamethreadPoolNamecloseCalledthreadIdcurrentWork"Idle"IdleelapsedTimepoolNameworkerName"p: "p: "; w: "; w:  serial counter useful for debugging Any time currentThreadCount and/or availableWorkerThreads is updated or accessed this ThreadPool's WorkQueue must be locked. And, it is expected that this ThreadPool's WorkQueue is the only object that updates and accesses these values directly and indirectly though a call to a method in this ThreadPool. If any call to update or access those values must synchronized on this ThreadPool's WorkQueue. Stores the number of available worker threads Stores the number of threads in the threadpool currently Minimum number of worker threads created at instantiation of the threadpool Maximum number of worker threads in the threadpool Inactivity timeout value for worker threads to exit and stop running Indicates if the threadpool is bounded or unbounded Running count of the work items processed Set the value to 1 so that divide by zero is avoided in averageWorkCompletionTime() Running aggregate of the time taken in millis to execute work items processed by the threads in the threadpool Name of the ThreadPool MonitoredObject for ThreadPool ThreadGroup in which threads should be createdThis constructor is used to create an unbounded threadpoolin the ThreadGroup of the current threadThis constructor is used to create bounded threadpool Note that this method should not return until AFTER all threads have died. Copy to avoid concurrent modification problems. Setup monitoring for this threadpool Get root monitored object Create the threadpool monitoring root Add the monitored object for the WorkQueue Package private method to get the monitored object for this classTo be called from the workqueue when work is added to theworkQueue. This method would create new threads if requiredor notify waiting threads on the queue for available work Thread creation needs to be in a doPrivileged block if there is a non-null security manager for two reasons: 1. The creation of a thread in a specific ThreadGroup    is a privileged operation.  Lack of a doPrivileged    block here causes an AccessControlException    (see bug 6268145). 2. We want to make sure that the permissions associated    with this thread do NOT include the permissions of    the current thread that is calling this method.    This leads to problems in the app server where    some threads in the ThreadPool randomly get    bad permissions, leading to unpredictable    permission errors (see bug 6021011).    A Java thread contains a stack of call frames,    one for each method called that has not yet returned.    Each method comes from a particular class.  The class    was loaded by a ClassLoader which has an associated    CodeSource, and this determines the Permissions    for all methods in that class.  The current    Permissions for the thread are the intersection of    all Permissions for the methods on the stack.    This is part of the Security Context of the thread.    When a thread creates a new thread, the new thread    inherits the security context of the old thread.    This is bad in a ThreadPool, because different    creators of threads may have different security contexts.    This leads to occasional unpredictable errors when    a thread is re-used in a different security context.    Avoiding this problem is simple: just do the thread    creation in a doPrivileged block.  This sets the    inherited security context to that of the code source    for the ORB code itself, which contains all permissions    in either Java SE or Java EE. The thread must be set to a daemon thread so the VM can exit if the only threads left are PooledThreads or other daemons.  We don't want to rely on the calling thread always being a daemon. Note that no exception is possible here since we are inside the doPrivileged block.To be called from the workqueue to create worker threads when noneavailable. If we get here, we need to create a thread. Decrementing the count of current worker threads. But, it will be increased in the finally block.This method will return the number of WorkQueues serviced by the threadpool.This method will decrement the number of available threadsin the threadpool which are waiting for work. Called fromWorkQueueImpl.requestWork()This method will increment the number of available threads unique id for the thread name seen by Thread.getName() set currentWork to null so that the work item can be garbage collected without waiting for the next work item. This should not be possible End of WorkerThread class/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/orbutil/threadpool/ThreadPoolManagerImpl.javagetThreadGroupgetThreadGroup()/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/orbutil/threadpool/ThreadPoolManagerImpl.classtgCountthreadPool/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/orbutil/threadpool/ThreadPoolManagerImpl$1.classPrivilegedAction<ThreadGroup>ptg"ORB ThreadGroup "ORB ThreadGroup isDestroyednumThreadsnumGroupsthreadpoolIdnumericIdForThreadpoolcomponentIdcomponentIndexaThreadPoolChooser See bugs 4916766 and 4936203 We intend to create new threads in a reliable thread group. This avoids problems if the application/applet creates a thread group, makes JavaIDL calls which create a new connection and ReaderThread, and then destroys the thread group. If our ReaderThreads were to be part of such destroyed thread group then it might get killed and cause other invoking threads sharing the same connection to get a non-restartable CommunicationFailure. We'd like to avoid that. Our solution is to create all of our threads in the highest thread group that we have access to, given our own security clearance. try to get a thread group that's as high in the threadgroup parent-child hierarchy, as we can get to. this will prevent an ORB thread created during applet-init from being killed when an applet dies. Discontinue going higher on a security exception. something wrong, we go back to the original codeThis method will return an instance of the threadpool given a threadpoolId,that can be used by any component in the app. server.NoSuchThreadPoolExceptionthrown when invalid threadpoolId is passedas a parameterThis method will return an instance of the threadpool given a numeric threadpoolId.This method will be used by the ORB to support the functionality ofdedicated threadpool for EJB beansthrown when invalidnumericIdForThreadpool is passedThis method is used to return the numeric id of the threadpool, given a StringthreadpoolId. This is used by the POA interceptors to add the numeric threadpoolId, as a tagged component in the IOR. This is used to provide the functionality ofReturn a String Id for a numericId of a threadpool managed by the threadpoolReturns the first instance of ThreadPool in the ThreadPoolManagerReturn an instance of ThreadPoolChooser based on the componentId that waspassed as argumentFIXME: This method is not used, but should be fixed oncenio select starts working and we start using ThreadPoolChooserReturn an instance of ThreadPoolChooser based on the componentIndex that waspassed as argument. This is added for improved performance so that the callerdoes not have to pay the cost of computing hashcode for the componentIdSets a ThreadPoolChooser for a particular componentId in the ThreadPoolManager. Thiswould enable any component to add a ThreadPoolChooser for their specific useGets the numeric index associated with the componentId specified for aThreadPoolChooser. This method would help the component call the moreefficient implementation i.e. getThreadPoolChooser(int componentIndex)/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/orbutil/threadpool/TimeoutException.java/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/orbutil/threadpool/WorkQueueImpl.javarequestWorkrequestWork(long)/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/orbutil/threadpool/WorkQueueImpl.classworkqueueMonitoredObjecttotalTimeInQueueworkItemsDequeuedworkItemsAddedtheWorkQueueworkerThreadPool/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/orbutil/threadpool/WorkQueueImpl$1.class/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/orbutil/threadpool/WorkQueueImpl$2.class/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/orbutil/threadpool/WorkQueueImpl$3.classworkremainingWaitTimefinishTime Initialized to 1 to avoid divide by zero in averageTimeInQueue() Name of the work queue MonitoredObject for work queue Setup monitoring for this workqueueReturns the total number of Work items added to the Queue.This method is unsynchronized and only gives a snapshot of thestate when it is calledReturns the total number of Work items in the Queue to be processed/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/presentation/rmi/DynamicAccessPermission.java/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/presentation/rmi/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/presentationcom.sun.corba.se.impl.presentation.rmiactionsCopyright (c) 2006, Oracle and/or its affiliates. All rights reserved.This class controls the use of dynamic proxies.A DynamicAccessPermission contains a name (also referred to as a "target name") butno actions list; you either have the named permissionor you don't.private static final long serialVersionUID = -8343910153355041693L;Creates a new DynamicAccessPermission with the specified name.the name of the DynamicAccessPermission.Creates a new DynamicAccessPermission object with the specified name.The name is the symbolic name of the DynamicAccessPermission, and theactions String is currently unused and should be null.should be null./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/presentation/rmi/DynamicMethodMarshallerImpl.javaabstractInterfaceRW/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/presentation/rmi/DynamicMethodMarshallerImpl.class/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/presentation/rmi/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/presentationanyRWcorbaObjectRWdoubleRWfloatRWlongRWintRWshortRWcharRWbyteRWbooleanRWthrowsRemotethrowsRemote(java.lang.reflect.Method)allMethodsThrowRemoteExceptionallMethodsThrowRemoteException(java.lang.Class)isAnyClassisAnyClass(java.lang.Class)resultRWReaderWriter[]argRWsneedsResultCopyneedsArgumentCopyhasVoidResulthasArgumentsehandler/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/presentation/rmi/DynamicMethodMarshallerImpl$1.classwrite(org.omg.CORBA_2_3.portable.OutputStream,java.lang.Object)read(org.omg.CORBA_2_3.portable.InputStream)/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/presentation/rmi/DynamicMethodMarshallerImpl$2.class"byte"/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/presentation/rmi/DynamicMethodMarshallerImpl$3.class/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/presentation/rmi/DynamicMethodMarshallerImpl$4.class/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/presentation/rmi/DynamicMethodMarshallerImpl$5.class"int"/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/presentation/rmi/DynamicMethodMarshallerImpl$6.class/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/presentation/rmi/DynamicMethodMarshallerImpl$7.class/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/presentation/rmi/DynamicMethodMarshallerImpl$8.class/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/presentation/rmi/DynamicMethodMarshallerImpl$9.class"org.omg.CORBA.Object"org.omg.CORBA.Object/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/presentation/rmi/DynamicMethodMarshallerImpl$10.class/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/presentation/rmi/DynamicMethodMarshallerImpl$11.class"abstract_interface"abstract_interfaceexceptionTypesMap<String,RemoteException>RemoteException[]Constructor<RemoteException>? super RemoteExceptionClass<? super RemoteException>TypeVariable<Class<RemoteException>>TypeVariable<Class<RemoteException>>[]/Library/Java/JavaVirtualMachines/jdk1.8.0_251.jdk/Contents/Home/jre/lib/rt.jar/com/sun/corba/se/impl/presentation/Library/Java/JavaVirtualMachines/jdk1.8.0_251.jdk/Contents/Home/jre/lib/rt.jar/com/sun/corba/se/impl/presentation/rmi/Library/Java/JavaVirtualMachines/jdk1.8.0_251.jdk/Contents/Home/jre/lib/rt.jar/com/sun/corba/se/impl/presentation/rmi/DynamicMethodMarshallerImpl$ReaderWriterBase.class"ReaderWriter["ReaderWriter[/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/presentation/rmi/DynamicMethodMarshallerImpl$12.class"remote("remote(/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/presentation/rmi/DynamicMethodMarshallerImpl$13.class"org.omg.CORBA.Object("org.omg.CORBA.Object(/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/presentation/rmi/DynamicMethodMarshallerImpl$14.class"value("value(resultType"Expected "Expected " arguments, but got " arguments, but got " arguments." arguments.? extends ThrowableClass<? extends Throwable>ae true if copyObjects call needs for args true if copyObject call needs for result Assume that cls is not Remote, !isAnyClass(cls), and !org.omg.CORBA.Object.class.isAssignableFrom( cls ). Then return whether cls is an RMI-IIOP abstract interface. Either cls is an interface that extends IDLEntity, or else cls does not extend java.rmi.Remote and all of its methods throw RemoteException. Check that all methods (other than those declared in java.lang.Object) throw an exception that is a subclass of RemoteException. Check that some exceptionType is a subclass of RemoteException For anything else, just read it as a value type. This could be further optimized to avoid copying if argTypes contains at most one immutable object type./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/presentation/rmi/DynamicStubImpl.java/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/presentation/rmi/DynamicStubImpl.classtypeIds4852612040012087675L4852612040012087675responseExpectedcnameclassDataihfactory XXX Do we need _get_codebase? The actual DynamicProxy for this stub. XXX Should probably only allow this once. XXX log this/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/presentation/rmi/ExceptionHandler.javaReturn true iff cls is an exception class that isassignment compatible with an exception declaredon the method used to create this ExceptionHandler.Write the exception ex to os.  ex must be assignmentcompatible with an exceptiondeclared on the method used to create thisExceptionHandler.Read the exception contained in the InputStreamin the ApplicationException.  If ae representsan exception that is assignment compatible withan exception on the method used to create thisexception handler, return the exception,otherwise return an UnexpectedException wrappingthe exception in ae./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/presentation/rmi/ExceptionHandlerImpl.javafindDeclaredExceptionfindDeclaredException(java.lang.String)/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/presentation/rmi/ExceptionHandlerImpl.classfindDeclaredException(java.lang.Class)ExceptionRW[]rws/Library/Java/JavaVirtualMachines/jdk1.8.0_251.jdk/Contents/Home/jre/lib/rt.jar/com/sun/corba/se/impl/presentation/rmi/ExceptionHandlerImpl$ExceptionRWBase.class/Library/Java/JavaVirtualMachines/jdk1.8.0_251.jdk/Contents/Home/jre/lib/rt.jar/com/sun/corba/se/impl/presentation/rmi/ExceptionHandlerImpl$ExceptionRWIDLImpl.classhelperNameidMethoderwClass<UserException>Map<String,UserException>UserException[]Constructor<UserException>? super UserExceptionClass<? super UserException>TypeVariable<Class<UserException>>TypeVariable<Class<UserException>>[]excNameCopyright (c) 2003, 2010, Oracle and/or its affiliates. All rights reserved.///////////////////////////////////////////////////////////////////////////// ExceptionRW interface and implementations. Used to read and write exceptions. read and ignore!The following check is not performedin order to maintain compatibility withrmic.  See bug 4989312.// Check for duplicate repository IDString repositoryId = erw.getId() ;int duplicateIndex = findDeclaredException( repositoryId ) ;if (duplicateIndex > 0) {ExceptionRW duprw = rws[duplicateIndex] ;String firstClassName =erw.getExceptionClass().getName() ;String secondClassName =duprw.getExceptionClass().getName() ;throw wrapper.duplicateExceptionRepositoryId(firstClassName, secondClassName, repositoryId ) ; This may occur when rws has not been fully populated, in which case the search should just fail. Note that the exception ID is present in both ae and in the input stream from ae.  The exception reader must actually read the exception ID from This is here just for the dynamicrmiiiop test/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/presentation/rmi/IDLNameTranslatorImpl.javagetUnmappedContainerNamegetUnmappedContainerName(java.lang.Class)/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/presentation/rmi/IDLNameTranslatorImpl.classgetMappedContainerNamegetMappedContainerName(java.lang.Class)getPackageNamegetPackageName(java.lang.Class)classToIDLTypeclassToIDLType(java.lang.Class)mangleOverloadedMethodmangleOverloadedMethod(java.lang.String,java.lang.reflect.Method)isUnderscoreisUnderscore(char)isIDLDecimalDigitisIDLDecimalDigit(char)isIDLAlphabeticCharisIDLAlphabeticChar(char)isIDLIdentifierCharisIDLIdentifierChar(char)isIDLIdentifierisIDLIdentifier(java.lang.String)identifierClashesWithContaineridentifierClashesWithContainer(java.lang.String,java.lang.String)mangleContainerClashmangleContainerClash(java.lang.String)mangleCaseSensitiveCollisionmangleCaseSensitiveCollision(java.lang.String)mangleUnicodeCharsmangleUnicodeChars(java.lang.String)hasLeadingUnderscorehasLeadingUnderscore(java.lang.String)mangleLeadingUnderscoremangleLeadingUnderscore(java.lang.String)mangleIDLKeywordClashmangleIDLKeywordClash(java.lang.String)isIDLKeywordisIDLKeyword(java.lang.String)mangleIdentifiermangleIdentifier(java.lang.String,boolean)mangleIdentifier(java.lang.String)buildNameTranslationbuildNameTranslation()IDLNameTranslatorImplIDLNameTranslatorImpl(java.lang.Class[])methods_IDLNameToMethodMap_methodToIDLNameMap_interf_idlKeywords_IS_ATTRIBUTE_PREFIXSET_ATTRIBUTE_PREFIXGET_ATTRIBUTE_PREFIXATTRIBUTE_METHOD_CLASH_MANGLE_CHARSOVERLOADED_TYPE_SEPARATORID_CONTAINER_CLASH_CHARLEADING_UNDERSCORE_CHARBASE_IDL_ARRAY_ELEMENT_TYPEBASE_IDL_ARRAY_MODULE_TYPEINNER_CLASS_SEPARATORUNDERSCOREHEX_DIGITSIDL_KEYWORDS"abstract""attribute"attribute"case"case"const"const"context""custom"custom"default""factory""FALSE"FALSE"in""inout"inout"interface"interface"module""oneway"oneway"out""private""public""raises"raises"readonly"readonly"supports"supports"switch"switch"TRUE"TRUE"truncatable"truncatable"typedef"typedef"unsigned"unsigned"ValueBase"ValueBase"valuetype"valuetype'E'E"_""org"org"omg"omg"boxedRMI"boxedRMI"seq""_get_"_get_"_set_"_set_keywordAllCapsinterfitypeidlName"access"accessidlTypesUtilallMethodInfo/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/presentation/rmi/IDLNameTranslatorImpl$1.classAccessibleObject[]nextMethodmethodInfoattributeNameouterIterouterinnerItermappedContainerNameorigMethodName"get""set"clash"Error : methods "Error : methods " and " and " both result in IDL name '" both result in IDL name '"'"'mangledNameidentifierAllCapsmangledIdentifiernextCharunicodeneedUnderscorenumZerosToAdddiv"U"isIdentifieralphaChar0x0041650x005A900x0061970x007A1220x00C01920x00D70x00F70x00300x0039570x005F95newMangledNameparameterTypesnextParamTypeidlTypemoduleNametypeNamenumArrayDimensionscomponentIdlTypemodulespackageName"\\$"\$"org.omg.boxedIDL."org.omg.boxedIDL.moreMangledthePackagefullyQualifiedClassNamelastDotunmappedNamepackageLengthIDLMethodInfoIDLMethodInfo()/Library/Java/JavaVirtualMachines/jdk1.8.0_251.jdk/Contents/Home/jre/lib/rt.jar/com/sun/corba/se/impl/presentation/rmi/IDLNameTranslatorImpl$IDLMethodInfo.classcontents"IDLNameTranslator["IDLNameTranslator["]\n"]
Copyright (c) 2003, 2013, Oracle and/or its affiliates. All rights reserved.Bidirectional translator between RMI-IIOP interface methods andand IDL Names. From CORBA Spec, Table 6 Keywords. Note that since all IDL identifiers are case insensitive, java identifier comparisons to these will be case insensitive also. used to mangle java inner class names used to form IDL array type names used to mangling java identifiers that have a leading underscore separator used between types in a mangled overloaded method name string appended to attribute if it clashes with a method name strings prepended to the attribute names in order to form their IDL names. Convert keyword to all caps to ease equality check. Instance state Remote interface for name translation. Maps used to hold name translations.  These do not need to be synchronized since the translation is never modified afterReturn an IDLNameTranslator for the given interface.IllegalStateExceptionif given class is not a validRMI/IIOP Remote InterfaceReturn an IDLNameTranslator for the given interfacex.if given classes are not  validRMI/IIOP Remote Interfaces Requirements for this method: 1. cls must be an exception but not a RemoteException. 2. If cls has an IDL keyword name, an underscore is prepended (1.3.2.2). 3. If cls jas a leading underscore, J is prepended (1.3.2.3). 4. If cls has an illegal IDL ident char, it is mapped to UXXXX where    XXXX is the unicode value in hex of the char (1.3.2.4). 5. double underscore for inner class (1.3.2.5). 6. The ID is "IDL:" + name with / separators + ":1.0".Initialize an IDLNameTranslator for the given interface. holds method info, keyed by method Handle the case of a non-public interface! Take an initial pass through all the methods and create some information that will be used to track the IDL name transformation. Perform case sensitivity test first.  This applies to all method names AND attributes.  Compare each method name and attribute to all other method names and attributes.  If names differ only in case, apply mangling as defined in section 1.3.2.7 of Java2IDL spec.  Note that we compare using the original names. Now check for overloaded method names and apply 1.3.2.6. Now mangle any properties that clash with method names. Ensure that no mapped method names clash with mapped name of container(1.3.2.9).  This is a case insensitive comparison. Populate name translation maps. Final check to see if there are any clashes after all the manglings have been applied.  If so, this is treated as an invalid interface.  Currently, we do a CASE-SENSITIVE comparison since that matches the rmic behavior. @@@ Shouldn't this be a case-insensitive check? @@@ I18NPerform all necessary stand-alone identifier mangling operationson a java identifier that is being transformed into an IDL name.That is, mangling operations that don't require looking at anythingelse but the identifier itself.  This covers sections 1.3.2.2, 1.3.2.3,and 1.3.2.4 of the Java2IDL spec.  Method overloading andcase-sensitivity checks are handled elsewhere. Apply leading underscore test (1.3.2.3) This should be done before IDL Keyword clash test, since clashing IDL keywords are mangled by adding a leading underscore. Apply IDL keyword clash test (1.3.2.2). This is not needed for attributes since when the full property name is composed it cannot clash with an IDL keyword. (Also, rmic doesn't do it.) Replace illegal IDL identifier characters (1.3.2.4) for all method names and attributes. isIDLKeyword and mangleIDLKeywordClash are exposed here so that IDLType can use them. XXX refactoring needed: 1. Split off isIDLKeywork and mangleIDLKeywordClash (and possibly    other methods) into a utility class. 2. Move all of classToIDLType to a constructor inside IDLType. The problem appears to be that we need all of the code that performs various checks for name problems and the corresponding fixes into a utility class.  Then we need to see what other refactorings present themselves.Checks whether a java identifier clashes with anIDL keyword.  Note that this is a case-insensitivecomparison.Used to implement section 1.3.2.2 of Java2IDL spec.Checks whether a java identifier starts with an underscore.Used to implement section 1.3.2.3 of Java2IDL spec.Implements Section 1.3.2.4 of Java2IDL Mapping.All non-IDL identifier characters must be replacedwith their Unicode representation.Implements mangling portion of Section 1.3.2.7 of Java2IDL spec.This method only deals with the actual mangling.  Decision aboutwhether case-sensitive collision mangling is required is madeelsewhere."...a mangled name is generated consisting of the original namefollowed by an underscore separated list of decimal indicesinto the string, where the indices identify all the upper casecharacters in the original string. Indices are zero based." There is always at least one trailing underscore, whether or not the identifier has uppercase letters. This bit of logic is needed to ensure that we have an underscore separated list of indices but no trailing underscores.  Basically, after we have at least one uppercase letter, we always put an undercore before printing the next one.Implements Section 1.3.2.9 of Java2IDL Mapping. Container in thiscontext means the name of the java Class(excluding package) in whichthe identifier is defined.  Comparison is case-insensitive.Returns Unicode mangling as defined in Section 1.3.2.4 ofJava2IDL spec."For Java identifiers that contain illegal OMG IDL identifiercharacters such as '$' or Unicode characters outside of ISO Latin 1,any such illegal characters are replaced by "U" followed by the4 hexadecimal characters(in upper case) representing the Unicodevalue.  So, the Java name a$b is mapped to aU0024b andx\u03bCy is mapped to xU03BCy." 1st char must be alphbetic.True if character is one of 114 Alphabetic characters asspecified in Table 2 of Chapter 3 in CORBA spec. NOTE that we can't use the java.lang.Character isUpperCase, isLowerCase, etc. methods since they include many characters other than the Alphabetic list in the CORBA spec.  Instead, we test for inclusion in the Unicode value ranges for the corresponding legal characters. A - Z a - z other letter uppercase, other letter lowercase, which is the entire upper half of C1 Controls except X and /True if character is one of 10 Decimal Digitsspecified in Table 3 of Chapter 3 in CORBA spec.Mangle an overloaded method name as defined in Section 1.3.2.6 ofJava2IDL spec.  Current value of method name is passed in as argument.We can't start from original method name since the name might havebeen partially mangled as a result of the other rules. Start by appending the separator string Calculate array depth, as well as base element type. Section 1.3.2.5 of Java2IDL spec defines mangling rules for inner classes. replace inner class separator with double underscore Get raw package name.  If there is a package, it will still have the "." separators and none of the mangling rules will have been applied. If this is a generated IDL Entity Type we need to prepend org_omg_boxedIDL per sections 1.3.5 and 1.3.9 Section 1.3.2.1 and 1.3.2.6 of Java2IDL spec defines rules for mapping java packages to IDL modules and for mangling module name portion of type name.  NOTE that of the individual identifier mangling rules, only the leading underscore test is done here. The other two(IDL Keyword, Illegal Unicode chars) are done in mangleOverloadedMethodName.Return Class' package name or null if there is no package. Try to get package name by introspection.  Some classloaders might not provide this information, so check for null. brute force methodReturn portion of class name excluding package name.Internal helper class for tracking information related to eachinterface method while we're building the name translation table. If this is a property, originalName holds the original attribute name. Otherwise, it holds the original method name. If this is a property, mangledName holds the mangled attribute name. Otherwise, it holds the mangled method name./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/presentation/rmi/IDLType.javamemberName_/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/presentation/rmi/IDLType.classmodules_cl_separatorfixIDLKeywordssbuffmodName"Exception""Ex"Ex"IDL:"IDL:":1.0":1.0Holds information about the OMG IDL mapping of a Java type. terminology for OMG IDL type package name name of element within module Note that this should probably be makeConcatenatedName( '/', true ) for spec compliance, but rmic does it this way, so we'll leave this. The effect is that an overloaded method like void foo( bar.typedef.Baz ) will get an IDL name of foo__bar_typedef_Baz instead of foo__bar__typedef_Baz (note the extra _ before typedef). Here we will check for IDL keyword collisions (see bug 5010332). This means that the repository ID for foo.exception.SomeException is "IDL:foo/_exception/SomeEx:1.0" (note the underscore in front of the exception module name). See bug 4989312: we must always add the Ex.True if this type doesn't have a containing module.  Thiswould be true of a java type defined in the default packageor a primitive./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/presentation/rmi/IDLTypeException.javaChecked exception containing information about anan IDL type validation./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/presentation/rmi/IDLTypesUtil.javavalidateConstantsvalidateConstants(java.lang.Class)/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/presentation/rmi/IDLTypesUtil.classvalidateDirectInterfacesvalidateDirectInterfaces(java.lang.Class)isRemoteExceptionOrSuperClassisRemoteExceptionOrSuperClass(java.lang.Class)validPropertyExceptionsvalidPropertyExceptions(java.lang.reflect.Method)validateExceptionsvalidateExceptions(java.lang.reflect.Method)isHasCorrespondingReadPropertyisHasCorrespondingReadProperty(java.lang.reflect.Method,java.lang.Class)readHasCorrespondingIsPropertyreadHasCorrespondingIsProperty(java.lang.reflect.Method,java.lang.Class)hasCorrespondingReadPropertyhasCorrespondingReadProperty(java.lang.reflect.Method,java.lang.Class,java.lang.String)IS_PROPERTY_PREFIXSET_PROPERTY_PREFIXGET_PROPERTY_PREFIX"is"" must be a java interface." must be a java interface." must extend java.rmi.Remote, " +
                "either directly or indirectly." must extend java.rmi.Remote, either directly or indirectly.remoteInterfacearrayTypeMap<String,Throwable>Throwable[]Constructor<Throwable>? super ThrowableClass<? super Throwable>TypeVariable<Class<Throwable>>TypeVariable<Class<Throwable>>[]Class<RuntimeException>Map<String,RuntimeException>RuntimeException[]Constructor<RuntimeException>? super RuntimeExceptionClass<? super RuntimeException>TypeVariable<Class<RuntimeException>>TypeVariable<Class<RuntimeException>>[]Class<Error>Map<String,Error>Error[]Constructor<Error>? super ErrorClass<? super Error>TypeVariable<Class<Error>>TypeVariable<Class<Error>>[]propertyTypewritePropertyreadPropertyPrefixwritePropertyMethodNamewritePropertyParametersfoundReadPropertyreadPropertyMethodNamereadPropertyMethodreadPropertyfoundIsPropertyisPropertyMethodNameisPropertyMethodremainder"long_long"long_long"java"java"lang"lang"CORBA"CORBA"WStringValue"WStringValue"javax"javax"rmi"rmi"ClassDesc"ClassDesc"io"io"Serializable"Serializable"Externalizable"Externalizable"Remote"RemotedeclaresRemoteExceptionOrSuperClasseIndex"Method '"Method '"' must throw at least one " +
                "exception of type java.rmi.RemoteException or one of its " +
                "super-classes"' must throw at least one exception of type java.rmi.RemoteException or one of its super-classes"Exception '"Exception '"' on method '"' on method '"' is not a allowed RMI/IIOP exception type"' is not a allowed RMI/IIOP exception typedirectInterfacesallMethodNamescurrentMethodNames" inherits method " inherits method " from multiple direct interfaces." from multiple direct interfaces./Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/presentation/rmi/IDLTypesUtil$1.class"Constant field '"Constant field '"' in class '"' in class '"' has invalid type' "' has invalid type' "'. Constants" +
                    " in RMI/IIOP interfaces can only have primitive" +
                    " types and java.lang.String types."'. Constants in RMI/IIOP interfaces can only have primitive types and java.lang.String types.Copyright (c) 2003, 2006, Oracle and/or its affiliates. All rights reserved.Utility class for testing RMI/IDL Types as defined inSection 1.2 of The Java Language to IDL Mapping.  Note thatthese are static checks only.  Runtime checks, such as thosedescribed in Section 1.2.3, #3, are not covered.rmic -iiop does not correctly implement the clause in 1.3.4.3about is<NAME>/get<NAME> conflicts.  The spec says thatis<NAME> is the property and get<NAME> is left alone,but rmic does the opposite.  We will follow rmic in this,but it's easy to change.Validate a class to ensure it conforms to the rules for aJava RMI/IIOP interface.IDLTypeExceptionif not a valid RMI/IIOP interface. Get all methods, including super-interface methods. Removed because of bug 4989053 validateDirectInterfaces(c);Section 1.2.2 Primitive TypesSection 1.2.4Section 1.2.5Section 1.2.6 Must be a checked exception, not including RemoteException or its subclasses.Section 1.2.7Section 1.2.8Return true if given method is legal property accessor as defined inSection 1.3.4.3 of Java2IDL spec. Some final checks that apply to all properties. Look for a valid corresponding Read property ignore. this means we didn't find a corresponding get property. Look for a valid corresponding Is property ignore. this means we didn't find a corresponding Is property. ignore. this means we didn't find a corresponding read property. don't set the first letter to lower-case if the first two are upper-caseReturn IDL Type name for primitive types as defined inSection 1.3.3 of Java2IDL spec or null if not a primitive type.Return IDL Type name for special case type mappings as defined inTable 1-1 of Java2IDL spec or null if given class is not a specialImplements 1.2.3 #2 and #4 Section 1.2.3, #2 Section 1.2.3, #4 See also bug 4972402 For all exceptions E in exceptions, (isCheckedException(E) => (isValue(E) || RemoteException.isAssignableFrom( E ) )Returns true if the method's throw clause conforms to the exceptionrestrictions for properties as defined in Section 1.3.4.3 ofJava2IDL spec.  This means that for all exceptions E declared on themethod, E isChecked => RemoteException.isAssignableFrom( E ).Implements Section 1.2.3, #2.Implements Section 1.2.3, #5. Comparison is based on method names only.  First collect all methods from current interface, eliminating duplicate names. Now check each method against list of all unique method names processed so far.Implements 1.2.3 #6/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/presentation/rmi/InvocationHandlerFactoryImpl.javagetInvocationHandlergetInvocationHandler(com.sun.corba.se.spi.presentation.rmi.DynamicStub)/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/presentation/rmi/InvocationHandlerFactoryImpl.classproxyInterfacesremoteInterfacesClass<DynamicStub>/Library/Java/JavaVirtualMachines/jdk1.8.0_251.jdk/Contents/Home/jre/lib/rt.jar/com/sun/corba/se/impl/presentation/rmi/InvocationHandlerFactoryImpl$CustomCompositeInvocationHandlerImpl.classproxydynamicStubHandlerstubMethodHandler/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/presentation/rmi/InvocationHandlerFactoryImpl$1.classPrivilegedAction<Void>Return the stub, which will actually be written to the stream.It will be custom marshalled, with the actual writing done inStubIORImpl.  There is a corresponding readResolve method onDynamicStubImpl which will re-create the full invocationhandler on read, and return the invocation handler on thereadResolve method. This is also used in DynamicStubImpl to implement readResolve. Create an invocation handler for the methods defined on DynamicStub, which extends org.omg.CORBA.Object.  This handler delegates all calls directly to a DynamicStubImpl, which extends org.omg.CORBA.portable.ObjectImpl. Create an invocation handler that handles any remote interface methods. Create a composite handler that handles the DynamicStub interface as well as the remote interfaces. If the method passed to invoke is not from DynamicStub or its superclasses, it must be from an implemented interface, so we just handle all of these with the stubMethodHandler.  This used to be done be adding explicit entries for stubMethodHandler for each remote interface, but that does not work correctly for abstract interfaces, since the graph analysis ignores abstract interfaces in order to compute the type ids correctly (see PresentationManagerImpl.NodeImpl.getChildren). Rather than produce more graph traversal code to handle this problem, we simply use a default. This also points to a possible optimization: just use explict checks for the three special classes, rather than a general table lookup that usually fails./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/presentation/rmi/JNDIStateFactoryImpl.javajavax.naminggetORBgetORB(javax.naming.Context)/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/presentation/rmi/JNDIStateFactoryImpl.classorbField/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/presentation/rmi/JNDIStateFactoryImpl$1.classClass<CNCtx>"_orb"Hashtable<?,?>Dictionary<?,?>Map<?,?>env XXX This creates a dependendcy on the implementation of the CosNaming service provider.StateFactory that turns java.rmi.Remote objects to org.omg.CORBA.Object.This version works either with standard RMI-IIOP or Dynamic RMI-IIOP.Based on the original com.sun.jndi.cosnaming.RemoteToCorba andcom.sun.jndi.toolkit.corba.CorbaUtils. XXX log exception at FINEReturns the CORBA object for a Remote object.If input is not a Remote object, or if Remote object uses JRMP, return null.If the RMI-IIOP library is not available, throw ConfigurationException.The object to turn into a CORBA object. If not Remote,or if is a JRMP stub or impl, return null.IgnoredThe non-null CNCtx whose ORB to use.The CORBA object for <tt>orig</tt> or null.ConfigurationExceptionIf the CORBA object cannot be obtaineddue to configuration problemsNamingExceptionIf some other problem prevented a CORBAobject from being obtained from the Remote object. Not for this StateFactory Wrong kind of context, so just give up and let another StateFactory try to satisfy getStateToBind. XXX log at FINE level? Wrong sort of object: just return null to allow another StateFactory to handle this.  This can happen easily because this StateFactory is specified for the application, not the service context provider. to handle this call. ignore RemoteException because stub might have already been connected This is necessary because the _orb field is package private in com.sun.jndi.cosnaming.CNCtx.  This is not an ideal solution. The best solution for our ORB is to change the CosNaming provider to use the StubAdapter.  But this has problems as well, because other vendors may use the CosNaming provider with a different ORB entirely. XXX log this exception at FINE level ignore the exception and return null. Note that the exception may be because ctx is not a CosNaming context./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/presentation/rmi/PresentationManagerImpl.javaaddNodesaddNodes(java.util.List,java.util.Set)/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/presentation/rmi/PresentationManagerImpl.classmakeTypeIdsmakeTypeIds(com.sun.corba.se.impl.presentation.rmi.PresentationManagerImpl.NodeImpl,com.sun.corba.se.impl.orbutil.graph.Graph,java.util.Set)getInterfaces(java.util.Set)getRootSetgetRootSet(java.lang.Class,com.sun.corba.se.impl.presentation.rmi.PresentationManagerImpl.NodeImpl,com.sun.corba.se.impl.orbutil.graph.Graph)useDynamicStubsdynamicStubFactoryFactorymethodToDMMclassToClassDatadictionary/Library/Java/JavaVirtualMachines/jdk1.8.0_251.jdk/Contents/Home/jre/lib/rt.jar/com/sun/corba/se/impl/presentation/rmi/PresentationManagerImpl$ClassDataImpl.classsfactorynameTranslatorrootSetinitialRootSetrootsnonRootSetresultListnodeSet/Library/Java/JavaVirtualMachines/jdk1.8.0_251.jdk/Contents/Home/jre/lib/rt.jar/com/sun/corba/se/impl/presentation/rmi/PresentationManagerImpl$NodeImpl.class"RMI:"RMI:":0000000000000000":0000000000000000"NodeImpl["NodeImpl[ XXX these should probably be WeakHashMaps.////////////////////////////////////////////////////////////////////////////// PresentationManager interface At this point, rootSet contains those remote interfaces that are not related by inheritance, and gr contains all reachable remote interfaces. Graph computations rootSet just contains root here Use this class and its superclasses (not Object) as initial roots Expand all nodes into the graph remove the roots and find roots again List<String> for the typeids If the rootSet has more than one element, we must put the type id of the implementation class first. Root represents the implementation class here./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/presentation/rmi/ReflectiveTie.java/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/presentation/rmi/ReflectiveTie.classtargetClassreplyjavaMethoddmm Unwrap the actual exception so that it can be wrapped by an UnknownException or thrown if it is a system exception. This is expected in the server dispatcher code./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/presentation/rmi/StubConnectImpl.java/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/presentation/rmi/StubConnectImpl.class"CORBA SystemException"CORBA SystemExceptionConnect the stub to the orb if necessary.The StubIORImpl for this stub (may be null)The externally visible stub seen by the user (may be the same as stub)The stub implementation that extends ObjectImplThe ORB to which we connect the stub. No IOR, can we get a Tie for this stub? Is the tie already connected?  If it is, check that it's connected to the same ORB, otherwise connect it. Thrown when tie is an ObjectImpl and its delegate is not set. Thrown when tie is a Servant and its delegate is not set. Get the delegate for the stub from the tie. ior is initialized, so convert ior to an object, extract the delegate, and set it on ourself/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/presentation/rmi/StubFactoryBase.java/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/presentation/rmi/StubFactoryBase.class/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/presentation/rmi/StubFactoryDynamicBase.javaStubFactoryDynamicBaseStubFactoryDynamicBase(java.lang.Void,com.sun.corba.se.spi.presentation.rmi.PresentationManager.ClassData,java.lang.ClassLoader)/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/presentation/rmi/StubFactoryDynamicBase.classcheckPermissioncheckPermission()sm"enableSubclassImplementation"enableSubclassImplementationunused this.loader must not be null, or the newProxyInstance call will fail./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/presentation/rmi/StubFactoryFactoryBase.javafullNameReturns the stub classname for the given interface name.fully qualified name remote class/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/presentation/rmi/StubFactoryFactoryDynamicBase.javaisIDLStubremoteCodeBaseexpectedClassclassLoadersf IDL stubs must always use static factories./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/presentation/rmi/StubFactoryFactoryProxyImpl.java/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/presentation/rmi/StubFactoryFactoryProxyImpl$1.classPrivilegedAction<StubFactoryProxyImpl>/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/presentation/rmi/StubFactoryFactoryProxyImpl.class/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/presentation/rmi/StubFactoryFactoryStaticImpl.java/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/presentation/rmi/StubFactoryFactoryStaticImpl.classstubNameexpectedTypeClassLoaderfirstStubNamesecondStubName"Could not load class "Could not load class tieClass The old code was optimized to try to guess which way to load classes first.  The real stub class name could either be className or "org.omg.stub." + className.  We will compute this as follows: If stubName starts with a "forbidden" package, try the prefixed version first, otherwise try the non-prefixed version first. In any case, try both forms if necessary. log only at FINE level XXX Is this step necessary, or should the Util.loadClass algorithm always produce a valid class if the setup is correct? Does the OMG standard algorithm need to be changed to include this step? XXX make this a system exception XXX log exceptions at FINE level_REVISIT_ The spec does not specify a loadingContext parameter forthe following call.  Would it be useful to pass one?/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/presentation/rmi/StubFactoryProxyImpl.java Construct the dynamic proxy that implements this stub using the composite handler/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/presentation/rmi/StubFactoryStaticImpl.java/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/presentation/rmi/StubFactoryStaticImpl.class/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/presentation/rmi/StubInvocationHandlerImpl.javaisLocalisLocal()/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/presentation/rmi/StubInvocationHandlerImpl.classlcrdgiopMethodNamesocopies/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/presentation/rmi/StubInvocationHandlerImpl$1.classmexexCopyInvoke the given method with the args and return the result.This may result in a remote invocation.The proxy used for this class (null if not using java.lang.reflect.Proxy) create request marshal arguments finish invocation unmarshal result local branch Make sure that we can invoke a method from a normally inaccessible package, as this reflective class must always be able to invoke a non-public method. mex should never be null, as null cannot be thrown This is not a user thrown exception from the method call, so don't copy it.  This is either an error or a reflective invoke exception./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/protocol/AddressingDispositionException.java/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/protocolcom.sun.corba.se.impl.protocolexpectedAddrDisp/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/protocol/AddressingDispositionException.class/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/protocolThis exception is thrown while reading GIOP 1.2 Request, LocateRequestto indicate that a TargetAddress disposition is unacceptable.If this exception is caught explicitly, this need to be rethrown. Thisis eventually handled within RequestPRocessor and an appropriate replyis sent back to the client.GIOP 1.2 allows three dispositions : KeyAddr (ObjectKey), ProfileAddr (iorprofile), IORAddressingInfo (IOR). If the ORB does not support thedisposition contained in the GIOP Request / LocateRequest 1.2 message,then it sends a Reply / LocateReply indicating the correct disposition,which the client ORB shall use to transparently retry the requestwith the correct disposition./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/protocol/BootstrapServerRequestDispatcher.java/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/protocol/BootstrapServerRequestDispatcher.classresponseserviceKeyserviceObjectClass BootstrapServerRequestDispatcher handles the requests coming to theBootstrapServer. It implements Server so that it can be registeredas a subcontract. It is passed a BootstrapServiceProperties objectwhich containsthe supported ids and their values for the bootstrap service. ThisProperties object is only read from, never written to, and is sharedamong all threads.The BootstrapServerRequestDispatcher responds primarily to GIOP requests,but LocateRequests are also handled for graceful interoperability.The BootstrapServerRequestDispatcher handles one request at a time.Dispatch is called by the ORB and will serve get(key) and list()invocations on the initial object key. Get the name of the requested service Look it up Write reply value Marshal the exception thrown Unknown exceptionLocates the object mentioned in the locate requests, and returnsobject here iff the object is the initial object key. A SystemExceptionthrown if the object key is not the initial object key.Not implemented/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/protocol/CorbaClientDelegateImpl.javagetClientRequestDispatchergetClientRequestDispatcher()/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/protocol/CorbaClientDelegateImpl.classcontactInfoListIterator"_interface"_interfaceobjimpl"IDL:omg.org/CORBA/InterfaceDef:1.0"IDL:omg.org/CORBA/InterfaceDef:1.0"org.omg.CORBA._InterfaceDefStub"org.omg.CORBA._InterfaceDefStubmyid"_is_a"_is_a"_non_existent"_non_existentcorbaDelegateotherDelotherIormaximumarg_listexclistctxlist implements com.sun.corba.se.impl.core.ClientRequestDispatcher so RMI-IIOP Util.isLocal can call ClientRequestDispatcher.useLocalInvocation. framework.subcontract.Delegate CORBA_2_3.portable.Delegate Remember chosen subcontract for invoke and releaseReply. NOTE: This is necessary since a stream is not available in releaseReply if there is a client marshaling error or an error in _invoke. NOTE: InputStream may be null (e.g., exception request from PI). instantiate the stub check if returned object is of correct type This cannot happen. dest is the typeId of the interface to compare against. repositoryIds is the list of typeIds that the stub knows about. First we look for an answer using local information. But repositoryIds may not be complete, so it may be necessary to go to server. DO NOT clear out internal variables to release memory This delegate may be pointed-to by other objrefs. obj._get_delegate() == this due to the argument passing conventions in portable.ObjectImpl, so we just ignore obj here. If ref is a local object, it is not a Stub! Optimize the x.is_equivalent( x ) case If delegate was created by a different ORB, return falseThis method overrides the org.omg.CORBA.portable.Delegate.equals method,and does the equality check based on IOR equality. Come here if other is not implemented by our ORB.Returns true if this object is implemented by a local servant.REVISIT: locatedIOR should be replaced with a method call thatreturns the current IOR for this request (e.g. ContactInfoChooser).The object reference which delegated to this delegate.true only if the servant incarnating this object is located inthis ORB. XXX this need to check isNextCallValid XXX Should this be public?Returns the codebase for object reference provided.@param self the object reference whose codebase needs to be returned.@return the codebase as a space delimited list of url strings ornull if none./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/protocol/CorbaClientRequestDispatcherImpl.javajava.util.concurrentConcurrentMap<ContactInfo,Object>/Users/jettt/IdeaProjects/jdk_test/target/classes/java/util/concurrent/ConcurrentMap.class/Users/jettt/IdeaProjects/jdk_test/target/classes/java/util/concurrentMap<ContactInfo,Object>locks/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/protocol/CorbaClientRequestDispatcherImpl.classConcurrentHashMap<ContactInfo,Object>/Users/jettt/IdeaProjects/jdk_test/target/classes/java/util/concurrent/ConcurrentHashMap.classAbstractMap<ContactInfo,Object>ConcurrentHashMap<ContactInfo,Object>()merge(com.sun.corba.se.pept.transport.ContactInfo,java.lang.Object,java.util.function.BiFunction)? super ContactInfoBiFunction<? super ContactInfo,? super Object,? extends Object>compute(com.sun.corba.se.pept.transport.ContactInfo,java.util.function.BiFunction)computeIfPresent(com.sun.corba.se.pept.transport.ContactInfo,java.util.function.BiFunction)Function<? super ContactInfo,? extends Object>computeIfAbsent(com.sun.corba.se.pept.transport.ContactInfo,java.util.function.Function)replace(com.sun.corba.se.pept.transport.ContactInfo,java.lang.Object)replace(com.sun.corba.se.pept.transport.ContactInfo,java.lang.Object,java.lang.Object)putIfAbsent(com.sun.corba.se.pept.transport.ContactInfo,java.lang.Object)BiConsumer<? super ContactInfo,? super Object>Entry<ContactInfo,Object>Set<Entry<ContactInfo,Object>>Collection<Entry<ContactInfo,Object>>Iterable<Entry<ContactInfo,Object>>Set<ContactInfo>Collection<ContactInfo>Iterable<ContactInfo>? extends ContactInfoMap<? extends ContactInfo,? extends Object>put(com.sun.corba.se.pept.transport.ContactInfo,java.lang.Object)AbstractMap<ContactInfo,Object>()ToIntFunction<Entry<K,V>>/Users/jettt/IdeaProjects/jdk_test/target/classes/java/util/function/ToIntFunction.classreduceEntriesToIntreduceEntriesToInt(long,java.util.function.ToIntFunction,int,java.util.function.IntBinaryOperator)ToIntFunction<Entry<ContactInfo,Object>>ToLongFunction<Entry<K,V>>/Users/jettt/IdeaProjects/jdk_test/target/classes/java/util/function/ToLongFunction.classreduceEntriesToLongreduceEntriesToLong(long,java.util.function.ToLongFunction,long,java.util.function.LongBinaryOperator)ToLongFunction<Entry<ContactInfo,Object>>ToDoubleFunction<Entry<K,V>>/Users/jettt/IdeaProjects/jdk_test/target/classes/java/util/function/ToDoubleFunction.classreduceEntriesToDoublereduceEntriesToDouble(long,java.util.function.ToDoubleFunction,double,java.util.function.DoubleBinaryOperator)ToDoubleFunction<Entry<ContactInfo,Object>>reduceEntriesreduceEntries(long,java.util.function.Function,java.util.function.BiFunction)Function<Entry<K,V>,? extends U>? super UBiFunction<? super U,? super U,? extends U>Function<Entry<ContactInfo,Object>,? extends U>? extends Entry<K,V>BiFunction<Entry<K,V>,Entry<K,V>,? extends Entry<K,V>>reduceEntries(long,java.util.function.BiFunction)? extends Entry<ContactInfo,Object>BiFunction<Entry<ContactInfo,Object>,Entry<ContactInfo,Object>,? extends Entry<ContactInfo,Object>>searchEntriessearchEntries(long,java.util.function.Function)forEachEntryforEachEntry(long,java.util.function.Function,java.util.function.Consumer)Consumer<? super U>? super Entry<K,V>Consumer<? super Entry<K,V>>forEachEntry(long,java.util.function.Consumer)? super Entry<ContactInfo,Object>Consumer<? super Entry<ContactInfo,Object>>ToIntFunction<? super V>reduceValuesToIntreduceValuesToInt(long,java.util.function.ToIntFunction,int,java.util.function.IntBinaryOperator)ToIntFunction<? super Object>ToLongFunction<? super V>reduceValuesToLongreduceValuesToLong(long,java.util.function.ToLongFunction,long,java.util.function.LongBinaryOperator)ToLongFunction<? super Object>ToDoubleFunction<? super V>reduceValuesToDoublereduceValuesToDouble(long,java.util.function.ToDoubleFunction,double,java.util.function.DoubleBinaryOperator)ToDoubleFunction<? super Object>reduceValuesreduceValues(long,java.util.function.Function,java.util.function.BiFunction)Function<? super V,? extends U>Function<? super Object,? extends U>reduceValues(long,java.util.function.BiFunction)searchValuessearchValues(long,java.util.function.Function)forEachValueforEachValue(long,java.util.function.Function,java.util.function.Consumer)Consumer<? super V>forEachValue(long,java.util.function.Consumer)ToIntFunction<? super K>reduceKeysToIntreduceKeysToInt(long,java.util.function.ToIntFunction,int,java.util.function.IntBinaryOperator)ToIntFunction<? super ContactInfo>ToLongFunction<? super K>reduceKeysToLongreduceKeysToLong(long,java.util.function.ToLongFunction,long,java.util.function.LongBinaryOperator)ToLongFunction<? super ContactInfo>ToDoubleFunction<? super K>reduceKeysToDoublereduceKeysToDouble(long,java.util.function.ToDoubleFunction,double,java.util.function.DoubleBinaryOperator)ToDoubleFunction<? super ContactInfo>reduceKeysreduceKeys(long,java.util.function.Function,java.util.function.BiFunction)Function<? super K,? extends U>Function<? super ContactInfo,? extends U>BiFunction<? super K,? super K,? extends K>reduceKeys(long,java.util.function.BiFunction)BiFunction<? super ContactInfo,? super ContactInfo,? extends ContactInfo>searchKeyssearchKeys(long,java.util.function.Function)forEachKeyforEachKey(long,java.util.function.Function,java.util.function.Consumer)Consumer<? super K>forEachKey(long,java.util.function.Consumer)Consumer<? super ContactInfo>ToIntBiFunction<? super K,? super V>/Users/jettt/IdeaProjects/jdk_test/target/classes/java/util/function/ToIntBiFunction.classreduceToIntreduceToInt(long,java.util.function.ToIntBiFunction,int,java.util.function.IntBinaryOperator)ToIntBiFunction<? super ContactInfo,? super Object>ToLongBiFunction<? super K,? super V>/Users/jettt/IdeaProjects/jdk_test/target/classes/java/util/function/ToLongBiFunction.classreduceToLongreduceToLong(long,java.util.function.ToLongBiFunction,long,java.util.function.LongBinaryOperator)ToLongBiFunction<? super ContactInfo,? super Object>ToDoubleBiFunction<? super K,? super V>/Users/jettt/IdeaProjects/jdk_test/target/classes/java/util/function/ToDoubleBiFunction.classreduceToDoublereduceToDouble(long,java.util.function.ToDoubleBiFunction,double,java.util.function.DoubleBinaryOperator)ToDoubleBiFunction<? super ContactInfo,? super Object>reducereduce(long,java.util.function.BiFunction,java.util.function.BiFunction)BiFunction<? super K,? super V,? extends U>BiFunction<? super ContactInfo,? super Object,? extends U>search(long,java.util.function.BiFunction)forEach(long,java.util.function.BiFunction,java.util.function.Consumer)forEach(long,java.util.function.BiConsumer)batchForbatchFor(long)/Library/Java/JavaVirtualMachines/jdk1.8.0_251.jdk/Contents/Home/jre/lib/rt.jar/java/util/concurrent/Library/Java/JavaVirtualMachines/jdk1.8.0_251.jdk/Contents/Home/jre/lib/rt.jar/java/util/concurrent/ConcurrentHashMap$Node.classuntreeifyuntreeify(java.util.concurrent.ConcurrentHashMap.Node)sumCountsumCount()helpTransferhelpTransfer(java.util.concurrent.ConcurrentHashMap.Node[],java.util.concurrent.ConcurrentHashMap.Node)Node<ContactInfo,Object>Node<ContactInfo,Object>[]resizeStampresizeStamp(int)KeySetView<>/Library/Java/JavaVirtualMachines/jdk1.8.0_251.jdk/Contents/Home/jre/lib/rt.jar/java/util/concurrent/ConcurrentHashMap$KeySetView.classCollectionView<>/Library/Java/JavaVirtualMachines/jdk1.8.0_251.jdk/Contents/Home/jre/lib/rt.jar/java/util/concurrent/ConcurrentHashMap$CollectionView.classKeySetView<K,V>CollectionView<K,V,K>keySet(java.lang.Object)KeySetView<ContactInfo,Object>CollectionView<ContactInfo,Object,ContactInfo>KeySetView<K,Boolean>CollectionView<K,Boolean,K>newKeySetnewKeySet(int)newKeySet()mappingCountmappingCount()Enumeration<ContactInfo>replaceNodereplaceNode(java.lang.Object,java.lang.Object,java.lang.Object)putVal(java.lang.Object,java.lang.Object,boolean)putVal(com.sun.corba.se.pept.transport.ContactInfo,java.lang.Object,boolean)ConcurrentHashMapConcurrentHashMap(int,float,int)ConcurrentHashMap<ContactInfo,Object>(int,float,int)ConcurrentHashMap(int,float)ConcurrentHashMap<ContactInfo,Object>(int,float)ConcurrentHashMap(java.util.Map)ConcurrentHashMap<ContactInfo,Object>(java.util.Map)ConcurrentHashMap(int)ConcurrentHashMap<ContactInfo,Object>(int)ConcurrentHashMap()setTabAtsetTabAt(java.util.concurrent.ConcurrentHashMap.Node[],int,java.util.concurrent.ConcurrentHashMap.Node)casTabAtcasTabAt(java.util.concurrent.ConcurrentHashMap.Node[],int,java.util.concurrent.ConcurrentHashMap.Node,java.util.concurrent.ConcurrentHashMap.Node)tabAttabAt(java.util.concurrent.ConcurrentHashMap.Node[],int)spreadspread(int)NCPUHASH_BITSRESERVEDTREEBINMOVEDMAX_ARRAY_SIZEopNameisOneWay".beginRequest->: op/".beginRequest->: op/newLock".beginRequest: op/".beginRequest: op/": Using cached connection: ": Using cached connection: ": Using created connection: ": Using created connection: retry": failed to create connection: ": failed to create connection: "ESTABLISHED"ESTABLISHED".beginRequest: ".beginRequest: ": created message mediator: ": created message mediator: ": created output object: ": created output object: ": Remarshal": Remarshal"RemarshalException: hasNext true\ncontact info "RemarshalException: hasNext true
contact info "RemarshalException: hasNext false"RemarshalException: hasNext false": initialized message": initialized message".beginRequest<-: op/".beginRequest<-: op/".marshalingComplete->: ".marshalingComplete->: ".marshalingComplete<-: ".marshalingComplete<-: ".marshalingComplete: ".marshalingComplete: ": finished sending request": finished sending request": exception: ": exception: ".processResponse: ".processResponse: ": response received": response receiveddoRemarshal": received system exception: ": received system exception: uscunknownueexceptionRepoId": received user exception": received user exception": received location forward": received location forward": received different addressing dispostion request": received different addressing dispostion request": received normal response": received normal response".continueOrThrowSystemOrRemarshal: ".continueOrThrowSystemOrRemarshal: ": throwing Remarshal": throwing Remarshal": throwing sex:": throwing sex:ovscscscctxtssctd"----------BEGIN server-side stack trace----------\n"----------BEGIN server-side stack trace----------
"\n"
            + "----------END server-side stack trace----------"
----------END server-side stack trace----------".endRequest->".endRequest->".endRequest: ignoring IOException - ".endRequest: ignoring IOException - ".endRequest<-".endRequest<-serverCodeSetsctxscodeSetCtxcssccdrInputObject"CorbaClientRequestDispatcherImpl"CorbaClientRequestDispatcherImplClientDelegate is the RMI client-side subcontract or representationIt implements RMI delegate as well as our internal ClientRequestDispatcherinterface. Portable Interceptor initialization. Connection. This locking is done so that multiple connections are not created for the same endpoint 7046238 - Synchronization on a single monitor for contactInfo parameters with identical hashCode(), so we lock on same monitor for equal parameters (which can refer to equal (in terms of equals()) but not the same objects) REVISIT: this part similar to marshalingComplete below. this part similar to Remarshal in this method below REVISIT: cast Do not do connection reclaim here since the connections are marked in use by registerWaiter() call and since this call happens later do it after that.              connectionCache.reclaim(); NOTE: Thread data so we can get the mediator in release reply in order to remove the waiter in CorbaConnection. We cannot depend on obtaining information in releaseReply via its InputStream argument since, on certain errors (e.g., client marshaling errors), the stream may be null. Likewise for releaseReply "self". NOTE: This must be done before initializing the message since that may start sending fragments which may end up in "early" replies or client marshaling exceptions. NOTE: Not necessary for oneways, but useful for debugging. This must be done BEFORE message initialization since fragments may be sent at that time. Do connection reclaim now This MUST come before message is initialized so service contexts may be added by PI because initial fragments may be sent during message initialization. NOTE: We get here because an interceptor raised ForwardRequest and updated the IOR/Iterator.  Since we have a fresh iterator hasNext should succeed. REVISIT: We should feed ALL interceptor exceptions to iterator.reportException so it can determine if it wants to retry.  Right now, SystemExceptions will flow to the client code. This assumes that interceptors update ContactInfoList outside of subcontract. Want to move that update to here. Fix for 6763340: Complete the first attempt before starting another.Bug 6382377: must not lose exception in PI Must run interceptor end point before retrying. NOTE: Interceptor ending point will run in releaseReply. for compiler We know for sure now that we've sent a message. So OK to not send initial again. NOTE: not necessary to set MessageMediator for PI. It already has it. Process the response. Invoke Portable Interceptors with receive_other Now that we have the service contexts processed and the correct ORBVersion set, we must finish initializing the stream. REVISIT - need interface for this operation. Invoke Portable Interceptors with receive_exception: If PI did not change the exception, throw a Remarshal. exception = null is to maintain symmetry with GenericPOAClientSC.  Otherwise, throw the exception PI wants thrown. No retry, so see if was unknown. It was not a comm failure nor unknown. This is the general case. Note: We should never need to execute this line, but we should assert in case exception is null somehow. For DII: This return will be ignored - already unmarshaled above. NOTE: Expects iterator to update target IOR Invoke Portable Interceptors with receive_other: If PI did not change exception, throw Remarshal, else throw the exception PI wants thrown. KMC: GenericPOAClientSC did not check exception != null Set the desired target addressing disposition. For consistency with corresponding code in GenericPOAClientSC: KMC: GenericPOAClientSC did not include exception != null checknormal response Invoke Portable Interceptors with receive_reply: Remember: not thrown if exception is null. Filters the given exception into a SystemException or a RemarshalException and throws it.  Assumes the given exception is of one of these two types.  This is a utility method for the above invoke code which must do this numerous times. If the exception is null, no exception is thrown. Note that this code is duplicated in GenericPOAClientSC.java do nothing. REVISIT - unify with PI handling NOTE - We must unregister the waiter NOW for this request since the retry will result in a new request id.  Therefore the old request id would be lost and we would have a memory leak in the responseWaitingRoom. The messageMediator may be null if COMM_FAILURE before it is created. Add the RMI-IIOP max stream format version service context to every request.  Once we have GIOP 1.3, we could skip it since we now support version 2, but probably safer to always send it. ORBVersion servicecontext needs to be sent NOTE : We only want to send the runtime context the first time Do not do c.setPostInitialContexts() here. If a client interceptor send_request does a ForwardRequest which ends up using the same connection then the service context would not be sent. no service context available, return gracefully. set the codebase returned by the server see if the version subcontract is present, if yes, then set the ORBversion Note: the inputObject may be null if an error occurs       in request or before _invoke returns. Note: self may be null also (e.g., compiler generates null in stub). Release any outstanding NIO ByteBuffers to the ByteBufferPool XREVISIT NOTE - Assumes unregistering the waiter for location forwards has already happened somewhere else. The code below is only going to unregister the final successful request. NOTE: In the case of a recursive stack of endRequests in a finally block (because of Remarshal) only the first call to unregisterWaiter will remove the waiter.  The rest will be noops. Invoke Portable Interceptors cleanup.  This is done to handle exceptions during stream marshaling.  More generally, exceptions that occur in the ORB after send_request (which includes after returning from _request) before _invoke: REVISIT: Early replies? See CDRInput/OutputObject.close() for more info. This won't result in a Corba error if an IOException happens. XXX This seems to be a broken double checked locking idiom: FIX IT! conn.getCodeSetContext() is null when no other requests have been made on this connection to trigger code set negotation. Double checking.  Don't let any other threads use this connection until the code sets are straight. This only looks at the first code set component.  If there can be multiple locations with multiple code sets, this requires more work. Didn't have a code set component.  The default will be to use ISO8859-1 for char data and throw an exception if wchar data is used. Get the native and conversion code sets the server specified in its IOR Perform the negotiation between this ORB's code sets and the ones from the IOR REVISIT.  OMG issue 3318 concerning sending the code set service context more than once was deemed too much for the RTF.  Here's our strategy for the moment: Send it on every request (necessary in cases of fragmentation with multithreaded clients or when the first thing on a connection is a LocateRequest).  Provide an ORB property to disable multiple sends. Note that the connection is null in the local case and no service context is included.  We use the ORB provided encapsulation streams. Also, there will be no negotiation or service context in GIOP 1.0.  ISO8859-1 is used for char/string, and wchar/wstring are illegal. Get the negotiated code sets (if any) out of the connection Either we shouldn't send the code set service context, or for some reason, the connection doesn't have its code sets. Perhaps the server didn't include them in the IOR.  Uses ISO8859-1 for char and makes wchar/wstring illegal. REVISIT - need interface for mark/reset/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/protocol/CorbaInvocationInfo.javaCorbaInvocationInfoCorbaInvocationInfo()/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/protocol/CorbaInvocationInfo.classclientRequestDispatcherisRetryInvocation REVISIT - these needs to be an interface-based impl./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/protocol/CorbaMessageMediatorImpl.javareleaseByteBufferToPoolreleaseByteBufferToPool()/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/protocol/CorbaMessageMediatorImpl.classaddExceptionDetailMessageaddExceptionDetailMessage(com.sun.corba.se.spi.protocol.CorbaMessageMediator,org.omg.CORBA.SystemException,com.sun.corba.se.spi.servicecontext.ServiceContexts)createAppropriateOutputObjectcreateAppropriateOutputObject(com.sun.corba.se.spi.protocol.CorbaMessageMediator,com.sun.corba.se.impl.protocol.giopmsgheaders.Message,com.sun.corba.se.impl.protocol.giopmsgheaders.LocateReplyMessage)endRequestendRequest(com.sun.corba.se.spi.protocol.CorbaMessageMediator)sendResponsesendResponse(com.sun.corba.se.spi.protocol.CorbaMessageMediator)dispatchErrordispatchError(com.sun.corba.se.spi.protocol.CorbaMessageMediator,java.lang.String,java.lang.Throwable)beginRequestbeginRequest(com.sun.corba.se.spi.protocol.CorbaMessageMediator)processCancelRequestprocessCancelRequest(int)transportDebugtransportDebug()dprint(java.lang.String,java.lang.Throwable)throwNotImplementedthrowNotImplemented(java.lang.String)throwNotImplemented()signalResponseReceivedsignalResponseReceived()setInputObjectsetInputObject()resumeSelectresumeSelect(com.sun.corba.se.impl.protocol.giopmsgheaders.Message)setWorkThenReadOrResumeSelectsetWorkThenReadOrResumeSelect(com.sun.corba.se.impl.protocol.giopmsgheaders.Message)setWorkThenPoolOrResumeSelectsetWorkThenPoolOrResumeSelect(com.sun.corba.se.impl.protocol.giopmsgheaders.Message)getStreamFormatVersionForThisRequestgetStreamFormatVersionForThisRequest(com.sun.corba.se.spi.ior.IOR,com.sun.corba.se.spi.ior.iiop.GIOPVersion)addrDispositiondispatchHeader".sendCancelRequestIfFinalFragmentNotSent->: ".sendCancelRequestIfFinalFragmentNotSent->: ".sendCancelRequestIfFinalFragmentNotSent: !ERROR : ".sendCancelRequestIfFinalFragmentNotSent: !ERROR : ".sendCancelRequestIfFinalFragmentNotSent<-: ".sendCancelRequestIfFinalFragmentNotSent<-: repoIdeanypoolToUsesvcmsfvsclocalMaxVersionremoteMaxVersionprotocolHandlereventHandler"?"".resumeSelect:->".resumeSelect:->".resumeSelect: id/".resumeSelect: id/".resumeSelect:<-".resumeSelect:<-"CorbaMessageMediatorImpl.setInputObject"CorbaMessageMediatorImpl.setInputObject".handleInput->: ".handleInput->: ".handleInput: CloseConnection: purging".handleInput: CloseConnection: purging".handleInput: MessageError: purging".handleInput: MessageError: purging".handleInput: ERROR: ".handleInput: ERROR: ".handleInput<-: ".handleInput<-: ".REQUEST 1.0->: ".REQUEST 1.0->: ".REQUEST 1.0: !!ERROR!!: ".REQUEST 1.0: !!ERROR!!: ".REQUEST 1.0<-: ".REQUEST 1.0<-: ".REQUEST 1.1->: ".REQUEST 1.1->: ".REQUEST 1.1: !!ERROR!!: ".REQUEST 1.1: !!ERROR!!: ".REQUEST 1.1<-: ".REQUEST 1.1<-: ".REQUEST 1.2->: id/".REQUEST 1.2->: id/".REQUEST 1.2: id/".REQUEST 1.2: id/": !!ERROR!!: ": !!ERROR!!: ".REQUEST 1.2<-: id/".REQUEST 1.2<-: id/".REPLY 1.0->: ".REPLY 1.0->: ".REPLY 1.0: !!ERROR!!: ".REPLY 1.0: !!ERROR!!: ".REPLY 1.0<-: ".REPLY 1.0<-: ".REPLY 1.1->: ".REPLY 1.1->: ".REPLY 1.1: !!ERROR!!: ".REPLY 1.1: !!ERROR!!: ".REPLY 1.1<-: ".REPLY 1.1<-: ".REPLY 1.2->: id/".REPLY 1.2->: id/": more?: ": more?: ".REPLY 1.2: id/".REPLY 1.2: id/".REPLY 1.2<-: id/".REPLY 1.2<-: id/".LOCATE_REQUEST 1.0->: ".LOCATE_REQUEST 1.0->: ".LOCATE_REQUEST 1.0: !!ERROR!!: ".LOCATE_REQUEST 1.0: !!ERROR!!: ".LOCATE_REQUEST 1.0<-: ".LOCATE_REQUEST 1.0<-: ".LOCATE_REQUEST 1.1->: ".LOCATE_REQUEST 1.1->: ".LOCATE_REQUEST 1.1: !!ERROR!!: ".LOCATE_REQUEST 1.1: !!ERROR!!: ".LOCATE_REQUEST 1.1<-:".LOCATE_REQUEST 1.1<-:".LOCATE_REQUEST 1.2->: id/".LOCATE_REQUEST 1.2->: id/".LOCATE_REQUEST 1.2: id/".LOCATE_REQUEST 1.2: id/".LOCATE_REQUEST 1.2<-: id/".LOCATE_REQUEST 1.2<-: id/".LOCATE_REPLY 1.0->:".LOCATE_REPLY 1.0->:".LOCATE_REPLY 1.0: !!ERROR!!: ".LOCATE_REPLY 1.0: !!ERROR!!: ".LOCATE_REPLY 1.0<-: ".LOCATE_REPLY 1.0<-: ".LOCATE_REPLY 1.1->: ".LOCATE_REPLY 1.1->: ".LOCATE_REPLY 1.1: !!ERROR!!: ".LOCATE_REPLY 1.1: !!ERROR!!: ".LOCATE_REPLY 1.1<-: ".LOCATE_REPLY 1.1<-: ".LOCATE_REPLY 1.2->: id/".LOCATE_REPLY 1.2->: id/".LOCATE_REPLY 1.2: id/".LOCATE_REPLY 1.2: id/".LOCATE_REPLY 1.2<-: id/".LOCATE_REPLY 1.2<-: id/".FRAGMENT 1.1->: "
                       + "more?: ".FRAGMENT 1.1->: more?: ".FRAGMENT 1.1: ++++DISCARDING++++: ".FRAGMENT 1.1: ++++DISCARDING++++: ".FRAGMENT 1.1: !!ERROR!!: ".FRAGMENT 1.1: !!ERROR!!: ".FRAGMENT 1.1<-: ".FRAGMENT 1.1<-: ".FRAGMENT 1.2->: id/".FRAGMENT 1.2->: id/".FRAGMENT 1.2: id/".FRAGMENT 1.2: id/": ++++DISCARDING++++: ": ++++DISCARDING++++: ".FRAGMENT 1.2<-: id/".FRAGMENT 1.2<-: id/".CANCEL->: id/".CANCEL->: id/".CANCEL: id/".CANCEL: id/".CANCEL<-: id/".CANCEL<-: id/"CorbaMessageMediatorImpl: not implemented "CorbaMessageMediatorImpl: not implemented "CorbaMessageMediatorImpl"CorbaMessageMediatorImpl"RequestMessage"RequestMessage"LocateRequestMessage"LocateRequestMessage".handleRequest->:".handleRequest->:".handleRequest: ".handleRequest: ": sending response": sending response".handleRequest<-: ".handleRequest<-: ".endRequest: IOException:".endRequest: IOException:": dispatching to scid: ": dispatching to scid: ": dispatching to sc: ": dispatching to sc: addrDispthrowablecompletionStatus".handleThrowableDuringServerDispatch: ".handleThrowableDuringServerDispatch: iteration"handleThrowableDuringServerDispatch: " +
                                     "cannot create response."handleThrowableDuringServerDispatch: cannot create response.": cannot handle: ": cannot handle: sexfexthrowable2replyHeaderlocateReplyHeadersysueiexistingOutputObject".createSystemExceptionResponse: ".createSystemExceptionResponse: baospwencapsOutputStreamserviceContextuserreplyOutputObject".createResponseHelper: ".createResponseHelper: ese".getServiceContextsForReply: ".getServiceContextsForReply: ": added SendingContextServiceContext": added SendingContextServiceContext": added ORB version service context": added ORB version service contextbbId".handleInput: releasing ByteBuffer (".handleInput: releasing ByteBuffer (") to ByteBufferPool") to ByteBufferPool REVISIT: make sure no memory leaks in client/server request/reply maps. REVISIT: normalize requestHeader, replyHeader, messageHeader. Client-side constructor. Acceptor constructor. Dispatcher constructor. Note: in some cases (e.g., a reply message) this message mediator will only be used for dispatch.  Then the original request side mediator will take over. MessageMediator REVISIT: probably move logic in outputObject to here. CorbaMessageMediator REVISIT - need separate field? Case: first a location forward, then a marshaling exception (e.g., non-serializable object).  Only send cancel once. REVISIT: we could attempt to send a final incomplete fragment in this case. Find the typecode for the exception Since we dont have the actual user exception class, the spec says we have to create an UnknownUserException and put it in the environment. must be a truly unknown exception A null msg should never happen. But, we'll be defensive just in case. REVISIT: ContactInfo/Acceptor output object factories just use this.  Maybe need to distinguish:    createOutputObjectForRequest    createOutputObjectForReply then do getStreamFormatVersionForRequest/ForReply here.If the RMI-IIOP maximum stream format version service contextis present, it indicates the maximum stream format version wecould use for the reply.  If it isn't present, the default is2 for GIOP 1.3 or greater, 1 for lower.This is only sent on requests.  Clients can find out theserver's maximum by looking for a tagged component in the IOR. NOTE: The request service contexts may indicate the max. Defaults to 1 for GIOP 1.2 or less, 2 for GIOP 1.3 or higher.return replyHeader.getReplyStatus() == ReplyMessage.LOCATION_FORWARD; Used by server side. REVISIT: should look up in orb registry. ResponseHandler Note: relies on side-effect of setting mediator output field. REVISIT - cast - need interface Didn't have the max stream format version tagged component. REVISIT - This could be a separate implementation object looked up in a registry.  However it needs some state in the message mediator so combine for now. pept.protocol.ProtocolHandler REVISIT - this should be handled internally. iiop.messages.MessageHandler Leader/Follower when using reader thread. When this thread is done working it will go back in pool. First unregister current registration. Have another thread become the reader. When using reader thread then wen this thread is done working it will continue reading. NOTE: VERY IMPORTANT: Only participate in select after getting to the point that proper serialization of fragments is ensured. REVISIT: not-OO: IMPORTANT: To avoid bug (4953599), we force the Thread that does the NIO select to also do the enable/disable of Ops using SelectionKey.interestOps(Ops of Interest). Otherwise, the SelectionKey.interestOps(Ops of Interest) may block indefinitely in this thread. REVISIT: refactor createInputObject (and createMessageMediator) into base PlugInFactory.  Get via connection (either ContactInfo or Acceptor). This will end up using the MessageMediator associated with the original request instead of the current mediator (which need to be constructed to hold the dispatchBuffer and connection). This handles message types for which we don't create classes. Mask the exception from thread.; REVISIT: this is identical to 1_0 except for fragment part. NOTE: in the old code this used to be done conditionally: if (header.moreFragmentsToFollow()). Now we always put it in. We take it out when the response is done. This must happen now so if a header is fragmented the stream may be found. Leader/Follower. Note: This *MUST* come after putting stream in above map since the header may be fragmented and you do not want to start reading again until the map above is set.inputObject.unmarshalHeader(); // done in subcontract. REVISIT: this should be done by waiting thread. More fragments are coming to complete this reply, so keep a reference to the InputStream so we can add the fragments In 1.1, we can't assume that we have the request ID in the first fragment.  Thus, another thread is used to be the reader while this thread unmarshals the extended header and wakes up the client thread. REVISIT - error handling. This must be done now. Not fragmented, therefore we know the request ID is here.  Thus, we can unmarshal the extended header and wake up the client thread without using a third thread as above. REVISIT - error handling during unmarshal. This must be done now to get the request id. We know that the request ID is in the first fragment REVISIT Put in subcontract. Fragmented LocateReplies are not allowed in 1.1. No need to put in client reply map - already there. If no input stream available, then discard the fragment. This can happen: 1. if a fragment message is received prior to receiving    the original request/reply message. Very unlikely. 2. if a fragment message is received after the    reply has been sent (early replies) Note: In the case of early replies, the fragments received during the request processing (which are never unmarshaled), will eventually be discarded by the GC. need to release dispatchByteBuffer to pool if we are discarding NOTE: This *must* come after queing the fragment when using the selector to ensure fragments stay in order. Note:  We know it's a 1.2 fragment, we have the data, but we need the IIOPInputStream instance to unmarshal the request ID... but we need the request ID to get the IIOPInputStream instance. So we peek at the raw bytes. See 1.1 comments. REVISIT: but if it is a server don't you have to remove the stream from the map?No need to do anything.Should we mark that last was received?if (! header.moreFragmentsToFollow()) {// Last fragment. REVISIT: Move these two to subcontract. REVISIT: move this to subcontract (but both client and server need it). The GIOP version of CancelRequest does not matter, since CancelRequest_1_0 could be sent to cancel a request which has a different GIOP version.CancelRequest processing logic :- find the request with matching requestId- call cancelProcessing() in BufferManagerRead [BMR]- the hope is that worker thread would call BMR.underflow()to wait for more fragments to come in. When BMR.underflow() iscalled, if a CancelRequest had already arrived,the worker thread would throw ThreadDeath,else the thread would wait to be notified of thearrival of a new fragment or CancelRequest. Upon notification,the woken up thread would check to see if a CancelRequest hadarrived and if so throw a ThreadDeath or it will continue toprocess the received fragment.- if all the fragments had been received prior to CancelRequestthen the worker thread would never block in BMR.underflow().So, setting the abort flag in BMR has no effect. The requestprocessing will complete normally.- in the case where the server has received enough fragments tostart processing the request and the server sends outan early reply. In such a case if the CancelRequest arrivesafter the reply has been sent, it has no effect. we do not support bi-directional giop yet, ignore. Try to get hold of the InputStream buffer. In the case of 1.0 requests there is no way to get hold of InputStream. Try out the 1.1 and 1.2 cases. was the request 1.2 ? was the request 1.1 ? XXX log this! either the request was 1.0 or an early reply has already been sent or request processing is over or its a spurious CancelRequest A spurious 1.1 CancelRequest has been received. special case this means that 1. the 1.1 requests' requestId has not been received    i.e., a CancelRequest was received even before the    1.1 request was received. The spec disallows this. 2. or the 1.1 request has a requestId 0. It is a little tricky to distinguish these two. So, be conservative and do not cancel the request. Downside is that 1.1 requests with requestId of 0 will never be cancelled. Any mediator obtained here should only ever be for a GIOP At this point we have a valid message mediator that contains a valid requestId. at this point we have chosen a request to be cancelled. But we do not know if the target object's method has been invoked or not. Request input stream being available simply means that the request processing is not over yet. simply set the abort flag in the BMRS and hope that the worker thread would notice it (this can happen only if the request stream is being unmarshalled and the target's method has not been invoked yet). This guarantees that the requests which have been dispatched to the target's method will never be cancelled. spi.protocol.CorbaProtocolHandler REVISIT - this makes hcks sendTwoObjects fail messageMediator.getConnection().close(); REVISIT - type and location REVISIT - can be null for TRANSIENT below. release NIO ByteBuffers to ByteBufferPool Given what close() does, this catch shouldn't ever happen. It also won't result in a Corba error if an IOException happens. Does nothing if already unmarshaled. This is necessary so mediator can act as ResponseHandler and pass necessary info to response constructors located in the subcontract. REVISIT - same class right now.messageMediator.setProtocolHandler(this); REVISIT: Should we catch SystemExceptions? create a response containing the expected target addressing disposition. no need to send reply REVISIT If exception is not OBJECT_NOT_EXIST, it should have a different reply This handles OBJECT_NOT_EXIST exceptions thrown in the subcontract or obj manager. Send back UNKNOWN_OBJECT. outputObject.setMessage(reply); // REVISIT - not necessary locate msgs 1.0 & 1.1 :=> grow, 1.2 :=> stream If we haven't unmarshaled the header, we probably don't have enough information to even send back a reply. Cannot do this check.  When target addressing disposition does not match (during header unmarshaling) it throws an exception to be handled here.if (! ((CDRInputObject)messageMediator.getInputObject()).unmarshaledHeader()) { REVISIT - catch and ignore RequestCanceledException. REVISIT - should we close connection? Else. User code (e.g., postinvoke, interceptors) may change the exception, so we end up back here. Report the changed exception. Reporting an exception response causes the poa current stack, the interceptor stacks, etc. to be balanced.  It also notifies interceptors that the request was cancelled. NOTE: We do not trap ThreadDeath above Throwable. There is no reason to stop the thread.  It is just a worker thread.  The ORB never throws ThreadDeath.  Client code may (e.g., in ServantManagers, interceptors, or servants) but that should not effect the ORB threads.  So it is just handled generically. Last resort. If user code throws a non-SystemException report it generically. from iiop.RequestProcessor. Respond with expected target addressing disposition. REVISIT: via acceptor factory. REVISIT: ignore service contexts during framework transition. They are set in SubcontractResponseHandler to the wrong connection. Then they would be set again here and a duplicate contexts exception occurs. REVISIT - same as above NOTE: This service context container gets augmented in tail call. It is possible that fragments of response have already been sent.  Then an error may occur (e.g. marshaling error like non serializable object).  In that case it is too late to send the exception.  We just return the existing fragmented stream here.  This will cause an incomplete last fragment to be sent.  Then the other side will get a marshaling error when attempting to unmarshal. REVISIT: Impl - make interface method to do the following. REVISIT: need to think about messageMediator containing correct pointer to output object. Only do this if interceptors have been initialized on this request and have not completed their lifecycle (otherwise the info stack may be empty or have a different request's entry on top). REVISIT: not necessary in framework now? Inform Portable Interceptors of the SystemException.  This is required to be done here because the ending interception point is called in the when creating the response below but we do not currently write the SystemException into the response until after the ending point is called. NOTE: We MUST add the service context before creating the response since service contexts are written to the stream when the response object is created. NOTE: From here on, it is too late to add more service contexts. They have already been serialized to the stream (and maybe fragments sent). NOTE: you must flush or baos will be empty. REVISIT - IOR arg is ignored. REVISIT - these should be invoked from subcontract. REVISIT = do not use null. REVISIT - not necessary?messageMediator.this.replyIOR = reply.getIOR(); NOTE: The mediator holds onto output object so return value not really necessary. Run ServantLocator::postinvoke.  This may cause a SystemException which will throw out of the constructor and return later to construct a reply for that exception.  The internal logic of returnServant makes sure that postinvoke is only called once. REVISIT: instead of instanceof, put method on all orbs. This flag is to deal with BootstrapServer use of reply streams, with ServerRequestDispatcher's use of reply streams, etc. It is possible to get marshaling errors in the skeleton after postinvoke has completed.  We must set this to false so that when the error exception reply is constructed we don't try to incorrectly access poa current (which will be the wrong one or an empty stack. Invoke server request ending interception points (send_*): Note: this may end up with a SystemException or an internal Runtime ForwardRequest Note this will be executed even if a ForwardRequest or SystemException is thrown by a Portable Interceptors ending point since we end up in this constructor again anyway. See createSystemExceptionResponse for why this is necesary. Once you get here then the final reply is available (i.e., postinvoke and interceptors have completed. send ORBVersion servicecontext as part of the Reply REVISIT - this method should be migrated to orbutil.ORBUtility           since all locations that release ByteBuffers use           very similar logic and debug information./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/protocol/CorbaServerRequestDispatcherImpl.javafindObjectAdapterfindObjectAdapter(com.sun.corba.se.spi.ior.ObjectKeyTemplate)/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/protocol/CorbaServerRequestDispatcherImpl.classgetServant(com.sun.corba.se.spi.oa.ObjectAdapter,byte[],java.lang.String)releaseServant(com.sun.corba.se.spi.oa.ObjectAdapter)poaWrapper".locate->".locate->".locate<-".locate<-".dispatch->: ".dispatch->: ".dispatch: ".dispatch: ": bad server id": bad server id": ForwardException caught": ForwardException caught": OADestroyed exception caught": OADestroyed exception caught": RequestCanceledException caught": RequestCanceledException caught": UnknownException caught ": UnknownException caught ": other exception ": other exception ".dispatch<-: ".dispatch<-: ".releaseServant->".releaseServant->".releaseServant: null object adapter".releaseServant: null object adapter".releaseServant<-".releaseServant<-".getServant->".getServant->".getServant<-".getServant<-mdi"unknown"".getServantWithPI->".getServantWithPI->".getServantWithPI<-".getServantWithPI<-sId".checkServerId->".checkServerId->".checkServerId: bad server id".checkServerId: bad server id".checkServerId<-".checkServerId<-".findObjectAdapter->".findObjectAdapter->".findObjectAdapter: failed to find ObjectAdapterFactory".findObjectAdapter: failed to find ObjectAdapterFactory".findObjectAdapter: failed to find ObjectAdaptor".findObjectAdapter: failed to find ObjectAdaptor".findObjectAdapter<-".findObjectAdapter<-nservspecialMethod".handleNullServant->: ".handleNullServant->: ".handleNullServant: ".handleNullServant: ": throwing OBJECT_NOT_EXIST": throwing OBJECT_NOT_EXIST".handleNullServant<-: ".handleNullServant<-: hasCodeSetContextisForeignORB".consumeServiceContexts->: ".consumeServiceContexts->: ".consumeServiceContexts: ".consumeServiceContexts: ": GIOP version: ": GIOP version: ": as code set context? ": as code set context? ".consumeServiceCOntexts: ".consumeServiceCOntexts: ": Determined to be an old Sun ORB": Determined to be an old Sun ORB": Determined to be a foreign ORB": Determined to be a foreign ORB".consumeServiceContexts<-: ".consumeServiceContexts<-: ".dispatchToServant->: ".dispatchToServant->: ".dispatchToServant: ".dispatchToServant: ": Handling special method": Handling special methoddynimplsreq": Handling old style DSI type servant": Handling old style DSI type servant": Handling POA DSI type servant": Handling POA DSI type servantinvhandle": Handling invoke handler type servant": Handling invoke handler type servant".dispatchToServant<-: ".dispatchToServant<-: excany".handleDynamicResult->: ".handleDynamicResult->: ".handleDynamicResult: ".handleDynamicResult: ": handling normal result": handling normal result": handling error": handling error".handleDynamicResult<-: ".handleDynamicResult<-: ".sendingReply->: ".sendingReply->: ".sendingReply<-: ".sendingReply<-: resp".sendingReply/Any->: ".sendingReply/Any->: ".sendingReply/Any: ".sendingReply/Any: ": handling system exception": handling system exception": handling user exception": handling user exception".sendingReply/Any<-: ".sendingReply/Any<-: ".processCodeSetContext->: ".processCodeSetContext->: csctx".processCodeSetContext: ".processCodeSetContext: ": Setting code sets to: ": Setting code sets to: ".processCodeSetContext<-: ".processCodeSetContext<-: "CorbaServerRequestDispatcherImpl"CorbaServerRequestDispatcherImpl my ORB instance Added from last version because it broke the build - RTW XXX remove me and rebuild: probably no longer needed public static final int UNKNOWN_EXCEPTION_INFO_ID = 9;XXX/REVISIT:We do not want to look for a servant in the POA/ServantManager case,but we could in most other cases.  The OA could have a method thatreturns true if the servant MAY exist, and false only if the servantdefinitely DOES NOT exist.We may wish to indicate OBJECT_HERE by some mechanism other thanreturning a null result.Called from ORB.locate when a LocateRequest arrives.Result is not always absolutely correct: may indicate OBJECT_HEREfor non-existent objects, which is resolved on invocation.  This"bug" is unavoidable, since in general the object may be destroyedbetween a locate and a request.  Note that this only checks thatthe appropriate ObjectAdapter is available, not that the servantactually exists.Need to signal one of OBJECT_HERE, OBJECT_FORWARD, OBJECT_NOT_EXIST.Result is null if object is (possibly) implemented here, otherwisean IOR indicating objref to forward the request to.OBJECT_NOT_EXISTis thrown if we know the object does notexist here, and we are not forwarding. Called only for its side-effect of throwing appropriate exceptions to set the codebase information, if any transmitted; and also appropriate ORB Version. correct ORBVersion set, we must finish initializing the stream. Check that this server is the right server Thrown by Portable Interceptors from InterceptorInvoker, through Response constructor. DO NOT CALL THIS HERE: releaseServant(objectAdapter); The problem is that OADestroyed is only thrown by oa.enter, in which case oa.exit should NOT be called, and neither should the invocationInfo stack be popped. Destroyed POAs can be recreated by normal adapter activation. So just restart the dispatch. IDLJ generated non-tie based skeletons do not catch the RequestCanceledException. Rethrow the exception, which will cause the worker thread to unwind the dispatch and wait for other requests. RMIC generated tie skeletons convert all Throwable exception types (including RequestCanceledException, ThreadDeath) thrown during reading fragments into UnknownException. If RequestCanceledException was indeed raised, then rethrow it, which will eventually cause the worker thread to unstack the dispatch and wait for other requests. Note that objectAdapter.enter() must be called before getServant. Prepare Portable Interceptors for a new server request and invoke receive_request_service_contexts.  The starting point may throw a SystemException or ForwardException. This must be set just after the enter so that exceptions thrown by enter do not cause the exception reply to pop the thread stack and do an extra oa.exit. Note: we do not know the MDI on a null servant. We only end up in that situation if _non_existent called, so that the following handleNullServant call does not throw anAlways throws OBJECT_NOT_EXIST if operation is not a special method.If operation is _non_existent or _not_existent, this will justreturn without performing any action, so that _non_existent can returnfalse.  Always throws OBJECT_NOT_EXIST for any other special method.Update for issue 4385. we cannot depend on this since for our local case, we do not send in this service context.  Can we rely on just the CodeSetServiceContext? boolean rtSC = false; // Runtime ServiceContext the RTSC is sent only once during session establishment.  We need to find out if the CodeBaseRef is already set.  If yes, then also the rtSC flag needs to be set to true this is not possible for the LocalCase since there is no IIOPConnection for the LocalCase used for a case where we have JDK 1.3 supporting 1.0 protocol, but sending 2 service contexts, that is not normal as per GIOP rules, based on above information, we figure out that we are talking to the legacy ORB and set the ORB Version Accordingly. this special case tell us that it is legacy SUN orb and not a foreign one rtSC is not available for localcase due to which this generic path would fail if relying on rtSCif (giopVersion.equals(GIOPVersion.V1_0) && hasCodeSetContext && rtSC) System.out.println("setting legacy ORB version"); If it didn't include our ORB version service context (below), then it must be a foreign ORB. try to get the ORBVersion sent as part of the ServiceContext if any Invoke on the servant using the portable DSI skeleton Note: When/if dynimpl.invoke calls arguments() or set_exception() then intermediate points are run. Check if ServerRequestImpl.result() has been called normal return Marshal out/inout/return parameters into the ReplyMessageMust always be called, just after the servant's method returns.Creates the ReplyMessage header and puts in the transaction contextif necessary. Check if the servant set a SystemException or UserException Get the exception object from the Any Marshal the exception backHandles setting the connection's code sets if required.Returns true if the CodeSetContext was in the request, false Somehow a code set service context showed up in the local case. If it's GIOP 1.0, it shouldn't have this context at all.  Our legacy ORBs sent it and we need to know if it's here to make ORB versioning decisions, but we don't use the contents. Note on threading: getCodeSetContext and setCodeSetContext are synchronized on the Connection.  At worst, this will result in multiple threads entering this block and calling setCodeSetContext but not actually changing the values on the Connection. Alternative would be to lock the connection for the whole block, but it's fine either way. The connection's codeSetContext is null until we've received a request with a code set context with the negotiated code sets. Use these code sets on this connection We had to read the method name using ISO 8859-1 (which is the default in the CDRInputStream for char data), but now we may have a new char code set.  If it isn't ISO8859-1, we must tell the CDR stream to null any converter references it has created so that it will reacquire the code sets again using the new info. This should probably compare with the stream's char code set rather than assuming it's ISO8859-1. (However, the operation name is almost certainly ISO8859-1 or ASCII.) If no code set information is ever sent from the client, the server will use ISO8859-1 for char and throw an exception for any wchar transmissions. In the local case, we use ORB provided streams for marshaling and unmarshaling.  Currently, they use ISO8859-1 for char/string and UTF16 for wchar/wstring./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/protocol/FullServantCacheLocalCRDImpl.javacachedInfopdesservantobj Note that info is shared across multiple threads using the same subcontract, each of which may have its own operation.  Therefore we need to clone it./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/protocol/INSServerRequestDispatcher.javagetINSReferencegetINSReference(java.lang.String)/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/protocol/INSServerRequestDispatcher.classinsKeyINSServerRequestDispatcher handles all INS related discovery request. The INS Servicecan be registered using ORB.register_initial_reference().This Singleton subcontract justfinds the target IOR and does location forward.XXX PI points are not invoked in either dispatch() or locate() method thisshould be fixed in Tiger. Need to signal one of OBJECT_HERE, OBJECT_FORWARD, OBJECT_NOT_EXIST. send a locate forward with the right IOR. If the insKey is not registered then it will throw OBJECT_NOT_EXIST ExceptiongetINSReference if it is registered in INSObjectKeyMap. If entry is not null then the locate is with an INS Object key, so send a location forward with the right IOR./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/protocol/InfoOnlyServantCacheLocalCRDImpl.java have its own operation.  Therefore we need to copy it./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/protocol/JIDLLocalCRDImpl.java REVISIT - This is called from TOAImpl. DO NOT set the IOR to null.  (Un)exporting is only concerns the servant not the IOR.  If the ior is set to null then null pointer exceptions happen during an colocated invocation. It is better to let the invocation proceed and get OBJECT_NOT_EXIST from the server side.ior = null;/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/protocol/LocalClientRequestDispatcherBase.javaisNextCallValid/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/protocol/LocalClientRequestDispatcherBase.class/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/protocol/LocalClientRequestDispatcherBase$1.classsreg Cached information needed for local dispatch If isNextIsLocalValid.get() == Boolean.TRUE, the next call to isLocal should be validPossible paths throughuseLocalInvocation/servant_preinvoke/servant_postinvoke:A: call useLocalInvocationIf useLocalInvocation returns false, servant_preinvoke is not called.If useLocalInvocation returns true,call servant_preinvokeIf servant_preinvoke returns null,goto A(local invocation proceeds normally)servant_postinvoke is calledCheck that the servant in info (which must not be null) isan instance of the expectedType.  If not, set the thread local flagand return false. Normally, this test will never fail.  However, if the servant and the stub were loaded in different class loaders, this test When servant_preinvoke returns null, the stub will recursively re-invoke itself.  Thus, the next call made from the stub is another useLocalInvocation call./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/protocol/MinimalServantCacheLocalCRDImpl.java/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/protocol/NotLocalLocalCRDImpl.java REVISIT: Rewrite rmic.HelloTest and rmic.LocalStubTest (which directly call servant_preinvoke) then revert to exception again./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/protocol/POALocalCRDImpl.javaservantExitservantExit(com.sun.corba.se.spi.oa.ObjectAdapter)/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/protocol/POALocalCRDImpl.classservantEnterservantEnter(com.sun.corba.se.spi.oa.ObjectAdapter)runexc"deal with this."deal with this. Look up the servant for this request and return it in a ServantObject.  Note that servant_postinvoke is always called by the stub UNLESS this method returns null.  However, in all cases we must be sure that ObjectAdapter.getServant and ObjectAdapter.returnServant calls are paired, as required for Portable Interceptors and Servant Locators in the POA. Thus, this method must call returnServant if it returns null. So just reinvoke this method. Cleanup after this call, then throw to allow outer try to handle the exception appropriately.ClientRequestDispatcher csub = (ClientRequestDispatcher)StubAdapter.getDelegate( ex.forward_reference ) ;IOR ior = csub.getIOR() ;setLocatedIOR( ior ) ; ThreadDeath on the server side should not cause a client side thread death in the local case.  We want to preserve this behavior for location transparency, so that a ThreadDeath has the same affect in either the local or remote case. The non-colocated case is handled in iiop.ORB.process, which throws the same exception./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/protocol/RequestCanceledException.java/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/protocol/RequestCanceledException.classIf this exception is caught explicitly, this need to be rethrown./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/protocol/RequestDispatcherRegistryImpl.javastringToServerSubcontract/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/protocol/RequestDispatcherRegistryImpl.classobjectAdapterFactoriesViewobjectAdapterFactoriesLCSFRegistryOAFRegistryCSRegistrySDRegistrysscsccThis is a registry of all subcontract ID dependent objects.  This includes:LocalClientRequestDispatcherFactory, ClientRequestDispatcher, ServerSubcontract, andObjectAdapterFactory. The default subcontract ID to use if there is no more specific ID available. This happens when invoking a foreign IOR. ServerRequestDispatcher registry ClientRequestDispatcher registry ObjectAdapterFactory registry LocalClientRequestDispatcherFactory registry Set of all ObjectAdapterFactory instances Read-only view of oaf instances Map from obect key string to ServerSubcontract for special bootstrap IORs ************************************************** Methods to find the subcontract side subcontract Note that both forms of getServerRequestDispatcher need to return the default server delegate if no other match is found. This is essential to proper handling of errors for malformed requests.  In particular, a bad MAGIC will result in a lookup in the named key table (stringToServerSubcontract), which must return a valid ServerRequestDispatcher.  A bad subcontract ID will similarly need to return the default ServerRequestDispatcher./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/protocol/ServantCacheLocalCRDBase.java/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/protocol/ServantCacheLocalCRDBase.classoades XXX This should be in the SPI InvocationInfo must be pushed before calling getInvocationServant This is an error since no user of this implementation should ever throw this exception End of File/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/protocol/SharedCDRClientRequestDispatcherImpl.javacdrOutputObjectinOrbinBufferinMsg/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/protocol/SharedCDRClientRequestDispatcherImpl$1.classPrivilegedAction<CDRInputObject>/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/protocol/SharedCDRClientRequestDispatcherImpl.classinOrb2inBuffer2inMsg2".marshalingComplete: ignoring IOException - ".marshalingComplete: ignoring IOException - /Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/protocol/SharedCDRClientRequestDispatcherImpl$2.class"SharedCDRClientRequestDispatcherImpl"SharedCDRClientRequestDispatcherImpl Rather than have separate CDR subcontract, use same CorbaClientRequestDispatcherImpl but have different MessageMediator finishSendingRequest and waitForResponse handle what is done below. Benefit: then in ContactInfo no need to do a direct new of subcontract - does not complicate subcontract registry. Create server-side input object. Dispatch REVISIT: Impl cast. InputStream must be closed on the InputObject so that its ByteBuffer can be released to the ByteBufferPool. We must do this before we re-assign the cdrInputObject reference below. No need to do anything since we're done with the input stream and cdrInputObject will be re-assigned a new client-side input object, (i.e. won't result in a corba error). Create client-side input object/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/protocol/SpecialMethod.javaSpecialMethod[]/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/protocol/SpecialMethod.classNonExistentNonExistent()/Library/Java/JavaVirtualMachines/jdk1.8.0_251.jdk/Contents/Home/jre/lib/rt.jar/com/sun/corba/se/impl/protocol/Library/Java/JavaVirtualMachines/jdk1.8.0_251.jdk/Contents/Home/jre/lib/rt.jar/com/sun/corba/se/impl/protocol/NonExistent.classNotExistentNotExistent()/Library/Java/JavaVirtualMachines/jdk1.8.0_251.jdk/Contents/Home/jre/lib/rt.jar/com/sun/corba/se/impl/protocol/NotExistent.class"_not_existent"_not_existentIsAIsA()/Library/Java/JavaVirtualMachines/jdk1.8.0_251.jdk/Contents/Home/jre/lib/rt.jar/com/sun/corba/se/impl/protocol/IsA.classclientIdanswerGetInterfaceGetInterface()/Library/Java/JavaVirtualMachines/jdk1.8.0_251.jdk/Contents/Home/jre/lib/rt.jar/com/sun/corba/se/impl/protocol/GetInterface.class _non_existent _not_existent _is_a _get_interface/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/protocol/giopmsgheaders/AddressingDispositionHelper.java/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/protocol/giopmsgheaderscom.sun.corba.se.impl.protocol.giopmsgheaders/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/protocol/giopmsgheaders/AddressingDispositionHelper.class/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/protocol/giopmsgheaders"IDL:messages/AddressingDisposition:1.0"IDL:messages/AddressingDisposition:1.0"AddressingDisposition"AddressingDispositioncom/sun/corba/se/impl/protocol/giopmsgheaders/AddressingDispositionHelper.javaGenerated by the IDL-to-Java compiler (portable), version "3.0"from ../../../../../../../src/share/classes/com/sun/corba/se/GiopIDL/g.idlSunday, June 4, 2000 5:18:54 PM PDT/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/protocol/giopmsgheaders/CancelRequestMessage.javaThis interface captures the CancelRequestMessage contract.Ram Jeyaraman 05/14/2000/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/protocol/giopmsgheaders/CancelRequestMessage_1_0.javaCancelRequestMessage_1_0CancelRequestMessage_1_0(int)/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/protocol/giopmsgheaders/CancelRequestMessage_1_0.classCancelRequestMessage_1_0()_request_idThis implements the GIOP 1.0 CancelRequest header. Accessor methods IO methods class CancelRequestMessage_1_0/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/protocol/giopmsgheaders/CancelRequestMessage_1_1.javaCancelRequestMessage_1_1CancelRequestMessage_1_1(int)/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/protocol/giopmsgheaders/CancelRequestMessage_1_1.classCancelRequestMessage_1_1()This implements the GIOP 1.1 CancelRequest header. class CancelRequestMessage_1_1/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/protocol/giopmsgheaders/CancelRequestMessage_1_2.javaCancelRequestMessage_1_2CancelRequestMessage_1_2(int)/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/protocol/giopmsgheaders/CancelRequestMessage_1_2.classCancelRequestMessage_1_2()This implements the GIOP 1.2 CancelRequest header. class CancelRequestMessage_1_2/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/protocol/giopmsgheaders/FragmentMessage.javaThis interface captures the FragmentMessage contract./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/protocol/giopmsgheaders/FragmentMessage_1_1.javaFragmentMessage_1_1FragmentMessage_1_1(com.sun.corba.se.impl.protocol.giopmsgheaders.Message_1_1)/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/protocol/giopmsgheaders/FragmentMessage_1_1.classFragmentMessage_1_1()msg11This implements the GIOP 1.1 Fragment header. 1.1 has no fragment header and so no request_idThis will never be called, since we do not currently read therequest_id from an CDRInputStream. Instead we use thereadGIOP_1_1_requestId to read the requestId from a byte buffer.1.1 has no request_id; so nothing to write class FragmentMessage_1_1/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/protocol/giopmsgheaders/FragmentMessage_1_2.javaFragmentMessage_1_2FragmentMessage_1_2(com.sun.corba.se.impl.protocol.giopmsgheaders.Message_1_1)/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/protocol/giopmsgheaders/FragmentMessage_1_2.classFragmentMessage_1_2(int)FragmentMessage_1_2()msg12This implements the GIOP 1.2 Fragment header. This is currently never called.readGIOP_1_2_requestId to read the requestId from a byte buffer. class FragmentMessage_1_2/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/protocol/giopmsgheaders/IORAddressingInfo.java_selected_profile_index_iorcom/sun/corba/se/impl/protocol/giopmsgheaders/IORAddressingInfo.java class IORAddressingInfo/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/protocol/giopmsgheaders/IORAddressingInfoHelper.java/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/protocol/giopmsgheaders/IORAddressingInfoHelper.class"IDL:messages/IORAddressingInfo:1.0"IDL:messages/IORAddressingInfo:1.0"selected_profile_index"selected_profile_index"ior""IORAddressingInfo"IORAddressingInfocom/sun/corba/se/impl/protocol/giopmsgheaders/IORAddressingInfoHelper.java/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/protocol/giopmsgheaders/KeyAddr.javacom/sun/corba/se/impl/protocol/giopmsgheaders/KeyAddr.java/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/protocol/giopmsgheaders/LocateReplyMessage.javaThis interface captures the LocateReplyMessage contract. 1.2/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/protocol/giopmsgheaders/LocateReplyMessage_1_0.javaLocateReplyMessage_1_0LocateReplyMessage_1_0(com.sun.corba.se.spi.orb.ORB,int,int,com.sun.corba.se.spi.ior.IOR)/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/protocol/giopmsgheaders/LocateReplyMessage_1_0.classLocateReplyMessage_1_0(com.sun.corba.se.spi.orb.ORB)locate_status_locate_statuscdrlocalWrapperThis implements the GIOP 1.0 LocateReply header. 1.0 LocateReply body does not contain SystemException raises exception on error The code below reads the reply body if status is OBJECT_FORWARD Note, this writes only the header information. IOR may be written afterwards into the reply mesg body. Static methods class LocateReplyMessage_1_0/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/protocol/giopmsgheaders/LocateReplyMessage_1_1.javaLocateReplyMessage_1_1LocateReplyMessage_1_1(com.sun.corba.se.spi.orb.ORB,int,int,com.sun.corba.se.spi.ior.IOR)/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/protocol/giopmsgheaders/LocateReplyMessage_1_1.classLocateReplyMessage_1_1(com.sun.corba.se.spi.orb.ORB)_reply_statusThis implements the GIOP 1.1 LocateReply header. Note, this writes only the header information. SystemException or class LocateReplyMessage_1_1/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/protocol/giopmsgheaders/LocateReplyMessage_1_2.javaLocateReplyMessage_1_2LocateReplyMessage_1_2(com.sun.corba.se.spi.orb.ORB,int,int,com.sun.corba.se.spi.ior.IOR)/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/protocol/giopmsgheaders/LocateReplyMessage_1_2.classLocateReplyMessage_1_2(com.sun.corba.se.spi.orb.ORB)minorCodeexClassNamereposIdThis implements the GIOP 1.2 LocateReply header. default; GIOP 1.2 LocateReply message bodies are not aligned on 8 byte boundaries. The code below reads the reply body in some cases LOC_SYSTEM_EXCEPTION & OBJECT_FORWARD & OBJECT_FORWARD_PERM & LOC_NEEDS_ADDRESSING_MODE read GIOP::AddressingDisposition from body and resend the original request using the requested addressing mode. The resending is transparent to the caller. IOR or GIOP::AddressingDisposition may be written afterwards into the reply mesg body. class LocateReplyMessage_1_2/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/protocol/giopmsgheaders/LocateReplyOrReplyMessage.java/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/protocol/giopmsgheaders/LocateRequestMessage.javaThis interface captures the LocateRequestMessage contract./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/protocol/giopmsgheaders/LocateRequestMessage_1_0.javaLocateRequestMessage_1_0LocateRequestMessage_1_0(com.sun.corba.se.spi.orb.ORB,int,byte[])/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/protocol/giopmsgheaders/LocateRequestMessage_1_0.classLocateRequestMessage_1_0(com.sun.corba.se.spi.orb.ORB)object_key_object_keyThis implements the GIOP 1.0 LocateRequest header. Accessor methods (LocateRequestMessage interface) this will raise a MARSHAL exception upon errors. class LocateRequestMessage_1_0/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/protocol/giopmsgheaders/LocateRequestMessage_1_1.javaLocateRequestMessage_1_1LocateRequestMessage_1_1(com.sun.corba.se.spi.orb.ORB,int,byte[])/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/protocol/giopmsgheaders/LocateRequestMessage_1_1.classLocateRequestMessage_1_1(com.sun.corba.se.spi.orb.ORB)_len1This implements the GIOP 1.1 LocateRequest header. class LocateRequestMessage_1_1/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/protocol/giopmsgheaders/LocateRequestMessage_1_2.javaLocateRequestMessage_1_2LocateRequestMessage_1_2(com.sun.corba.se.spi.orb.ORB,int,com.sun.corba.se.impl.protocol.giopmsgheaders.TargetAddress)/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/protocol/giopmsgheaders/LocateRequestMessage_1_2.classLocateRequestMessage_1_2(com.sun.corba.se.spi.orb.ORB)_targetThis implements the GIOP 1.2 LocateRequest header. this does AddressingDisposition check class LocateRequestMessage_1_2/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/protocol/giopmsgheaders/Message.java0x47494F5011959867680x504F494713473733830x010x020x000x30x3FThis is the base interface for different message type interfaces. Generic constants Other useful constants Encoding related constants Message types 1.1 & 1.2: Mutator methods/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/protocol/giopmsgheaders/MessageBase.java/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/protocol/giopmsgheaders/MessageBase.classgetSystemExceptiongetSystemException(java.lang.String,int,org.omg.CORBA.CompletionStatus,java.lang.String,com.sun.corba.se.impl.logging.ORBUtilSystemException)nullChecknullCheck(java.lang.Object)readSizereadSize(byte,byte,byte,byte,boolean)extractObjectKeyextractObjectKey(com.sun.corba.se.impl.protocol.giopmsgheaders.TargetAddress,com.sun.corba.se.spi.orb.ORB)extractObjectKey(byte[],com.sun.corba.se.spi.orb.ORB)AreFragmentsAllowedAreFragmentsAllowed(byte,byte,byte,byte)createRequestcreateRequest(com.sun.corba.se.spi.orb.ORB,com.sun.corba.se.spi.ior.iiop.GIOPVersion,byte,int,boolean,byte[],java.lang.String,com.sun.corba.se.spi.servicecontext.ServiceContexts,org.omg.CORBA.Principal)threadPoolToUse"GIOPRequest"GIOPRequest"GIOPReply"GIOPReply"GIOPCancelRequest"GIOPCancelRequest"GIOPLocateRequest"GIOPLocateRequest"GIOPLocateReply"GIOPLocateReply"GIOPCloseConnection"GIOPCloseConnection"GIOPMessageError"GIOPMessageError"GIOPFragment"GIOPFragment"Unknown"UnknownrequestEncodingVersionorbVersionviewBuffer".readGIOPHeader: ".readGIOPHeader: ".readGIOPHeader: GIOP header is: ".readGIOPHeader: GIOP header is: 0x0D".readGIOPHeader: Message GIOP version: ".readGIOPHeader: Message GIOP version: ".readGIOPHeader: ORB Max GIOP Version: ".readGIOPHeader: ORB Max GIOP Version: ".readGIOPHeader: creating RequestMessage".readGIOPHeader: creating RequestMessage".readGIOPHeader: creating LocateRequestMessage".readGIOPHeader: creating LocateRequestMessage".readGIOPHeader: creating CancelRequestMessage".readGIOPHeader: creating CancelRequestMessage".readGIOPHeader: creating ReplyMessage".readGIOPHeader: creating ReplyMessage".readGIOPHeader: creating LocateReplyMessage".readGIOPHeader: creating LocateReplyMessage".readGIOPHeader: creating Message for CloseConnection or MessageError".readGIOPHeader: creating Message for CloseConnection or MessageError".readGIOPHeader: creating FragmentMessage".readGIOPHeader: creating FragmentMessage".readGIOPHeader: UNKNOWN MESSAGE TYPE: ".readGIOPHeader: UNKNOWN MESSAGE TYPE: msg10viewBufmsgBuf".readGIOPHeader: header construction complete.".readGIOPHeader: header construction complete.msgSizeMinusHeader".readGIOPBody: received message:".readGIOPBody: received message:service_contextsrequesting_principalresponse_flags0x03requestMessageiorInfoflagmsgTypeorbTargetAddrPrefreqAddrDispiiopProfileTaggedProfile[]a1a2a3a4someEx"MessageBase"MessageBaseThis class acts as the base class for the various GIOP message types. Thisalso serves as a factory to create various message types. We currentlysupport GIOP 1.0, 1.1 and 1.2 message types. This is only used when the giopDebug flag is turned on. (encodingVersion == 0x00) implies CDR encoding, (encodingVersion >  0x00) implies Java serialization version. Since this is executed in debug mode only the overhead of using a View Buffer is not an issue. We'll also use a read-only View Buffer so we don't disturb the state of byteBuffer. Sanity checkscheck for magic corruptioncheck for version incompatibilitycheck if fragmentation is allowed based on mesg type.. 1.0 fragmentation disallowed; FragmentMessage is non-existent.. 1.1 only {Request, Reply} msgs maybe fragmented.. 1.2 only {Request, Reply, LocateRequest, LocateReply} msgsmaybe fragmented. If Magic is incorrect, it is an error. ACTION : send MessageError and close the connection. Extract the encoding version from the request GIOP Version, if it contains an encoding, and set GIOP version appropriately. For Java serialization, we use GIOP Version 1.2 message format. Entering this block means the request is using Java encoding, and the encoding version is <= this ORB's Java encoding version. For requests, sending ORB should use the version info published in the IOR or may choose to use a <= version for requests. If the version is greater than published version, it is an error. For replies, the ORB should always receive a version it supports or less, but never greater (except for MessageError) ACTION : Send back a MessageError() with the the highest version the server ORB supports, and close the connection. create appropriate messages typesmsg = new RequestMessage(orb.giopDebugFlag); 1.0 1.1msg = new LocateRequestMessage(orb.giopDebugFlag);msg = new CancelRequestMessage(orb.giopDebugFlag);msg = new ReplyMessage(orb.giopDebugFlag);msg = new LocateReplyMessage(orb.giopDebugFlag); REVISIT a MessageError  may contain the highest version server can support. In such a case, a new request may be made with the correct version or the connection be simply closed. Note the connection may have been closed by the server.msg = new Message(orb.giopDebugFlag);msg = new FragmentMessage(orb.giopDebugFlag); not possible (error checking done already) unknown message type ? ACTION : send MessageError and close the connection Initialize the generic GIOP header instance variables. 'request partitioning' not supported on GIOP version 1.0 so just use the default thread pool, 0. 1.1 & 1.2 IMPORTANT: For 'request partitioning', the thread pool to use            information is stored in the leading 6 bits of byte 6. IMPORTANT: Request partitioning is a PROPRIETARY EXTENSION !!! NOTE: Bitwise operators will promote a byte to an int before       performing a bitwise operation and bytes, ints, longs, etc       are signed types in Java. Thus, the need for the       THREAD_POOL_TO_USE_MASK operation. For debugging purposes, save the 12 bytes of the header REVISIT: is giopHeader still used? Note: Currently we use response_expected flag to decide if the call is oneway or not. Ideally, it is possible to expect a response on a oneway call too, but we do not support it now.// REVISIT The following is the correct way to do it. This gives// more flexibility.if ((DII::INV_NO_RESPONSE == false) && response_expected) {response_flags = 0x03; // regular two-way} else if ((DII::INV_NO_RESPONSE == false) && !response_expected) {// this condition is not possible} else if ((DII::INV_NO_RESPONSE == true) && response_expected) {// oneway, but we need response for LocationForwards or// SystemExceptions.response_flags = 0x01;} else if ((DII::INV_NO_RESPONSE == true) && !response_expected) {// oneway, no response requiredresponse_flags = 0x00; object key will be used for target addressing only object_key based target addressing is allowed for GIOP 1.0 & 1.1 iop profile will be used ior will be used profile index invalid target addressing disposition value add request partitioning thread pool to use info default pool This method is not currently used. New fragment messages are always created from existing messages. Creating a FragmentMessage from InputStream is done in createFromStream(..)Set a flag in the given buffer (fragment bit, byte order bit, etc)Clears a flag in the given bufferConstruct an ObjectKey from a byte[].ObjectKey the object key. XXX log this exception This exception is thrown if any exceptions are raised while extracting the object key or if the object key is empty.Extract the object key from TargetAddress. AddressingDisposition::KeyAddr AddressingDisposition::ProfileAddr AddressingDisposition::IORAddr this cannot happen There is no need for a explicit exception, since the TargetAddressHelper.read() would have raised a BAD_OPERATION exception by now. extracting the object key from the TargetAddress or if all the the valid TargetAddress::AddressingDispositions are empty./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/protocol/giopmsgheaders/MessageHandler.javaInterface which allows an implementation to usedouble dispatch when processing the variousconcrete message types found in this package. REVISIT - These should not throw IOException.           Should be handled internally.Used for message types for which we don't have concrete classes, yet,such as CloseConnection and MessageError, as well as unknown types. Request Reply LocateRequest LocateReply Fragment CancelRequest/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/protocol/giopmsgheaders/Message_1_0.javaMessage_1_0Message_1_0(int,boolean,byte,int)/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/protocol/giopmsgheaders/Message_1_0.classMessage_1_0()message_sizemessage_typebyte_orderGIOP_version_magic_byte_order_message_type_message_sizepatchThis implements the GIOP 1.0 Message header.@author Ram Jeyaraman 05/14/2000 Patch the size field in the header. This should do nothing even if it is called. The Message Header already is read off java.io.InputStream (not a CDRInputStream) by IIOPConnection in order to choose the correct CDR Version, msg_type, and msg_size. So, we would never need to read the Message Header off a CDRInputStream.this.magic = istream.read_long();this.GIOP_version = (new GIOPVersion()).read(istream);this.byte_order = istream.read_boolean();this.message_type = istream.read_octet();this.message_size = istream.read_ulong(); class Message_1_0/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/protocol/giopmsgheaders/Message_1_1.javaMessage_1_1Message_1_1(int,com.sun.corba.se.spi.ior.iiop.GIOPVersion,byte,byte,int)/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/protocol/giopmsgheaders/Message_1_1.classMessage_1_1()UPPER_THREE_BYTES_OF_INT_MASK_GIOP_versiontmpFlagsThis implements the GIOP 1.1 & 1.2 Message header. Constants NOTE: This is a SUN PROPRIETARY EXTENSION Add the poolToUse to the upper 6 bits of byte 6 of the GIOP header. this.flags represents byte 6 here. IMPORTANT: Bitwise operations will promote            byte types to int before performing            bitwise operations. And, Java            types are signed.Allows us to create a fragment message from any message type. check for message type validity// A fragmented mesg can be created only if the current mesg' fragment// bit is set. Otherwise, raise error// too stringent checkif ( (this.flags & MORE_FRAGMENTS_BIT) != MORE_FRAGMENTS_BIT ) {throw wrapper.fragmentationDisallowed( CompletionStatus.COMPLETED_MAYBE); This should do nothing even if it is called. The Message Header is read off a java.io.InputStream (not a CDRInputStream) by IIOPConnection in order to choose the correct CDR Version , msg_type, and msg_size.this.flags = istream.read_octet(); class Message_1_1/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/protocol/giopmsgheaders/Message_1_2.javaMessage_1_2Message_1_2(int,com.sun.corba.se.spi.ior.iiop.GIOPVersion,byte,byte,int)/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/protocol/giopmsgheaders/Message_1_2.classMessage_1_2()The byteBuffer is presumed to have contents of the message alreadyread in.  It must have 12 bytes of space at the beginning for the GIOP header,but the header doesn't have to be copied in. save restore/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/protocol/giopmsgheaders/ProfileAddr.javacom/sun/corba/se/impl/protocol/giopmsgheaders/ProfileAddr.java/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/protocol/giopmsgheaders/ReferenceAddr.javacom/sun/corba/se/impl/protocol/giopmsgheaders/ReferenceAddr.java/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/protocol/giopmsgheaders/ReplyMessage.javaThis interface captures the ReplyMessage contract. Note: If the value, order, or number of these constants change, please update the REPLY_MESSAGE_TO_PI_REPLY_STATUS table in PIHandlerImpl./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/protocol/giopmsgheaders/ReplyMessage_1_0.javaReplyMessage_1_0ReplyMessage_1_0(com.sun.corba.se.spi.orb.ORB,com.sun.corba.se.spi.servicecontext.ServiceContexts,int,int,com.sun.corba.se.spi.ior.IOR)/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/protocol/giopmsgheaders/ReplyMessage_1_0.classReplyMessage_1_0(com.sun.corba.se.spi.orb.ORB)_service_contextsThis implements the GIOP 1.0 Reply header. SYSTEM_EXCEPTION & LOCATION_FORWARD do nothing. The client stub will read the exception from body./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/protocol/giopmsgheaders/ReplyMessage_1_1.javaReplyMessage_1_1ReplyMessage_1_1(com.sun.corba.se.spi.orb.ORB,com.sun.corba.se.spi.servicecontext.ServiceContexts,int,int,com.sun.corba.se.spi.ior.IOR)/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/protocol/giopmsgheaders/ReplyMessage_1_1.classReplyMessage_1_1(com.sun.corba.se.spi.orb.ORB)This implements the GIOP 1.1 Reply header./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/protocol/giopmsgheaders/ReplyMessage_1_2.javaReplyMessage_1_2ReplyMessage_1_2(com.sun.corba.se.spi.orb.ORB,int,int,com.sun.corba.se.spi.servicecontext.ServiceContexts,com.sun.corba.se.spi.ior.IOR)/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/protocol/giopmsgheaders/ReplyMessage_1_2.classReplyMessage_1_2(com.sun.corba.se.spi.orb.ORB)This implements the GIOP 1.2 Reply header. CORBA formal 00-11-0 15.4.2.2 GIOP 1.2 body must be aligned on an 8 octet boundary. Ensures that the first read operation called from the stub code, during body deconstruction, would skip the header padding, that was inserted to ensure that the body was aligned on an 8-octet boundary. SYSTEM_EXCEPTION & LOCATION_FORWARD & LOCATION_FORWARD_PERM & NEEDS_ADDRESSING_MODE resending is transparent to the client program. Ensures that the first write operation called from the stub code, during body construction, would insert a header padding, such that the body is aligned on an 8-octet boundary. class ReplyMessage_1_2/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/protocol/giopmsgheaders/RequestMessage.javaThis interface captures the RequestMessage contract. interface RequestMessage/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/protocol/giopmsgheaders/RequestMessage_1_0.javaRequestMessage_1_0RequestMessage_1_0(com.sun.corba.se.spi.orb.ORB,com.sun.corba.se.spi.servicecontext.ServiceContexts,int,boolean,byte[],java.lang.String,org.omg.CORBA.Principal)/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/protocol/giopmsgheaders/RequestMessage_1_0.classRequestMessage_1_0(com.sun.corba.se.spi.orb.ORB)_response_expected_operation_requesting_principalThis implements the GIOP 1.0 Request header. Accessor methods (RequestMessage interface) REVISIT Should we throw an exception or return null ? Mutators No-op, must be GIOP Version 1.1 or greater to support this SUN PROPRIETARY EXTENSION. class RequestMessage_1_0/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/protocol/giopmsgheaders/RequestMessage_1_1.javaRequestMessage_1_1RequestMessage_1_1(com.sun.corba.se.spi.orb.ORB,com.sun.corba.se.spi.servicecontext.ServiceContexts,int,boolean,byte[],byte[],java.lang.String,org.omg.CORBA.Principal)/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/protocol/giopmsgheaders/RequestMessage_1_1.classRequestMessage_1_1(com.sun.corba.se.spi.orb.ORB)reserved_reserved_o0This implements the GIOP 1.1 Request header. Added in GIOP 1.1 class RequestMessage_1_1/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/protocol/giopmsgheaders/RequestMessage_1_2.javaRequestMessage_1_2RequestMessage_1_2(com.sun.corba.se.spi.orb.ORB,int,byte,byte[],com.sun.corba.se.impl.protocol.giopmsgheaders.TargetAddress,java.lang.String,com.sun.corba.se.spi.servicecontext.ServiceContexts)/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/protocol/giopmsgheaders/RequestMessage_1_2.classRequestMessage_1_2(com.sun.corba.se.spi.orb.ORB)_response_flagsThis implements the GIOP 1.2 Request header.case 1: LSBit[1] == 1not a oneway call (DII flag INV_NO_RESPONSE is false)  // Ox03LSBit[0] must be 1.case 2: LSBit[1] == 0if (LSB[0] == 0) // Ox00oneway callelse if (LSB[0] == 1) // 0x01oneway call; but server may providea location forward response or system exception response. class RequestMessage_1_2/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/protocol/giopmsgheaders/TargetAddress.javaverifyiorverifyior(short)/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/protocol/giopmsgheaders/TargetAddress.classverifyprofileverifyprofile(short)verifyobject_keyverifyobject_key(short)__uninitialized__discriminator___ior___profile___object_key32768com/sun/corba/se/impl/protocol/giopmsgheaders/TargetAddress.java class TargetAddress/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/protocol/giopmsgheaders/TargetAddressHelper.java/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/protocol/giopmsgheaders/TargetAddressHelper.class"IDL:messages/TargetAddress:1.0"IDL:messages/TargetAddress:1.0_disTypeCode0_anyOf_members0"object_key""profile""TargetAddress"TargetAddress_dis0_profilecom/sun/corba/se/impl/protocol/giopmsgheaders/TargetAddressHelper.java Branch for object_key Branch for profile Branch for ior/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/resolver/BootstrapResolverImpl.java/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/resolvercom.sun.corba.se.impl.resolverinvokeinvoke(java.lang.String,java.lang.String)/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/resolver/BootstrapResolverImpl.class/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/resolverbootstrapDelegateinitialKeyinitialIORparameterremarshalinStream Create a new IOR with the magic of INITFor the BootStrap operation we do not expect to have more than oneparameter. We do not want to extend BootStrap protocol any further,as INS handles most of what BootStrap can handle in a portable way.InputStream which contains the response from theBootStrapOperation. Invoke. If there is a location forward then you will need to invoke again on the updated information. Just calling this same routine with the same host/port does not take the location forward info into account. The only reason a null objref is passed is to get the version of invoke used by streams.  Otherwise the PortableInterceptor call stack will become unbalanced since the version of invoke which only takes the stream does not call PortableInterceptor ending points. Note that the first parameter is ignored inside invoke. NOTE: do note trap and ignore errors. Let them flow out./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/resolver/CompositeResolverImpl.java/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/resolver/CompositeResolverImpl.class/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/resolver/FileResolverImpl.javacheckcheck()/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/resolver/FileResolverImpl.classfileModifiedsavedPropsstringifiedObjecttheKeyslastModfileIS"bootstrap.filenotfound"bootstrap.filenotfound"bootstrap.exception"bootstrap.exception Obtain all the keys from the property objectChecks the lastModified() timestamp of the file and optionallyre-reads the Properties object from the file if newer./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/resolver/INSURLOperationImpl.javaclearRootNamingContextCacheclearRootNamingContextCache()/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/resolver/INSURLOperationImpl.classgetDefaultRootNamingContextgetDefaultRootNamingContext()getIORUsingCorbalocgetIORUsingCorbaloc(com.sun.corba.se.impl.naming.namingutil.INSURL)resolveCorbanameresolveCorbaname(com.sun.corba.se.impl.naming.namingutil.CorbanameURL)resolveCorbalocresolveCorbaloc(com.sun.corba.se.impl.naming.namingutil.CorbalocURL)resolveINSURLresolveINSURL(com.sun.corba.se.impl.naming.namingutil.INSURL)getIORFromStringgetIORFromString(java.lang.String)UN_SHIFTNIBBLES_PER_BYTErootContextCacheLockrootNamingContextExtbootstrapResolver0xF00x0FtheURLObjecttheCorbaLocObjecttheCorbaNametheNamingContextStringifiedNamecorbalocResultcorbalocObjectprofileMapprofileList1_0theEndpointInfotheKeyStringpTemplate/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/resolver/INSURLOperationImpl$1.classToDoubleFunction<>Comparator<T>comparingDoublecomparingDouble(java.util.function.ToDoubleFunction)ToDoubleFunction<? super T>ToLongFunction<>comparingLongcomparingLong(java.util.function.ToLongFunction)ToLongFunction<? super T>ToIntFunction<>comparingIntcomparingInt(java.util.function.ToIntFunction)ToIntFunction<? super T>Comparable<? super U>comparingcomparing(java.util.function.Function)Function<? super T,? extends U>comparing(java.util.function.Function,java.util.Comparator)Comparator<? super U>nullsLastnullsLast(java.util.Comparator)Comparator<? super T>nullsFirstnullsFirst(java.util.Comparator)Comparable<? super T>naturalOrdernaturalOrder()reverseOrderreverseOrder()thenComparingDoublethenComparingDouble(java.util.function.ToDoubleFunction)thenComparingLongthenComparingLong(java.util.function.ToLongFunction)thenComparingIntthenComparingInt(java.util.function.ToIntFunction)thenComparingthenComparing(java.util.function.Function)thenComparing(java.util.function.Function,java.util.Comparator)thenComparing(java.util.Comparator)reversedreversed()comparecompare(java.lang.Object,java.lang.Object)gv1gv2profileTemplateiiopAddressComponentptThis class provides an Operation that converts from CORBA INS URL strings intoCORBA object references.  It will eventually become extensible, but for now itsimply encapsulates the existing implementation.  Once the full extensibilityis in place, we want this operation to convert string to INSURL, which has mainlya public resolver method that returns an object reference.Ken Root Naming Context for default resolution of names. The URLHandler to parse INS URL's "UPPER NIBBLE" shift factor for <<This static method takes a Stringified IOR and converts it into IOR object.It is the caller's responsibility to only pass strings that start with "IOR:". Length must be even for str to be valid XXX handle this as just another URL scheme XXX resolve should be a method on INSURLresolves a corbaloc: url that is encapsulated in a CorbalocURL object.the CORBA.Object if resolution is successful If RIR flag is true use the Bootstrap protocolresolves a corbaname: url that is encapsulated in a CorbanameURL object. Case 1 of corbaname: rir# Case 2 of corbaname: ::hostname# This means return the Root Naming contextThis is an internal method to get the IOR from the CorbalocURL object. corbalocObject cannot be null, because it's validated during parsing. So no null check is required. If there is no KeyString then it's invalid Add profile for GIOP version used by this ORB Now remove this value from the map Create a comparator that can sort in decending order (1.2, 1.1, ...) Now sort using the above comparator Add the profiles in the sorted order Finally add the 1.0 profilesThis is required for corbaname: resolution. Currently weare not caching RootNamingContext as the reference to rootNamingContextmay not be Persistent in all the implementations._REVISIT_ to clear the rootNamingContext in case of COMM_FAILURE.the org.omg.COSNaming.NamingContextExt if resolution issuccessfulA utility method to clear the RootNamingContext, if there is anexception in resolving CosNaming:Name from the RootNamingContext,/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/resolver/LocalResolverImpl.javanameToClosure/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/resolver/LocalResolverImpl.class/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/resolver/ORBDefaultInitRefResolverImpl.javaorbDefaultInitRef/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/resolver/ORBDefaultInitRefResolverImpl.classurlHandlerurlString XXX Validate the URL? If the ORBDefaultInitRef is not defined simply return null If the ORBDefaultInitDef is  defined as corbaloc: then create the corbaloc String in the format <ORBInitDefaultInitDef Param>/<Identifier> and resolve it using resolveCorbaloc method/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/resolver/ORBInitRefResolverImpl.javaorbInitRefTable/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/resolver/ORBInitRefResolverImpl.classinitRefs/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/resolver/SplitLocalResolverImpl.java/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/resolver/SplitLocalResolverImpl.class/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/transport/ByteBufferPoolImpl.java/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/transportcom.sun.corba.se.impl.transport/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/transport/ByteBufferPoolImpl.class/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/transportitsObjectCounteritsPoolitsByteBufferSizeitsOrbtheORBtheAskSizeabbpoolSizethebbrefInPooltmpbbthreadName": Duplicate ByteBuffer reference (": Duplicate ByteBuffer reference (Charlie Hunt Construct a ByteBufferPool for a pool of NIO ByteBuffers of ORB fragment size.Locations where ByteBuffers are gotten from the pool:1. ContactInfoBase.createMessageMediator()2. ByteBufferWithInfo.growBuffer()3. ByteBufferWithInfo(ORB, BufferManagerWrite) - constructor If the requested ByteBuffer size is less than or equal to the ORB fragment size, and we have not disabled use of direct byte buffers (normally for debugging purposes) then get a DirectByteBuffer from the pool if there is one, if there is not one in the pool, then allocate a a DirectByteBuffer of ORB fragment size. If the request ByteBuffer size is greater than the ORB fragment size, allocate a new non-direct ByteBuffer. check if there's one in the pool, if not allocate one. clear ByteBuffer before returning it NOTE: Moved the 'else' part of the above if statement       outside the synchronized block since it is likely       less expensive to check poolSize than to allocate a       DirectByteBuffer in the synchronized block. increment the number of ByteBuffers gotten from pool IMPORTANT: Since this counter is used only for information            purposes, it does not use synchronized access. Requested ByteBuffer size larger than the pool manages. Just allocate a non-direct ByteBufferLocations where ByteBuffers are released to the pool:1. ByteBufferWithInfo.growBuffer()2. BufferManagerWriteCollect.sendMessage()3. CDROutputStream_1_0.close()4. CDRInputStream_1_0.close()5. BufferManagerReadStream.underflow()6. BufferManagerWrite.close()7. BufferManagerRead.close()8. CorbaMessageMediatorImpl.releaseByteBufferToPool() If the ByteBuffer is a DirectByteBuffer, add it to the pool. Otherwise, set its reference to null since it's not kept in the pool and caller is saying he/she is done with it. NOTE: The size of the ByteBuffer is not checked with the       this pool's ByteBuffer size since only DirectByteBuffers       ever allocated. Hence, only DirectByteBuffer are checked       here. An additional check could be added here for that though. use with debug to determine if byteBuffer is already in the pool. Check to make sure we don't have 'thebb' reference already in the pool before adding it. NOTE: The else part of this if will only get called       if debug = true and refInPool = true, see logic above. add ByteBuffer back to the pool otherwise, log a stack trace with duplicate message decrement the count of ByteBuffers released ByteBuffer not pooled nor needed Get a count of the outstanding allocated DirectByteBuffers. (Those allocated and have not been returned to the pool)./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/transport/CorbaConnectionCacheBase.javacacheTypemonitoringNameconnectionsnumberOfConnectionsbackingStore".reclaim->: ".reclaim->: " (" (toCloselru".reclaim: closing: ".reclaim: closing: ".reclaim: connections reclaimed (".reclaim: connections reclaimed (".reclaim<-: ".reclaim<-: ".constructor: cacheType: ".constructor: cacheType: " monitoringName: " monitoringName: ".stats: ".stats: "/total "/total "/busy "/busy "/idle"
                   + " ("/idle ("CorbaConnectionCacheBase"CorbaConnectionCacheBaseCopyright (c) 2001, 2010, Oracle and/or its affiliates. All rights reserved. pept.transport.ConnectionCache _REVISIT_ Need to worry about wrap around some dayDiscarding least recently used Connections that are not busyThis method must be synchronized since one WorkerThread couldbe reclaming connections inside the synchronized backingStoreblock and a second WorkerThread (or a SelectorThread) could havealready executed the if (numberOfConnections <= .... ). As aresult the second thread would also attempt to reclaim connections.If connection reclamation becomes a performance issue, the connectionreclamation could make its own task and consequently executed ina separate thread.Currently, the accept & reclaim are done in the same thread, WorkerThreadby default. It could be changed such that the SelectorThread would doit for SocketChannels and WorkerThreads for Sockets by updating theParserTable. REVISIT - A less expensive alternative connection reclaiming           algorithm could be investigated. Find least recently used and not busy connection in cache REVISIT - log XXX is necessary to do a GC to reclaim closed network connections ?? java.lang.System.gc(); spi.transport.ConnectionCache This is public so folb.Server test can access it./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/transport/CorbaContactInfoBase.java".createMessageMediator: waiting for message header on connection: ".createMessageMediator: waiting for message header on connection: ".createMessageMediator: waiting for message on connection: ".createMessageMediator: waiting for message on connection: corbaMessageMediator".finishCreatingMessageMediator: waiting for message body on connection: ".finishCreatingMessageMediator: waiting for message body on connection: "CorbaContactInfoBase["
            + "]"CorbaContactInfoBase[]"CorbaContactInfoBase"CorbaContactInfoBase NOTE: This may be different from same named one in CorbaContactInfoList. Note: not all derived classes will use a connection cache. These are convenience methods that may not be used. Called when client making an invocation. REVISIT: Would like version, ior, requestid, etc., decisions to be in client subcontract.  Cannot pass these to this factory method because it breaks generic abstraction. Maybe set methods on mediator called from subcontract after creation? Called when connection handling a read event. read giop header only read entire giop message Called when connection reading message body read giop body only REVISIT: Duplicate of acceptor code. spi.transport.CorbaContactInfo REVISIT - remove this./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/transport/CorbaContactInfoListImpl.javaeffectiveTargetIORContactInfoListsocketInfosCopyright (c) 2002, 2006, Oracle and/or its affiliates. All rights reserved. spi.transport.CorbaContactInfoList org.omg.CORBA.portable.Delegate REVISIT - hashCode(org.omg.CORBA.Object self) For use by "sticky manager" if one is registered. NOTE: IMPORTANT: Only do local.  The APP Server interceptors check effectiveTarget.isLocal - which is determined via the IOR - so if we added other addresses then transactions and interceptors would not execute. XREVISIT - See Base Line 62setLocalSubcontract sets cached information that is set wheneverthe effectiveTargetIOR changes.Note: this must be maintained accurately whether or not the ORBallows local optimization, because ServantManagers in the POAALWAYS use local optimization ONLY (they do not have a remote case). XXX Note that this always uses the first IIOP profile to get the scid.  What about multi-profile IORs?  This should perhaps be tied to the current ContactInfo in some way, together with an implementation of ClientDelegate that generally prefers co-located ContactInfo.  This may in fact mean that we should do this at the ContactInfo level, rather than the IOR/profile level./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/transport/CorbaContactInfoListIteratorImpl.javaprimaryContactInfolistOfContactInfosdispositionforwardedIOR REVISIT: create a unit test for this class. ITERATOR state End ITERATOR state listOfContactInfos is null when used by the legacy socket factory.  In that case this iterator is NOT used. List is immutable so no need to synchronize access. REVISIT: Implement as internal closure iterator which would wraps sticky or default.  Then hasNext and next just call the closure. We hold onto the last in case we get an addressing disposition retry.  Then we use it again. We also hold onto it for the sticky manager. com.sun.corba.se.pept.transport.ContactInfoListIterator spi.CorbaContactInfoListIterator The normal operation for a standard iterator is to throw ConcurrentModificationException whenever the underlying collection changes.  This is implemented by keeping a modification counter (the timestamp may fail because the granularity is too coarse). Essentially what you need to do is whenever the iterator fails this way, go back to ContactInfoList and get a new iterator. Need to update CorbaClientRequestDispatchImpl to catch and use that exception. If we report the exception in _request (i.e., beginRequest we cannot throw RemarshalException to the stub because _request does not declare that exception. To keep the two-level dispatching (first level chooses ContactInfo, second level is specific to that ContactInfo/EPT) we need to ensure that the request dispatchers get their iterator from the InvocationStack (i.e., ThreadLocal). That way if the list iterator needs a complete update it happens right here./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/transport/CorbaInboundConnectionCacheImpl.java/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/transport/CorbaInboundConnectionCacheImpl.class".close: ".close: ".put: ".put: ".remove: ".remove: orbMOconnectionMOinboundConnectionMOthisMO/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/transport/CorbaInboundConnectionCacheImpl$1.class/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/transport/CorbaInboundConnectionCacheImpl$2.class/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/transport/CorbaInboundConnectionCacheImpl$3.class"CorbaInboundConnectionCacheImpl"CorbaInboundConnectionCacheImpl pept.transport.InboundConnectionCache ORB REVISIT - add ORBUtil mkdir -p like operation for this. CONNECTION INBOUND CONNECTION NODE FOR THIS CACHE ATTRIBUTE/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/transport/CorbaOutboundConnectionCacheImpl.java".get: ".get: outboundConnectionMO/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/transport/CorbaOutboundConnectionCacheImpl$1.class/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/transport/CorbaOutboundConnectionCacheImpl$2.class/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/transport/CorbaOutboundConnectionCacheImpl$3.class"CorbaOutboundConnectionCacheImpl"CorbaOutboundConnectionCacheImpl pept.transport.OutboundConnectionCache OUTBOUND CONNECTION/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/transport/CorbaResponseWaitingRoomImpl.javaMap<Integer,OutCallDesc>out_calls/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/transport/CorbaResponseWaitingRoomImpl.class/Library/Java/JavaVirtualMachines/jdk1.8.0_251.jdk/Contents/Home/jre/lib/rt.jar/com/sun/corba/se/impl/transport/Library/Java/JavaVirtualMachines/jdk1.8.0_251.jdk/Contents/Home/jre/lib/rt.jar/com/sun/corba/se/impl/transport/CorbaResponseWaitingRoomImpl$OutCallDesc.classOutCallDescOutCallDesc()HashMap<Integer,OutCallDesc>AbstractMap<Integer,OutCallDesc>HashMap<Integer,OutCallDesc>()? super OutCallDesc? extends OutCallDescBiFunction<? super OutCallDesc,? super OutCallDesc,? extends OutCallDesc>merge(java.lang.Integer,com.sun.corba.se.impl.transport.CorbaResponseWaitingRoomImpl.OutCallDesc,java.util.function.BiFunction)BiFunction<? super Integer,? super OutCallDesc,? extends OutCallDesc>Function<? super Integer,? extends OutCallDesc>replace(java.lang.Integer,com.sun.corba.se.impl.transport.CorbaResponseWaitingRoomImpl.OutCallDesc)replace(java.lang.Integer,com.sun.corba.se.impl.transport.CorbaResponseWaitingRoomImpl.OutCallDesc,com.sun.corba.se.impl.transport.CorbaResponseWaitingRoomImpl.OutCallDesc)putIfAbsent(java.lang.Integer,com.sun.corba.se.impl.transport.CorbaResponseWaitingRoomImpl.OutCallDesc)BiConsumer<? super Integer,? super OutCallDesc>getOrDefault(java.lang.Object,com.sun.corba.se.impl.transport.CorbaResponseWaitingRoomImpl.OutCallDesc)Entry<Integer,OutCallDesc>Set<Entry<Integer,OutCallDesc>>Collection<Entry<Integer,OutCallDesc>>Iterable<Entry<Integer,OutCallDesc>>Collection<OutCallDesc>Iterable<OutCallDesc>Map<? extends Integer,? extends OutCallDesc>put(java.lang.Integer,com.sun.corba.se.impl.transport.CorbaResponseWaitingRoomImpl.OutCallDesc)AbstractMap<Integer,OutCallDesc>()Node<Integer,OutCallDesc>TreeNode<Integer,OutCallDesc>newTreeNode(int,java.lang.Integer,com.sun.corba.se.impl.transport.CorbaResponseWaitingRoomImpl.OutCallDesc,java.util.HashMap.Node)newNode(int,java.lang.Integer,com.sun.corba.se.impl.transport.CorbaResponseWaitingRoomImpl.OutCallDesc,java.util.HashMap.Node)Node<Integer,OutCallDesc>[]putVal(int,java.lang.Integer,com.sun.corba.se.impl.transport.CorbaResponseWaitingRoomImpl.OutCallDesc,boolean,boolean)HashMap<Integer,OutCallDesc>(java.util.Map)HashMap<Integer,OutCallDesc>(int)HashMap<Integer,OutCallDesc>(int,float)".registerWaiter: ".registerWaiter: ".unregisterWaiter: ".unregisterWaiter: returnStream".waitForResponse->: ".waitForResponse->: ".waitForResponse: one way - not waiting: ".waitForResponse: one way - not waiting: ".waitForResponse: waiting: ".waitForResponse: waiting: ".waitForResponse: exception: ".waitForResponse: exception: ".waitForResponse<-: ".waitForResponse<-: ".responseReceived: id/".responseReceived: id/": no waiter: ": no waiter: ".responseReceived: ".responseReceived: ": notifying waiters": notifying waiterssystemException".signalExceptionToAllWaiters: ".signalExceptionToAllWaiters: ".signalExceptionToAllWaiters: out_calls size :".signalExceptionToAllWaiters: out_calls size :".signalExceptionToAllWaiters: signaling ".signalExceptionToAllWaiters: signaling corbaMsgMediator"CorbaResponseWaitingRoomImpl"CorbaResponseWaitingRoomImpl Maps requestId to an OutCallDesc. pept.transport.ResponseWaitingRoom The waiter is removed in releaseReply in the same way as a normal request. Wait for the reply from the server. The ReaderThread reads in the reply IIOP message and signals us. REVISIT -- exceptions from unmarshaling code will go up through this client thread! On fragmented streams the header MUST be unmarshaled here (in the client thread) in case it blocks. If the header was already unmarshaled, this won't do anything REVISIT: cast - need interface method. This is an interesting case.  It could mean that someone sent us a reply message, but we don't know what request it was for.  That would probably call for an error.  However, there's another case that's normal and we should think about -- If the unmarshaling thread does all of its work inbetween the time the ReaderThread gives it the last fragment and gets to the out_calls.get line, then it will also be null, so just return; Set the reply InputObject and signal the client thread that the reply has been received. The thread signalled will remove outcall descriptor if appropriate. Otherwise, it'll be removed when last fragment for it has been put on BufferManagerRead's queue.//////////////////////////////////////////////// CorbaResponseWaitingRoom anything waiting for BufferManagerRead's fragment queue needs to be cancelled IMPORTANT: If inputObject is null, then no need to tell            BufferManagerRead to cancel request processing. attempt to wake up waiting threads in all cases This can happen when getting early reply fragments for a request which has completed (e.g., client marshaling error)./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/transport/CorbaTransportManagerImpl.java".registerAcceptor->: ".registerAcceptor->: ".registerAcceptor<-: ".registerAcceptor<-: ".close->".close->icc".close<-".close<-objectAdapterManagerId"CorbaTransportManagerImpl"CorbaTransportManagerImpl REVISIT - impl/poa specific: pept TransportManager REVISIT: Would like to be able to configure the connection cache type used. CorbaTransportManager REVISIT - need to filter based on arguments. REVISIT - initialization will be moved to OA. Lazy initialization of acceptors. REVISIT - POA specific policies implemenation/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/transport/DefaultIORToSocketInfoImpl.javacreateSocketInfocreateSocketInfo(java.lang.String,int)/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/transport/DefaultIORToSocketInfoImpl.classiiopProfileTemplatealternate/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/transport/DefaultIORToSocketInfoImpl$1.classgetPortgetPort()getHostgetHost()getTypegetType() NOTE: we could check for 0 (i.e., CSIv2) but, for a non-CSIv2-configured client ORB talking to a CSIv2 configured server ORB you might end up with an empty contact info list which would then report a failure which would not be as instructive as leaving a ContactInfo with a 0 port in the list./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/transport/DefaultSocketFactoryImpl.java/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/transport/DefaultSocketFactoryImpl.class/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/transport/DefaultSocketFactoryImpl$1.classPrivilegedAction<Boolean>"com.sun.CORBA.transport.enableTcpKeepAlive"com.sun.CORBA.transport.enableTcpKeepAliveinetSocketAddress Disable Nagle's algorithm (i.e., always send immediately)./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/transport/EventHandlerBase.java/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/transport/EventHandlerBase.classselectionKey".handleEvent->: ".handleEvent->: ".handleEvent: addWork to pool: ".handleEvent: addWork to pool: "NoSuchThreadPoolException"".handleEvent: ".handleEvent: ".handleEvent: doWork".handleEvent: doWork".handleEvent<-: ".handleEvent<-: "EventHandlerBase"EventHandlerBase EventHandler methodsThis is not thread-safe by design.Only one thread should call it - a reader/listener/select thread.Not stateless: interest ops, registration. REVISIT: need to close connection./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/transport/ListenerThreadImpl.java/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/transport/ListenerThreadImpl.classenqueueTimekeepRunningselector".doWork: Start ListenerThread: ".doWork: Start ListenerThread: ".doWork: BEFORE ACCEPT CYCLE: ".doWork: BEFORE ACCEPT CYCLE: ".doWork: AFTER ACCEPT CYCLE: ".doWork: AFTER ACCEPT CYCLE: ".doWork: Exception in accept: ".doWork: Exception in accept: ".doWork: Terminated ListenerThread: ".doWork: Terminated ListenerThread: timeInMillis"ListenerThread"ListenerThread"ListenerThreadImpl"ListenerThreadImpl ListenerThread methods. Work methods. REVISIT - this needs alot more from previous ListenerThread/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/transport/ReadTCPTimeoutsImpl.javabackoff_factor/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/transport/ReadTCPTimeoutsImpl.classmax_giop_header_time_to_waitmax_time_to_waitinitial_time_to_waitinitial_timemax_timemax_giop_header_timebackoff_percent/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/transport/ReaderThreadImpl.java/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/transport/ReaderThreadImpl.class".doWork: Start ReaderThread: ".doWork: Start ReaderThread: ".doWork: Start ReaderThread cycle: ".doWork: Start ReaderThread cycle: ".doWork: End ReaderThread cycle: ".doWork: End ReaderThread cycle: ".doWork: exception in read: ".doWork: exception in read: ".doWork: Terminated ReaderThread: ".doWork: Terminated ReaderThread: "ReaderThread"ReaderThread"ReaderThreadImpl"ReaderThreadImpl ReaderThread methods. REVISIT - this needs alot more from previous ReaderThread. REVISIT - put in pool;/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/transport/SelectorImpl.java/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/transport/SelectorImpl.classdestroyReaderThreaddestroyReaderThread(com.sun.corba.se.pept.transport.EventHandler)createReaderThreadcreateReaderThread(com.sun.corba.se.pept.transport.EventHandler)destroyListenerThreaddestroyListenerThread(com.sun.corba.se.pept.transport.EventHandler)createListenerThreadcreateListenerThread(com.sun.corba.se.pept.transport.EventHandler)enableInterestOpsenableInterestOps()handleDeferredRegistrationshandleDeferredRegistrations()startSelectorstartSelector()setClosedsetClosed(boolean)isClosedisClosed()clearDeferredRegistrationsclearDeferredRegistrations()closedselectorStartedreaderThreadslistenerThreadsinterestOpsListdeferredRegistrations".registerInterestOps:-> ".registerInterestOps:-> ehOpskeyAndOp".registerInterestOps: selector.wakeup: ".registerInterestOps: selector.wakeup: ".registerInterestOps: EventHandler SelectionKey not valid ".registerInterestOps: EventHandler SelectionKey not valid ".registerInterestOps:<- ".registerInterestOps:<- ".registerForEvent: ".registerForEvent: ".registerForEvent: closed: ".registerForEvent: closed: ".registerForEvent: default: ".registerForEvent: default: "SelectorImpl.registerForEvent: unknown interest ops"SelectorImpl.registerForEvent: unknown interest ops".unregisterForEvent: ".unregisterForEvent: ".unregisterForEvent: closed: ".unregisterForEvent: closed: ".unregisterForEvent: default: ".unregisterForEvent: default: "SelectorImpl.uregisterForEvent: unknown interest ops"SelectorImpl.uregisterForEvent: unknown interest ops".close".close".close: already closed".close: already closedlistenerThreadreaderThread".close: selector.wakeup: ".close: selector.wakeup: "SelectorThread"SelectorThreadIterator<SelectionKey>Set<SelectionKey>Collection<SelectionKey>Iterable<SelectionKey>Spliterator<SelectionKey>? super SelectionKeyConsumer<? super SelectionKey>Stream<SelectionKey>BaseStream<SelectionKey,Stream<SelectionKey>>Predicate<? super SelectionKey>? extends SelectionKeyCollection<? extends SelectionKey>Iterable<? extends SelectionKey>add(java.nio.channels.SelectionKey)".run: Beginning of selection cycle".run: Beginning of selection cycle".run: selector.select: ".run: selector.select: csEx".run: n = ".run: n = ".run: eventHandler.handleEvent".run: eventHandler.handleEvent".run: End of selection cycle".run: End of selection cycle".run: ignoring".run: ignoring".run: selector.close ".run: selector.close ".run: selector.close: ".run: selector.close: deferredListSize".clearDeferredRegistrations:deferred list size == ".clearDeferredRegistrations:deferred list size == channel".clearDeferredRegistrations: ".clearDeferredRegistrations: ".clearDeferredRegistrations:close channel == ".clearDeferredRegistrations:close channel == ".clearDeferredRegistrations:close channel class == ".clearDeferredRegistrations:close channel class == ? extends SelectableChannelClass<? extends SelectableChannel>Map<String,? extends SelectableChannel>SelectableChannel[]? extends SelectableChannel[]Constructor<? extends SelectableChannel>? super ? extends SelectableChannelClass<? super ? extends SelectableChannel>TypeVariable<Class<? extends SelectableChannel>>TypeVariable<Class<? extends SelectableChannel>>[]ioEx".startSelector: Selector.open exception".startSelector: Selector.open exception".startSelector: Selector.open: IOException: ".startSelector: Selector.open: IOException: ".startSelector: selector.start completed.".startSelector: selector.start completed.".handleDeferredRegistrations: ".handleDeferredRegistrations: listSizekeyOpselectionKeyOps".enableInterestOps:->".enableInterestOps:->".enableInterestOps: ".enableInterestOps: ".enableInterestOps:<-".enableInterestOps:<-".createListenerThread: ".createListenerThread: ".destroyListenerThread: ".destroyListenerThread: ".destroyListenerThread: cannot find ListenerThread - ignoring.".destroyListenerThread: cannot find ListenerThread - ignoring.".createReaderThread: ".createReaderThread: ".destroyReaderThread: ".destroyReaderThread: ".destroyReaderThread: cannot find ReaderThread - ignoring.".destroyReaderThread: cannot find ReaderThread - ignoring."SelectorImpl"SelectorImpl tell Selector Thread there's an update to a SelectorKey's Ops wakeup Selector thread to process close request Kill listeners. Kill readers. Selector///////////////////////////////////////////////// Thread methods.if (timeout == 0 && orb.transportDebugFlag) {dprint(".run: selector.select() returned: " + n);if (n == 0) {continue; IMPORTANT: ignore all errors so the select thread keeps running. Otherwise a guaranteed hang./////////////////////////////////////////////////// REVISIT - better handling/reporting Need to check if the SelectionKey is valid because a connection's SelectionKey could be put on the list to have its OP enabled and before it's enabled be reclaimed. Otherwise, the enabling of the OP will throw an exception here and exit this method an potentially not enable all registered ops. So, we ignore SelectionKeys that are invalid. They will get cleaned up on the next Selector.select() call. Private class to contain a SelectionKey and a SelectionKey op. Used only by SelectorImpl to register and enable SelectionKey Op. REVISIT - Could do away with this class and use the EventHanlder           directly. A SelectionKey.[OP_READ|OP_WRITE|OP_ACCEPT|OP_CONNECT]/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/transport/SharedCDRContactInfoImpl.java/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/transport/SharedCDRContactInfoImpl.class"connection is not null"connection is not null"SharedCDRContactInfoImpl["
            + "]"SharedCDRContactInfoImpl[] This is only necessary for the pi.clientrequestinfo test. It tests that request ids are different. Rather than rewrite the test, just fake it. REVISIT - use registry/ XXX LOGGING Connection; Fake RequestId NOTE: GROW./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/transport/SocketOrChannelAcceptorImpl.java".initialize: ".initialize: ? extends SocketOrChannelAcceptorImplClass<? extends SocketOrChannelAcceptorImpl>Map<String,? extends SocketOrChannelAcceptorImpl>SocketOrChannelAcceptorImpl[]? extends SocketOrChannelAcceptorImpl[]Constructor<? extends SocketOrChannelAcceptorImpl>? super ? extends SocketOrChannelAcceptorImplClass<? super ? extends SocketOrChannelAcceptorImpl>TypeVariable<Class<? extends SocketOrChannelAcceptorImpl>>TypeVariable<Class<? extends SocketOrChannelAcceptorImpl>>[]".accept: ".accept: ".accept: new: ".accept: new: ".accept: registerForEvent: ".accept: registerForEvent: ".accept:".accept:".close->:".close->:".close:".close:".close<-:".close<-:iiopAddresstemplatePortrpPolicy"AcceptedConnections"AcceptedConnections"Should not happen."Should not happen.".doWork->: ".doWork->: ".doWork: ! selectionKey.isAcceptable: ".doWork: ! selectionKey.isAcceptable: permissionStr".doWork: ignoring SecurityException: ".doWork: ignoring SecurityException: ".doWork: ignoring Exception: ".doWork: ignoring Exception: ".doWork: ignoring Throwable: ".doWork: ignoring Throwable: ".doWork<-:".doWork<-:sock"(not initialized)"(not initialized)"SocketOrChannelAcceptorImpl"SocketOrChannelAcceptorImpl REVISIT impl/poa specific BEGIN Legacy support. END Legacy support. pept.transport.Acceptor Determine the listening port (for the IOR). This is important when using emphemeral ports (i.e., when the port value to the constructor is 0). Register with transport (also sets up monitoring). Finish configuation. Configure to use listener and reader threads. NOTE: The connection MUST be put in the cache BEFORE being registered with the selector.  Otherwise if the bytes are read on the connection it will attempt a time stamp but the cache will be null, resulting in NPE. A connection needs to be timestamped before putting to the cache. Otherwise the newly created connection (with 0 timestamp) could be incorrectly reclaimed by concurrent reclaim() call OR if there will be no events on this connection then it could be reclaimed by upcoming reclaim() call. REVISIT - need to close - recreate - then register new one. NOTE: if register cycling we do not want to shut down ORB since local beans will still work.  Instead one will see a growing log file to alert admin of problem. CorbaAcceptor REVISIT - how does this play with legacy ORBD port exchange?CONFLICT: with legacy below.public String getName()return this.toString(); IMPORTANT: To avoid bug (4953599), we force the Thread that does the NIO select to also do the enable/disable of Ops using SelectionKey.interestOps(). Otherwise, the SelectionKey.interestOps() may block indefinitely. NOTE: If "acceptorSocketUseWorkerThreadForEvent" is set to to false in ParserTable.java, then this method, doWork(), will get executed by the same thread (SelectorThread) that does the NIO select. If "acceptorSocketUseWorkerThreadForEvent" is set to true, a WorkerThread will execute this method, doWork(). Hence, the registering of the enabling of the SelectionKey's interestOps is done here instead of calling SelectionKey.interestOps(<interest op>). Factory methods. REVISIT: refactor into common base or delegate. REVISIT - no factoring so cheat to avoid code dup right now. REVISIT **** COUPLING !!!! SocketOrChannelAcceptor BEGIN Legacy support LegacyServerSocketEndPointInfo and EndPointInfo Kluge alert: Work and Legacy both define getName. Try to make this behave best for most cases. END Legacy support/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/transport/SocketOrChannelConnectionImpl.javaserverRequestMap/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/transport/SocketOrChannelConnectionImpl.class".read->: ".read->: ".read<-: ".read<-: ".readBits->: ".readBits->: "SocketOrChannelConnectionImpl.readBits"SocketOrChannelConnectionImpl.readBits".readBits: ".readBits: ": ThreadDeath: ": ThreadDeath: ": purgeCalls: Throwable: ": purgeCalls: Throwable: ": Throwable: ": Throwable: ": sendMessageError: IOException: ": sendMessageError: IOException: ".readBits<-: ".readBits<-: ".finishReadingBits->: ".finishReadingBits->: "SocketOrChannelConnectionImpl.finishReadingBits"SocketOrChannelConnectionImpl.finishReadingBits".finishReadingBits: ".finishReadingBits: ".finishReadingBits<-: ".finishReadingBits<-: ".dispatch: ThreadDeath".dispatch: ThreadDeath".dispatch: purgeCalls: Throwable".dispatch: purgeCalls: Throwable".dispatch: Throwable".dispatch: Throwable".dispatch: sendMessageError: IOException".dispatch: sendMessageError: IOExceptionmax_wait_time".read: got ByteBuffer id (".read: got ByteBuffer id (bbsbbbmsg".read: releasing ByteBuffer id (".read: releasing ByteBuffer id (bytecounttime_to_waittotal_time_in_wait"End-of-stream"End-of-stream"readFully(): unexpected exception "readFully(): unexpected exception ".close->: ".close->: ".close: isBusy so no close: ".close: isBusy so no close: ".close: exception: ".close: exception: ".close<-: ".close<-: ".closeConnectionResources->: ".closeConnectionResources->: ".closeConnectionResources: ".closeConnectionResources: ".closeConnectionResources<-: ".closeConnectionResources<-: "*****SocketOrChannelConnectionImpl.createOutputObject - should not be called."*****SocketOrChannelConnectionImpl.createOutputObject - should not be called.timestateString".writeLock->: ".writeLock->: localState".writeLock: OPENING InterruptedException: ".writeLock: OPENING InterruptedException: ".writeLock: ESTABLISHED InterruptedException: ".writeLock: ESTABLISHED InterruptedException: ".writeLock: default: ".writeLock: default: ".writeLock: bad state".writeLock: bad state".writeLock<-: ".writeLock<-: ".writeUnlock->: ".writeUnlock->: ".writeUnlock<-: ".writeUnlock<-: ".doWork<-: ".doWork<-: shouldReadHeaderOnly"OPENING"OPENING"CLOSE_SENT"CLOSE_SENT"CLOSE_RECVD"CLOSE_RECVD"ABORT"ABORT"???"???dielockHeldminor_codecompletion_status".purgeCalls->: ".purgeCalls->: ".purgeCalls: exiting since state is: ".purgeCalls: exiting since state is: ".purgeCalls: SystemException".purgeCalls: SystemException"; continuing "; continuing ".purgeCalls: Exception closing socket: ".purgeCalls: Exception closing socket: ".purgeCalls<-: ".purgeCalls<-: "SocketOrChannelConnectionImpl[" + " "SocketOrChannelConnectionImpl[ "SocketOrChannelConnectionImpl"SocketOrChannelConnectionImpl New transport. protected for test: genericRPCMSGFramework.IIOPConnection constructor. From iiop.Connection.java The socket used for this connection. Start at some value other than zero since this is a magic value in some protocols. Server request map: used on the server side of Connection Maps request ID to IIOPInputStream. This is a flag associated per connection telling us if the initial set of sending contexts were sent to the receiver already... Remote reference to CodeBase server (supplies FullValueDescription, among other things) CodeBase cache for this connection.  This will cache remote operations, handle connecting, and ensure we don't do any remote operations until necessary. transport read timeout values A message mediator used when shouldReadGiopHeaderOnly is true to maintain request message state across execution in a SelectorThread and WorkerThread. Used in genericRPCMSGFramework test. Both client and servers. Client constructor. Client-side convenience. Server-side constructor. Server-side convenience framework.transport.Connection Null can happen when client closes stream causing purgecalls. REVISIT - use common factory base class. REVISIT - make sure reader thread is killed. Notify anyone waiting.keepRunning = false; REVISIT - if this is called after purgeCalls then the state of the socket is ABORT so the writeLock in close throws an exception.  It is ignored but causes IBM (screen scraping) tests to fail.close(); This call is the transition from the tranport block to the protocol block. The reading of data incorporates a strategy to detect a rogue client. The strategy is implemented as follows. As long as data is being read, at least 1 byte or more, we assume we have a well behaved client. If no data is read, then we sleep for a time to wait, re-calculate a new time to wait which is lengthier than the previous time spent waiting. Then, if the total time spent waiting does not exceed a maximum time we are willing to wait, we attempt another read. If the maximum amount of time we are willing to spend waiting for more data is exceeded, we throw an IOException. NOTE: Reading of GIOP headers are treated with a smaller       maximum time to wait threshold. Based on extensive       performance testing, all GIOP headers are being       read in 1 read access. ignore exception failed to read entire message To support non-channel connections.NOTE: cannot perform this test.  If one ask for aByteBuffer from the pool which is bigger than the sizeof ByteBuffers managed by the pool, then the pool willreturn a HeapByteBuffer.if (byteBuffer.hasArray()) {throw wrapper.unexpectedNonDirectByteBufferWithChannelSocket(); IMPORTANT: For non-blocking SocketChannels, there's no guarantee            all bytes are written on first write attempt. TimeStamp connection to indicate it has been used Note granularity of connection usage is assumed for now to be that of a IIOP packet.Note:it is possible for this to be called more than once REVISIT It will be good to have a read lock on the reader thread before we proceed further, to avoid the reader thread (server side) from processing requests. This avoids the risk that a new request will be accepted by ReaderThread while the ListenerThread is attempting to close this connection. we are busy! stop the reader without causing it to do purgeCallsException ex = new Exception();reader.stop(ex); // REVISIT NOTE: !!!!!! This does writeUnlock(). REVISIT - remove this method from Connection and all it subclasses. This is used by the GIOPOutputObject in order to throw the correct error when handling code sets. Can we determine if we are on the server side by other means?  XREVISIT REVISIT: ASSERTSets the writeLock for this connection.If the writeLock is already set by someone else, block till thewriteLock is released and can set by us.IMPORTANT: this connection's lock must be acquired beforesetting the writeLock and must be unlocked after setting the writeLock. Keep looping till we can set the writeLock. somebody has changed 'state' so be careful Loop back do not stay here too long if state != ESTABLISHED Bug 4752117 XXX Need to distinguish between client and server roles here probably. the connection has been closed or closing ==> throw rebind exception wake up one guy waiting to write Assumes the caller handles writeLock and writeUnlock Don't we need to check for CloseConnection here?  REVISIT XREVISIT - Shouldn't the MessageMediator be the one to handle writing the data here? Write the fragment/message REVISIT - no flush?socket.getOutputStream().flush();ADDED(Ram J) 10/13/2000 In the event of an IOException, trysending a CancelRequest for regular requests / locate requests Since IIOPOutputStream's msgheader is set only once, and not altered during sending multiple fragments, the original msgheader will always have the requestId. REVISIT This could be optimized to send a CancelRequest only if any fragments had been sent already.REVISIT: MOVE TO SUBCONTRACTMessage msg = os.getMessage();if (msg.getType() == Message.GIOPRequest ||msg.getType() == Message.GIOPLocateRequest) {GIOPVersion requestVersion = msg.getGIOPVersion();int requestId = MessageBase.getRequestId(msg);sendCancelRequest(requestVersion, requestId);} catch (IOException e2) {// most likely an abortive connection closure.// ignore, since nothing more can be done.if (orb.transportDebugFlag) { REVISIT When a send failure happens, purgeCalls() need to be called to ensure that the connection is properly removed from further usage (ie., cancelling pending requests with COMM_FAILURE with an appropriate minor_code CompletionStatus.MAY_BE). Relying on the IIOPOutputStream (as noted below) is not sufficient as it handles COMM_FAILURE only for the final fragment (during invoke processing). Note that COMM_FAILURE could happen while sending the initial fragments. Also the IIOPOutputStream does not properly close the connection. It simply removes the connection from the table. An orderly closure is needed (ie., cancel pending requests on the connection COMM_FAILURE as well. IIOPOutputStream will cleanup the connection info when it sees this exception. REVISIT - Reading of a GIOP header only is information           that should be passed into the constructor           from the SocketOrChannelConnection factory.    public Acceptor getAcceptor() - already defined above. IMPORTANT: Sanity checks on SelectionKeys such as            SelectorKey.isValid() should not be done            here. get the partialMessageMediator created by SelectorThread read remaining info needed in a MessageMediator spi.transport.CorbaConnection. IMPORTANT: Reader Threads must NOT read Giop header only. REVISIT - inteface defines isServer but already defined in higher interface. REVISIT: this is also defined in: com.sun.corba.se.spi.legacy.connection.ConnectionIt is possible for a Close Connection to have been* sent here, but we will not check for this. A "lazy"* Exception will be thrown in the Worker thread after the* incoming request has been processed even though the connection* is closed before the request is processed. This is o.k because* it is a boundary condition. To prevent it we would have to add* more locks which would reduce performance in the normal case. Negotiated code sets for char and wchar data Needs to be synchronized for the following case when the client doesn't send the code set context twice, and we have two threads in ServerRequestDispatcher processCodeSetContext. Thread A checks to see if there is a context, there is none, so     it calls setCodeSetContext, getting the synch lock. Thread B checks to see if there is a context.  If we didn't synch,     it might decide to outlaw wchar/wstring. Double check whether or not we need to do this If the client says it's negotiated a code set that isn't a fallback and we never said we support, then it has a bug. from iiop.IIOPConnection.java Map request ID to an InputObject. This is so the client thread can start unmarshaling the reply and remove it from the out_calls map while the ReaderThread can still obtain the input stream to give new fragments.  Only the ReaderThread touches the clientReplyMap, so it doesn't incur synchronization overhead. Can never be unset...Wake up the outstanding requests on the connection, and hand themCOMM_FAILURE exception with a given minor code.Also, delete connection from connection table andstop the reader thread.Note that this should only ever be called by the Reader thread forthis connection.The minor code for the COMM_FAILURE major code.Kill the reader thread (this thread) before exiting. If this invocation is a result of ThreadDeath caused by a previous execution of this routine, just exit. Grab the writeLock (freeze the calls) Mark the state of the connection and determine the request status Signal all threads with outstanding requests on this connection and give them the SystemException; REVISIT: Stop the reader thread Signal all the waiters of the writeLock. There are 4 types of writeLock waiters: 1. Send waiters: 2. SendReply waiters: 3. cleanUp waiters: 4. purge_call waiters:The following methods are for dealing with Connection cleaning forbetter scalability of servers in high network load conditions.************************************************************************Send a CancelRequest message. This does not lock the connection, so thecaller needs to ensure this method is called appropriately.- could be due to abortive connection closure. REVISIT: See comments in CDROutputObject constructor. Begin Code Base methods --------------------------------------- Set this connection's code base IOR.  The IOR comes from the SendingContext.  This is an optional service context, but all JavaSoft ORBs send it. The set and get methods don't need to be synchronized since the first possible get would occur during reading a valuetype, and that would be after the set. Sets this connection's code base IOR.  This is done after getting the IOR out of the SendingContext service context. Our ORBs always send this, but it's optional in CORBA. Get a CodeBase stub to use in unmarshaling.  The CachedCodeBase won't connect to the remote codebase unless it's necessary. End Code Base methods ----------------------------------------- set transport read thresholds Must be public - used in encoding./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/transport/SocketOrChannelContactInfoImpl.java"SocketConnections"SocketConnections"SocketOrChannelContactInfoImpl["SocketOrChannelContactInfoImpl["SocketOrChannelContactInfoImpl"SocketOrChannelContactInfoImpl/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/util/IdentityHashtable.java/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/utilcom.sun.corba.se.impl.util/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/util/IdentityHashtable.class/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/utilIdentityHashtableEntry[]0.75f0.75101taboldTablenewTableIdentityHashtable is a modified copy of the 1.1.6 Hashtable class whichdoes not rely on the hashCode() and equals() methods of the key or value;instead, it uses the System.identityHashcode() method and pointer comparison.In addition, all synchronization has been removed.The hash table data.The total number of entries in the hash table.Rehashes the table when count exceeds this threshold.The load factor for the hashtable.Constructs a new, empty hashtable with the specified initialcapacity and the specified load factor.the initial capacity of the hashtable.a number between 0.0 and 1.0.if the initial capacity is lessthan or equal to zero, or if the load factor is less thanor equal to zero.JDK1.0Constructs a new, empty hashtable with the specified initial capacityand default load factor.Constructs a new, empty hashtable with a default capacity and loadfactor.Returns the number of keys in this hashtable.the number of keys in this hashtable.Tests if this hashtable maps no keys to values.<code>true</code> if this hashtable maps no keys to values;Returns an enumeration of the keys in this hashtable.an enumeration of the keys in this hashtable.java.util.Enumerationjava.util.Hashtable#elements()Returns an enumeration of the values in this hashtable.Use the Enumeration methods on the returned object to fetch the elementssequentially.an enumeration of the values in this hashtable.java.util.Hashtable#keys()Tests if some key maps into the specified value in this hashtable.This operation is more expensive than the <code>containsKey</code>a value to search for.<code>true</code> if some key maps to the<code>value</code> argument in this hashtable;NullPointerExceptionif the value is <code>null</code>.java.util.Hashtable#containsKey(java.lang.Object)Tests if the specified object is a key in this hashtable.possible key.<code>true</code> if the specified object is a key in thishashtable; <code>false</code> otherwise.java.util.Hashtable#contains(java.lang.Object)Returns the value to which the specified key is mapped in this hashtable.a key in the hashtable.the value to which the key is mapped in this hashtable;<code>null</code> if the key is not mapped to any value inthis hashtable.java.util.Hashtable#put(java.lang.Object, java.lang.Object)Rehashes the contents of the hashtable into a hashtable with alarger capacity. This method is called automatically when thenumber of keys in the hashtable exceeds this hashtable's capacityand load factor.System.out.println("rehash old=" + oldCapacity + ", new=" + newCapacity + ", thresh=" + threshold + ", count=" + count);Maps the specified <code>key</code> to the specified<code>value</code> in this hashtable. Neither the key nor thevalue can be <code>null</code>.The value can be retrieved by calling the <code>get</code> methodwith a key that is equal to the original key.the hashtable key.the previous value of the specified key in this hashtable,or <code>null</code> if it did not have one.if the key or value is<code>null</code>.java.util.Hashtable#get(java.lang.Object) Make sure the value is not null Makes sure the key is not already in the hashtable. Rehash the table if the threshold is exceeded Creates the new entry.Removes the key (and its corresponding value) from thishashtable. This method does nothing if the key is not in the hashtable.the key that needs to be removed.the value to which the key had been mapped in this hashtable,or <code>null</code> if the key did not have a mapping.Clears this hashtable so that it contains no keys.Returns a rather long string representation of this hashtable.a string representation of this hashtable./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/util/IdentityHashtableEntry.java/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/util/IdentityHashtableEntry.classIdentityHashtableEntryIdentityHashtableEntry()IdentityHashtable collision list./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/util/IdentityHashtableEnumerator.javaIdentityHashtableEnumeratorIdentityHashtableEnumerator(com.sun.corba.se.impl.util.IdentityHashtableEntry[],boolean)/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/util/IdentityHashtableEnumerator.class"IdentityHashtableEnumerator"A hashtable enumerator class.  This class should remain opaqueto the client. It will use the Enumeration interface./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/util/JDKBridge.javaloadClassMloadClassM(java.lang.String,java.lang.String,boolean)/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/util/JDKBridge.classuseCodebaseOnlyUSE_CODEBASE_ONLY_KEYLOCAL_CODEBASE_KEY"java.rmi.server.codebase"java.rmi.server.codebase"java.rmi.server.useCodebaseOnly"java.rmi.server.useCodebaseOnly"1.2 VM"1.2 VMpropCopyright (c) 1995, 2004, Oracle and/or its affiliates. All rights reserved.Utility methods for doing various method calls which are usedby multiple classesGet local codebase System property (java.rmi.server.codebase).May be null or a space separated array of URLS.Return true if the system property "java.rmi.server.useCodebaseOnly"is set, false otherwise.the name of the classa space-separated array of urls at whicha ClassLoader who may be used tothrowsClassNotFoundException if class cannot be loaded.// If on 1.2, use a policy with all permissions.System.setSecurityManager (new javax.rmi.download.SecurityManager());String targetClass = "[[Lrmic.Typedef;";System.out.println("localCodebase =  "+localCodebase);System.out.println("Trying to load "+targetClass);Class clz = loadClass(targetClass,null,localCodebase);System.out.println("Loaded: "+clz);} catch (ClassNotFoundException e) {System.out.println("Caught "+e);Set the codebase and useCodebaseOnly properties. This is publiconly for test code.Set the default code base. This method is here onlyfor test code./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/util/JDKClassLoader.javaloadClass(java.lang.Class,java.lang.String)/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/util/JDKClassLoader.classclassCacheJDKClassLoaderJDKClassLoader()/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/util/JDKClassLoader$1.classaClassKNOWN_TO_FAIL/Library/Java/JavaVirtualMachines/jdk1.8.0_251.jdk/Contents/Home/jre/lib/rt.jar/com/sun/corba/se/impl/util/Library/Java/JavaVirtualMachines/jdk1.8.0_251.jdk/Contents/Home/jre/lib/rt.jar/com/sun/corba/se/impl/util/JDKClassLoader$JDKClassLoaderCache.classJDKClassLoaderCacheJDKClassLoaderCache()latestLoader/Library/Java/JavaVirtualMachines/jdk1.8.0_251.jdk/Contents/Home/jre/lib/rt.jar/com/sun/corba/se/impl/util/JDKClassLoader$JDKClassLoaderCache$CacheKey.classUtility method for crawling call stack to load class Maintain the same error semantics as Class.forName() It would be nice to bypass JDKClassLoader's attempts completely if it's known that the latest user defined ClassLoader will fail. Otherwise, we end up calling Class.forName here as well as in the next step in JDKBridge.  That can take a long time depending on the length of the classpath. Note: Looking at the only place in JDKBridge where this code is invoked, it is clear that aClass will always be null. See createKey for a description of what's involved Loading this class with the call stack loader isn't known to fail, so try to load it. Record that we failed to find the class with this particular loader.  This way, we won't waste time looking with this loader, again.Private cache implementation specific to JDKClassLoader. JDKClassLoader couldn't find the class with the located ClassLoader.  Note this in our cache so JDKClassLoader can abort early next time. Factory for a key (CacheKey is an implementation detail of JDKClassLoaderCache). A key currently consists of the class name as well as the latest user defined class loader, so it's fairly expensive to create. Determine whether or not this combination of class name and ClassLoader is known to fail. Synchronized WeakHashMap Cache result used to mark the caches when there is no way JDKClassLoader could succeed with the given key Key consisting of the class name and the latest user defined class loader Try to incorporate both class name and loader into the hashcode WeakHashMap may compare null keys I've made a decision to actually compare the loader references.  I don't want a case when two loader instances override their equals methods and only compare code base. This way, at worst, our performance will be slower, but we know we'll do the correct loading./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/util/ORBProperties.java"org.omg.CORBA.ORBClass=com.sun.corba.se.impl.orb.ORBImpl"org.omg.CORBA.ORBClass=com.sun.corba.se.impl.orb.ORBImpl"org.omg.CORBA.ORBSingletonClass=com.sun.corba.se.impl.orb.ORBSingleton"org.omg.CORBA.ORBSingletonClass=com.sun.corba.se.impl.orb.ORBSingletonpropFile Check if orb.properties exists Write properties to orb.properties/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/util/PackagePrefixChecker.javaPACKAGE_PREFIX/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/util/PackagePrefixChecker.class"org.omg.stub."org.omg.stub."java."java."net.jini."net.jini."net.jini"net.jini"jini."jini."jini"jini"javax."javax.PackagePrefixChecker provides static utility methods for getting package prefixes.M. Mortazavi || p.startsWith("com.sun.") || p.equals("com.sun")/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/util/RepositoryId.javareplace(java.lang.String,java.lang.String,java.lang.String)/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/util/RepositoryId.classdelete(java.lang.String,int,int)convertFromISOLatin1convertFromISOLatin1(java.lang.String)getIdFromHelpergetIdFromHelper(java.lang.Class)createHashStringcreateHashString(java.lang.Class)createHashString(java.io.Serializable)init(java.lang.String)RepositoryIdRepositoryId(java.lang.String)RepositoryId()ASCII_HEXkSpecialPrimitiveskSpecialCasesArrayPrefixkSpecialCasesClasseskSpecialCasesVersionskSpecialCasesStubValueskSpecialCasesRepIDskSpecialArrayTypeStringskExternalizableHashStrkInterfaceOnlyHashStrkInterfaceHashCodekSequencePrefixLengthkIDLPrefixLengthkValuePrefixLengthkArrayPrefixkCORBAPrefixkSequencePrefixkIDLClassnamePrefixkIDLNamePrefixkIDLPrefixkValuePrefixkSequenceKeywordactualSuidLongsuidLongdefinedInIdunqualifiedNamecompleteClassNameisIDLTypeisRMIValueTypeisSequenceversionStringisSupportedFormatrepStrToClassrepStrToByteArrayclassSeqToRepStrclassIDLToRepStrclassToRepStrdefaultServerURLIDL_IDENTIFIER_CHARS123456789L123456789"omg.org/"omg.org/"CORBA/"CORBA/"0000000000000000"0000000000000000"0000000000000001"00000000000000010x060x08"omg.org/CORBA/"omg.org/CORBA/"omg.org/CORBA/Any"omg.org/CORBA/AnyClass<ClassDesc>"javax.rmi.CORBA."javax.rmi.CORBA."CORBA.WStringValue"CORBA.WStringValueMap<String,String>Constructor<String>Class<? super String>TypeVariable<Class<String>>TypeVariable<Class<String>>[]"javax.rmi.CORBA.ClassDesc"javax.rmi.CORBA.ClassDescMap<String,Class<>>Constructor<Class<>>? super Class<>Class<? super Class<>>TypeVariable<Class<Class<>>>TypeVariable<Class<Class<>>>[]"CORBA.Object"CORBA.Object"org.omg.CORBA.WStringValue"org.omg.CORBA.WStringValue"javax/rmi/CORBA/"javax/rmi/CORBA/"java/lang/"java/lang/"java/io/"java/io/aRepIdsecondIndex"RepsitoryId must have the form <type>:<body>"RepsitoryId must have the form <type>:<body>"IDL::1.0"IDL::1.0repStrrepStrBytesspecialCaseclazzRepIDStrtargetRepidclazzRepid"Mismatched serialization UIDs : Source (Rep. ID"Mismatched serialization UIDs : Source (Rep. ID") = ") = " whereas Target (Rep. ID " whereas Target (Rep. ID "The repository ID is not of an RMI value type (Expected ID = "The repository ID is not of an RMI value type (Expected ID = "; Received ID = "; Received ID = actualLongdeclaredLongdeclaredrepidoriginalClazznumOfDimshelperClazzhexNumber"0x"0x"\\U"\U0xF000614400x0F0038400x00F00x000F"0000"0000toleftrightcodeBasePresenttypeInfochunkedEncodingvalue_tag0x000000010x00000006 Imports for using codebase URL to load classd11638 files in the same package, therefore remove their referenceimport com.sun.corba.se.impl.util.JDKBridge;import com.sun.corba.se.impl.util.IdentityHashtable; Legal IDL Identifier characters (1 = legal). Note that '.' (2E) is marked as legal even though it is not legal in IDL. This allows us to treat a fully qualified Java name with '.' package separators uniformly, and is safe because that is the only legal use of '.' in a Java name. 0 1 2 3  4 5 6 7  8 9 a b  c d e f 00-0f 10-1f 20-2f 30-3f 40-4f 50-5f 60-6f 70-7f 80-8f 90-9f a0-af b0-bf c0-cf d0-df e0-ef f0-ff Repository ID fragments Value tag utility methods and constants Public, well known repository IDs _REVISIT_ : A table structure with a good search routine for all of this would be more efficient and easier to maintain... String Any Class Anita4: convert to uppercase Object Sequence Serializable Externalizable Remote (The empty string is used for java.rmi.Remote)kSpecialCasesClasses.put(kRemoteTypeStr, java.rmi.Remote.class);Used to convert ascii to hex. bug fix for 4328952; to eliminate possibility of overriding this in a subclass. Interface Rep ID Strings Dummy arguments for getIdFromHelper method To create a RepositoryID, use code similar to the following: RepositoryId.cache.getId( id ); Special case for remote fix where Attempting to obtain a FullValueDescription for an RMI value type with a String field causes an exception. default if not explicitly specified we have a declared hash also actualSuid = suid.substring(pos); suid = suid.substring(0, pos-1); _REVISIT_ : Special case version failure ? This method will return the classname from the typestring OR if the classname turns out to be a special class "pseudo" name, then the matching real classname is returned. This method calls getClazzFromType() and falls back to the repStrToClass cache if no class was found.  It's used where any class matching the given repid is an acceptable result.Checks to see if the FullValueDescription should be retrieved.ThrowsIOException if suids do not match or if the repositoryIDis not an RMIValueType to avoid race condition where multiple threads could be accessing this method, and their access to the cache may be interleaved giving unexpected resultsObjectStreamClass osc = ObjectStreamClass.lookup(clazz);com.sun.corba.se.impl.io.ValueUtility.log("RepositoryId",mssg);Creates a repository ID for a sequence.  This is for expert users only asthis method assumes the object passed is an array.  If passed an objectthat is not an array, it will produce a rep id for a sequence of zerolength.  This would be an error.The Java object to create a repository ID forthat is not an array, it will produce a malformed rep id.The Java class to create a repository ID forCreates a repository ID for a normal Java Type.com.sun.corba.se.impl.io.TypeMismatchExceptionif ser implements theorg.omg.CORBA.portable.IDLEntity interface which indicates it is an IDL Value type.Creates a repository ID for an IDL Java Type.The IDL Value object to create a repository ID forThe major version numberThe minor version numberif ser does not implement theCreatea a repository ID for the type if it is either a java typeor an IDL type.The type to create rep. id forThe rep. id.Convert strings with illegal IDL identifier characters.Section 5.5.7 of OBV spec. We gotta convert. Have we already started? No, so get set up... Convert the character into the IDL escape syntax...Convert strings with ISO Latin 1 escape sequences back to original strings. Convert Hexadecimal/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/util/RepositoryIdCache.javasetCachessetCaches(com.sun.corba.se.impl.util.RepositoryIdCache)/Library/Java/JavaVirtualMachines/jdk1.8.0_251.jdk/Contents/Home/jre/lib/rt.jar/com/sun/corba/se/impl/util/RepositoryIdPool.classincreasePoolincreasePool(int)MAX_CACHE_SIZERepositoryIdPoolRepositoryIdPool()/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/util/RepositoryIdCache.class Really limited pool - in this case just creating several at a time... Pool managementif (cache.size() <= MAX_CACHE_SIZE)// _REVISIT_ This will not work w/out either thread tracing or weak references.  I am// betting that thread tracing almost completely negates benefit of reuse.  Until either// 1.2 only inclusion or proof to the contrary, I'll leave it this way...int numToReclaim = cache.size() / 2;Enumeration keys = cache.keys();Enumeration elements = cache.elements();for (int i = numToReclaim; i > 0; i--) {Object key = keys.nextElement();Object element = elements.nextElement();push(element);cache.remove(key);repId = pool.popId().init(key);/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/util/SUNVMCID.java0x535500001398079488The vendor minor code ID reserved for Sun by the OMG.All VMCIDs occupy the high order 20 bits.The vendor minor code ID reserved for Sun. This value is or'd withthe high order 20 bits of the minor code to produce the minor valuein a system exception./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/util/Utility.java/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/impl/util/Utility.classstubNameForCompilerstubNameForCompiler(java.lang.String,boolean)stubName(java.lang.String,boolean)loadStubAndUpdateCacheloadStubAndUpdateCache(javax.rmi.CORBA.Tie,com.sun.corba.se.spi.presentation.rmi.PresentationManager.StubFactory,java.lang.String,boolean)loadClassOfTypeloadClassOfType(java.lang.String,java.lang.String,java.lang.ClassLoader,java.lang.Class,java.lang.ClassLoader)loadTieloadTie(java.lang.Class)CACHE_MISSstubToTieCachetieToStubCachetieCache"_Stub"_Stub"_DynamicStub"_DynamicStub"Stub"Stub"_Tie"_TieconvertToStubokayremoteObjobjClassClass<PortableRemoteObject>theClassloadedClass"expectedTypeClassLoader not class loader of "  +
                    "expected Type."expectedTypeClassLoader not class loader of expected Type.relatedTyperelatedTypeClassLoader"relatedTypeClassLoader not class loader of relatedType."relatedTypeClassLoader not class loader of relatedType.? extends ValueFactoryClass<? extends ValueFactory>Map<String,? extends ValueFactory>ValueFactory[]? extends ValueFactory[]Constructor<? extends ValueFactory>? super ? extends ValueFactoryClass<? super ? extends ValueFactory>TypeVariable<Class<? extends ValueFactory>>TypeVariable<Class<? extends ValueFactory>>[]"DefaultFactory"DefaultFactoryfactoryClassonlyMostDerivedcachedstubDeltieIsStub? extends TieClass<? extends Tie>stubFactoryFactoryMap<String,? extends Tie>Tie[]? extends Tie[]Constructor<? extends Tie>? super ? extends TieClass<? super ? extends Tie>TypeVariable<Class<? extends Tie>>TypeVariable<Class<? extends Tie>>[]"Printing stack trace:"Printing stack trace:StubEntryStubEntry(org.omg.CORBA.Object,boolean)/Library/Java/JavaVirtualMachines/jdk1.8.0_251.jdk/Contents/Home/jre/lib/rt.jar/com/sun/corba/se/impl/util/StubEntry.classmostDerivedHandy class full of static functions.Ensure that stubs, ties, and implementation objectsare 'connected' to the runtime. Converts implementationobjects to a type suitable for sending on the wire.the ORB to connect to if obj is exported to IIOP.true if implementation types should beconverted to Stubs rather than just org.omg.CORBA.Object.the connected object.if obj is an implementationwhich has not been exported. The stub could not be connected because it has an invalid IOR... This is an implementation object which has not been exported to IIOP OR is a JRMP stub or implementation object which cannot be marshalled into an ORB stream... Didn't need to do anything, just return the input...Get a new instance of an RMI-IIOP Tie for thegiven server object. Have we tried to find this guy before? No, so try it... First try the classname... If we don't have a valid tie at this point, walk up the parent chain until we either load a tie or encounter PortableRemoteObject or java.lang.Object... Did we get it? Nope, so cache that fact... Yes, so cache it... Yes, return a new instance or fail again if it was a miss last time...Load an RMI-IIOP TieClear the stub/tie caches. Intended for use bytest code.Load a class and check that it is assignable to a given type.@param className the class name.@param remoteCodebase the codebase to use. May be null.@param loader the class loader of last resort. May be null.@param expectedType the expected type. May be null.@return the loaded class.Sequence finding of the stubs according to specIf-else is put here for speed up of J2EE.According to the OMG spec, the if clause is not dead code.It can occur if some compiler has allowed generationinto org.omg.stub hierarchy for non-offendingclasses. This will encourage people toproduce non-offending class stubs in their own hierarchy. If no class was loaded, or if the loaded class is not of the correct type, make a further attempt to load the correct class using the classloader of the expected type. _REVISIT_ Is this step necessary, or should the Util,loadClassLoad a class and check that it is compatible with a given type.@param loadingContext the loading context. May be null.@param relatedType the related type. May be null. If no class was not loaded, or if the loaded class is not of the using the classloader of the related type.Get the helper for an IDLValueThrows MARSHAL exception if no helper found. no repId or unrecognized repIdGet the factory for an IDLValueThrows MARSHAL exception if no factory found. Try other way if earlier search found a non-default factory, or the same default factory that loadClassForClass would return, bale out now...Load an RMI-IIOP Stub given a Tie.@param tie the tie.@param stubClass the stub class. May be null.@param onlyMostDerived if true, will fail if cannot load a stub for thefirst repID in the tie. If false, will walk all repIDs.@return the stub or null if not found. Do we already have it cached? No, so go try to load it... Yes, is it a stub?  If not, it was a miss last time, so return null again... It's a stub. Does the cached stub meet the requirements of the caller? If the caller does not require the most derived stub and does not require a specific stub type, we don't have to check any further because the cached type is good enough... We must reload because we do not have the most derived cached already... The stubFactory arg must be null here to force onlyMostDerived=true to work We do not have exactly the right stub. First, try to upgrade the cached stub by forcing it to the most derived stub... If that failed, try again with the exact type we need... Use the cached stub. Is the delegate set? No, so set it if we can...Load an RMI-IIOP Stub given a Tie, but do not look in the cache.This method must be called with the lock held for tieToStubCache.@param stubFactory the stub factory. May be null.@return the StubEntry or null if not found. This will throw an exception if the tie is not a Servant.  XXX Handle this better? Now walk all the RepIDs till we find a stub or fail... Stub == null, so cache the miss... The tie does not have a delegate set, so stash this tie away using the stub as a key so that later, when the stub is connected, we can find and connect the tie as well... Tie extends Servant Exception is caught because of any of the following reasons 1) POA is not associated with the TIE 2) POA Policies for the tie-associated POA    does not support _this_object() call. Update the cache...If we loadStub(Tie,...) stashed away a tie which wasnot connected, remove it from the cache and returnit.Remove any cached Stub for the given tie.Remove cached tie/servant pair.Convert a RepId to a stubName... Convert the typeid to a RepositoryId instance, get the className and mangle it as needed...Load an RMI-IIOP Stub.  This is used in PortableRemoteObject.narrow. Get the codebase from the delegate to use when loading the new stub, if possible... We can't assume that narrowFrom is a CORBA_2_3 stub, yet it may have a 2_3 Delegate that provides a codebase.  Swallow the ClassCastException otherwise.Load an RMI-IIOP Stub class.  This is used in theStaticStubFactoryFactory code. Get the repID and check for "" special case. We should never be called with it (See CDRInputStream and the loadStub() method)... Get the stubname from the repID and load the class. If we have a valid 'sender', fall back to using its codebase if we need to...Create an RMI stub name.Create an RMI tie name.Create an IDL stub name.Read an object reference from the input stream and narrowit to the desired type.the stream to read from.Read an abstract interface type from the input stream and narrow/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/impl/util/Version.java"RMI-IIOP"RMI-IIOP/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/internal/CosNaming/BootstrapServer.java/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/internal/CosNaming/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/internalcom.sun.corba.se.internal.CosNaming/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/internal/CosNaming/BootstrapServer.class/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/internal/CosNaming/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/internalpropertiesFilenamelresfrescressres"-InitialServicesFile"-InitialServicesFile"bootstrap.usage"bootstrap.usage"BootstrapServer""bootstrap.filenotreadable"bootstrap.filenotreadable"bootstrap.success"bootstrap.success"This should not happen"This should not happenClass BootstrapServer is the main entry point for the bootstrap serverimplementation.  The BootstrapServer makes all object referencesdefined in a configurable file available using the oldnaming bootstrap protocol.Main startup routine for the bootstrap server.It first determines the port on which to listen, checks that thespecified file is available, and then creates the resolverthat will be used to service the requests in theBootstrapServerRequestDispatcher.the command-line arguments to the main program. Process arguments Look for the filename Was the initial port specified? If so, override This property normally is applied for the client side configuration of resolvers.  Here we are using it to define the server port that the with which the resolvers communicate. Create a file Verify that if it exists, it is readable Success: start up Use the SERVER_PORT to create an Acceptor using the old legacy code in ORBConfiguratorImpl.  When (if?) the legacy support is removed, this code will need to create an Acceptor directly. This causes the acceptors to start listening./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/internal/Interceptors/PIORB.java/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/internal/Interceptorscom.sun.corba.se.internal.InterceptorsDeprecated class for backward compatibility./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/internal/POA/POAORB.java/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/internal/POAcom.sun.corba.se.internal.POA/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/internal/corba/ORBSingleton.java/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/internal/corbacom.sun.corba.se.internal.corba/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/internal/iiop/ORB.java/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/internal/iiopcom.sun.corba.se.internal.iiopCopyright (c) 1995, 2003, Oracle and/or its affiliates. All rights reserved.1.4 value: com.sun.corba.se.internal.corba.ORB Class ORB/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/org/omg/CORBA/ORB.java/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/org/omg/CORBA/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/org/omg/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/orgcom.sun.corba.se.org.omg.CORBAThis ORB class is defined to provide a home for theregister_initial_reference operation, which is added byportable interceptors and CORBA 2.4.  It is added hereuntil there is an official Java language mapping for the/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/pept/broker/Broker.java/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/pept/broker/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/peptcom.sun.corba.se.pept.broker/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/pept/encoding/InputObject.java/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/pept/encodingcom.sun.corba.se.pept.encoding<p> An <code>InputObject</code> is the interface used by thepresentation block to get programming language typed data from dataencoded in a message. </p><p> The implementation of an <code>InputObject</code> contains theencoded data.  When the presentation block asks for data theimplementation of <code>InputObject</code> is responsible for convertingthe encoded representation of the data to the types expected by theprogramming language.</p><p>A particular <em>encoding</em> would subclass<code>InputObject</code>.  The subclass would provide methods to getthe data types appropriate to the presentation block (e.g., simpletypes such as int or boolean, all the way to any type derived from<code>java.io.Serializable</code>.).</p><p>Note: the protocol block may also use the <code>InputObject</code> toobtain header metadata.</p>/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/pept/encoding/OutputObject.java<p> An <code>OutputObject</code> is the interface used by thepresentation block to give programming language typed data tothe encoding block to be encoded and sent in a message. </p><p> The implementation of an <code>OutputObject</code> contains theencoded data.  When the presentation block gives programming languagetyped data to<code>OutputObject</code>, theimplementation of <code>OutputObject</code> is responsible for convertingthat data to the encoded representation of the data for a particularencoding.</p><code>OutputObject</code>.  The subclass would provide methods to set<p>Note: the protocol block may also use the <code>OutputObject</code> toset header metadata.</p>/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/pept/protocol/ClientDelegate.java/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/pept/protocolcom.sun.corba.se.pept.protocol<p>The presentation block interacts with the PEPt architecturevia the <code>ClientDelegate</code>.</p>The {@link com.sun.corba.se.pept.broker.Broker Broker} associatedwith an invocation.{@link com.sun.corba.se.pept.broker.Broker Broker}Get the{@link com.sun.corba.se.pept.transport.ContactInfoList ContactInfoList}which represents they encoding/protocol/transport combinations thatmay be used to contact the service./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/pept/protocol/ClientInvocationInfo.java/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/pept/protocol/ClientRequestDispatcher.java<code>ClientRequestDispatcher</code> coordinates the request (and possibleresponse) processing for a specific <em>protocol</em>.At the beginning of a request the presentation block uses thisto obtain an{@link com.sun.corba.se.pept.encoding.OutputObject OutputObject}to set data to be sent on a message.- the remote method name- <code>true</code> if the message is asynchronous- the{@link com.sun.corba.se.pept.transport.ContactInfo ContactInfo}which which created/chose this <code>ClientRequestDispatcher</code>After the presentation block has set data on theit signals the PEPt runtime to send the encoded data by calling this{@link com.sun.corba.se.pept.encoding.InputObject InputObject}if the message is synchronous.{@link org.omg.CORBA.portable.ApplicationException ApplicationException}if the remote side raises an exception declared in the remote interface.{@link org.omg.CORBA.portable.RemarshalException RemarshalException}if the PEPt runtime would like the presentation block to start over. REVISIT EXCEPTIONSAfter the presentation block completes a request it signalsthe PEPt runtime by calling this method.This method may release resources.  In some cases it may causecontrol or error messages to be sent./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/pept/protocol/MessageMediator.java<code>MessageMediator</code> is a central repository for artifactsassociated with an individual message.which created this <code>MessageMediator</code>.{@link com.sun.corba.se.pept.transport.Connection Connection}on which this message is sent or received.Used to initialize message headers.Note: this should be moved to a <code>RequestDispatcher</code>.Used to send the message (or its last fragment).Used to wait for a response for synchronous messages.Used to set theused for the message.Used to get the/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/pept/protocol/ProtocolHandler.java<code>ProtocolHandler</code> is used to determine thetype of an incoming message. REVISIT - return typeThis method determines the type of an incoming message anddispatches it appropriately.For example, on the server side, it may find a{@link com.sun.corba.se.pept.protocol.ServerRequestDispatcherServerRequestDispatcher} to handle the request.  On the client-sideit may signal a waiting thread to handle a reply.deprecated/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/pept/protocol/ServerRequestDispatcher.java<code>ServerRequestDispatcher</code> coordinates the request (and possibleThis method coordinates the processing of a message receivedon the server side.For example, this may involve finding an "object adapter" whichwould return Ties/Servants to handle the request./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/pept/transport/Acceptor.java/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/pept/transportcom.sun.corba.se.pept.transport<p>The <b><em>primary</em></b> PEPt server-side plug-in point and enablerfor <b><em>altenate encodings, protocols and transports</em></b>.</p><p><code>Acceptor</code> is a <em>factory</em> for client-sideartifacts used to receive a message (and possibly send a response).</p>Used to initialize an <code>Acceptor</code>.For example, initialization may mean to create a{@link java.nio.channels.ServerSocketChannel ServerSocketChannel}.Note: this must be prepared to be be called multiple times.<code>true</code> when it performs initializatinactions (typically the first call.Used to determine if an <code>Acceptor</code> has been initialized.<code>true</code. if the <code>Acceptor</code> has beenPEPt uses separate caches for each type of <code>Acceptor</code>as given by <code>getConnectionCacheType</code>.{@link java.lang.String}Set the{@link com.sun.corba.se.pept.transport.Inbound.ConnectionCache InboundConnectionCache}to be used by this <code>Acceptor</code>.as given by {@link #getConnectionCacheType}.{@link #setConnectionCache} and {@link #getConnectionCache} supportan optimzation to avoid hashing to find that cache.connectionCache.used by this <code>Acceptor</code>{@link com.sun.corba.se.pept.transport.ConnectionCache ConnectionCache}Used to determine if the <code>Acceptor</code> should registerwith{@link com.sun.corba.se.pept.transport.Selector Selector}to handle accept events.For example, this may be <em>false</em> in the case of Solaris Doorswhich do not actively listen.<code>true</code> if the <code>Acceptor</code> should beregistered withAccept a connection request.This is called either when the selector gets an accept eventfor this <code>Acceptor</code> or by a{@link com.sun.corba.se.pept.transport.ListenerThread ListenerThread}.It results in abeing created.Close the <code>Acceptor</code>.{@link com.sun.corba.se.pept.transport.EventHandler EventHandler}associated with this <code>Acceptor</code>. Factory methods REVISIT: Identical to ContactInfo method.  Refactor into base interface.Used to get a{@link com.sun.corba.se.pept.protocol.MessageMeidator MessageMediator}to hold internal data for a message received using the specificencoding, protocol, transport combination represented by this<code>Acceptor</code>.Used to finish creating ato with internal data for a message received using the specific{@link com.sun.corba.se.pept.protocol.MessageMediator MessageMediator}for the specific <em>encoding</em> represented by this Usage dictates implementation equals and hashCode./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/pept/transport/ByteBufferPool.javatheSize/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/pept/transport/Connection.java<p><code>Connection</code> represents a <em>transport</em> in thePEPt architecture.</p>Used to determine if the <code>Connection</code> should registerwith the{@link com.sun.corba.se.pept.transport.TransportManagerTransportManager}to handle read events.For example, an HTTP transport would not register since the requestingthread would just block on read when waiting for the reply.<code>true</code> if it should be registered. REVISIT - why special?Called to read incoming messages.<code>true</code> if the thread calling read can be released.Close the <code>Connection</code>. REVISIT: replace next two with PlugInFactory (implemented by ContactInfo and Acceptor).{@link com.sun.corba.se.pept.transport.Acceptor Acceptor}that created this <code>Connection</code>.Indicates whether aor acreated the<code>Connection</code>.<code>true</code> if <code>Connection</code> ancreated the <code>Connection</code>.Indicates if the <code>Connection</code> is in the process ofsending or receiving a message.<code>true</code> if the <code>Connection</code> is busy.Timestamps are used for connection management, in particular, forreclaiming idle <code>Connection</code>s.the "time" the <code>Connection</code> was last used.- the "time" the <code>Connection</code> was last used.The "state" of the <code>Connection</code>.param stateGrab a write lock on the <code>Connection</code>.If another thread already has a write lock then the callingthread will block until the lock is released.  The callingthread must call{@link #writeUnlock}when it is done.Release a write lock on the <code>Connection</code>.Send the data encoded inon the <code>Connection</code>.@param outputObjectRegister an invocation'swith the <code>Connection</code>.This is useful in protocols which support fragmentation.If a message expect's a response then this method is called.This method might block on a read (e.g., HTTP), put the callingthread to sleep while another thread read's the response (e.g., GIOP),or it may use the calling thread to perform the server-side work(e.g., Solaris Doors).Unregister an invocation's/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/pept/transport/ConnectionCache.javaClose all connections in the connection cache.This is used as a final cleanup, and will resultin abrupt termination of any pending communications./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/pept/transport/ContactInfo.java<p>The <b><em>primary</em></b> PEPt client-side plug-in point and enabler<p><code>ContactInfo</code> is a <em>factory</em> for client-sideartifacts usedto construct and send a message (and possibly receive and process aresponse).</p>The parent{@link com.sun.corba.se.pept.broker.ContactInfoList ContactInfoList}for this <code>ContactInfo</code>.{@link com.sun.corba.se.pept.protocol.ClientRequestDispatcherClientRequestDispatcher}used to handle the specific <em>protocol</em> represented by this<code>ContactInfo</code>.Used to determine if awill be present in an invocation.For example, it may be<code>false</code> in the case of shared-memory<code>Input/OutputObjects</code>.<code>true</code> if awill be used for an invocation.Used to determine if theused for a request should be cached.If <code>true</code> then PEPt will attempt to reuse an existing{@link com.sun.corba.se.pept.transport.Connection Connection}. Ifone is not found it will create a new one and cache it for future use.<code>true</code> if{@link com.sun.corba.se.pept.transport.Connection Connection}screated by this <code>ContactInfo</code> should be cached.PEPt uses separate caches for each type of <code>ContactInfo</code>{@link com.sun.corba.se.pept.transport.Outbound.ConnectionCache OutboundConnectionCache}to be used by this <code>ContactInfo</code>.used by this <code>ContactInfo</code>to send and receive messages on the specific <em>transport</em>represented by this <code>ContactInfo</code>.to hold internal data for a message to be sent using the specificwith internal data for a message received using the specificUsed to lookup artifacts associated with this <code>ContactInfo</code>.the hash value./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/pept/transport/ContactInfoList.java<p> <code>ContactInfoList</code> contains one or more{@link com.sun.corba.se.pept.transport.ContactInfo ContactInfo}.{@link com.sun.corba.se.pept.transport.ContactInfoListIteratorContactInfoListIterator} to retrieve individualfrom the list.ContactInfoListIterator}./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/pept/transport/ContactInfoListIterator.java<code>ContactInfoIterator</code> is used to retrieve individualThe underlying list for this iterator.Used to report information to the iterator to be usedin future invocations.obtained from this iterator which resulted in a successful invocation.in effect when an invocation exception occurs.{@link java.lang.RuntimeException RuntimeException}.Returns true if the request should be retried.The exception to report to the presentation block.If the iterator reaches the end before the invocationis successful one returns this exception (previously reported tothe iterator via {@link #reportException})./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/pept/transport/EventHandler.javaThis should only be registered with ONE selector. NOTE: if there is more than one interest op this does not allow discrimination between different ops and how threading is handled. REVISIT: need base class with two derived./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/pept/transport/InboundConnectionCache.java/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/pept/transport/ListenerThread.java/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/pept/transport/OutboundConnectionCache.java/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/pept/transport/ReaderThread.java/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/pept/transport/ResponseWaitingRoom.java REVISIT: maybe return void (or MessageMediator)./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/pept/transport/Selector.javaeventHander/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/pept/transport/TransportManager.java/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/activation/Activator.java/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/activation/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spicom/sun/corba/se/spi/activation/Activator.java .from /jenkins/workspace/8-2-build-macosx-x86_64/jdk8u251/737/corba/src/share/classes/com/sun/corba/se/spi/activation/activation.idl/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/activation/ActivatorHelper.java/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/spi/activation/ActivatorHelper.class/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/spi/activation/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/spi"IDL:activation/Activator:1.0"IDL:activation/Activator:1.0com/sun/corba/se/spi/activation/ActivatorHelper.java ./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/activation/ActivatorHolder.javacom/sun/corba/se/spi/activation/ActivatorHolder.java ./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/activation/ActivatorOperations.javacom/sun/corba/se/spi/activation/ActivatorOperations.java . A new ORB started server registers itself with the Activator Install a particular kind of endpoint list active servers If the server is not running, start it up. If the server is running, shut it down currently running, this method will activate it. list all registered ORBs for a server After this hook completes, the server may still be running./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/activation/BadServerDefinition.javacom/sun/corba/se/spi/activation/BadServerDefinition.java ./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/activation/BadServerDefinitionHelper.java/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/spi/activation/BadServerDefinitionHelper.class"IDL:activation/BadServerDefinition:1.0"IDL:activation/BadServerDefinition:1.0com/sun/corba/se/spi/activation/BadServerDefinitionHelper.java ./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/activation/BadServerDefinitionHolder.javacom/sun/corba/se/spi/activation/BadServerDefinitionHolder.java ./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/activation/EndPointInfo.javacom/sun/corba/se/spi/activation/EndPointInfo.java ./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/activation/EndPointInfoHelper.java/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/spi/activation/EndPointInfoHelper.class"IDL:activation/EndPointInfo:1.0"IDL:activation/EndPointInfo:1.0com/sun/corba/se/spi/activation/EndPointInfoHelper.java ./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/activation/EndPointInfoHolder.javacom/sun/corba/se/spi/activation/EndPointInfoHolder.java ./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/activation/EndpointInfoListHelper.java/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/spi/activation/EndpointInfoListHelper.class"IDL:activation/EndpointInfoList:1.0"IDL:activation/EndpointInfoList:1.0com/sun/corba/se/spi/activation/EndpointInfoListHelper.java ./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/activation/EndpointInfoListHolder.javacom/sun/corba/se/spi/activation/EndpointInfoListHolder.java ./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/activation/IIOP_CLEAR_TEXT.javacom/sun/corba/se/spi/activation/IIOP_CLEAR_TEXT.java . to avoid a compilation dependency./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/activation/InitialNameService.javacom/sun/corba/se/spi/activation/InitialNameService.java ./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/activation/InitialNameServiceHelper.java/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/spi/activation/InitialNameServiceHelper.class"IDL:activation/InitialNameService:1.0"IDL:activation/InitialNameService:1.0com/sun/corba/se/spi/activation/InitialNameServiceHelper.java ./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/activation/InitialNameServiceHolder.javacom/sun/corba/se/spi/activation/InitialNameServiceHolder.java ./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/activation/InitialNameServiceOperations.javacom/sun/corba/se/spi/activation/InitialNameServiceOperations.java . bind initial name/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/activation/InitialNameServicePackage/NameAlreadyBound.java/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/activation/InitialNameServicePackagecom.sun.corba.se.spi.activation.InitialNameServicePackagecom/sun/corba/se/spi/activation/InitialNameServicePackage/NameAlreadyBound.java ./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/activation/InitialNameServicePackage/NameAlreadyBoundHelper.java/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/spi/activation/InitialNameServicePackage/NameAlreadyBoundHelper.class/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/spi/activation/InitialNameServicePackage"IDL:activation/InitialNameService/NameAlreadyBound:1.0"IDL:activation/InitialNameService/NameAlreadyBound:1.0com/sun/corba/se/spi/activation/InitialNameServicePackage/NameAlreadyBoundHelper.java ./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/activation/InitialNameServicePackage/NameAlreadyBoundHolder.javacom/sun/corba/se/spi/activation/InitialNameServicePackage/NameAlreadyBoundHolder.java ./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/activation/InvalidORBid.javacom/sun/corba/se/spi/activation/InvalidORBid.java ./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/activation/InvalidORBidHelper.java/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/spi/activation/InvalidORBidHelper.class"IDL:activation/InvalidORBid:1.0"IDL:activation/InvalidORBid:1.0com/sun/corba/se/spi/activation/InvalidORBidHelper.java ./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/activation/InvalidORBidHolder.javacom/sun/corba/se/spi/activation/InvalidORBidHolder.java ./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/activation/Locator.javacom/sun/corba/se/spi/activation/Locator.java ./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/activation/LocatorHelper.java/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/spi/activation/LocatorHelper.class"IDL:activation/Locator:1.0"IDL:activation/Locator:1.0com/sun/corba/se/spi/activation/LocatorHelper.java ./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/activation/LocatorHolder.javacom/sun/corba/se/spi/activation/LocatorHolder.java ./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/activation/LocatorOperations.javacom/sun/corba/se/spi/activation/LocatorOperations.java . Starts the server if it is not already running. get the port for the endpoint of the locator to pick a particular port type./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/activation/LocatorPackage/ServerLocation.java/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/activation/LocatorPackagecom.sun.corba.se.spi.activation.LocatorPackagecom/sun/corba/se/spi/activation/LocatorPackage/ServerLocation.java . class ServerLocation/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/activation/LocatorPackage/ServerLocationHelper.java/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/spi/activation/LocatorPackage/ServerLocationHelper.class/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/spi/activation/LocatorPackage"IDL:activation/Locator/ServerLocation:1.0"IDL:activation/Locator/ServerLocation:1.0"ServerLocation"ServerLocationcom/sun/corba/se/spi/activation/LocatorPackage/ServerLocationHelper.java ./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/activation/LocatorPackage/ServerLocationHolder.javacom/sun/corba/se/spi/activation/LocatorPackage/ServerLocationHolder.java ./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/activation/LocatorPackage/ServerLocationPerORB.javacom/sun/corba/se/spi/activation/LocatorPackage/ServerLocationPerORB.java ./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/activation/LocatorPackage/ServerLocationPerORBHelper.java/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/spi/activation/LocatorPackage/ServerLocationPerORBHelper.class"IDL:activation/Locator/ServerLocationPerORB:1.0"IDL:activation/Locator/ServerLocationPerORB:1.0com/sun/corba/se/spi/activation/LocatorPackage/ServerLocationPerORBHelper.java ./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/activation/LocatorPackage/ServerLocationPerORBHolder.javacom/sun/corba/se/spi/activation/LocatorPackage/ServerLocationPerORBHolder.java ./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/activation/NoSuchEndPoint.javacom/sun/corba/se/spi/activation/NoSuchEndPoint.java ./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/activation/NoSuchEndPointHelper.java/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/spi/activation/NoSuchEndPointHelper.class"IDL:activation/NoSuchEndPoint:1.0"IDL:activation/NoSuchEndPoint:1.0com/sun/corba/se/spi/activation/NoSuchEndPointHelper.java ./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/activation/NoSuchEndPointHolder.javacom/sun/corba/se/spi/activation/NoSuchEndPointHolder.java ./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/activation/ORBAlreadyRegistered.javacom/sun/corba/se/spi/activation/ORBAlreadyRegistered.java ./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/activation/ORBAlreadyRegisteredHelper.java/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/spi/activation/ORBAlreadyRegisteredHelper.class"IDL:activation/ORBAlreadyRegistered:1.0"IDL:activation/ORBAlreadyRegistered:1.0com/sun/corba/se/spi/activation/ORBAlreadyRegisteredHelper.java ./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/activation/ORBAlreadyRegisteredHolder.javacom/sun/corba/se/spi/activation/ORBAlreadyRegisteredHolder.java ./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/activation/ORBPortInfo.javacom/sun/corba/se/spi/activation/ORBPortInfo.java ./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/activation/ORBPortInfoHelper.java/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/spi/activation/ORBPortInfoHelper.class"IDL:activation/ORBPortInfo:1.0"IDL:activation/ORBPortInfo:1.0com/sun/corba/se/spi/activation/ORBPortInfoHelper.java ./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/activation/ORBPortInfoHolder.javacom/sun/corba/se/spi/activation/ORBPortInfoHolder.java ./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/activation/ORBPortInfoListHelper.java/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/spi/activation/ORBPortInfoListHelper.class"IDL:activation/ORBPortInfoList:1.0"IDL:activation/ORBPortInfoList:1.0com/sun/corba/se/spi/activation/ORBPortInfoListHelper.java ./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/activation/ORBPortInfoListHolder.javacom/sun/corba/se/spi/activation/ORBPortInfoListHolder.java ./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/activation/ORBidHelper.java/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/spi/activation/ORBidHelper.class"IDL:activation/ORBid:1.0"IDL:activation/ORBid:1.0com/sun/corba/se/spi/activation/ORBidHelper.java . issue resolved./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/activation/ORBidListHelper.java/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/spi/activation/ORBidListHelper.class"IDL:activation/ORBidList:1.0"IDL:activation/ORBidList:1.0com/sun/corba/se/spi/activation/ORBidListHelper.java ./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/activation/ORBidListHolder.javacom/sun/corba/se/spi/activation/ORBidListHolder.java ./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/activation/POANameHelper.java/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/spi/activation/POANameHelper.class"IDL:activation/POAName:1.0"IDL:activation/POAName:1.0"POAName"POANamecom/sun/corba/se/spi/activation/POANameHelper.java ./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/activation/POANameHolder.javacom/sun/corba/se/spi/activation/POANameHolder.java ./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/activation/Repository.javacom/sun/corba/se/spi/activation/Repository.java ./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/activation/RepositoryHelper.java/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/spi/activation/RepositoryHelper.class"IDL:activation/Repository:1.0"IDL:activation/Repository:1.0com/sun/corba/se/spi/activation/RepositoryHelper.java ./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/activation/RepositoryHolder.javacom/sun/corba/se/spi/activation/RepositoryHolder.java ./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/activation/RepositoryOperations.javacom/sun/corba/se/spi/activation/RepositoryOperations.java . always uninstalled. unregister server definition get server definition Return whether the server has been installed if the server is currently marked as installed. if the server is currently marked as uninstalled. list registered servers servers. Find the ServerID associated with the given application name./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/activation/RepositoryPackage/ServerDef.java/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/activation/RepositoryPackagecom.sun.corba.se.spi.activation.RepositoryPackagecom/sun/corba/se/spi/activation/RepositoryPackage/ServerDef.java ./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/activation/RepositoryPackage/ServerDefHelper.java/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/spi/activation/RepositoryPackage/ServerDefHelper.class/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/spi/activation/RepositoryPackage"IDL:activation/Repository/ServerDef:1.0"IDL:activation/Repository/ServerDef:1.0com/sun/corba/se/spi/activation/RepositoryPackage/ServerDefHelper.java ./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/activation/RepositoryPackage/ServerDefHolder.javacom/sun/corba/se/spi/activation/RepositoryPackage/ServerDefHolder.java ./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/activation/RepositoryPackage/StringSeqHelper.java/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/spi/activation/RepositoryPackage/StringSeqHelper.class"IDL:activation/Repository/StringSeq:1.0"IDL:activation/Repository/StringSeq:1.0"StringSeq"StringSeqcom/sun/corba/se/spi/activation/RepositoryPackage/StringSeqHelper.java ./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/activation/RepositoryPackage/StringSeqHolder.javacom/sun/corba/se/spi/activation/RepositoryPackage/StringSeqHolder.java ./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/activation/Server.javacom/sun/corba/se/spi/activation/Server.java .Server callback API, passed to Activator in active method. interface Server/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/activation/ServerAlreadyActive.javacom/sun/corba/se/spi/activation/ServerAlreadyActive.java ./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/activation/ServerAlreadyActiveHelper.java/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/spi/activation/ServerAlreadyActiveHelper.class"IDL:activation/ServerAlreadyActive:1.0"IDL:activation/ServerAlreadyActive:1.0com/sun/corba/se/spi/activation/ServerAlreadyActiveHelper.java ./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/activation/ServerAlreadyActiveHolder.javacom/sun/corba/se/spi/activation/ServerAlreadyActiveHolder.java ./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/activation/ServerAlreadyInstalled.javacom/sun/corba/se/spi/activation/ServerAlreadyInstalled.java ./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/activation/ServerAlreadyInstalledHelper.java/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/spi/activation/ServerAlreadyInstalledHelper.class"IDL:activation/ServerAlreadyInstalled:1.0"IDL:activation/ServerAlreadyInstalled:1.0com/sun/corba/se/spi/activation/ServerAlreadyInstalledHelper.java ./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/activation/ServerAlreadyInstalledHolder.javacom/sun/corba/se/spi/activation/ServerAlreadyInstalledHolder.java ./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/activation/ServerAlreadyRegistered.javacom/sun/corba/se/spi/activation/ServerAlreadyRegistered.java ./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/activation/ServerAlreadyRegisteredHelper.java/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/spi/activation/ServerAlreadyRegisteredHelper.class"IDL:activation/ServerAlreadyRegistered:1.0"IDL:activation/ServerAlreadyRegistered:1.0com/sun/corba/se/spi/activation/ServerAlreadyRegisteredHelper.java ./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/activation/ServerAlreadyRegisteredHolder.javacom/sun/corba/se/spi/activation/ServerAlreadyRegisteredHolder.java ./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/activation/ServerAlreadyUninstalled.javacom/sun/corba/se/spi/activation/ServerAlreadyUninstalled.java ./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/activation/ServerAlreadyUninstalledHelper.java/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/spi/activation/ServerAlreadyUninstalledHelper.class"IDL:activation/ServerAlreadyUninstalled:1.0"IDL:activation/ServerAlreadyUninstalled:1.0com/sun/corba/se/spi/activation/ServerAlreadyUninstalledHelper.java ./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/activation/ServerAlreadyUninstalledHolder.javacom/sun/corba/se/spi/activation/ServerAlreadyUninstalledHolder.java ./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/activation/ServerHeldDown.javacom/sun/corba/se/spi/activation/ServerHeldDown.java ./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/activation/ServerHeldDownHelper.java/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/spi/activation/ServerHeldDownHelper.class"IDL:activation/ServerHeldDown:1.0"IDL:activation/ServerHeldDown:1.0com/sun/corba/se/spi/activation/ServerHeldDownHelper.java ./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/activation/ServerHeldDownHolder.javacom/sun/corba/se/spi/activation/ServerHeldDownHolder.java ./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/activation/ServerHelper.java/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/spi/activation/ServerHelper.class"IDL:activation/Server:1.0"IDL:activation/Server:1.0"Server"Servercom/sun/corba/se/spi/activation/ServerHelper.java ./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/activation/ServerHolder.javacom/sun/corba/se/spi/activation/ServerHolder.java ./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/activation/ServerIdHelper.java/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/spi/activation/ServerIdHelper.class"IDL:activation/ServerId:1.0"IDL:activation/ServerId:1.0com/sun/corba/se/spi/activation/ServerIdHelper.java ./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/activation/ServerIdsHelper.java/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/spi/activation/ServerIdsHelper.class"IDL:activation/ServerIds:1.0"IDL:activation/ServerIds:1.0com/sun/corba/se/spi/activation/ServerIdsHelper.java ./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/activation/ServerIdsHolder.javacom/sun/corba/se/spi/activation/ServerIdsHolder.java ./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/activation/ServerManager.javacom/sun/corba/se/spi/activation/ServerManager.java ./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/activation/ServerManagerHelper.java/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/spi/activation/ServerManagerHelper.class"IDL:activation/ServerManager:1.0"IDL:activation/ServerManager:1.0com/sun/corba/se/spi/activation/ServerManagerHelper.java ./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/activation/ServerManagerHolder.javacom/sun/corba/se/spi/activation/ServerManagerHolder.java ./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/activation/ServerManagerOperations.javacom/sun/corba/se/spi/activation/ServerManagerOperations.java ./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/activation/ServerNotActive.javacom/sun/corba/se/spi/activation/ServerNotActive.java ./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/activation/ServerNotActiveHelper.java/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/spi/activation/ServerNotActiveHelper.class"IDL:activation/ServerNotActive:1.0"IDL:activation/ServerNotActive:1.0com/sun/corba/se/spi/activation/ServerNotActiveHelper.java ./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/activation/ServerNotActiveHolder.javacom/sun/corba/se/spi/activation/ServerNotActiveHolder.java ./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/activation/ServerNotRegistered.javacom/sun/corba/se/spi/activation/ServerNotRegistered.java ./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/activation/ServerNotRegisteredHelper.java/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/spi/activation/ServerNotRegisteredHelper.class"IDL:activation/ServerNotRegistered:1.0"IDL:activation/ServerNotRegistered:1.0com/sun/corba/se/spi/activation/ServerNotRegisteredHelper.java ./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/activation/ServerNotRegisteredHolder.javacom/sun/corba/se/spi/activation/ServerNotRegisteredHolder.java ./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/activation/ServerOperations.javacom/sun/corba/se/spi/activation/ServerOperations.java . interface ServerOperations/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/activation/TCPPortHelper.java/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/spi/activation/TCPPortHelper.class"IDL:activation/TCPPort:1.0"IDL:activation/TCPPort:1.0com/sun/corba/se/spi/activation/TCPPortHelper.java ./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/activation/_ActivatorImplBase.java/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/spi/activation/_ActivatorImplBase.class"active""registerEndpoints"registerEndpointscom/sun/corba/se/spi/activation/_ActivatorImplBase.java . activation/Activator/active activation/Activator/registerEndpoints activation/Activator/getActiveServers activation/Activator/activate activation/Activator/shutdown activation/Activator/install activation/Activator/getORBNames activation/Activator/uninstall/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/activation/_ActivatorStub.java/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/spi/activation/_ActivatorStub.classcom/sun/corba/se/spi/activation/_ActivatorStub.java . active registerEndpoints/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/activation/_InitialNameServiceImplBase.java/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/spi/activation/_InitialNameServiceImplBase.classcom/sun/corba/se/spi/activation/_InitialNameServiceImplBase.java . activation/InitialNameService/bind/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/activation/_InitialNameServiceStub.java/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/spi/activation/_InitialNameServiceStub.classcom/sun/corba/se/spi/activation/_InitialNameServiceStub.java ./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/activation/_LocatorImplBase.java/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/spi/activation/_LocatorImplBase.classcom/sun/corba/se/spi/activation/_LocatorImplBase.java . activation/Locator/locateServer activation/Locator/locateServerForORB activation/Locator/getEndpoint activation/Locator/getServerPortForType/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/activation/_LocatorStub.java/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/spi/activation/_LocatorStub.classcom/sun/corba/se/spi/activation/_LocatorStub.java ./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/activation/_RepositoryImplBase.java/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/spi/activation/_RepositoryImplBase.classcom/sun/corba/se/spi/activation/_RepositoryImplBase.java . activation/Repository/registerServer activation/Repository/unregisterServer activation/Repository/getServer activation/Repository/isInstalled activation/Repository/install activation/Repository/uninstall activation/Repository/listRegisteredServers activation/Repository/getApplicationNames activation/Repository/getServerID/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/activation/_RepositoryStub.java/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/spi/activation/_RepositoryStub.classcom/sun/corba/se/spi/activation/_RepositoryStub.java ./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/activation/_ServerImplBase.java/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/spi/activation/_ServerImplBase.classcom/sun/corba/se/spi/activation/_ServerImplBase.java . activation/Server/shutdown activation/Server/install activation/Server/uninstall class _ServerImplBase/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/activation/_ServerManagerImplBase.java/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/spi/activation/_ServerManagerImplBase.classcom/sun/corba/se/spi/activation/_ServerManagerImplBase.java ./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/activation/_ServerManagerStub.java/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/spi/activation/_ServerManagerStub.classcom/sun/corba/se/spi/activation/_ServerManagerStub.java ./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/activation/_ServerStub.java/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/spi/activation/_ServerStub.classcom/sun/corba/se/spi/activation/_ServerStub.java . class _ServerStub/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/copyobject/CopierManager.java/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/copyobjectcom.sun.corba.se.spi.copyobjectManager of ObjectCopier implementations used to support javax.rmi.CORBA.Util.copyObject(s).This provides simple methods for registering all supported ObjectCopier factories.A default copier is also supported, for use in contexts where no specific copier idis available.Set the Id of the copier to use if no other copier has been set.Return the copier for the default copier id.  Throws a BAD_PARAM exceptionif no default copier id has been set.Register an ObjectCopierFactory under a particular id.  This can be retrievedlater by getObjectCopierFactory./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/copyobject/CopyobjectDefaults.javareferenceObjectCopierFactory/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/spi/copyobject/CopyobjectDefaults.class/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/spi/copyobjectreferenceObjectCopierCopyobjectDefaultsCopyobjectDefaults()/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/spi/copyobject/CopyobjectDefaults$3.classmakemake()/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/spi/copyobject/CopyobjectDefaults$1.class/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/spi/copyobject/CopyobjectDefaults$2.classf1/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/spi/copyobject/CopyobjectDefaults$4.classObtain the ORB stream copier factory.  Note that this version behaves differentlythan the others: each ObjectCopier produced by the factory only preserves aliasingwithin a single call to copy.  The others copiers all preserve aliasing acrossall calls to copy (on the same ObjectCopier instance).Obtain the reference object "copier".  This does no copies: it justreturns whatever is passed to it.Create a fallback copier factory from the two ObjectCopierFactoryarguments.  This copier makes an ObjectCopierFactory that createsinstances of a fallback copier that first tries an ObjectCopiercreated from f1, then tries one created from f2, if the firstthrows a ReflectiveCopyException./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/copyobject/ObjectCopier.javaProvides an interface for a variety of means to copy an arbitraryobject.  Any implementation of this interface must return an exactcopy of obj, preserving all aliasing across all objects reachablefrom obj.  ReflectiveCopyException must be thrown if the implementationcannot copy obj for some reason.  Note that a trivial implementationof this interface is possible (always return obj), but this is oftennot the desired implementation./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/copyobject/ObjectCopierFactory.javaObjectCopier factory interface used for registration.Create a new instance of an ObjectCopier./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/copyobject/ReflectiveCopyException.java/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/encoding/CorbaInputObject.java/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/encodingcom.sun.corba.se.spi.encoding/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/encoding/CorbaOutputObject.java/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/extension/CopyObjectPolicy.java/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/extensioncom.sun.corba.se.spi.extension/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/spi/extension/CopyObjectPolicy.class/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/spi/extension"CopyObjectPolicy["CopyObjectPolicy[Policy used to specify the copyObject implementation to use./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/extension/RequestPartitioningPolicy.java/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/spi/extension/RequestPartitioningPolicy.class"RequestPartitioningPolicy["RequestPartitioningPolicy[Policy used to support the request partitioning feature and tospecify the partition to use./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/extension/ServantCachingPolicy.javaServantCachingPolicyServantCachingPolicy(int)/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/spi/extension/ServantCachingPolicy.classminimalPolicyinfoOnlyPolicy"FULL"FULL"INFO_ONLY"INFO_ONLY"MINIMAL"MINIMAL"ServantCachingPolicy["ServantCachingPolicy[Policy used to implement servant caching optimization in the POA.Creating a POA with an instance pol of this policy wherepol.getType() &gt; NO_SERVANT_CACHING will cause the servant to belooked up in the POA and cached in the LocalClientRequestDispatcher whenthe ClientRequestDispatcher is colocated with the implementation of theobjref.  This greatly speeds up invocations at the cost of violating thePOA semantics.  In particular, every request to a particular objrefmust be handled by the same servant.  Note that this is typically thecase for EJB implementations.If servant caching is used, there are two different additionalfeatures of the POA that are expensive:<ol><li>POA current semantics<li>Proper handling of POA destroy.POA current semantics requires maintaining a ThreadLocal stack ofinvocation information that is always available for POACurrent operations.Maintaining this stack is expensive on the timescale of optimized co-locatedcalls, so the option is provided to turn it off.  Similarly, causingPOA.destroy() calls to wait for all active calls in the POA to completerequires careful tracking of the entry and exit of invocations in the POA.Again, tracking this is somewhat expensive.Do not cache servants in the ClientRequestDispatcher.  This willalways support the full POA semantics, including changing theservant that handles requests on a particular objref.Perform servant caching, preserving POA current and POA destroy semantics.We will use this as the new default, as the app server is making heavier usenow of POA facilities.Perform servant caching, preservent only POA current semantics.At least this level is required in order to support selection of ObjectCopiersfor co-located RMI-IIOP calls, as the current copier is stored inOAInvocationInfo, which must be present on the stack inside the call.Perform servant caching, not preserving POA current or POA destroy semantics.Return the default servant caching policy./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/extension/ZeroPortPolicy.javaZeroPortPolicyZeroPortPolicy(boolean)/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/spi/extension/ZeroPortPolicy.class"ZeroPortPolicy["ZeroPortPolicy[Policy used to implement zero IIOP port policy in the POA./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/ior/EncapsulationFactoryBase.java/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/iorcom.sun.corba.se.spi.ior/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/spi/ior/EncapsulationFactoryBase.class/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/spi/ior/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/ior/IOR.javaOnly instances of TaggedProfile are contained in the list.Return the type id string from the IOR.Return an iterator that iterates over tagged profiles withidentifier id.  It is not possible to modify the list through thisiterator.Return a representation of this IOR in the standard GIOP stringifiedformat that begins with "IOR:".Return a representation of this IOR in the standard GIOP marshalledform.Return true if this IOR has no profiles.Return true if this IOR is equivalent to ior.  Here equivalent meansthat the typeids are the same, they have the same number of profiles,and each profile is equivalent to the corresponding profile.Return the IORTemplate for this IOR.  This is simply a listof all TaggedProfileTemplates derived from the TaggedProfilesof the IOR./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/ior/IORFactories.javaIORFactoriesIORFactories()/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/spi/ior/IORFactories.classortortivf/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/spi/ior/IORFactories$1.classread_value(org.omg.CORBA_2_3.portable.InputStream)/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/spi/ior/IORFactories$2.classThis class provides a number of factory methods for creatingvarious IOR SPI classes which are not subclassed for specific protocols.The following types must be created using this class:<li>ObjectId</li><li>ObjectKey</li><li>IOR</li><li>IORTemplate</li>Create an ObjectId for the given byte sequence.Create an ObjectKey for the given ObjectKeyTemplate andObjectId.Create an empty IOR for the given orb and typeid.  The result is mutable.Create an empty IOR for the given orb with a null typeid.  The result is mutable.Read an IOR from an InputStream.  ObjectKeys are not shared.Create an IORTemplate with the given ObjectKeyTemplate.  The resultis mutable.Read an IORTemplate from an InputStream.This method must be called in order to register the valuefactories for the ObjectReferenceTemplate and ObjectReferenceFactoryvalue types. Create and register the factory for the Object Reference Template implementation. Create and register the factory for the Object Reference Factory/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/ior/IORFactory.javaAn IORFactory provides the capability of creating IORs.  It containssome collection of TaggedProfileTemplates, which can be iterated overfor portable interceptors.Construct an IOR containing the given ORB, typeid, and ObjectId.The same ObjectId will be used for all TaggedProfileTemplates inthe IORFactory.Return true iff this.makeIOR(orb,typeid,oid).isEquivalent(other.makeIOR(orb,typeid,oid) for all orb, typeid, and oid./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/ior/IORTemplate.javaAn IORTemplate provides all of the data necessary to create an IOR exceptfor the typeId and ObjectId.  It is a list of TaggedProfileTemplates.Iterate over all TaggedProfileTemplates in this IORTemplatewith the given id./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/ior/IORTemplateList.javaAn IORTemplateList is a list of IORTemplate instances.  It can be used to create IORs.This is useful for representing IORs made of profiles from different objectadapters.Note that any IORFactory can be added to an IORTemplateList, but it is flattenedso that the result is just a list of IORTemplate instances./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/ior/IORTypeCheckRegistry.java/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/ior/Identifiable.javaThis interface represents an entity that can be written to anOutputStream and has an identity that is represented by an integer.This identity is essentially the type of the entity, and is used inorder to know how to read the entity back from an InputStream.Return the (type) identity of this entity./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/ior/IdentifiableBase.javaProvide support for properly reading and writing Identifiable objectsthat are also encapsulations (tagged profiles and components).Write the data for this object as a CDR encapsulation.This is used for writing tagged components and profiles.These data types must be written out as encapsulations,which means that we need to first write the data out toan encapsulation stream, then extract the data and writeit to os as an array of octets./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/ior/IdentifiableContainerBase.java/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/spi/ior/IdentifiableContainerBase$1.classadvanceadvance()ideConvenience class for defining objects that contain lists of Identifiables.Mainly implements iteratorById.  Also note that the constructor creates thelist, which here is always an ArrayList, as this is much more efficient overallfor short lists.Create this class with an empty list of identifiables.The current implementation uses an ArrayList.Return an iterator which iterates over all contained Identifiableswith type given by id./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/ior/IdentifiableFactory.javaFactory interface for creating Identifiables.Return the id of this factory, which is the id of the resultof any create call.Construct the appropriate Identifiable object with thegiven id from the InputStream is./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/ior/IdentifiableFactoryFinder.javaInterface used to manage a group of related IdentifiableFactory instances.Factories can be registered, and invoked through a create method, whichmust be implemented to handle the case of no registered factoryappropriately.If there is a registered factory for id, use it toread an Identifiable from is.  Otherwise create anappropriate generic container, or throw an error.The type of generic container, or error behavior isa property of the implementation.Register a factory for the given id./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/ior/MakeImmutable.java/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/ior/ObjectAdapterId.javaThis is the object adapter ID for an object adapter.Typically this is the path of strings starting from theRoot POA to get to a POA, but other implementations are possible.Return the number of elements in the adapter ID.Return an iterator that iterates over the componentsof this adapter ID.  Each element is returned as a String.Get the adapter name simply as an array of strings./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/ior/ObjectId.java/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/ior/ObjectKey.javaThe full object key, which is contained in an IIOPProfile.The object identifier corresponds to the information passed intoPOA::create_reference_with_id and POA::create_reference(in the POA case).  The templaterepresents the information that is object adapter specific andshared across multiple ObjectKey instances.Return the object identifier for this Object key.Return the template for this object key./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/ior/ObjectKeyFactory.javaConstruct ObjectKey and ObjectKeyTemplate instances from theirCDR-marshalled representation.Create an ObjectKey from its octet sequence representation.Create an ObjectKeyTemplate from its representationin an InputStream./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/ior/ObjectKeyTemplate.javaAn ObjectKeyTemplate represents the part of an Object Keythat corresponds to the object adapter used to create anobject reference.  The template is shared between manyobject references.An ID used to determine how to perform operations on thisObjectKeyTemplate.  This id determines how to process requestson this object reference, and what object adapter type to use.Return the server ID for this template.For CORBA 3.0, this should be a String, but it is currentlyan int in the object key template.Return the ORB ID for this template.Return the object adapter ID for this template.Compute an adapter ID for this template than includesall of the template information.This value is cached to avoid the expense of recomputing/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/ior/TaggedComponent.javaGeneric interface for all tagged components.  Users of the ORB maycreate implementations of this class and also corresponding factoriesof type TaggedComponentFactory.  The factories can be registered with anORB instance, in which case they will be used to unmarshal IORs containingthe registered tagged component./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/ior/TaggedComponentBase.javaBase class to use for implementing TaggedComponents.  It implementsthe getIOPComponent method using the TaggedComponent.write() method./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/ior/TaggedComponentFactoryFinder.javaCreate a tagged component from a GIOP marshalled representationof a tagged component.  This is needed for portable interceptors./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/ior/TaggedProfile.javaTaggedProfile represents a tagged profile in an IOR.A profile contains all of the information necessary for an invocation.It contains one or more endpoints that may be used for an invocation.A TaggedProfile conceptually has three parts: A TaggedProfileTemplate,an ObjectKeyTemplate, and an ObjectId.Return true is prof is equivalent to this TaggedProfile.This means that this and prof are indistinguishable forthe purposes of remote invocation.  Typically this means thatthe profile data is identical and both profiles contain exactlythe same components (if components are applicable).isEquivalent( prof ) should imply that getObjectId().equals(prof.getObjectId() ) is true, and so isgetObjectKeyTemplate().equals( prof.getObjectKeyTemplate() ).Return the TaggedProfile as a CDR encapsulation in the standardformat.  This is required for Portable interceptors.Return true if this TaggedProfile was created in orb.Caches the result./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/ior/TaggedProfileTemplate.javaBase template for creating TaggedProfiles.  A TaggedProfile will often containtagged components.  A template that does not contain components acts likean empty immutable list.Return an iterator that iterates over tagged components withCreate a TaggedProfile from this template.Write the profile create( oktemp, id ) to the OutputStream os.Return true if temp is equivalent to this template.  Equivalencemeans that in some sense an invocation on a profile created by thistemplate has the same results as an invocation on a profilecreated from temp.  Equivalence may be weaker than equality.Return the tagged components in this profile (if any)in the GIOP marshalled form, which is required for PortableInterceptors.  Returns null if either the profile has nocomponents, or if this type of profile can never contain/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/ior/TaggedProfileTemplateBase.java/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/ior/WriteContents.java/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/ior/Writeable.javaThis interface represents an entity that can be written to an OutputStream.Write this object directly to the output stream./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/ior/iiop/AlternateIIOPAddressComponent.java/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/ior/iiopcom.sun.corba.se.spi.ior.iiop/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/ior/iiop/CodeSetsComponent.java/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/ior/iiop/GIOPVersion.java/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/spi/ior/iiop/GIOPVersion.class/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/spi/ior/iiop0x01000x01010x01020x0103majorBminorBdotIdx"GIOP major, minor, and decimal point required: "GIOP major, minor, and decimal point required: profVersiontargetOrbVersionprof_majorprof_minororb_majororb_minor Static fields Major version 13 indicates Java serialization, Minor version [00-FF] is the version number. General methodsThis chooses the appropriate GIOP version.the GIOP version 13.00 if Java serialization is enabled, orsmallest(profGIOPVersion, orbGIOPVersion) Check if the profile is from a legacy Sun ORB. we are dealing with a SUN legacy orb which emits 1.1 IORs, in spite of being able to handle only GIOP 1.0 messages. Now the target has to be (FOREIGN | NEWER*) both major version are the same/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/ior/iiop/IIOPAddress.javaIIOPAddress represents the host and port used to establish aTCP connection for an IIOP request./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/ior/iiop/IIOPFactories.javaIIOPFactoriesIIOPFactories()/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/spi/ior/iiop/IIOPFactories.class/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/spi/ior/iiop/IIOPFactories$1.classreadContentsreadContents(org.omg.CORBA_2_3.portable.InputStream)(int)/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/spi/ior/iiop/IIOPFactories$2.class/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/spi/ior/iiop/IIOPFactories$3.class/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/spi/ior/iiop/IIOPFactories$4.class/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/spi/ior/iiop/IIOPFactories$5.class/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/spi/ior/iiop/IIOPFactories$6.class/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/spi/ior/iiop/IIOPFactories$7.classcmp/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/spi/ior/iiop/IIOPFactories$8.class/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/spi/ior/iiop/IIOPFactories$9.classThis class provides all of the factories for the IIOP profiles andcomponents.  This includes direct construction of profiles and templates,as well as constructing factories that can be registered with anIdentifiableFactoryFinder./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/ior/iiop/IIOPProfile.javaIIOPProfile represents an IIOP tagged profile.It is essentially composed of an object identifier anda template.  The template contains all of theIIOP specific information in the profile.Templates are frequently shared between many different profiles,while the object identifiy is unique to each profile.Return the servant for this profile, if it is localAND if the OA that implements this objref supports direct access to servantsoutside of an invocation.XXX move this to the ObjectKeyTemplateReturn the GIOPVersion of this profile.  Caches the result.Return the Codebase of this profile.  Caches the result./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/ior/iiop/IIOPProfileTemplate.javaIIOPProfileTemplate represents the parts of an IIOPProfile that are independentof the object identifier.  It is a container of tagged components.Return the GIOP version of this profile.Return the IIOP address from the IIOP profile.  This is called theprimary address here since other addresses may be contained in/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/ior/iiop/JavaCodebaseComponent.java/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/ior/iiop/MaxStreamFormatVersionComponent.java/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/ior/iiop/ORBTypeComponent.java/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/ior/iiop/RequestPartitioningComponent.java/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/legacy/connection/Connection.java/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/legacy/connection/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/legacycom.sun.corba.se.spi.legacy.connectionThis interface represents the connection on which a request is made./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/legacy/connection/GetEndPointInfoAgainException.java/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/spi/legacy/connection/GetEndPointInfoAgainException.class/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/spi/legacy/connection/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/spi/legacyThis exception is raised by <code>ORBSocketFactory.createSocket</code>.It informs the ORB that it should call<code>ORBSocketFactory.getEndPointInfo</code> again with thegiven <code>socketInfo</code> object as an argument (i.e., a cookie)./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/legacy/connection/LegacyServerSocketEndPointInfo.java"DEFAULT_ENDPOINT"DEFAULT_ENDPOINT"BOOT_NAMING"BOOT_NAMING"NO_NAME"NO_NAMELegacyServerSocketEndPointInfo is an abstraction of a port.e.g.: "CLEAR_TEXT", "SSL", ...Get the host name of this end point. Subcontracts must use thisinstead of InetAddress.getHostName() because this would takeinto account the value of the ORBServerHost property.The ORBD's proxy port of this end point.Note: Pre-ORT "port-exchange" model. NAME is used while we still have a "port-exchange" ORBD to get what used to be called "default" or "bootstrap" endpoints./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/legacy/connection/LegacyServerSocketManager.java/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/legacy/connection/ORBSocketFactory.javaDEPRECATED.  DEPRECATED. DEPRECATED. DEPRECATED. <p>This interface gives one the ability to plug in their own socketfactory class to an ORB. <p>Usage: <p>One specifies a class which implements this interface via the<code>ORBConstants.SOCKET_FACTORY_CLASS_PROPERTY</code>property. <p>Example: <p>-Dcom.sun.CORBA.connection.ORBSocketFactoryClass=MySocketFactory</pre> <p>Typically one would use the same socket factory class on both theserver side and the client side (but this is not required). <p>A <code>ORBSocketFactory</code> class should have a public defaultconstructor which is called once per instantiating ORB.init call.That ORB then calls the methods of that <code>ORBSocketFactory</code>to obtain client and server sockets. <p>This interface also supports multiple server end points.  See thedocumentation on <code>createServerSocket</code> below.A server ORB always creates an "IIOP_CLEAR_TEXT" listening port.That port is put into IOP profiles of object references exportedby an ORB. <p>If<code>createServerSocket(String type, int port)</code>is passed <code>IIOP_CLEAR_TEXT</code> as a <code>type</code>argument it should then call and return<code>new java.net.ServerSocket(int port)</code> <p><code>createSocket(SocketInfo socketInfo)</code>is passed <code>IIOP_CLEAR_TEXT</code> in<code>socketInfo.getType()</code> it shouldthen call and returnnew java.net.Socket(socketInfo.getHost(),socketInfo.getPort())This method is used by a server side ORB. <p>When an ORB needs to create a listen socket on which connectionrequests are accepted it calls<code>createServerSocket(String type, int port)</code>.The type argument says which type of socket should be created. <p>The interpretation of the type argument is the responsibility ofan instance of <code>ORBSocketFactory</code>, except in the caseof <code>IIOP_CLEAR_TEXT</code>, in which case a standard serversocket should be created. <p>Multiple Server Port API: <p>In addition to the IIOP_CLEAR_TEXT listening port, it is possibleto specify that an ORB listen on additional port of specific types. <p>This API allows one to specify that an ORB should create an X,or an X and a Y listen socket. <p>If X, to the user, means SSL, then one just plugs in an SSLsocket factory. <p>Or, another example, if X and Y, to the user, means SSL withoutauthentication and SSL with authentication respectively, then theyplug in a factory which will either create an X or a Y socketdepending on the type given to<code>createServerSocket(String type, int port)</code>. <p>One specifies multiple listening ports (in addition to thedefault IIOP_CLEAR_TEXT port) using the<code>ORBConstants.LISTEN_SOCKET_PROPERTY</code>Example usage:<p>... \-Dcom.sun.CORBA.connection.ORBSocketFactoryClass=com.my.MySockFact \-Dcom.sun.CORBA.connection.ORBListenSocket=SSL:0,foo:1 \The meaning of the "type" (SSL and foo above) is controlledby the user. <p>ORBListenSocket is only meaningful for servers. <p>The property value is interpreted as follows.  For eachtype/number pair: <p>If number is 0 then use an emphemeral port for the listener ofthe associated type. <p>If number is greater then 0 use that port number. <p>An ORB creates a listener socket for each typespecified by the user by callingwith the type specified by the user. <p>After an ORB is initialized and the RootPOA has been resolved,it is then listening onall the end points which were specified.  It may be necessaryto add this additional end point information to object referencesexported by this ORB.  <p>Each object reference will contain the ORB's default IIOP_CLEAR_TEXTend point in its IOP profile.  To add additional end point information(i.e., an SSL port) to an IOR (i.e., an object reference) one needsto intercept IOR creation usingan <code>PortableInterceptor::IORInterceptor</code>. <p>Using PortableInterceptors (with a non-standard extension): <p>Register an <code>IORInterceptor</code>.  Inside its<code>establish_components</code> operation:com.sun.corba.se.spi.legacy.interceptor.IORInfoExt ext;ext = (com.sun.corba.se.spi.legacy.interceptor.IORInfoExt)info;int port = ext.getServerPort("myType");Once you have the port you may add information to referencescreated by the associated adapter by calling<code>IORInfo::add_ior_component</code><p> <p>Note: if one is using a POA and the lifespan policy of thatPOA is persistent then the port number returnedby <code>getServerPort</code> <em>may</em>be the corresponding ORBD port, depending on whether the POA/ORBDprotocol is the present port exchange or if, in the future,the protocol is based on object reference template exchange.In eithercase, the port returned will be correct for the protocol.(In more detail, if the port exchange protocol is used thengetServerPort will return the ORBD's port since the portexchange happens before, at ORB initialization.If object referenceexchange is used then the server's transient port will be returnedsince the templates are exchanged after adding components.) <p>Persistent object reference support: <p>When creating persistent object references with alternatetype/port info, ones needs to configure the ORBD to also supportthis alternate info.  This is done as follows: <p>- Give the ORBD the same socket factory you gave to the clientand server. <p>- specify ORBListenSocket ports of the same types that yourservers support.  You should probably specify explicit portnumbers for ORBD if you embed these numbers inside IORs. <p>Note: when using the port exchange protocolthe ORBD and servers will exchange portnumbers for each given type so they know about each other.When using object reference template exchange the server'stransient ports are contained in the template. <p>- specify your <code>BadServerIdHandler</code> (discussed below)using the<code>ORBConstants.BAD_SERVER_ID_HANDLER_CLASS_PROPERTY</code> <p>-Dcom.sun.CORBA.POA.ORBBadServerIdHandlerClass=corba.socketPersistent.MyBadServerIdHandlerThe <code>BadServerIdHandler</code> ...<p>See <code>com.sun.corba.se.impl.activation.ServerManagerImpl.handle</code>for example code on writing a bad server id handler.  NOTE:  Thisis an unsupported internal API.  It will not exist in future releases.Secure connections to other services: <p>If one wants secure connections to other services such asNaming then one should configure them with the same<code>SOCKET_FACTORY_CLASS_PROPERTY</code> and<code>LISTEN_SOCKET_PROPERTY</code>as used by other clients and servers in your distributed system. <p>This method is used by a client side ORB. <p>Each time a client invokes on an object reference, the reference'sassociated ORB will callgetEndPointInfo(ORB orb,IOR ior,SocketInfo socketInfo)NOTE: The type of the <code>ior</code> argument is an internalrepresentation for efficiency.  If the <code>ORBSocketFactory</code>interface ever becomes standardized then the <code>ior</code> willmost likely change to a standard type (e.g., a stringified ior,an <code>org.omg.IOP.IOR</code>, or ...). <p>Typically, this method will look at tagged components in thegiven <code>ior</code> to determine what type of socket to create. <p>Typically, the <code>ior</code> will contain a tagged componentspecifying an alternate port type and number.  <p>This method should return an <code>SocketInfo</code> objectcontaining the type/host/port to be used for the connection.If there are no appropriate tagged components then this methodshould return an <code>SocketInfo</code> object with the type<code>IIOP_CLEAR_TEXT</code> and host/port from the ior's IOPprofile. <p>If the ORB already has an existing connection to the returnedtype/host/port, then that connection is used.  Otherwise the ORB calls<code>createSocket(SocketInfo socketInfo)</code> <p>The <code>orb</code> argument is useful for handlingthe <code>ior</code> argument. <p>The <code>SocketInfo</code> given to <code>getEndPointInfo</code>is either null or an object obtainedfrom <code>GetEndPointInfoAgainException</code> <p>DEPRECATED.  DEPRECATED. DEPRECATED. DEPRECATED. <pThis method should return a client socket of the giventype/host/port. <p>Note: the <code>SocketInfo</code> is the same instance as wasreturned by <code>getSocketInfo</code> so extra cookie info maybe attached. <p>If this method throws GetEndPointInfoAgainException then theORB calls <code>getEndPointInfo</code> again, passing it the<code>SocketInfo</code> object contained in the exception. <p>/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/legacy/interceptor/IORInfoExt.java/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/legacy/interceptorcom.sun.corba.se.spi.legacy.interceptor/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/legacy/interceptor/ORBInitInfoExt.javaThe interface defines an extension to the standard ORBInitInfothat gives access to the ORB being initialized.  Interceptors runas the last stage of initialization of the ORB, so the ORBinstance returned by getORB is fully initialized.  Note thatthis facility eventually shows up post-CORBA 3.0 as a resultof the resolution of OMG core issue on accessing the ORB fromlocal objects./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/legacy/interceptor/RequestInfoExt.javaThis interface is implemented by our implementation ofPortableInterceptor.ClientRequestInfo andPortableInterceptor.ServerRequestInfo. <p>The return value will be null when a local transportis used./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/legacy/interceptor/UnknownType.java/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/logging/CORBALogDomains.java/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/loggingcom.sun.corba.se.spi.loggingCORBALogDomainsCORBALogDomains()/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/spi/logging/CORBALogDomains.class/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/spi/logging"javax.enterprise.resource.corba"javax.enterprise.resource.corba"rpc"rpc"rpc.presentation"rpc.presentation"rpc.encoding"rpc.encoding"rpc.protocol"rpc.protocol"rpc.transport"rpc.transport"naming"naming"naming.lifecycle"naming.lifecycle"naming.read"naming.read"naming.update"naming.update"orbd.locator"orbd.locator"orbd.activator"orbd.activator"orbd.repository"orbd.repository"orbd.servertool"orbd.servertool"orb""orb.lifecycle"orb.lifecycle"orb.resolver"orb.resolver"oa""oa.lifecycle"oa.lifecycle"oa.ior"oa.ior"oa.invocation"oa.invocation"rmiiiop"rmiiiop"rmiiiop.delegate"rmiiiop.delegate"util"Defines constants for all of the logging domains used in the ORB.Note that this is the suffix to the log domain.  The full domain is given by<code>javax.enterprise.resource.corba.{ORBId}.{Log domain}</code>where {ORBId} is the ORB ID of the ORB instance doing the logging.<P>The ORB implementation packages are mapped into these domains as follows:<li>activation: orbd.*<li>corba: rpc.presentation (CORBA API, typecode/any), oa.invocation (DII)<li>core: service context code in rpc.protocol (will eventually move to its own package)<li>dynamicany: rpc.presentation<li>encoding: rpc.encoding<li>iiop: rmiiop.delegate (ShutdownUtilDelegate needs to move somewhere)<li>interceptors: rpc.protocol<li>io: rpc.encoding<li>ior: oa.ior<li>javax: rmiiiop.delegate<li>logging: logging does not have a domain<li>naming: naming<li>oa: oa<li>orb: orb.lifecycle<li>orbutil: util<li>protocol: rpc.protocol<li>resolver: orb.resolver<li>transport: rpc.transport<li>txpoa: this will be removed in the future.<li>util: util Top level log domain for CORBALog domain for code directly implementing the CORBA API andthe typecode/any machinery.Log domain for any sort of wire encoding used in marshallingLog domain for the code used to handle any kind of invocationprotocol.  This includes client and server delegates, client andserver request dispatchers, service contexts, portable interceptors,and the GIOP protocol (but not CDR representation of data).Log domain for low-level transport details, which areindependent of encoding and presentation details.  Thisincludes selectors, acceptors, connections, connection management,and any other transport management functions.Log domain for naming context creation and destruction.Log domain for name service lookup.Log domain for name service bind, rebind, destroy, and other statechange operations.Log domain for the ORBD locator function, which forwardsclient requests to their current server incarnation.Log domain for the ORBD activator function, which startsserver instances on demand.Log domain for the Implementation Repository.Log domain for the servertool utilitiy used to update theimplementation repository.Log domain for ORB initialization, configuration, startup,and shutdown.Log domain for ORB client side name resolution and supportingfunctions such as INS.Log domain for creation, destruction, and state change ofObject Adapters and related classes (e.g. POAManager).Log domain for all IOR related code.Log domain for object adapter request dispatch.Log domain for the RMI-IIOP implementation in the Stub, Util, andPortableRemoteObject delegates.Log domain for utility classes./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/logging/LogWrapperBase.javainferCallerinferCaller(java.lang.Class,java.util.logging.LogRecord)/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/spi/logging/LogWrapperBase.classwrapperClasslrecframewcnamebaseNameClass<LogWrapperBase>Map<String,LogWrapperBase>LogWrapperBase[]Constructor<LogWrapperBase>? super LogWrapperBaseClass<? super LogWrapperBase>TypeVariable<Class<LogWrapperBase>>TypeVariable<Class<LogWrapperBase>>[]ix Private method to infer the caller's class and method names Get the stack trace. The top of the stack should always be a method in the wrapper class, or in this base class. Search back to the first method not in the wrapper class or this class. Set the class and method if we are not past the end of the stack trace/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/logging/LogWrapperFactory.java/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/monitoring/LongMonitoredAttributeBase.java/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/monitoringcom.sun.corba.se.spi.monitoringmaInfo</p>A Cleaner Abstraction to provide a Monitored Attribute of type 'Long'///////////////////////////////////// operationsConstructs LongMonitoredAttribute, by creating theMonitoredAttributeInfo with 'Long' as the class type.Users are expected to extend this class and provide the implementationfor getValue() and if needed clearState() as well.of tthe MonitoredAttributeof the Attribute, Please provid a well thought outdescription, so that the admin can make sense of the attribute supplied. end LongMonitoredAttributeBase/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/monitoring/MonitoredAttribute.javaMonitored Attribute is the interface to represent a MonitorableAttribute. Using this interface, one can get the value of the attributeand set the value if it is a writeable attribute.Gets the Monitored Attribute Info for the attribute.monitoredAttributeInfofor this Monitored Attribute.Sets the value for the Monitored Attribute if isWritable() is false, themethod will throw ILLEGAL Operation exception.Also, the type of 'value' should be same as specified in theMonitoredAttributeInfo for a particular instance.should be any one of the Basic Java Type Objects which areLong, Double, Float, String, Integer, Short, Character, Byte.Gets the value of the Monitored Attribute. The value can be obtainedfrom different parts of the module. User may choose to delegate the callto getValue() to other variables.NOTE: It is important to make sure that the type of Object returned ingetvalue is same as the one specified in MonitoredAttributeInfo for thisattribute.is the current value for this MonitoredAttributeGets the name of the Monitored Attribute.of this AttributeIf this attribute needs to be cleared, the user needs to implement thismethod to reset the state to initial state. If the Monitored Attributedoesn't change like for example (ConnectionManager High Water Mark),then clearState() is a No Op. end MonitoredAttribute/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/monitoring/MonitoredAttributeBase.javasetMonitoredAttributeInfosetMonitoredAttributeInfo(com.sun.corba.se.spi.monitoring.MonitoredAttributeInfo)/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/spi/monitoring/MonitoredAttributeBase.class/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/spi/monitoringMonitoredAttributeBaseMonitoredAttributeBase(java.lang.String)attributeInfo"The Attribute "The Attribute " is not Writable..." is not Writable..."The method implementation is not provided for the attribute "The method implementation is not provided for the attribute A Convenient class provided to help users extend and implement onlygetValue(), if there is no need to clear the state and the attribute is notwritable.Constructor.A Package Private Constructor for internal use only.A Package Private convenience method for setting MonitoredAttributeInfoIf the concrete class decides not to provide the implementation of thismethod, then it's OK. Some of the  examples where we may decide to notprovide the implementation is the connection state. Irrespective ofthe call to clearState, the connection state will be showing thecurrect state of the connection.NOTE: This method is only used to clear the Monitored Attribute state,not the real state of the system itself.This method should be implemented by the concrete class.This method should be implemented by the concrete class only if theattribute is writable. If the attribute is not writable and if thismethod called, it will result in an IllegalStateException.Gets the MonitoredAttributeInfo for the attribute.Gets the name of the attribute. end MonitoredAttributeBase/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/monitoring/MonitoredAttributeInfo.javaMonitored AttributeInfo contains the meta information of the MonitoredAttribute.If the Attribute is writable from ASAdmin then isWritable() will returntrue.a boolean with true or falseisStatistic() is true if the attribute is presented as a Statistic.Class Type: We will allow only basic class types: 1)Boolean 2)Integer3)Byte 4)Long 5)Float 6)Double 7)String 8)Charactera Class TypeGet's the description for the Monitored Attribute.a String with description end MonitoredAttributeInfo/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/monitoring/MonitoredAttributeInfoFactory.javaMonitoredAttributeInfoFactory used mostly by internal classes. If theUser needs to define some special MonitoredAttributes like a Charactertype Monitored Attribute, they can use this factory to build the metainformation.A Simple Factory Method to create the Monitored Attribute Info./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/monitoring/MonitoredObject.javaMonitored Object provides an Hierarchichal view of the ORB MonitoringSystem. It can contain multiple children and a single parent. EachMonitored Object may also contain Multiple Monitored Attributes.Gets the name of this MonitoredObject</p><p>a String with name of this Monitored ObjectGets the description of MonitoredObjecta String with Monitored Object Description.This method will add a child Monitored Object to this Monitored Object.This method will remove child Monitored Object identified by the given nameof the ChildMonitored ObjectGets the child MonitoredObject associated with this MonitoredObjectinstance using name as the key. The name should be fully qualified namelike orb.connectionmanagera MonitoredObject identified by the given nameGets all the Children registered under this instance of MonitoredObject.Collection of immediate Children associated with this MonitoredObject.Sets the parent for this Monitored Object.There will be only one parent for an instance of MontoredObject, thiscall gets parent and returns null if the Monitored Object is the root.a MonitoredObject which is a Parent of this Monitored Object instanceAdds the attribute with the given name.is the MonitoredAttribute which will be set as one of theattribute of this MonitoredObject.Removes the attribute with the given name.is the MonitoredAttribute nameGets the Monitored Object registered by the given namea MonitoredAttribute identified by the given nameof the attributeGets all the Monitored Attributes for this Monitored Objects. It doesn'tinclude the Child Monitored Object, that needs to be traversed usinggetChild() or getChildren() call.Collection of all the Attributes for this MonitoredObjectClears the state of all the Monitored Attributes associated with theMonitored Object. It will also clear the state on all it's childMonitored Object. The call to clearState will be initiated fromCORBAMBean.startMonitoring() call. end MonitoredObject/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/monitoring/MonitoredObjectFactory.javaMonitoredObject Factory to create Monitored Object.A Simple Factory Method to create the Monitored Object. The nameshould be the leaf level name./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/monitoring/MonitoringConstants.java"ORB Management and Monitoring Root"ORB Management and Monitoring Root"Connections"Connections"Statistics on inbound/outbound connections"Statistics on inbound/outbound connections"Inbound"Inbound"Statistics on inbound connections"Statistics on inbound connections"Outbound"Outbound"Statistics on outbound connections"Statistics on outbound connections"Connection statistics"Connection statistics"NumberOfConnections"NumberOfConnections"The total number of connections"The total number of connections"NumberOfIdleConnections"NumberOfIdleConnections"The number of idle connections"The number of idle connections"NumberOfBusyConnections"NumberOfBusyConnections"The number of busy connections"The number of busy connections"threadpool"threadpool"Monitoring for all ThreadPool instances"Monitoring for all ThreadPool instances"Monitoring for a ThreadPool"Monitoring for a ThreadPool"currentNumberOfThreads"currentNumberOfThreads"Current number of total threads in the ThreadPool"Current number of total threads in the ThreadPool"numberOfAvailableThreads"numberOfAvailableThreads"Number of available threads in the ThreadPool"Number of available threads in the ThreadPool"numberOfBusyThreads"numberOfBusyThreads"Number of busy threads in the ThreadPool"Number of busy threads in the ThreadPool"averageWorkCompletionTime"averageWorkCompletionTime"Average elapsed time taken to complete a work item by the ThreadPool"Average elapsed time taken to complete a work item by the ThreadPool"currentProcessedCount"currentProcessedCount"Number of Work items processed by the ThreadPool"Number of Work items processed by the ThreadPool"Monitoring for a Work Queue"Monitoring for a Work Queue"totalWorkItemsAdded"totalWorkItemsAdded"Total number of Work items added to the Queue"Total number of Work items added to the Queue"workItemsInQueue"workItemsInQueue"Number of Work items in the Queue to be processed"Number of Work items in the Queue to be processed"averageTimeInQueue"averageTimeInQueue"Average time a work item waits in the work queue"Average time a work item waits in the work queue Connection Monitoring ThreadPool and WorkQueue monitoring constants/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/monitoring/MonitoringFactories.javamonitoringManagerFactory/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/spi/monitoring/MonitoringFactories.classmonitoredAttributeInfoFactorymonitoredObjectFactoryThis is used for getting the default factories forMonitoredObject, MonitoredAttributeInfo and MonitoringManager. We do notexpect users to use the MonitoredAttributeInfo factory most of the timebecause the Info is automatically built by StringMonitoredAttributeBaseand LongMonitoredAttributeBase. attributesGets the MonitoredObjectFactorya MonitoredObjectFactoryGets the MonitoredAttributeInfoFactory. The user is not expected to use thisFactory, since the MonitoredAttributeInfo is internally created byStringMonitoredAttributeBase, LongMonitoredAttributeBase andStatisticMonitoredAttribute. If User wants to create a MonitoredAttributeof some other special type like a DoubleMonitoredAttribute, they canbuild a DoubleMonitoredAttributeBase like LongMonitoredAttributeBaseand build a MonitoredAttributeInfo required by MonitoredAttributeBaseinternally by using this Factory.a MonitoredAttributeInfoFactoryGets the MonitoredManagerFactory. The user is not expected to use thisFactory, since the ORB will be automatically initialized with theMonitoringManager.User can get hold of MonitoringManager associated with ORB by callingorb.getMonitoringManager( )a MonitoredManagerFactory/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/monitoring/MonitoringManager.javaMonitoring Manager will have a 1 to 1 association with the ORB. Thisgives access to the top level Monitored Object, using which moreMonitored Objects and Attributes can be added and traversed.Gets the Root Monitored Object which contains a Hierarchy Of MonitoredObjects exposing various Monitorable Attributes of Various modules.MonitoredObjectInitialize is called whenever there is a start monitoring call to CORBAMBean. This will result in triaging initialize to all theMonitoredObjects and it's Monitored Attributes. end MonitoringManager/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/monitoring/MonitoringManagerFactory.javaMonitoringObjectFactory is used internally by the ORB, It is not forgeneral public use./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/monitoring/StatisticMonitoredAttribute.java/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/spi/monitoring/StatisticMonitoredAttribute.classstatisticsAccumulatorStatisticsMonitoredAttribute is provided as a convenience to collect theStatistics of any entity. The getValue() call will be delegated to theStatisticsAccumulator set by the user. Every StatisticMonitoredAttribute will have a StatisticAccumulator. User will use Statisticsaccumulator to accumulate the samples associated with this Monitored Attribute Mutex is passed from the user class which is providing the sample values. getValue() and clearState() is synchronized on this user provided mutexConstructs the StaisticMonitoredAttribute, builds the requiredMonitoredAttributeInfo with Long as the class type and is alwaysreadonly attribute.Of this attributea StatisticMonitoredAttributeshould provide a good description on the kind of statisticscollected, a good example is "Connection Response Time Stats will Provide thedetailed stats based on the samples provided from every request completiontime"is the StatisticsAcumulator that user will use to accumulate thesamples and this Attribute Object will get the computed statistics valuesfrom.using which clearState() and getValue() calls need to be locked. end StatisticMonitoredAttributeGets the value from the StatisticsAccumulator, the value will be a formattedString with the computed statistics based on the samples accumulated in theStatistics Accumulator.Clears the state on Statistics Accumulator, After this call all samples aretreated fresh and the old sample computations are disregarded.Gets the statistics accumulator associated with StatisticMonitoredAttribute.Usually, the user don't need to use this method as they can keep the handleto Accumulator to collect the samples./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/monitoring/StatisticsAccumulator.javaclearStateclearState()/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/spi/monitoring/StatisticsAccumulator.classsampleCountsampleSquareSumsampleSum"Minimum Value = "Minimum Value = " " +
            "Maximum Value = " Maximum Value = " " +
            "Average Value = " Average Value = " " +
            "Standard Deviation = " Standard Deviation = " " + "Samples Collected = " Samples Collected = sampleSumSquareunitexpectedUnitexpectedMinexpectedMaxexpectedSampleCountexpectedAverageexpectedStandardDeviationdifference"Unit is not same as expected Unit" +
                "\nUnit = "Unit is not same as expected Unit
Unit = "ExpectedUnit = "ExpectedUnit = "Minimum value is not same as expected minimum value" +
                "\nMin Value = "Minimum value is not same as expected minimum value
Min Value = "Expected Min Value = "Expected Min Value = "Maximum value is not same as expected maximum value" +
                "\nMax Value = "Maximum value is not same as expected maximum value
Max Value = "Expected Max Value = "Expected Max Value = "Sample count is not same as expected Sample Count" +
                "\nSampleCount = "Sample count is not same as expected Sample Count
SampleCount = "Expected Sample Count = "Expected Sample Count = "Average is not same as expected Average" +
                "\nAverage = "Average is not same as expected Average
Average = "Expected Average = "Expected Average = "Standard Deviation is not same as expected Std Deviation" +
                "\nStandard Dev = "Standard Deviation is not same as expected Std Deviation
Standard Dev = "Expected Standard Dev = "Expected Standard Dev = StatisticsAccumulator accumulates the samples provided by the user andcomputes the value of minimum, maximum, sum and sample square sum. Whenthe StatisticMonitoredAttribute calls getValue(), it will compute allthe statistics for the collected samples (Which are Minimum, Maximum,Average, StandardDeviation) and provides a nice printable record as aString.Users can easily extend this class and provide the implementation oftoString() method to format the stats as desired. By default all the statsare printed in a single line. Users can extend this class to get access to current Max value Users can extend this class to get access to current Min valueUser will use this method to just register a sample with theStatisticsAccumulator. This is the only method that User will use toexpose the statistics, internally the StatisticMonitoredAttribute willcollect the information when requested from the ASAdmin.a double value to make it more precise end sampleComputes the Standard Statistic Results based on the samples collectedso far and provides the complete value as a formatted StringUsers can extend StatisticsAccumulator to provide the completeStats in the format they prefer, if the default format doesn't suffice.If users choose to custom format the stats.We use a derived Standard Deviation formula to compute SD. This waythere is no need to hold on to all the samples provided.The method is protected to let users extend and format the results.Construct the Statistics Accumulator by providing the unit as a String.The examples of units are &quot;Hours&quot;, &quot;Minutes&quot;,&quot;Seconds&quot;, &quot;MilliSeconds&quot;, &quot;Micro Seconds&quot;etc.,a StatisticsAccumulator with ...a String representing the units for the samples collectedClears the samples and starts fresh on new samples.This is an internal API to test StatisticsAccumulator... We are computing Standard Deviation from two different methods for comparison. So, the values will not be the exact same to the last few digits. So, we are taking the difference and making sure that the difference is not greater than 1. end StatisticsAccumulator/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/monitoring/StringMonitoredAttributeBase.javaA Convenient Abstraction to present String type Monitored Attribute. Oneof the examples of StringMonitoredAttribute is the State information.Constructs StringMonitoredAttribute with the MonitoredAttributeInfobuilt with the class type of String.of this attributea StringMonitoredAttributeBase end StringMonitoredAttributeBase/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/oa/NullServant.java/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/oacom.sun.corba.se.spi.oaNullServant is used to represent a null servant returnedOAInvocationInfo after aObjectAdapter.getInvocationServant( OAInvocationInfo ) call.If the getInvocationServant call could not locate a servantfor the ObjectId in the OAInvocationInfo, getServantContainerwill contain a NullServant.  Later stages of the requestdispatch may choose either to throw the exception or performsome other action in response to the NullServant result.Obtain the exception that is associated with thisNullServant instance./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/oa/OADefault.javaOADefault provides methods to create the standard ObjectAdapterFactoryinstances for this version of the ORB.  These methods are generallyused in ORBConfigurator instances to construct an ORB instance./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/oa/OADestroyed.javaThis exception is thrown when an operation on an ObjectAdapterfails because the ObjectAdapter was destroyed during the operation./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/oa/OAInvocationInfo.java/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/spi/oa/OAInvocationInfo.class/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/spi/oaservantContainerThis class is a holder for the information required to implement POACurrent.It is also used for the ServantObject that is returned by _servant_preinvoke calls.This allows us to avoid allocating an extra object on each collocated invocation. This is the container object for the servant. In the RMI-IIOP case, it is the RMI-IIOP Tie, and the servant is the target of the Tie. In all other cases, it is the same as the Servant. These fields are to support standard OMG APIs. These fields are to support the Object adapter implementation. This is the copier to be used by javax.rmi.CORBA.Util.copyObject(s) For the current request. Copy constructor of sorts; used in local optimization pathgetters Create CookieHolder on demand.  This is only called by a single thread, so no synchronization is needed.setters/Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/oa/ObjectAdapter.java REVISIT: What should the order be?  enter/push...pop/exit?ObjectAdapter represents the abstract model of an objectadapter that was introduced by ORT.  This means that allobject adapters must:<LI>Have an ORB</LI><LI>Have a name</LI><LI>Have an adapter manager (represented by an ID)</LI><LI>Have an adapter template</LI><LI>Support getting and setting their ObjectReferenceFactory</LI><LI>Provide access to their current state</LI><LI>Support adding components to their profiles expressed in the adapter template</LI><LI>All object adapters must invoke ORB.AdapterCreated when they are created.<LI>All adapter managers must invoke ORB.AdapterManagerStateChanged whenObject adapters must also provide mechanisms for:<LI>Managing object reference lifecycle</LI><LI>Controlling how servants are associated with object references</LI><LI>Manage the state of the adapter, if the adapter desires to implement such mechanisms</LI>Such mechanisms are all object adapter specific, and so we do not attempt tocreate general APIs for these functions here.  The object adapter itselfmust provide these APIs directly to the user, and they do not affect the rest of theORB.  This interface basically makes it possible to plug any object adapter into theORB and have the OA work propertly with portable interceptors, and also have requestsdispatched properly to the object adapter.The basic function of an ObjectAdapter is to map object IDs to servants and to supportthe dispatch operation of the subcontract, which dispatches requests to servants.This is the purpose of the getInvocationServant method.  In addition, ObjectAdapters must beable to change state gracefully in the presence of executing methods.  Thisrequires the use of the enter/exit methods.  Finally, ObjectAdapters oftenrequire access to information about requests.  This is accomodated through theOAInvocationInfo class and the thread local stack maintained by push/pop/peekInvocationInfoon the ORB.To be useful, this dispatch cycle must be extremely efficient.  There are severalscenarios that matter:<li>A remote invocation, where the dispatch is handled in the server subcontract.</li><li>A local invocation, where the dispatch is handled in the client subcontract.</li><li>A cached local invocation, where the servant is cached when the IOR is establishedfor the client subcontract, and the dispatch is handled in the client subcontractto the cached subcontract.<li></ol>Each of these 3 cases is handled a bit differently.  On each request, assume as knownObjectId and ObjectAdapterId, which can be obtained from the object key.The ObjectAdaptorFactory is available in the subcontract registry, where it isregistered under the subcontract ID.  The Subcontract ID is also available in theobject key.<li>The remote pattern:<li>oa = oaf.find( oaid )</li><li>oa.enter()</li><li>info = oa.makeInvocationInfo( oid )</li><li>info.setOperation( operation )</li><li>push info</li><li>oa.getInvocationServant( info )</li><li>sreq.setExecuteReturnServantInResponseConstructor( true )</li><li>dispatch to servant</li><li>oa.returnServant()</li><li>oa.exit()</li><li>pop info</li></li>REVISIT: Is this the required order for exit/pop?  Cna they be nested instead?Note that getInvocationServant and returnServant may throw exceptions.  In such cases,returnServant, exit, and pop must be called in the correct order.<li>The local pattern:This is the same as the remote case, except that setExecuteReturnServantInResponseConstructoris not needed (or possible, since there is no server request).<li>The fast local pattern: When delegate is constructed,first extract ObjectKey from IOR in delegate,then get ObjectId, ObjectAdapterId, and ObjectAdapterFactory (oaf). Then:<li>info = oa.makeInvocationInfo( oid ) (note: no operation!)</li><li>push info (needed for the correct functioning of getInvocationServant)</li><li>pop infoThe info instance (which includes the Servant) is cached in the client subcontract.<p>Then, on each invocation:</p><li>newinfo = copy of info (clone)</li><li>push newinfo</li><li>oa.returnServant()</li>  // XXX This is probably wrong: remove it.XXX fast local should not call returnServant: what is correct here?////////////////////////////////////////////////////////////////////////// Basic methods for supporting interceptorsReturns the ORB associated with this adapter.Returns the IOR template of this adapter.  The profilesin this template may be updated only during the AdapterCreated call.After that call completes, the IOR template must be made immutable.Note that the server ID, ORB ID, and adapter name are all availablefrom the IOR template. Methods needed to support ORT.Return the ID of the AdapterManager for this object adapter.Return the current state of this object adapter (seeorg.omg.PortableInterceptors for states.Change the current factory.  This may only be called during theAdapterCreated call. Methods required for dispatching to servantsGet the servant corresponding to the given objectId, if this is supported.This method is only used for models where the servant is an ObjectImpl,which allows the servant to be used directly as the stub.  This allows an objectreference to be replaced by its servant when it is unmarshalled locally.Such objects are not ORB mediated.info must contain a valid objectId in this call.The servant is set in the InvocationInfo argument that is passed intothis call.is the InvocationInfo object for the object referenceForwardException(a runtime exception) is thrown if the requestis to be handled by a different object reference.enter must be called before each request is invoked on a servant.OADestroyedis thrown when an OA has been destroyed, whichrequires a retry in the case where an AdapterActivator is present.exit must be called after each request has been completed.  If enteris called, there must always be a corresponding exit.Must be called every time getInvocationServant is called afterthe request has completed.Create an instance of InvocationInfo that is appropriate for thisObject adapter./Users/jettt/IdeaProjects/jdk_test/src/main/java/com/sun/corba/se/spi/oa/ObjectAdapterBase.javacurrentFactory/Users/jettt/IdeaProjects/jdk_test/target/classes/com/sun/corba/se/spi/oa/ObjectAdapterBase.classadapterTemplate_omgLifecycleWrapper_omgInvocationWrapper_lifecycleWrapper_invocationWrapper_iorWrappernotifyORBpih Exception wrappers Data related to the construction of object references and supporting the Object Reference Template.This creates the complete template.When it is done, reference creation can proceed. This calls acceptors which create profiles and may add tagged components to those profiles. This runs the IORInterceptors. Note that all current subclasses share the same implementation of this method, but overriding it would make sense for OAs that use a different Invo    F    